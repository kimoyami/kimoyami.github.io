<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>小雅米，来来往往这么多人，有多少是圆梦后才衣锦还乡的呢？</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-09-13T03:58:22.391Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>kimoyami</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>论积性函数与线性筛</title>
    <link href="http://yoursite.com/2020/09/13/%E8%AE%BA%E7%A7%AF%E6%80%A7%E5%87%BD%E6%95%B0%E4%B8%8E%E7%BA%BF%E6%80%A7%E7%AD%9B/"/>
    <id>http://yoursite.com/2020/09/13/论积性函数与线性筛/</id>
    <published>2020-09-13T03:15:25.000Z</published>
    <updated>2020-09-13T03:58:22.391Z</updated>
    
    <content type="html"><![CDATA[<p>草，这离上一次更新也不知道有多少了，有生之年系列？</p><a id="more"></a><h1 id="线性筛"><a href="#线性筛" class="headerlink" title="线性筛"></a>线性筛</h1><p>线性筛保证了每个数只被它最小的素因子筛到一次，模板如下：<br><div><div class="fold_hider"><div class="close hider_title">代码</div></div><div class="fold"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; maxn; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(!vis[i])&#123;</span><br><span class="line">        prime.eb(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; prime.size() &amp;&amp; i * prime[j] &lt; maxn; j++)&#123;</span><br><span class="line">        vis[i * prime[j]] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(i % prime[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><br>关键在为什么$i \% prime[j] == 0$的就会break掉，考虑$i * prime[j + 1]$一定会被$prime[j]和另一个i$相乘的时候筛掉，所以我们在这里break掉保证每个数只被筛掉一次。</p><h1 id="积性函数"><a href="#积性函数" class="headerlink" title="积性函数"></a>积性函数</h1><p>积性函数分为如下两类：</p><ul><li>完全积性函数：$f(ab) = f(a) * f(b)$</li><li>普通积性函数: $f(ab) = f(a) * f(b), gcd(a, b) = 1$<br>一般我们要讨论的就是普通积性函数。</li></ul><h1 id="线性筛积性函数"><a href="#线性筛积性函数" class="headerlink" title="线性筛积性函数"></a>线性筛积性函数</h1><p>一般来说，积性函数都是可以用线性筛来求解的，一般需要考虑如下最重要的部分：</p><ul><li>$f(p^k)$是否好求解<br>假设上面求解复杂度为$x$，那么线性筛该积性函数的复杂度就为$O(n + \frac{nx}{logn})$</li></ul><p>先给出一些定义：</p><ul><li>$low(i):$表示i最小素因子的乘积<br>例如$low(36) = 2^2 = 4， low(27) = 3^3 = 27$</li></ul><p>按照如下流程进行线性筛积性函数:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; maxn; i++)&#123;</span><br><span class="line">       <span class="keyword">if</span>(!vis[i])&#123;</span><br><span class="line">           prime.eb(i);</span><br><span class="line">           low[i] = i</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; prime.size() &amp;&amp; i * prime[j] &lt; maxn; j++)&#123;</span><br><span class="line">           vis[i * prime[j]] = <span class="number">1</span>;</span><br><span class="line">           low[i * prime[j]] = low[i] * prime[j]</span><br><span class="line">           <span class="keyword">if</span>(i % prime[j] == <span class="number">0</span>) &#123;</span><br><span class="line">               <span class="keyword">if</span>(low[i] == i) f[i * prime[j]] = 求解</span><br><span class="line">               <span class="keyword">else</span>&#123;</span><br><span class="line">                   f[i * prime[j]] = f[i / low[i]] * f[low[i * prime[j]]];</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">else</span>&#123;</span><br><span class="line">               f[i * prime[j]] = f[i] * f[prime[j]];</span><br><span class="line">               low[i * prime[j]] = prime[j] </span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>主要解释一下<script type="math/tex">i \% prime[j] == 0</script>里面的部分，考虑如果<script type="math/tex">prime[j]不是i的唯一素因子</script>，那么<script type="math/tex">i * prime[j]</script>可以分解为只包含<script type="math/tex">prime[j]</script>和剩下部分的两个因子组成，并且一定互质，这样可以推出来<script type="math/tex">f[i * prime[j]]</script>的值。<br>但如果<script type="math/tex">prime[j]是i的唯一素因子</script>，这样做就会有问题了，也就是前面所说的$f(p^k)$的答案我们需要单独求解。</p><h1 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h1><p>来看一个练习题<br><a href="https://ac.nowcoder.com/acm/contest/7329/F" target="_blank" rel="noopener">解方程</a></p><script type="math/tex; mode=display">f(n) * g_p(n) = g_q(n)</script><p>由莫比乌斯反演我们知道<script type="math/tex">g_p(n)^{-1} = g_p(n)\mu(n)</script></p><script type="math/tex; mode=display">f(n) = g_q(n) * (g_p(n)\mu(n))</script><p>右边两个都是积性函数，积性函数的迪利克雷卷积也是积性函数。<br>那么我们只用想办法求$f(p^k)$就可以了<br>由莫比乌斯函数我们知道，只有两项是有贡献的，所以很好求，求解复杂度是$log(n)$的<br>所以线性筛的复杂度$O(n + \frac{nlogn}{logn}) = O(n)$<br><div><div class="fold_hider"><div class="close hider_title">代码</div></div><div class="fold"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> db;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vi;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;ll&gt; vl;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;pii&gt; vp;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">const</span> ll INF = <span class="number">1e18</span>;</span><br><span class="line"><span class="keyword">const</span> db eps = <span class="number">1e-10</span>;</span><br><span class="line"><span class="keyword">const</span> db pi = <span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> eb emplace_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ep emplace</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mem(a) memset(a, 0, sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> copy(a, b) memcpy(a, b, sizeof(b))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PA cout &lt;&lt; <span class="meta-string">"pass\n"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lowbit(x) (x &amp; -x)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(x) x.begin(), x.end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TM cout &lt;&lt; db(clock()) / CLOCKS_PER_SEC &lt;&lt; <span class="meta-string">'\n'</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">mt19937 <span class="title">mrand</span><span class="params">(chrono::high_resolution_clock::now().time_since_epoch().count())</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;<span class="title">inline</span> <span class="title">void</span> <span class="title">upmin</span>(<span class="title">T</span> &amp;<span class="title">x</span>, <span class="title">T</span> <span class="title">y</span>) &#123;</span>x = x &gt; y ? y : x;&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;<span class="title">inline</span> <span class="title">void</span> <span class="title">upmax</span>(<span class="title">T</span> &amp;<span class="title">x</span>, <span class="title">T</span> <span class="title">y</span>) &#123;</span>x = x &lt; y ? y : x;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pow_mod</span><span class="params">(<span class="keyword">int</span> q, <span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(w)&#123;</span><br><span class="line">        <span class="keyword">if</span>(w &amp; <span class="number">1</span>) ret = <span class="number">1l</span>l * ret * q % mod;</span><br><span class="line">        q = <span class="number">1l</span>l * q * q % mod;</span><br><span class="line">        w &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e7</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> f[maxn], low[maxn];</span><br><span class="line">vi prime;</span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"><span class="keyword">int</span> n, p, q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    f[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; maxn; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!vis[i])&#123;</span><br><span class="line">            prime.eb(i);</span><br><span class="line">            f[i] = (pow_mod(i, q) + mod - pow_mod(i, p)) % mod;</span><br><span class="line">            low[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; prime.size() &amp;&amp; i * prime[j] &lt; maxn; j++)&#123;</span><br><span class="line">            vis[i * prime[j]] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(i % prime[j] == <span class="number">0</span>)&#123;</span><br><span class="line">                low[i * prime[j]] = low[i] * prime[j];</span><br><span class="line">                <span class="keyword">if</span>(i == low[i]) &#123;</span><br><span class="line">                    f[i * prime[j]] = (pow_mod(i * prime[j], q) - <span class="number">1l</span>l * pow_mod(i, q) * pow_mod(prime[j], p) % mod + mod) % mod;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    f[i * prime[j]] = <span class="number">1l</span>l * f[i / low[i]] * f[low[i * prime[j]]] % mod;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                f[i * prime[j]] = <span class="number">1l</span>l * f[i] * f[prime[j]] % mod;</span><br><span class="line">                low[i * prime[j]] = prime[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        res ^= f[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>), <span class="built_in">cin</span>.tie(<span class="number">0</span>), <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; fixed &lt;&lt; setprecision(<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; p &gt;&gt; q;</span><br><span class="line">    init();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></p><p>什么时候迪利克雷卷积也要系统学一下，未完待续~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;草，这离上一次更新也不知道有多少了，有生之年系列？&lt;/p&gt;
    
    </summary>
    
      <category term="积性函数" scheme="http://yoursite.com/categories/%E7%A7%AF%E6%80%A7%E5%87%BD%E6%95%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>集成学习</title>
    <link href="http://yoursite.com/2020/07/11/%E9%9B%86%E6%88%90%E5%AD%A6%E4%B9%A0/"/>
    <id>http://yoursite.com/2020/07/11/集成学习/</id>
    <published>2020-07-11T07:07:56.000Z</published>
    <updated>2020-07-11T09:48:12.129Z</updated>
    
    <content type="html"><![CDATA[<h1 id="集成学习简介"><a href="#集成学习简介" class="headerlink" title="集成学习简介"></a>集成学习简介</h1><p>集成学习通过构建多个个体学习器，并让他们单独产生结果，最后将它们的结果合并起来，给出一个整体的最终结果。这就好像如果每个人单独做一套题，可能不管是谁，都会做错一部分题。但如果有很多人一起做，最后根据大家的结果和一个合并策略，选出一个结果，后者的正确率一般来说会高很多。<br>集成学习通过将多个学习器结合，常可获得比单一学习器显著优越的泛化性能，这对弱学习器(泛化性能略优于随机猜测的学习器)尤为明显。<br>首先我们希望各个学习器本身要有准确性，如果各个学习器本身的准确度不够，最后出来的结果一定不好。其次我们希望各个学习器之间要有差异，即学习器要多样性。如果大部分学习器学习方法和参数都差不多的话，相当于它们都会做出一样的预测，那么集成学习就没有意义了。但事实上，准确性和多样性很多时候是冲突的，如何产生”好而不同”的个体学习器，是集成学习的核心。<br>根据个体学习器的生成方式，集成学习方法大致可分为两大类，即个体学习器间存在强依赖关系、必须串行生成的序列化方法，以及个体学习器间不存在强依赖关系，可同时生成的并行化方法；前者代表是$Boosting$，后者代表是$Bagging$和随机森林。</p><h1 id="Boosting"><a href="#Boosting" class="headerlink" title="Boosting"></a>Boosting</h1><p>$Boosting$是一族可将弱学习器提升为强学习器的算法。先从初始训练集训练出一个基学习器，再根据基学习器的表现对训练样本分布进行调整，使得先前基学习器做错的样本在后面得到更多的关注。</p><h2 id="AdaBoost"><a href="#AdaBoost" class="headerlink" title="AdaBoost"></a>AdaBoost</h2><p>$AdaBoost$的算法流程如下：<br><img src="/mlimg/Adaboost.png" alt=""><br>$AdaBoost$的核心是两个权重：数据集权重$D$和分类器权重$a$。前者为了在生成每一个分类器时，决定每个数据对损失函数的影响，即我们需要把重心放在之前分错类的那些数据上。后者是对测试数据进行预测时，各个分类器对最终结果影响的比重。<br>初始每个训练样本都具有相同的权重，每一次我们生成一个新的分类器，并用带权的数据对它进行训练，算出训练后的误差率，然后根据错误率确定这个分类器在最后决策中占的权重，然后更新数据集权重$D$，然后继续生成下一个分类器。<br>那么就会有如下问题：<br><strong>$a_t$的表达式是怎么推到来的？</strong><br>$AdaBoost$采用指数损失函数$l_{exp}(H | D) = E_{x \sim D}[e^{-f(x)H(x)}]$<br>我们知道最后结果由各个分类器线性加权得到：<script type="math/tex">H(x) = \sum_{t = 1}^Ta_th_t(x)</script><br>所以如果我们要确定当前分类器的$a_t$，考虑对其求偏导：<script type="math/tex">\frac{\partial l_{exp}(a_th_t | D_t)}{\partial a_t} = -e^{-a_t}(1 - \epsilon_t) + e^{a_t}\epsilon_t</script><br>令其等于0即可得出<script type="math/tex">a_t = \frac{1}{2}ln(\frac{1 - \epsilon_t}{\epsilon_t})</script></p><p><strong>$Z_t$是干嘛的，怎么计算出来的？</strong><br>$Z_t$是归一化常数，为了保证所有$D_i$的和加起来为1，<script type="math/tex">Z_t = \sum_{i}D_t(i)e^{-a_ty_ih_t(x_i)} = \sum_{h_t(x_i) = y_i}D_t(i)e^{-a_i} + \sum_{h_t(x_i) \neq y_i}D_t(i)e^{a_i}</script>。<br>代入$a_t$，得<script type="math/tex">Z_t = 2\sqrt{\epsilon_t(1 - \epsilon_t)}</script></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;集成学习简介&quot;&gt;&lt;a href=&quot;#集成学习简介&quot; class=&quot;headerlink&quot; title=&quot;集成学习简介&quot;&gt;&lt;/a&gt;集成学习简介&lt;/h1&gt;&lt;p&gt;集成学习通过构建多个个体学习器，并让他们单独产生结果，最后将它们的结果合并起来，给出一个整体的最终结果。这就
      
    
    </summary>
    
      <category term="机器学习" scheme="http://yoursite.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>决策树</title>
    <link href="http://yoursite.com/2020/07/10/%E5%86%B3%E7%AD%96%E6%A0%91/"/>
    <id>http://yoursite.com/2020/07/10/决策树/</id>
    <published>2020-07-10T01:22:55.000Z</published>
    <updated>2020-07-11T08:05:42.550Z</updated>
    
    <content type="html"><![CDATA[<h1 id="决策树简介"><a href="#决策树简介" class="headerlink" title="决策树简介"></a>决策树简介</h1><p>决策树(Decision Tree)是在已知各种情况发生概率的基础上，通过构成决策树来求取净现值的期望值大于等于零的概率，评价项目风险，判断其可行性的决策分析方法，是直观运用概率分析的一种图解法。由于这种决策分支画成图形很像一棵树的枝干，故称决策树。</p><h1 id="划分选择"><a href="#划分选择" class="headerlink" title="划分选择"></a>划分选择</h1><h2 id="信息增益"><a href="#信息增益" class="headerlink" title="信息增益"></a>信息增益</h2><p>信息熵是度量样本集合纯度最常用的一种指标。假设当前样本集合$D$中第$k$类样本所占比例为$p_k(k = 1, 2, \dots, |\gamma|)$,则$D$的信息熵定义为：<script type="math/tex">Ent(D) = -\sum_{k = 1}^{|\gamma|}p_klog_2p_k</script>。信息熵的值越小，信息的纯度越高。<br>假设某个样本的属性$a$的$V$个可能取值${a^1, a^2, a^3, \dots, a^V}$，若使用$a$来对样本集合$D$进行划分，则会在这里产生$V$个分支结点。其中第$v$个结点包含了$D$中所有在属性$a$上取值为$a^v$的样本，记为$D^v$。我们利用属性$a$对样本集$D$进行划分所获得的信息增益记为<script type="math/tex">Gain(D, a) = Ent(D) - \sum_{v = 1}^V\frac{|D^v|}{|D|}Ent(D^v)</script>。<br>一般来说，信息增益越大，意味着用属性$a$来进行划分所获得的纯度提升越大，我们在每次对属性进行选择的时候，都用信息增益进行选择，即选择能获得最大增益的属性作为当前决策树结点进行划分。$ID3$算法就是采用信息增益作为选择标准。</p><h2 id="增益率"><a href="#增益率" class="headerlink" title="增益率"></a>增益率</h2><p>根据上面的式子我们可以发现，信息增益偏向于选择属性取值数较多的集合。一般情况来说，取值情况较多，每个部分纯度就越大，总体的纯度就越大。为了减少这种偏向带来的影响，我们不直接使用信息增益，而使用增益率。我们定义增益率为<script type="math/tex">Gain_ratio(D, a) = \frac{Gain(D, a)}{IV(a)}</script>，其中<script type="math/tex">IV(a) = -\sum_{v = 1}^V\frac{|D^v|}{D}log_2\frac{|D^v|}{D}</script><br>我们发现增益率会偏向于取值数较少的属性。因此，$C4.5$算法采用了启发式的方法，先选择信息增益高于平均水平的属性，再从中选择增益率最高的。</p><h2 id="基尼指数"><a href="#基尼指数" class="headerlink" title="基尼指数"></a>基尼指数</h2><p>$CART$决策树采用基尼指数来选择划分属性。定义<script type="math/tex">Gini(D) = \sum_{k = 1}^{|\gamma|}\sum_{k' \neq k}p_kp_{k'} = 1 - \sum_{k = 1}^{|\gamma|}p_k^2</script>。属性$a$的基尼指数定义为:<script type="math/tex">Gini_index(D, a) = \sum_{v = 1}^V\frac{|D^v|}{D}Gini(D^v)</script><br>划分的时候，我们选择基尼指数最小的属性作为当前决策树结点进行划分。</p><h1 id="剪枝处理"><a href="#剪枝处理" class="headerlink" title="剪枝处理"></a>剪枝处理</h1><p>当决策树分支过多的时候，就会出现过拟合的情况，泛化能力会很差，这时候我们要对决策树进行剪枝。</p><h2 id="预剪枝"><a href="#预剪枝" class="headerlink" title="预剪枝"></a>预剪枝</h2><p>如果在某个结点我们不再进行划分，我们会选择出此时这个结点属性集中出现最多的结果，并将它作为这个结点的结果。预剪枝指的是在当前结点进行划分的时候，我们先将取它原本应该取的划分属性，然后对比它划分前后的准确率，如果不划分的准确率更高，我们就不进行划分。预剪枝的本质就是基于贪心，但有可能给决策树带来欠拟合的风险。</p><h2 id="后剪枝"><a href="#后剪枝" class="headerlink" title="后剪枝"></a>后剪枝</h2><p>后剪枝指的是我们先完整生成一棵决策树，自底向上考察每一个结点，如果将其子树替换为某个叶节点，并且能提高准确率，我们就进行替换剪枝。<br>后剪枝一般来说欠拟合风险小，泛化性能优于预剪枝，但其训练开销大。</p><h1 id="连续与缺失值"><a href="#连续与缺失值" class="headerlink" title="连续与缺失值"></a>连续与缺失值</h1><h2 id="连续值处理"><a href="#连续值处理" class="headerlink" title="连续值处理"></a>连续值处理</h2><p>如果我们遇到了连续属性，我们仍使用决策树，我们要先对连续值进行一定处理。<br>假设样本集$D$和连续属性$a$，假设$a$在$D$上出现了$n$个不同的取值，我们将这些值从小到大进行排序，记为$a^1, a^2, \dots, a^n$。对此，我们可以写出$n - 1$个划分点<script type="math/tex">T_a = {\frac{a^i + a^{i + 1}}{2} | 1 \leq i \leq n - 1}</script>。然后我们就可以像离散属性点一样来考察这些划分点。</p><h2 id="缺失值处理"><a href="#缺失值处理" class="headerlink" title="缺失值处理"></a>缺失值处理</h2><p>假如样本的某些属性值丢失，如果放弃有缺失值的样本，会造成信息的浪费。因为，我们采取以下办法来训练带缺失值的样本：<br>给定训练集$D$和属性$a$，设$\widetilde{D}$为$D$中在属性$a$上没有缺失值的样本子集。假设我们给每个样本赋予一个权重$w_x$，并定义：</p><ul><li>$\rho = \frac{\sum_{x \in \widetilde{D}}w_x}{\sum_{x \in D} w_x}$</li><li>$\widetilde{p_k} = \frac{\sum_{x \in \widetilde{D_k}}w_x}{\sum_{x \in \widetilde{D}}w_x}(1 \leq k \leq |\gamma|)$</li><li>$\widetilde{r_v} = \frac{\sum_{x \in \widetilde{D}^v}w_x}{\sum_{x \in \widetilde{D}}w_x}(1 \leq v \leq V)$<br>简单来说，$\rho$表示无缺失值样本所占比例，$\widetilde{p_k}$表示无缺失值样本中第$k$类所占的比例，$\widetilde{r_v}$表示无缺失值样本中在属性$a$上取值$a^v$的样本所占的比例。<br>根据定义，可以推广信息增益计算式为：<script type="math/tex">Gain(D, a) = \rho * Gain(\widetilde{D}, a)</script><br>当样本$x$在属性$a$上划分值缺失时，则将$x$划入所有子结点中，再将其样本权值调整为$\widetilde{r_v} *w_x$。就是让同一个样本根据已知的分布情况，以不同的概率划入到不同的子结点中去。</li></ul><p>来一个鸢尾花的测试<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_iris</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> tree</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"></span><br><span class="line">iris = load_iris()</span><br><span class="line">x = iris[<span class="string">'data'</span>]</span><br><span class="line">y = iris[<span class="string">'target'</span>]</span><br><span class="line"></span><br><span class="line">train_x, test_x, train_y, test_y = train_test_split(x, y, test_size=<span class="number">0.25</span>, random_state=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">train_x = train_x.reshape(train_x.shape[<span class="number">0</span>], <span class="number">-1</span>)</span><br><span class="line">test_x = test_x.reshape(test_x.shape[<span class="number">0</span>], <span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">clf = tree.DecisionTreeClassifier()</span><br><span class="line">clf = clf.fit(train_x, train_y)</span><br><span class="line"></span><br><span class="line">cnt = <span class="number">0</span></span><br><span class="line">sum = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(test_x.shape[<span class="number">0</span>]):</span><br><span class="line">    t = []</span><br><span class="line">    t.append(test_x[i])</span><br><span class="line">    predict_y = clf.predict(t)</span><br><span class="line">    sum += <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span>(predict_y == test_y[i]): cnt += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">print(cnt, sum)</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;决策树简介&quot;&gt;&lt;a href=&quot;#决策树简介&quot; class=&quot;headerlink&quot; title=&quot;决策树简介&quot;&gt;&lt;/a&gt;决策树简介&lt;/h1&gt;&lt;p&gt;决策树(Decision Tree)是在已知各种情况发生概率的基础上，通过构成决策树来求取净现值的期望值大于等于零的
      
    
    </summary>
    
      <category term="机器学习" scheme="http://yoursite.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>贝叶斯分类器</title>
    <link href="http://yoursite.com/2020/07/01/%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%88%86%E7%B1%BB%E5%99%A8/"/>
    <id>http://yoursite.com/2020/07/01/贝叶斯分类器/</id>
    <published>2020-07-01T06:50:36.000Z</published>
    <updated>2020-07-11T08:05:37.480Z</updated>
    
    <content type="html"><![CDATA[<h1 id="先验概率和后验概率"><a href="#先验概率和后验概率" class="headerlink" title="先验概率和后验概率"></a>先验概率和后验概率</h1><p>之前一直搞不清楚这两个概念，这里来区分一下。<br>先验概率是指根据以往经验和分析得到的概率，如全概率公式，它往往作为”由因求果”问题中的”因”出现。<br>后验概率是指依据得到”结果”信息所计算出的最有可能是那种事件发生，如贝叶斯公式中的，是”执果寻因”问题中的”因”。</p><p>举个例子，女朋友每个月都会生气，假设什么都没发生，她今天生气的概率为$p_1$，这就是一种先验概率。<br>当你跟她打电话，发现她说话非常不耐烦，你觉得她今天大概率会生气，假设此时她生气的概率$p_2$，这就是一种后验概率。<br>懂了吧，后验概率其实就是一种条件概率，即是在你观测到某些信息后再发生这个事情的概率有多少。</p><h1 id="贝叶斯定理"><a href="#贝叶斯定理" class="headerlink" title="贝叶斯定理"></a>贝叶斯定理</h1><p>贝叶斯定理说的就是条件概率的事情，定义很简单:$P(A | B) = \frac{P(AB)<br>}{P(B)}$<br>我们可以这样写：$P(B | A) = \frac{P(AB)}{P(A)}$<br>那么可以得到：$P(A | B) = \frac{P(A)P(B | A)}{P(B)}$<br>假设事件$A$是女朋友今天生气了，事件$B$是女朋友打电话不耐烦，那么这个概率可以转换成求女朋友生气的概率、女朋友不耐烦的概率以及女朋友在生气情况下打电话不耐烦的概率。因为很多时候往往都是正面的条件概率不好求，但反面的会比较好求，即可以通过贝叶斯定理进行转换。</p><p>假设$x = (x_1, x_2, \dots, x_n)$表示包含有$D$维属性的数据对象。训练集有$k$个类别，分别为$y = (y_1, y_2, \dots, y_k)$。假设有待分类对象$x$，我们需要找<script type="math/tex">\argmax_{y_i \in y}(P(y_i | x))</script><br>根据上面的推导，我们可以转换为<script type="math/tex">P(y_i | x) = \frac{P(x | y_i)P(y_i)}{P(x)}</script>，由于$P(x)$是常数，实际上只需要最大化$P(x | y_i)P(y_i)$</p><h1 id="朴素贝叶斯分类器"><a href="#朴素贝叶斯分类器" class="headerlink" title="朴素贝叶斯分类器"></a>朴素贝叶斯分类器</h1><p>朴素贝叶斯分类器假设$x$的各个属性之间独立，那么上面就可以改写为：<script type="math/tex">P(y_i)\prod_{j = 1}^nP(x_j | y_i)</script><br>关于<script type="math/tex">P(x_j | y_i)</script>的计算方法，假设$y_i$有$m$个，其中带有$x_j$属性的有$n$个，当样本足够多时，我们就可以用频率值代替概率值，即：$P(x_j | y_i) = \frac{n}{m}$。<br>然而这个方法有个缺陷，属性一旦多了，有可能样本不能覆盖所有属性。假设一个属性样本中没出现过，那么概率直接就为0了。对此，我们对其进行拉普拉斯修正：<script type="math/tex">P(x_j | y_i) = \frac{n + 1}{m + N_j}</script>，其中$N_j$表示第$j$个属性一共可能的取值数。<br>如果属性取值是连续函数，可考虑采用概率密度函数。</p><h1 id="半朴素贝叶斯分类器"><a href="#半朴素贝叶斯分类器" class="headerlink" title="半朴素贝叶斯分类器"></a>半朴素贝叶斯分类器</h1><p>事实上，所有属性相互独立这个条件是很难满足的，这样就产生了半朴素贝叶斯分类器。独依赖估计是半朴素贝叶斯分类器常采用的一种策略，即每个属性最多依赖于一个其他属性。</p><h2 id="SPODE"><a href="#SPODE" class="headerlink" title="SPODE"></a>SPODE</h2><p>$SPODE$方法假设所有属性都依赖于同一个属性，这个属性称为超父属性。这个可以通过交叉验证等模型选择方法来确定。</p><h2 id="TAN"><a href="#TAN" class="headerlink" title="TAN"></a>TAN</h2><p>$SPODE$有他的局限性，即不一定所有属性都会有一个强相关的依赖属性，这时候就产生了$TAN$，$TAN$是基于最大带权生成树算法。<br>定义两个属性之间的条件互信息<script type="math/tex">I(x_i, x_j | y) = \sum_{x_i, x_j; y_k \in y}P(x_i, x_j | y_k)log\frac{P(x_i, x_j | y_k)}{P(x_i | y_k)P(x_j | y_k)}</script><br>然后可以以属性为点，构成完成图，任意两点<script type="math/tex">w(i, j) = I(x_i, x_j | y)</script>，对于做最大生成树（取负然后变为最小生成树），最后给边定向即可。</p><h2 id="AODE"><a href="#AODE" class="headerlink" title="AODE"></a>AODE</h2><p>$AODE$尝试将每个属性作为超父属性，然后将那些有足够训练数据支撑的$SPODE$集成起来作为最终结果。<script type="math/tex">\sum_{i = 1, |D_{x_i} \geq m'|}^dP(c, x_i) \prod_{j = 1}^dP(x_j | c, x_i)</script></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;先验概率和后验概率&quot;&gt;&lt;a href=&quot;#先验概率和后验概率&quot; class=&quot;headerlink&quot; title=&quot;先验概率和后验概率&quot;&gt;&lt;/a&gt;先验概率和后验概率&lt;/h1&gt;&lt;p&gt;之前一直搞不清楚这两个概念，这里来区分一下。&lt;br&gt;先验概率是指根据以往经验和分析得
      
    
    </summary>
    
      <category term="机器学习" scheme="http://yoursite.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>无监督学习</title>
    <link href="http://yoursite.com/2020/06/28/%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0/"/>
    <id>http://yoursite.com/2020/06/28/无监督学习/</id>
    <published>2020-06-28T10:04:08.000Z</published>
    <updated>2020-07-11T08:05:39.737Z</updated>
    
    <content type="html"><![CDATA[<p>我又在无监督学习（不学习）了</p><h1 id="无监督学习简介"><a href="#无监督学习简介" class="headerlink" title="无监督学习简介"></a>无监督学习简介</h1><p>前面区分过无监督学习和有监督学习，无监督学习没有输出标签，即没有$y$，无监督学习需要根据数据找出隐藏的数据结构，比如分类。</p><h1 id="K均值"><a href="#K均值" class="headerlink" title="K均值"></a>K均值</h1><h2 id="K-Means"><a href="#K-Means" class="headerlink" title="K-Means"></a>K-Means</h2><p>给你一堆空间里的点，让你把他们分成k类，使得所有类的最小化平方误差和最小E，也就是所谓的聚类，假设簇划分为$(C_1,C_2,\dots C_k)$，有<script type="math/tex">E = \sum_{i = 1}^k\sum_{x \in C_i}||x - \mu_{i}||_2^2</script>。其中有$\mu_i = \frac{1}{|C_i|}\sum_{x \in C_i}x$。<br>直接求解最小值是一个$NP$问题，所以K均值算法采用启发式迭代的方法，其具体步骤非常简单，首先有k个初始的聚类中心，迭代有如下几步：</p><ul><li>遍历每一个点</li><li>找到离这个点最近的聚类中心，把这个点标记属于这个聚类</li><li>对于每一个新标记出的聚类，计算其新的几何中心</li></ul><p>根据以上步骤迭代至收敛为止。</p><p>k均值算法算法对初始化非常敏感，如果只是随机选择，可能会落入局部最优解，并且收敛会很慢，为此对于初始化，有新的方法提出。</p><h2 id="K-Means-1"><a href="#K-Means-1" class="headerlink" title="K-Means++"></a>K-Means++</h2><p>假设要分为k类，我们需要初始化k个聚类中心，按照如下步骤：</p><ul><li>从输入的数据点集合中随机选择一个点作为第一个聚类中心$\mu_1$</li><li>对于数据集中的每一个点$x_i$，计算它与已选择的聚类中心中最近聚类中心的距离$D(x_i) = argmin||x_i - \mu_r||_2^2 r = 1, 2, \dots k_{selected}$</li><li>选择一个新的数据点作为新的聚类中心，选择的原则是：$D(x)$较大的点，被选取作为聚类中心的概率较大</li><li>重复步骤2-3直到选择出k个聚类质心</li><li>利用这k个质心来作为初始化质心去运行标准的K-Means算法</li></ul><h2 id="elkan-K-Means"><a href="#elkan-K-Means" class="headerlink" title="elkan K-Means"></a>elkan K-Means</h2><p>在普通k均值算法中，我们要计算样本点到所有质心的距离，这个复杂度跟向量维度有关，考虑通过三角形定理进行优化：三角形两边之和大于第三边，两边之差小于第三边。<br>知道两个质心$\mu_{j1}, \mu_{j2}$，如果我们预处理了两个质心间的距离$D(j_1, j_2)$，计算时发现$2D(x, j_1) \leq D(j_1, j_2)$，我们立即就可以知道$D(x, j_1) \leq D(x, j_2)$。此时我们就不需要再计算$D(x, j_2)$</p><h2 id="K-Means与KNN"><a href="#K-Means与KNN" class="headerlink" title="K-Means与KNN"></a>K-Means与KNN</h2><p>$K-Means$是无监督学习的聚类算法，没有样本输出；而$KNN$是监督学习的分类算法，有对应的类别输出。$KNN$基本不需要训练，对测试集里面的点，只需要找到在训练集中最近的k个点，用这最近的k个点的类别来决定测试点的类别。而$K-Means$则有明显的训练过程，找到k个类别的最佳质心，从而决定样本的簇类别。</p><h1 id="主成分分析-PCA"><a href="#主成分分析-PCA" class="headerlink" title="主成分分析(PCA)"></a>主成分分析(PCA)</h1><p>这玩意我怎么总觉得自己又看懂了，又没看懂呢。。。</p><p>简单来说，$PCA$是一种降维方法，因为可能某些数据本身就具备相关性，同时存在就会冗余，我们要在降维的同时将信息的损失尽量降低。</p><p>要掌握$PCA$，我们需要补充一些基础知识。</p><h2 id="向量的表示及基变换"><a href="#向量的表示及基变换" class="headerlink" title="向量的表示及基变换"></a>向量的表示及基变换</h2><h3 id="内积与投影"><a href="#内积与投影" class="headerlink" title="内积与投影"></a>内积与投影</h3><p>假设有两个向量$a, b$，他们的内积为$a^Tb$。考虑向量只有二维，通过几何意义我们可以发现内积的绝对值的几何意义是投影的长度，这个几何意义可以推广到高维去。</p><h3 id="基底"><a href="#基底" class="headerlink" title="基底"></a>基底</h3><p>我们平时表示某个向量例如$(2, 3)$，表示其在$x$正半轴上延申2个单位，在$y$正半轴上延申3个单位，其实我们是省略了基底，我们默认的基底都是$(1, 0), (0, 1)$，向量$(2, 3)$应该表示为$(1, 0)^T(2) + (0, 1)^T(3)$</p><h3 id="基变换的矩阵表示"><a href="#基变换的矩阵表示" class="headerlink" title="基变换的矩阵表示"></a>基变换的矩阵表示</h3><p>考虑从一组基换到另一组，这个过程我们可以用矩乘来表示，下面给一个例子：<br><img src="/mlimg/basechange.png" alt=""><br>维度不一样的话，只需要将变换矩阵的维度一起更改就可以了。</p><h2 id="方差"><a href="#方差" class="headerlink" title="方差"></a>方差</h2><p>那么降维后，我们希望数据越分散越好，因为越发散越能体现数据之间的不同，我们用方差来衡量数据的分散性。</p><h2 id="协方差"><a href="#协方差" class="headerlink" title="协方差"></a>协方差</h2><p>在希望方差尽量大的前提下，我们希望选择的维度越不相关越好。因为如果相关，那么我们可以继续对他降维，直到各个维度都不相关或者相关性很弱。我们用协方差来衡量相关性质，协方差公式如下：$Cov(a, b) = \frac{1}{m}\sum_{i = 1}^m(a_i - \overline{a})(b_i - \overline{b})$。假设我们对数据进行过归一化，均值为0，上面就可以简化为：$Cov(a, b) = \frac{1}{m}\sum_{i = 1}^ma_ib_i$。我们发现这个就等于$\frac{1}{m}XX^T(X是由样本组成的矩阵)$</p><p>至此，我们得到了降维问题的优化目标：<strong>将一组$N$维向量降为$K$维（$0 \leq K \leq N$），其目标是选择$K$个单位（模为1）正交基，使得原始数据变换到这组基上后，各字段两两间协方差为0，而字段的方差则尽可能大（在正交的约束下，取最大的$K$个方差，即取绝对值最大的$K$个特征值）。</strong></p><p>设原始数据矩阵X对应的协方差矩阵为$C$，而$P$是一组基按行组成的矩阵，设$Y = PX$，则$Y$为$X$对$P$做基变换后的数据。设$Y$的协方差矩阵为$D$，我们推导一下$D$与$C$的关系：</p><script type="math/tex; mode=display">D = \frac{1}{m}YY^T = \frac{1}{m}(PX)(PX)^T = \frac{1}{m}PXX^TP^T = PCP^T</script><p>现在我们要寻找一个矩阵$P$，满足$PCP^T$是一个对角矩阵，并且对角元素按从大到小依次排列，那么$P$的前$K$行就是要寻找的基，用$P$的前$K$行组成的矩阵乘以$X$就使得$X$从$N$维降到了$K$维并满足上述优化条件。由于协方差矩阵$C$是一个是对称矩阵，其必然有：</p><ul><li>实对称矩阵不同特征值对应的特征向量必然正交</li><li>设特征向量$λ$重数为$r$，则必然存在$r$个线性无关的特征向量对应于$λ$，因此可以将这$r$个特征向量单位正交化。<br>根据相似对角化，我们一定可以找到一个矩阵$\Lambda = PCP^T$，其中$\Lambda$是对角矩阵，$PP^T = I$。其对角元素为各特征向量对应的特征值（可能有重复）。</li></ul><p>这就是$PCA$的证明，关于里面特征值分解的内容。。看看以后补还是鸽掉吧。</p><h2 id="数据重现"><a href="#数据重现" class="headerlink" title="数据重现"></a>数据重现</h2><p>当我们想重现回高维数据时，不可能得到准确值，因为我们降维后，是用的投影值来代替原来的数据，实际上真实点到垂足点上还有段距离，这部分信息我们是丢失了的，是不可逆的，所以最终只能得到预估值。<br>我们知道$Y = PX$，又有$PP^T = I$，可以得到$X_{approx} = P^TY$，注意矩阵的维度即可。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我又在无监督学习（不学习）了&lt;/p&gt;
&lt;h1 id=&quot;无监督学习简介&quot;&gt;&lt;a href=&quot;#无监督学习简介&quot; class=&quot;headerlink&quot; title=&quot;无监督学习简介&quot;&gt;&lt;/a&gt;无监督学习简介&lt;/h1&gt;&lt;p&gt;前面区分过无监督学习和有监督学习，无监督学习没有输出标签
      
    
    </summary>
    
      <category term="机器学习" scheme="http://yoursite.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>支持向量机</title>
    <link href="http://yoursite.com/2020/06/27/%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/"/>
    <id>http://yoursite.com/2020/06/27/支持向量机/</id>
    <published>2020-06-27T03:47:19.000Z</published>
    <updated>2020-07-11T08:05:34.425Z</updated>
    
    <content type="html"><![CDATA[<h1 id="支持向量机简介"><a href="#支持向量机简介" class="headerlink" title="支持向量机简介"></a>支持向量机简介</h1><p>支持向量机（support vector machines, SVM）是一种二分类模型，它的基本模型是定义在特征空间上的间隔最大的线性分类器，间隔最大使它有别于感知机；SVM还包括核技巧，这使它成为实质上的非线性分类器。SVM的的学习策略就是间隔最大化，可形式化为一个求解凸二次规划的问题，也等价于正则化的合页损失函数的最小化问题。SVM的的学习算法就是求解凸二次规划的最优化算法。</p><h1 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h1><p>支持向量机(SVM)基本想法是找到能够正确划分平面数据集且间隔(Margin)最大的分隔超平面。这里间隔指的两个异类点之间的最近距离。这个距离可以用来衡量抗干扰性，距离越大抗干扰性越强。<br>假设超平面是$w^Tx + b = 0$，任意一个点$x$到超平面的距离为：$\frac{|w^Tx + b|}{||w||}$。<br>我们令正类的$y_i = 1$，负类的$y_i = -1$，假设超平面上所有向量都被分类正确，那么有:</p><script type="math/tex; mode=display">f(x)=\left\{\begin{aligned}&w^Tx_i + b \geq 1, &y_i = +1\\&w^Tx_i + b \leq 1, &y_i = -1\\\end{aligned}\right.</script><p>那么其中最近的两个异类点之间的距离$\gamma$便是取等的时候，即为$\gamma = \frac{2}{||w||}$<br>想要找到最大的$\gamma$，问题转换成了如下：</p><script type="math/tex; mode=display">\begin{aligned}&\max_{w, b}\frac{2}{||w||} \\&s.t. \ y_i(w^Tx_i + b) \geq 1\end{aligned}</script><h1 id="拉格朗日乘子法与KKT条件"><a href="#拉格朗日乘子法与KKT条件" class="headerlink" title="拉格朗日乘子法与KKT条件"></a>拉格朗日乘子法与KKT条件</h1><p>我们知道对于带约束的求极值问题，我们可以通过拉格朗日乘子法将约束去掉。高等数学里一般讲的都是等式约束，如果含有不等式约束我们就需要使用$KKT$条件。<br>我们写出$KKT$条件的数学表达式：</p><script type="math/tex; mode=display">\begin{aligned}&L(x, \lambda_j, \mu_k) = f(x) + \sum_{j = 1}^m\lambda_jg_j(x) + \sum_{k = 1}^p\mu_kh_k(x) \\&\nabla_xL =0 \\&g_j(x) = 0 \ j = 1, \cdots, m, \\&h_k(x) \leq 0 \\&\mu_k \geq 0\end{aligned}</script><p>其实用一句很简单的话来说，最值要嘛在各边界点处取到，要嘛在极值点处取到，这就是$KKT$条件。</p><h1 id="核函数"><a href="#核函数" class="headerlink" title="核函数"></a>核函数</h1><p>上述讲的都是线性可分的$SVM$，但很多时候平面无法线性可分，这时候我们可以把它扔到高维空间去，让它在高维空间上线性可分。<br><img src="/mlimg/transtohighdim.png" alt=""><br>那么我们需要找到一个$\phi(\cdot)$，能把原来的$x$转换到高维空间上。<br>考虑到中间有一步需要求$\phi(x_i)^T\phi(x_j)$，如果转换到高维空间上计算复杂度会很大，这时候就出现了核函数$\kappa(x_i, x_j) = \phi(x_i)^T\phi(x_j)$，使得我们不需要知道$\phi(\cdot)$的具体形式，也可以求出$\kappa(x_i, x_j) = \phi(x_i)^T\phi(x_j)$的值。<br><strong>核函数只是用来计算映射到高维空间之后的内积的一种简便方法。</strong></p><h1 id="逻辑回归和SVM选用建议"><a href="#逻辑回归和SVM选用建议" class="headerlink" title="逻辑回归和SVM选用建议"></a>逻辑回归和SVM选用建议</h1><p>设特征数为$n$，样本数为$m$，给出如下选择建议：</p><ul><li>$n$很大：逻辑回归或者不带核函数的$SVM$</li><li>$n$很小，$m$适中:带高斯核函数的$SVM$</li><li>$n$很小，$m$很大：逻辑回归或者不带核函数的$SVM$</li></ul><h1 id="软间隔"><a href="#软间隔" class="headerlink" title="软间隔"></a>软间隔</h1><p>前面讨论中，我们要求所有样本都分类正确，但实际上，如果要让所有样本都正确，得出的超平面稳定性可能会很差，现在考虑允许一部分样本不满足约束$y_i(w^Tx_i + b) \geq 1$，原来的最优化问题变为了：</p><script type="math/tex; mode=display">\begin{aligned}&\min_{w, b}\frac{1}{2}||w||^2 + C\sum_{i = 1}^ml_{0/1}(y_i(w^Tx_i + b) - 1)\end{aligned}</script><p>其中$C$被称为正则化系数，$l_{0/1}$如下：</p><script type="math/tex; mode=display">l_{0/1} = \left\{\begin{aligned}1, z < 0\\0, z \geq 0\end{aligned}\right.</script><p>实际上$l_{0/1}$非凸非连续，数学性质不好，我们常用如下三种函数来替代：</p><ul><li>$hinge$损失:$l_{hinge}(z) = max(0, 1 - z)$</li><li>指数损失：$l_{exp}(z) = e^{-z}$</li><li>对率损失：$l_{log}(z) = log(1 + e^{-z})$</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;支持向量机简介&quot;&gt;&lt;a href=&quot;#支持向量机简介&quot; class=&quot;headerlink&quot; title=&quot;支持向量机简介&quot;&gt;&lt;/a&gt;支持向量机简介&lt;/h1&gt;&lt;p&gt;支持向量机（support vector machines, SVM）是一种二分类模型，它的基本模型
      
    
    </summary>
    
      <category term="机器学习" scheme="http://yoursite.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>系统的设计与评估</title>
    <link href="http://yoursite.com/2020/06/21/%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E8%AF%84%E4%BC%B0/"/>
    <id>http://yoursite.com/2020/06/21/系统的设计与评估/</id>
    <published>2020-06-21T03:11:22.000Z</published>
    <updated>2020-07-11T08:05:22.087Z</updated>
    
    <content type="html"><![CDATA[<h1 id="模型的改善措施"><a href="#模型的改善措施" class="headerlink" title="模型的改善措施"></a>模型的改善措施</h1><p>当你觉得模型的效果不如意的时候，可以有如下的一些改善措施：</p><ul><li>获取更多的数据</li><li>减少一部分特征</li><li>获取更多的特征</li><li>尝试更高阶的多项式</li><li>尝试增大正则项的系数</li><li>尝试减少正则项的系数</li></ul><p>我们需要了解模型不好的原因在哪里，根本不好的原因来采取正确的改善措施。</p><h1 id="模型评估"><a href="#模型评估" class="headerlink" title="模型评估"></a>模型评估</h1><p>前面我们也提过过拟合的问题，即在训练集上模型表现得很好，但是在测试集上的表现很差，泛用性差、不稳定，易干扰。为了较科学的评估一个模型，我们需要把数据集分为两部分，训练集 + 测试集，一般这个比例为7：3，注意需要把数据集的顺序给打乱。</p><p>对于测试误差，如果是回归问题，形式与$cost$ $function$是一样的，即：$\frac{1}{2m}\sum_{i = 1}^m(h_{\theta}(x^{(i)}) - y^{(i)})^2$。如果是分类问题，可以用其分类问题对应的$cost$ $function$来衡量，或者用另一种评判方法：0/1分类，即每次找出可能性最大的预测结果，然后与对应结果相比，0表示相同，1表示不同，最后对所有样本求和再除以样本总量，就跟正确率其实是一个东西。</p><h1 id="模型选择和训练、验证、测试集"><a href="#模型选择和训练、验证、测试集" class="headerlink" title="模型选择和训练、验证、测试集"></a>模型选择和训练、验证、测试集</h1><p>当我们要进行不同模型之间的比较时，我们需要分出一部分数据用来调整超参数，这个部分我们称为测试集。测试集是模型训练过程中单独留出的样本集，它可以用于调整模型的超参数和用于对模型的能力进行初步评估。我们用验证集的误差来作为模型选择的标准。<br>对比见下：<br><img src="/mlimg/vsandts.png" alt=""></p><h1 id="偏差与方差"><a href="#偏差与方差" class="headerlink" title="偏差与方差"></a>偏差与方差</h1><h2 id="偏差与方差-1"><a href="#偏差与方差-1" class="headerlink" title="偏差与方差"></a>偏差与方差</h2><p><img src="/mlimg/biasandvariance.png" alt=""><br>上面的图其实能说明问题了。<br>偏差：样本与真实值之间的差距<br>方差：样本与期望值之间的差距<br>误差 = 偏差 + 方差（西瓜书上有推导）</p><p>如果模型欠拟合时，即高偏差，这时候就需要复杂化模型。当模型出现过拟合时，即高方差，这时候就需要简化模型。</p><h2 id="正则化的偏差与方差"><a href="#正则化的偏差与方差" class="headerlink" title="正则化的偏差与方差"></a>正则化的偏差与方差</h2><p>考虑正则化的系树$\lambda$，增大$\lambda$，相当于增大惩罚，即在简化模型，即在增大偏差，减小方差。减小$\lambda$，相当于减小惩罚，即在复杂模型，即在减小偏差，增大方差。</p><h1 id="查准率、召回率"><a href="#查准率、召回率" class="headerlink" title="查准率、召回率"></a>查准率、召回率</h1><p><img src="/mlimg/sickandhealthy.png" alt=""></p><ul><li>查准率 $P = \frac{TP}{TP + FP}$</li><li>召回率 $R = \frac{TP}{TP + FN}$</li></ul><p>这两个指标主要针对数据比例倾斜的情况，比如癌症，一个预测恒输出0的函数预测正确率会非常高，这时候就需要这两个指标来进行衡量。</p><p>这两个指标往往是负相关的关系，即FP和FN是负相关的关系。拿癌症举例子，你要预测为癌症的人的准确率高，就必然会将一部分本来是癌症的预测为不是癌症，反过来也是一样的道理。</p><p>我们定义$F = 2 \frac{PR}{P + R}$，我们最后用F值来评估模型的有效性。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;模型的改善措施&quot;&gt;&lt;a href=&quot;#模型的改善措施&quot; class=&quot;headerlink&quot; title=&quot;模型的改善措施&quot;&gt;&lt;/a&gt;模型的改善措施&lt;/h1&gt;&lt;p&gt;当你觉得模型的效果不如意的时候，可以有如下的一些改善措施：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;获取更多的数据
      
    
    </summary>
    
      <category term="机器学习" scheme="http://yoursite.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>神经网络</title>
    <link href="http://yoursite.com/2020/06/15/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
    <id>http://yoursite.com/2020/06/15/神经网络/</id>
    <published>2020-06-15T03:55:10.000Z</published>
    <updated>2020-07-11T08:05:14.339Z</updated>
    
    <content type="html"><![CDATA[<h1 id="神经网络简介"><a href="#神经网络简介" class="headerlink" title="神经网络简介"></a>神经网络简介</h1><h2 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h2><p>前面我们学习了线性模型，但现实中很多模型都是非线性的，我们又很难知道它对应的非线性模型的形式是什么，所以我们引入神经网络来解决非线性模型。<br>神经网络的模型图如下：<br><img src="/mlimg/neuralnetwork.png" alt=""><br>第一层我们称为输入层，最后一层我们成为输出层，其余所有层都称为中间层。</p><h2 id="非线性实例"><a href="#非线性实例" class="headerlink" title="非线性实例"></a>非线性实例</h2><p>为什么神经网络能够求出非线性模型呢，我们拿一个例子来看。<br>假设我们要求$x_1  AND  x_2$<br>这玩意我们可以用一个线性模型来拟合，如图：<br><img src="/mlimg/andopt.png" alt=""><br>如果是$NOT  x$:<br><img src="/mlimg/notopt.png" alt=""><br>那如果是$x_1  xnor  x_2$呢，这显然是一个非线性模型。<br>我们可以把它拆成$(NOT  x_1)  AND  (NOT  x_2)$<br>发现可以用一个中间层来保存两个$NOT$的结果，再组合$AND$的结果。<br>这也就是为什么神经网络能用来表达非线性模型。</p><h2 id="多元分类"><a href="#多元分类" class="headerlink" title="多元分类"></a>多元分类</h2><p>当任务是一个多元分类问题时，我们常对标准结果向量化：即每一个标准结果都是一个$n$ x $1$向量，并且只有其对应的那个特征元素为1，其他所有元素为0。<br>例如三元分类，标准向量如下：<br>$\left[<br>\begin{matrix}<br>1 \\<br>0 \\<br>0<br>\end{matrix}<br>\right]<br>$ $\left[<br>\begin{matrix}<br>0 \\<br>1 \\<br>0<br>\end{matrix}<br>\right]<br>$ $\left[<br>\begin{matrix}<br>0 \\<br>0 \\<br>1<br>\end{matrix}<br>\right]<br>$</p><h1 id="反向传播"><a href="#反向传播" class="headerlink" title="反向传播"></a>反向传播</h1><p>感觉反向传播的推导挺麻烦的，慢慢写吧。。</p><p>当每次正向传播得到预测值后，我们要根据预测值和真实值的误差，反向更新各个点的参数，从而让他们朝着使$loss$ $function$减小的方向更新。<br>我们用$a^{(i)}$表示第$i$层经过激活函数后输出的值<br>我们用$z^{(i)}$表示第$i$层经过激活函数前输出的值<br>我们用$\delta^{(i)}$表示第$i$层的误差，输出层的$\delta = a - y$<br>令代价函数为：$J(\theta) = -ylogh(x) - (1 - y)(1 - h(x))$<br>假设我们已知第$x + 1$层误差为$\delta^{x + 1}$，现在我们要求第$x$层的误差：<br>已知$\delta^{(x)} = \frac{\partial J(\theta)}{\partial z^{(x)}}$<br>$\delta^{(x)} = \frac{\partial J}{\partial a^{x + 1}}\frac{\partial a^{(x + 1)}}{\partial z^{(x + 1)}}\frac{\partial z^{(x + 1)}}{\partial a^{(x)}}\frac{\partial a^{(x)}}{\partial z^{(x)}}$<br>$ = (\frac{-y}{a^{(x + 1)}} + \frac{1 - y}{1 - a^{(x + 1)}})\frac{\partial g(z^{(x + 1)})}{\partial z^{(x + 1)}}\theta^{(x)}\frac{\partial g(z^{(x)})}{\partial z^{(x)}}$<br>$ = \delta^{(x + 1)}\theta^{(x)}a^{(x)}(1 - a^{(x)})$<br>考虑维度问题：<br>$ = (\theta^{(x)})^T\delta^{(x + 1)}g’(z^{(x)})$<br>可能从$\frac{\partial g(z^{(x)})}{\partial z^{(x)}} = a^{(x)}(1 - a^{(x)})$这一步不是特别好理解，需要对函数求导，拆成两部分相乘，然后发现两边都可以用$a$替换回来，就变成后面的形式了。</p><p>考虑参数更新<br>$dw = \frac{\partial J(\theta)}{\partial w} = \frac{\partial J(\theta)}{\partial \alpha}\frac{\partial \alpha}{\partial z}\frac{\partial z}{\partial w} = (a - y) x$<br>考虑维度问题：<br>$= x^{T}(a - y)$</p><p>自己写了个最简单的神经网络，吐了，以后还是调库吧，效果也不是很好，可能有地方写错了。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> h5py</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">path = <span class="string">'C:/Users/Nemo Sherry/Desktop'</span></span><br><span class="line">train_dataset = h5py.File(path + <span class="string">'/train_catvnoncat.h5'</span>, <span class="string">"r"</span>)</span><br><span class="line">test_dataset = h5py.File(path + <span class="string">'/test_catvnoncat.h5'</span>, <span class="string">"r"</span>)</span><br><span class="line">test_x = np.array(test_dataset[<span class="string">'test_set_x'</span>])</span><br><span class="line">test_y = np.array(test_dataset[<span class="string">'test_set_y'</span>])</span><br><span class="line">train_x = np.array(train_dataset[<span class="string">'train_set_x'</span>])</span><br><span class="line">m = train_x.shape[<span class="number">0</span>]</span><br><span class="line">train_y = np.array(train_dataset[<span class="string">'train_set_y'</span>])</span><br><span class="line">train_x = train_x.reshape(train_x.shape[<span class="number">0</span>], <span class="number">-1</span>)</span><br><span class="line">test_x = test_x.reshape(test_x.shape[<span class="number">0</span>], <span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(train_x.shape[<span class="number">0</span>]):</span><br><span class="line">    np.append(train_x[i], <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(test_x.shape[<span class="number">0</span>]):</span><br><span class="line">    np.append(test_x[i], <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">train_x = train_x.T</span><br><span class="line">test_x = test_x.T</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">train_x = train_x / <span class="number">1</span></span><br><span class="line">test_x = test_x / <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(train_x.shape[<span class="number">0</span>]):</span><br><span class="line">    train_x[i] = (train_x[i] - np.sum(train_x[i]) / train_x.shape[<span class="number">1</span>]) / <span class="number">255</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(test_x.shape[<span class="number">0</span>]):</span><br><span class="line">    test_x[i] = (test_x[i] - np.sum(test_x[i]) / test_x.shape[<span class="number">1</span>]) / <span class="number">255</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sigmoid</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1.</span> / (<span class="number">1</span> + np.exp(-x))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sum = <span class="number">0</span></span><br><span class="line">cnt = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">read = <span class="keyword">True</span></span><br><span class="line">w = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> read:</span><br><span class="line">    sys.stdin = open(<span class="string">'weight.txt'</span>,<span class="string">'r'</span>)</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        x = sys.stdin.readline()</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> x : <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>: x = float(x)</span><br><span class="line">        w.append(x)</span><br><span class="line">    w = np.array(w)</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>: w = np.zeros(train_x.shape[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">file = open(<span class="string">'weight.txt'</span>,<span class="string">'w'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">predict</span><span class="params">(w, x, y)</span>:</span></span><br><span class="line">    z = np.dot(w, x)</span><br><span class="line">    a = sigmoid(z)</span><br><span class="line">    a.reshape(a.shape[<span class="number">0</span>], <span class="number">1</span>)</span><br><span class="line">    cost = (<span class="number">-1.</span> / m) * np.sum(y * np.log(a) + (<span class="number">1</span> - y) * np.log(<span class="number">1</span> - a))</span><br><span class="line">    print(cost)</span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">lr = <span class="number">0.1</span></span><br><span class="line">la = <span class="number">5</span></span><br><span class="line"></span><br><span class="line">is_train = <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">propagate</span><span class="params">(w, x, y)</span>:</span></span><br><span class="line">    a = sigmoid(np.dot(w, x))</span><br><span class="line">    dw = <span class="number">1</span> / m * np.dot(x, (a - y).T)</span><br><span class="line">    w = w - lr * dw</span><br><span class="line">    <span class="keyword">return</span> w</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> is_train:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1000</span>):</span><br><span class="line">        w = propagate(w, train_x, train_y)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cnt = <span class="number">0</span></span><br><span class="line">sum = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">t = sigmoid(np.dot(w, train_x))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(t.shape[<span class="number">0</span>]):</span><br><span class="line">    sum += <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> (t[i] &gt;= <span class="number">0.5</span>) == (train_y[i]): cnt += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">print(cnt, sum)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cnt = <span class="number">0</span></span><br><span class="line">sum = <span class="number">0</span></span><br><span class="line">t = sigmoid(np.dot(w, test_x))</span><br><span class="line"></span><br><span class="line">predict(w, test_x, test_y)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(t.shape[<span class="number">0</span>]):</span><br><span class="line">    sum += <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> (t[i] &gt;= <span class="number">0.5</span>) == (test_y[i]): cnt += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">print(cnt, sum)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(w.shape[<span class="number">0</span>]):</span><br><span class="line">    file.write(str(w[i]))</span><br><span class="line">    file.write(<span class="string">'\n'</span>)</span><br><span class="line">file.close()</span><br></pre></td></tr></table></figure></p><p>中间还被一个坑坑了很久，读入进来的numpy的dtype是uint16类型的，我想每一行归一化，一开始直接对每一行操作，然后元素就全变成0了。猜测应该是在对第一行操作的时候，会先把这个numpy的dtype类型转成float的，然后就莫名丢失了内容。所以numpy要转类型要对整个矩阵一起转，不能只转某一行。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;神经网络简介&quot;&gt;&lt;a href=&quot;#神经网络简介&quot; class=&quot;headerlink&quot; title=&quot;神经网络简介&quot;&gt;&lt;/a&gt;神经网络简介&lt;/h1&gt;&lt;h2 id=&quot;模型&quot;&gt;&lt;a href=&quot;#模型&quot; class=&quot;headerlink&quot; title=&quot;模型&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="机器学习" scheme="http://yoursite.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>正则化</title>
    <link href="http://yoursite.com/2020/06/14/%E6%AD%A3%E5%88%99%E5%8C%96/"/>
    <id>http://yoursite.com/2020/06/14/正则化/</id>
    <published>2020-06-14T02:55:40.000Z</published>
    <updated>2020-07-11T08:05:18.956Z</updated>
    
    <content type="html"><![CDATA[<h1 id="拟合"><a href="#拟合" class="headerlink" title="拟合"></a>拟合</h1><p>如果一个模型拟合的不好，一般是如下两种：</p><ul><li>欠拟合</li><li>过拟合<br><img src="/mlimg/fit.png" alt=""><br>第一张图就是欠拟合，很显然不管什么样的直线模型都不能反映出房价后面逐渐平稳的趋势。<br>第二张图拟合效果不错，能反映出整个房价的变化趋势。<br>第三张图就是过拟合，我们知道用拉格朗日插值可以根据$n + 1$个点求出一个唯一确定$n$次多项式，但很显然各个项系数可能会非常大，稳定性也会很差。过拟合实际上就是逐渐靠近这个插值的多项式，使得它能在这些训练集的数据上跑的很好，但是测试集效果就会很差（抗干扰能力不强，容易受噪声影响）。</li></ul><p><img src="/mlimg/overfit.png" alt=""><br>如上图也是过拟合，边界的情况不够平滑，事实上我们希望的是下面这样的模型:<br><img src="/mlimg/goodfit.png" alt=""><br>虽然会在边界有一些误判，这也是很正常的，因为有噪声干扰等的原因，但我们希望边界平滑，从而有更好的泛用性。</p><p>为了解决如上的过拟合问题，我们引入了正则项。</p><h1 id="范数"><a href="#范数" class="headerlink" title="范数"></a>范数</h1><p>在介绍正则项前，我们先来看范数的相关内容。</p><h2 id="L-P范数"><a href="#L-P范数" class="headerlink" title="L-P范数"></a>L-P范数</h2><p>$||x||_p = \sqrt[p]{\sum_{i = 1}^nx_i^p}$</p><p>这是范数的通用定义，实际上在机器学习中，$L0, L1, L2$范数用的比较多，其它的使用都非常的少</p><h2 id="L0范数"><a href="#L0范数" class="headerlink" title="L0范数"></a>L0范数</h2><p>$L0$范围根据上面的定义其实不太准确，$L0$范数实际上求的是非零元素的个数。这貌似非常适合用来筛选特征，但实际上$L_0$范围不好找到一个好的数学表达形式（开0次方等行为比较诡异），所以$L_0$的最优化问题一般会被下放到$L_1, L_2$范数下进行最优化</p><h2 id="L1范数"><a href="#L1范数" class="headerlink" title="L1范数"></a>L1范数</h2><p>$L1$范数根据定义可以看出来是进行绝对值求和，下面我们对带有$L1$范数的梯度下降进行一下探究。</p><p>$\theta_j = \theta_j - \alpha(\frac{1}{m}\sum_{i = 1}^m\frac{\partial J(\theta)}{\theta_j} + \frac{\lambda}{m} * sgn(\theta_j))$<br>我们发现，与原来相比，当$\theta$大于0时，他会减去一个数，当$\theta$小于0时，他会加上一个数，当$\theta$等于0时，他不会改变。所以$L1$范围会让参数尽量的等于0，从而起到了参数稀疏化的作用，从而能够用来进行特征筛选。</p><h2 id="L2范数"><a href="#L2范数" class="headerlink" title="L2范数"></a>L2范数</h2><p>$L2$范数根据定义看出就是距离欧几里得距离求和，下面我们对带有$L2$范数的梯度下降进行一下探究。<br>$\theta_j = \theta_j - \alpha(\frac{1}{m}\sum_{i = 1}^m\frac{\partial J(\theta)}{\theta_j} + \frac{\lambda}{m} \theta_j) = (1 - \alpha \lambda)\theta - \frac{1}{m}\sum_{i = 1}^m\frac{\partial J(\theta)}{\theta_j}$<br>我们发现$L_2$范数每次更新时，相当于把自己乘上一个小于1的数再减去梯度，这过程就会使得参数越来越靠近0，但不会等于0，所以$L2$范数限制了参数会出现很大的情况，从而防止过拟合的情况发生。</p><h1 id="正则项"><a href="#正则项" class="headerlink" title="正则项"></a>正则项</h1><p>在原来的$loss$ $function$后面加上某些范数，这些加上的项就是正则项了。<br>对于梯度下降的正则项推导前面都做得差不多了，下面来看一看正规方程的：<br>$J(\theta) = \frac{1}{2m}(\theta X - T)^T(\theta X - T) + \frac{1}{2m}\lambda\theta^T\theta$<br>求导:<br>$\frac{\partial J(\theta)}{\partial \theta} = \frac{1}{2m}  (2X^TX\theta - 2X^TY + \lambda\theta^T\theta) = 0$<br>得到：<br>$\theta = (X^TX + \lambda E)^{-1}X^TY$<br>前面讨论无正则项时，$X^TX$可能会有不可逆的情况，通过加正则项可以解决这种不可逆的情况。</p><p>注意：</p><ul><li>实际使用中为了方便，可能会在正则项前面配一个常数，方便求导的时候可以直接约掉。</li><li>一般正则项我们不包含常数项，原因是常数项大不会扭曲边界，且很多时候确实需要大的常数项</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;拟合&quot;&gt;&lt;a href=&quot;#拟合&quot; class=&quot;headerlink&quot; title=&quot;拟合&quot;&gt;&lt;/a&gt;拟合&lt;/h1&gt;&lt;p&gt;如果一个模型拟合的不好，一般是如下两种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;欠拟合&lt;/li&gt;
&lt;li&gt;过拟合&lt;br&gt;&lt;img src=&quot;/mlimg
      
    
    </summary>
    
      <category term="机器学习" scheme="http://yoursite.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>Logistic回归</title>
    <link href="http://yoursite.com/2020/06/11/Logistic%E5%9B%9E%E5%BD%92/"/>
    <id>http://yoursite.com/2020/06/11/Logistic回归/</id>
    <published>2020-06-11T11:52:11.000Z</published>
    <updated>2020-07-11T08:05:11.813Z</updated>
    
    <content type="html"><![CDATA[<h1 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h1><p>之前学习了线性回归问题，$Logistic$回归虽然还带了回归的字眼，但实际上是一个分类问题。</p><p>分类问题和回归问题前面也做了区分，简单来说分类问题输出的是一个离散的值，相当于输出一个标签。</p><p>我们先讨论二分类的问题，假设分类标签为0、1。如果我们用线性回归的方法去拟合，会出现大于1或者小于0的情况，对于这部分情况我们难以给它分类。所以这才引出了$Logistic$回归</p><h1 id="假设陈述"><a href="#假设陈述" class="headerlink" title="假设陈述"></a>假设陈述</h1><p>我们引入$sigmoid$函数:<br><img src="/mlimg/sigmoid.png" alt=""><br>由图可知，如果用$sigmoid$函数，就可以把原来在值域的值转换到区间[0, 1]中，并且具体的数值可以用来近似表示分类为1(正例)的概率。<br>最后就有$h_{\theta}(X) = \frac{1}{1 + e^{-\theta^TX}}$</p><h1 id="决策边界"><a href="#决策边界" class="headerlink" title="决策边界"></a>决策边界</h1><p>决策边界是用来进行类别划分的边界函数，可以是线性函数也可以是非线性函数。<br><img src="/mlimg/decisionboundary.png" alt=""><br>在$Logistic$回归中，我们有如下预测：</p><ul><li>当$h_{\theta}(X) \geq 0.5$，即$\theta^TX \geq 0$，此时$y = 1$</li><li>当$h_{\theta}(X) &lt; 0.5$，即$\theta^TX &lt; 0$，此时$y = 0$<br>故边界由下述等式来确定：<br>$\theta^TX = 0$</li></ul><h1 id="最大似然估计"><a href="#最大似然估计" class="headerlink" title="最大似然估计"></a>最大似然估计</h1><p>最大似然估计是指在已知一组观测值和模型假设的情况下，求出能使得结果与观测值相同时最大可能性的模型参数。用人话来讲，就是我知道一组观测结果，知道模型的函数，但有些参数没确定，我需要确定这些参数，使得发生与观测情况相同事件的概率最大。</p><p>从另一个角度来说，对于函数$p(x | \theta)$，$x$表示一个具体的数据，$\theta$表示该模型的参数。</p><p>如果$\theta$已知，相当于就是概率函数，代入$x$就能求得$x$样本下时间发生的概率</p><p>如果$x$已知，相当于就是似然函数，它描述了对于不同的模型参数，出现$x$这个样本的概率</p><p>下面有个简单的例子，假设箱子里有一堆球，分别为黑白两色，假设某个人抽了100次，出现了60次白球，40次黑球，我们想知道白球占比是多少？<br>虽然是一个非常简单的问题，但是背后原理就是最大似然估计。<br>这个下面的模型就很简单，概率函数(出现白球)设为$p(x) = p$<br>它的最大似然估计为$p^{60}(1 - p)^{40}$<br>求导算出最大点的$p = 0.6$<br>这就是一个简单的最大似然估计的例子。</p><h1 id="代价函数"><a href="#代价函数" class="headerlink" title="代价函数"></a>代价函数</h1><p>我们先写出最终分类的概率函数：<br>$p(y | x;\theta) = (h_{\theta}(x))^y(1 - h_{\theta}(x))^{1 - y}$<br>对于一组m个的样本$(x_i, y_i)$，我们写出它的似然函数：<br>$L(\theta) = \prod_{i = 1}^m(h_{\theta}(x_i))^{y_i}(1 - h_{\theta}(x_i))^{1 - y_i}$<br>我们对其取对数似然：<br>$l(\theta) = logL(\theta) = \sum_{i = 1}^m(y_ilogh_{\theta}(x_i) + (1 - y_i)log(1 - h_{\theta}(x_i)))$<br>似然函数越大，表示拟合的越好；损失函数越小，同样表示拟合的越好，所以我们可以把似然函数取个反作为损失函数。<br>$J(\theta) = -l(\theta)$<br>这样我们就可以运用前面的梯度下降法来更新了<br>$\theta = \theta - \alpha\frac{1}{m}\frac{\partial J(\theta)}{\partial \theta}$<br>求导过程不写了，直接写最后结果：<br>$\theta_j = \theta_j - \alpha\sum_{i = 1}^m(h_{\theta}(x^{i}) - y^{(i)})x_j^{(i)}$</p><h1 id="多分类问题"><a href="#多分类问题" class="headerlink" title="多分类问题"></a>多分类问题</h1><p>感觉这上面多分类讲的有点简单啊，又查了查资料 + 看了下西瓜书，补充一些内容</p><p>我们已经知道了二分类问题，多分类问题就可以直接套用二分类的做法，只是需要多一个到二分类问题的转换。而这个转换的形式就有几种。</p><h2 id="一对一拆分-OvO"><a href="#一对一拆分-OvO" class="headerlink" title="一对一拆分(OvO)"></a>一对一拆分(OvO)</h2><p>一对一拆分就是最暴力的，对于$n$个分类，我们两两组合，构造$\frac{n(n - 1)}{2}$个二分类器，对于每一个分类器，我们把这两类的数据拿进去训练。对于一个样本，我们用每一个分类器都进行一次预测，最后取票数最高的作为最终预测值。</p><p>特点：分类器数目较多，需要的空间较大，每个分类器只使用两类数据。</p><h2 id="一对多拆分-OvR"><a href="#一对多拆分-OvR" class="headerlink" title="一对多拆分(OvR)"></a>一对多拆分(OvR)</h2><p>一对多拆分就是每次只选一个分类作为1(正例)，剩下的都作为反例，得到$n$个分类器。对于每个分类器都用所有数据去训练。对于一个样本，若有一个分类器为正类，则为该类别，否则取置信度最高的分类器识别的类别。</p><p>特点：分类器较少，每个分类器都需要训练全部数据。</p><h2 id="多对多拆分-MvM"><a href="#多对多拆分-MvM" class="headerlink" title="多对多拆分(MvM)"></a>多对多拆分(MvM)</h2><p>多对多拆分共有$m$个分类器，每个分类器将其中若干个类作为正类，剩下的作为反类，并采取纠错输出码(ECOC)<br>ECOC工作过程主要分为以下两步：<br>1.对N个类做M次划分，每次划分将一部分作为正类，一部分划分反类，从而形成一个二分类训练集。一共产生M个训练集，训练出M个分类器。<br>2.M个分类器分别对测试样本进行预测，这些预测标记组成一个编码。将这个预测编码与每个类各自的编码进行比较，返回其中距离最小的类别作为最终结果。<br><img src="/mlimg/ECOC.png" alt=""><br>如图所示，我们把样本拿到所有分类器中预测，得到一个ECOC码，我们根据码距找最近的，这里有两种码距，简单介绍一下：</p><ul><li>海明距离：简单来说就是有多少个不一样的距离就是多少</li><li>欧氏距离：类比空间里求欧氏距离的公式就可以求出</li></ul><p>特点：对同一个学习任务来说，ECOC编码越长，纠错能力越强。然而编码越长所需要的训练的分类器越多，计算存储开销都会增大；另一方面对于有限类别码长超过一定范围就没有意义了。对于同等长度的编码，理论上来说，任务两个类别之间的编码距离越远，则纠错能力越强。</p><p>最后附上内置数据集里的一个预测，跑的OvR，效果还挺不错的<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_iris <span class="comment">#导入IRIS数据集</span></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">iris = load_iris()</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line">x = iris[<span class="string">'data'</span>]</span><br><span class="line">x = x.tolist()</span><br><span class="line">y = iris[<span class="string">'target'</span>]</span><br><span class="line"></span><br><span class="line">w1 = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>)]</span><br><span class="line">w2 = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>)]</span><br><span class="line">w3 = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>)]</span><br><span class="line"><span class="comment">#print(w)</span></span><br><span class="line"></span><br><span class="line">lr = <span class="number">0.01</span></span><br><span class="line">m = len(x) // <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(x)):</span><br><span class="line">    x[i].append(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(w, x)</span>:</span></span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(w)):</span><br><span class="line">        res += w[i] * x[i]</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> / (<span class="number">1</span> + math.exp(-res))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> t <span class="keyword">in</span> range(<span class="number">1000000</span>):</span><br><span class="line">    i = random.randint(<span class="number">0</span>, <span class="number">20</span>) + random.randint(<span class="number">0</span>, <span class="number">2</span>) * <span class="number">50</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(len(w1)):</span><br><span class="line">        w1[j] = w1[j] - <span class="number">1</span> / m * lr * (f(w1, x[i]) - (<span class="number">1</span> <span class="keyword">if</span> y[i] == <span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span>)) * x[i][j]</span><br><span class="line">        w2[j] = w2[j] - <span class="number">1</span> / m * lr * (f(w2, x[i]) - (<span class="number">1</span> <span class="keyword">if</span> y[i] == <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span>)) * x[i][j]</span><br><span class="line">        w3[j] = w3[j] - <span class="number">1</span> / m * lr * (f(w3, x[i]) - (<span class="number">1</span> <span class="keyword">if</span> y[i] == <span class="number">2</span> <span class="keyword">else</span> <span class="number">0</span>)) * x[i][j]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">all = <span class="number">0</span></span><br><span class="line">correct = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">px = []</span><br><span class="line">py = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">150</span>):</span><br><span class="line">    all += <span class="number">1</span></span><br><span class="line">    p = [f(w1, x[i]), f(w2, x[i]), f(w3, x[i])]</span><br><span class="line">    flag = <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> max(p) == p[y[i]]:</span><br><span class="line">        correct += <span class="number">1</span></span><br><span class="line">        py.append(y[i])</span><br><span class="line">    <span class="keyword">else</span>: py.append(p.index(max(p)))</span><br><span class="line">    px.append(i)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(correct, all, correct / all)</span><br><span class="line"></span><br><span class="line">plt.plot(px, py, <span class="string">'.'</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;分类&quot;&gt;&lt;a href=&quot;#分类&quot; class=&quot;headerlink&quot; title=&quot;分类&quot;&gt;&lt;/a&gt;分类&lt;/h1&gt;&lt;p&gt;之前学习了线性回归问题，$Logistic$回归虽然还带了回归的字眼，但实际上是一个分类问题。&lt;/p&gt;
&lt;p&gt;分类问题和回归问题前面也做了区
      
    
    </summary>
    
      <category term="机器学习" scheme="http://yoursite.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>多变量线性回归</title>
    <link href="http://yoursite.com/2020/06/09/%E5%A4%9A%E5%8F%98%E9%87%8F%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/"/>
    <id>http://yoursite.com/2020/06/09/多变量线性回归/</id>
    <published>2020-06-09T07:30:43.000Z</published>
    <updated>2020-07-11T08:05:07.846Z</updated>
    
    <content type="html"><![CDATA[<h1 id="多功能"><a href="#多功能" class="headerlink" title="多功能"></a>多功能</h1><h2 id="一些定义"><a href="#一些定义" class="headerlink" title="一些定义"></a>一些定义</h2><ul><li>$x_i^{(j)}$:第$i$个样本的第$j$个特征</li></ul><h2 id="多变量形式"><a href="#多变量形式" class="headerlink" title="多变量形式"></a>多变量形式</h2><p>$h_{\theta}(x) = \theta_0 + \theta_1x_1 + \theta_2x_2 + \dots + \theta_nx_n$, 这里的$x_i$就代表第$i$个特征</p><h2 id="矩阵定义"><a href="#矩阵定义" class="headerlink" title="矩阵定义"></a>矩阵定义</h2><p>我们这里用矩阵来定义，后面我们将发现，运算过程可以变为矩阵的乘法。</p><ul><li><p>$\theta =<br>\left[<br>\begin{matrix}<br> \theta_0\\<br> \theta_1\\<br> \theta_2\\<br> .\\<br> .\\<br> \theta_n<br>\end{matrix}<br>\right]<br>$</p></li><li><p>$x =<br>\left[<br>\begin{matrix}<br> 1\\<br> x_1\\<br> x_2\\<br> .\\<br> .\\<br> x_n<br>\end{matrix}<br>\right]<br>$</p></li></ul><p>我们发现上面的$h_{\theta}(x)$可以写成$h_{\theta}(x) = \theta^Tx$</p><h1 id="多元梯度下降法"><a href="#多元梯度下降法" class="headerlink" title="多元梯度下降法"></a>多元梯度下降法</h1><p>其实就是把线性的拿来做了一个拓展，形式都完全一样</p><ul><li>$J(\theta_0, \theta_1, \theta_2\cdots, \theta_n) = \frac{1}{2m}\sum_{i = 1}^m(\theta_{i0} + \theta_1x_{i1} + \theta_2x_{i2} + \cdots + \theta_nx_{in} - y_i) ^ 2$</li></ul><p>那么我们有如下的更新方法：<br>$\theta_z = \theta_z - \alpha\frac{1}{m}\sum_{i = 1}^m(h_{\theta}(x^{(i)}) - y^{(i)})x_z{(i)}$，其中$x_0 = 1$</p><h1 id="特征放缩"><a href="#特征放缩" class="headerlink" title="特征放缩"></a>特征放缩</h1><p>在$h_{\theta}(x) = \theta_0 + \theta_1x_1 + \theta_2x_2 + \dots + \theta_nx_n$中，假设各个$x_i$的取值范围大小相差很大，在更新上会出现不稳定的问题。原因就是参数值大的出现的波动会更大，举个例子，假设各个参数$\theta_i$都增加0.01，那么取值范围较大的$x_i$特征就会使整个函数的波动更大，在等高线图上表现出来就是$x_i$越大$\theta_i$会显得越加扁平，会造成其他维度的更新较为缓慢。<strong>这样即造成迭代过程中很多轮次实际上是为了消除特征尺度上的不一致，</strong>故而增加了迭代的轮次，收敛速度变慢。<br><img src="\mlimg\equalheight1.png" alt=""></p><p>如果各个维度取值范围接近，那么在等高线图上看起来就会显得很均匀，比如二维平面上就是一个圆，三维平面上就是一个球。<br><img src="\mlimg\equalheight2.png" alt=""></p><p>明显从图中发现，越均匀就会减少很多”绕路”的更新，更直接的接近最小值。</p><p>特征放缩的方法有很多，最常用的是如下：<br>$x’ = \frac{x - \mu}{s}$，其中$s = max - min$，又称为标准差。<br>还有其他很多不同的方法，这里不赘述。</p><h1 id="多项式回归"><a href="#多项式回归" class="headerlink" title="多项式回归"></a>多项式回归</h1><p>多项式回归很简单，只需要把上述的多变量形式里面的$x_i$换成对应的幂次就行了。这个过程中要特别注意特征放缩的问题，因为多项式拟合里出现了幂次，很容易就使得某个原来$x$的取值范围变得很大。</p><h1 id="正规方程"><a href="#正规方程" class="headerlink" title="正规方程"></a>正规方程</h1><p>求解正规方程是不是就是最小二乘法的过程啊。。。</p><p>假设方程一共$n + 1$个特征，我们把每个训练的样本看作一个向量：<br>$x_i =<br>\left[<br>  \begin{matrix}<br>  x_i^{(0)}\\<br>  x_i^{(1)}\\<br>  x_i^{(2)}\\<br>  .\\<br>  .\\<br>  .\\<br>  x_i^{(n)}<br>  \end{matrix}<br>\right]<br>$ </p><p>我们就可以构造$X、y$矩阵:<br>$X =<br>\left[<br>  \begin{matrix}<br>  x_1\\<br>  x_2\\<br>  x_3\\<br>  .\\<br>  .\\<br>  .\\<br>  x_n<br>  \end{matrix}<br>\right]<br>$</p><p>$y =<br>\left[<br>  \begin{matrix}<br>  y_1\\<br>  y_2\\<br>  y_3\\<br>  .\\<br>  .\\<br>  .\\<br>  y_n<br>  \end{matrix}<br>\right]<br>$<br>最优化参数$\theta$矩阵就满足如下式子：<br>$\theta = (X^TX)^{-1}X^Ty$<br>这式子就跟最小二乘推导出的东西一毛一样嘛（应该说的就是一个东西）</p><p>关于梯度下降法和正规方程法的对比如下：<br><img src="/mlimg/comparegdandne.png" alt=""></p><h1 id="正规方程不可逆"><a href="#正规方程不可逆" class="headerlink" title="正规方程不可逆"></a>正规方程不可逆</h1><p>从上面式子看到，如果想要能求出正确结果，需要满足$X^TX$是可逆的，事实上可能会存在一些情况导致其不可逆，原因可能如下：</p><ul><li>特征太多，样本太少</li><li>特征之间不是独立关系</li></ul><p>第一点说的就是矩阵的秩太小，达不到满秩，自然就不可逆。<br>第二点说的是各个向量不是线性无关的，所以本质上秩在经过行列变换后会变小，达不到满秩。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;多功能&quot;&gt;&lt;a href=&quot;#多功能&quot; class=&quot;headerlink&quot; title=&quot;多功能&quot;&gt;&lt;/a&gt;多功能&lt;/h1&gt;&lt;h2 id=&quot;一些定义&quot;&gt;&lt;a href=&quot;#一些定义&quot; class=&quot;headerlink&quot; title=&quot;一些定义&quot;&gt;&lt;/a&gt;一些定
      
    
    </summary>
    
      <category term="机器学习" scheme="http://yoursite.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>单变量线性回归</title>
    <link href="http://yoursite.com/2020/06/08/%E5%8D%95%E5%8F%98%E9%87%8F%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/"/>
    <id>http://yoursite.com/2020/06/08/单变量线性回归/</id>
    <published>2020-06-08T02:31:51.000Z</published>
    <updated>2020-07-11T08:04:51.162Z</updated>
    
    <content type="html"><![CDATA[<h1 id="模型描述"><a href="#模型描述" class="headerlink" title="模型描述"></a>模型描述</h1><p>$y = \theta_0  +  \theta_1x$</p><h1 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h1><ul><li>$(x^{(i)}, y^{(i)})$表示训练集中第i对样本</li><li>$J(\theta_1, \theta_2  )$ $=$ $\frac{1}{2m}\sum_{i = 1}^m(h(x^{(i)})  - y^{(i)})^2$</li></ul><h1 id="梯度下降法"><a href="#梯度下降法" class="headerlink" title="梯度下降法"></a>梯度下降法</h1><ul><li>$\theta_i$ = $\theta_i$ - $\alpha \frac{\partial J(\theta_1, \theta_2)}{\theta_i}$，其中$\alpha$代表学习率</li></ul><p>其实根据高等数学知识可知，求偏导可以相当于把整个函数看作一元函数，我们已知一元导数表示在该点$x$增大，$y$增大的趋势。如果$x$增大$y$也增大，那么我们希望$x$减小，否则希望$x$增大，所以可以发现上面梯度下降的减号是很有道理的。<br>对于每一个变量我们都按上述操作进行更新，最后函数$J$就能往最小值逼近。</p><ul><li>梯度下降虽然是每次更新是让各个参数向着函数值减少值方向在变化，但并不一定是让各个参数一直在向最优的结果变化，举个例子：<br>$y = \theta_0  +  \theta_1x$<br>假设对于某个时刻，$\theta_1$很小，$\theta_0$很大，此时$loss$ $function$也很大，求导后发现$\theta_1$会继续减小，但实际上最优的情况比当前$\theta_1$要大。<br>但这并不影响什么，实际上只要迭代次数足够多，最后一定会绕回到非常靠近最优解的位置。</li></ul><p>附上一个小的test，拟合一条直线，数据随缘取的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">x = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">y = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>]</span><br><span class="line"></span><br><span class="line">w = [<span class="number">1000000</span>, <span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">lr = <span class="number">0.001</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1000000</span>):</span><br><span class="line">    k_sum = <span class="number">0</span></span><br><span class="line">    b_sum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(min(len(x), len(y))):</span><br><span class="line">        k_sum += (w[<span class="number">1</span>] * x[j] + w[<span class="number">0</span>] - y[j]) * x[j]</span><br><span class="line">        b_sum += (w[<span class="number">1</span>] * x[j] + w[<span class="number">0</span>] - y[j])</span><br><span class="line"></span><br><span class="line">    k_sum /= <span class="number">10</span></span><br><span class="line">    b_sum /= <span class="number">10</span></span><br><span class="line">    w[<span class="number">0</span>] = w[<span class="number">0</span>] - lr * b_sum</span><br><span class="line">    w[<span class="number">1</span>] = w[<span class="number">1</span>] - lr * k_sum</span><br><span class="line"></span><br><span class="line">print(w[<span class="number">0</span>], w[<span class="number">1</span>])</span><br></pre></td></tr></table></figure><p>最后得到k，b如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">k = <span class="number">1.9999999999994449</span></span><br><span class="line">b = <span class="number">1.0000000000011102</span></span><br></pre></td></tr></table></figure></p><p>发现非常接近准确值$y = 2x + 1$</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;模型描述&quot;&gt;&lt;a href=&quot;#模型描述&quot; class=&quot;headerlink&quot; title=&quot;模型描述&quot;&gt;&lt;/a&gt;模型描述&lt;/h1&gt;&lt;p&gt;$y = \theta_0  +  \theta_1x$&lt;/p&gt;
&lt;h1 id=&quot;损失函数&quot;&gt;&lt;a href=&quot;#损失函数&quot;
      
    
    </summary>
    
      <category term="机器学习" scheme="http://yoursite.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>初始机器学习</title>
    <link href="http://yoursite.com/2020/06/06/%E5%88%9D%E5%A7%8B%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    <id>http://yoursite.com/2020/06/06/初始机器学习/</id>
    <published>2020-06-06T01:54:32.000Z</published>
    <updated>2020-07-11T08:05:04.565Z</updated>
    
    <content type="html"><![CDATA[<h1 id="监督学习"><a href="#监督学习" class="headerlink" title="监督学习"></a>监督学习</h1><p>这一章好像没啥内容，主要是区分几个概念。</p><h2 id="监督学习-1"><a href="#监督学习-1" class="headerlink" title="监督学习"></a>监督学习</h2><p>利用一组已知类别的样本调整分类器的参数，使其达到所要求性能的过程</p><h2 id="分类问题与回归问题"><a href="#分类问题与回归问题" class="headerlink" title="分类问题与回归问题"></a>分类问题与回归问题</h2><p>由字面意思可得，分类问题解决的是把目标归属到某个类别当中，而回归问题解决的是通过一系列相关因素预测目标的一个值。</p><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><ul><li>分类问题的目标值是离散的，回归是连续的</li><li>二者$loss$ $function$函数性质不同，回归问题$loss$函数输出空间是度量空间，即可以”定量”，而分类问题$loss$函数输出空间不是度量空间，即只有正确和错误之分，只能”定性”</li></ul><h1 id="无监督学习"><a href="#无监督学习" class="headerlink" title="无监督学习"></a>无监督学习</h1><h2 id="无监督学习-1"><a href="#无监督学习-1" class="headerlink" title="无监督学习"></a>无监督学习</h2><p>根据类别未知(没有被标记)的训练样本解决模式识别中的各种问题</p><h2 id="无监督学习与有监督学习区别"><a href="#无监督学习与有监督学习区别" class="headerlink" title="无监督学习与有监督学习区别"></a>无监督学习与有监督学习区别</h2><ul><li>有监督学习有$y$，而无监督学习无$y$<br>上述说法只是表面现象，但感觉没有直击本质。搜集资料时看到一位网友的总结：标签$y$其实是一种施加于对$x$进行压缩过程中的约束。这就是有监督学习。换句话说，机器学习本质上是一种数据的压缩，有监督学习给了这种压缩一个约束，而无监督学习是让机器自己对数据进行重建，如下图：<br><img src="/mlimg/compare_superandunsuper.png" alt=""></li></ul><p>让我们来举两个例子：</p><ul><li>根据患者各方面情况判断是否得了某种病 有监督学习</li><li>根据新闻内容，内容相近的归为一个专题 无监督学习</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;监督学习&quot;&gt;&lt;a href=&quot;#监督学习&quot; class=&quot;headerlink&quot; title=&quot;监督学习&quot;&gt;&lt;/a&gt;监督学习&lt;/h1&gt;&lt;p&gt;这一章好像没啥内容，主要是区分几个概念。&lt;/p&gt;
&lt;h2 id=&quot;监督学习-1&quot;&gt;&lt;a href=&quot;#监督学习-1&quot; cla
      
    
    </summary>
    
      <category term="机器学习" scheme="http://yoursite.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>多项式，永远滴神</title>
    <link href="http://yoursite.com/2020/04/27/%E5%A4%9A%E9%A1%B9%E5%BC%8F%EF%BC%8C%E6%B0%B8%E8%BF%9C%E6%BB%B4%E7%A5%9E/"/>
    <id>http://yoursite.com/2020/04/27/多项式，永远滴神/</id>
    <published>2020-04-27T13:15:48.000Z</published>
    <updated>2020-07-11T08:12:12.130Z</updated>
    
    <content type="html"><![CDATA[<h1 id="FFT"><a href="#FFT" class="headerlink" title="FFT"></a>FFT</h1><p>先咕</p><h1 id="NTT"><a href="#NTT" class="headerlink" title="NTT"></a>NTT</h1><p>先咕</p><h1 id="FWT"><a href="#FWT" class="headerlink" title="FWT"></a>FWT</h1><p>FWT是解决形如<script type="math/tex">C_k = \sum_{i \ op \ j}A_i * B_j</script>，其中op可以是$\&amp;  | \bigoplus$等操作，普通方法肯定是$O(n^2)$的，考虑$FFT$是做了一种变化，然后变化后进行点乘，再逆变化回去，就可以把复杂度优化到$O(nlogn)$，$FWT$能不能采取类似的思路呢？答案是肯定的。<br>我们需要构造$FWT(A)$，使得$FWT(A  op  B) = FWT(A) * FWT(B)$<br>仔细观察，发现这个东西满足交换律：$FWT(A | B) = FWT(B | A)$<br>再观察，发现这玩意还满足结合律：$FWT((A + B) | C) = FWT(A | C) + FWT(B | C)$<br>我们对于一个多项式$A$，定义$A_0，A_1$，分别表示前一半和后一半多项式（二进制最高位为0和为1）。</p><h2 id="or"><a href="#or" class="headerlink" title="or"></a>or</h2><p>$FWT(A) = (FWT(A_0), FWT(A_0 + A_1))$<br>你问括号里的加法是什么意思？就是可以把他们看成一个维度相同的向量，对应位置相加。<br>你问括号里一个逗号什么意思，就是两个多项式拼起来。前面是前一半的结果，后面是后一半的结果。</p><p>考虑正确性，因为是或运算，FWT其实求的就是子集的前缀和（所有子集的和），首先前一半系数必然最高位都为0，所以只能是由$A_0$里面来产生的贡献。考虑后面，因为最高位必须为1，所以一部分贡献来自最高位为1的，同时考虑某个位置去掉最高位的1，会对应$A_0$中的某个位置，这部分贡献也会被包含，所以最终贡献就是$A_0 + A_1$<br>然后我们就可以递归去做求的$or的FWT$了（事实上实现的时候我们采用循环）</p><p>考虑怎么反变换回来，其实很简单$IFWT(A) = (IFWT(A_0)，IFWT(A_1 - A_0))$</p><h2 id="and"><a href="#and" class="headerlink" title="and"></a>and</h2><p>and刚好是跟or反过来的，or的$FWT$表示的是某个集合所有的子集的和，而and的$FWT$是表示的某个集合所有包含它的集合的和，相当于可以描述为后缀和？那么它的$FWT$我们考虑表示$FWT(A) = FWT(FWT(A_0 + A_1), FWT(A_1))$。</p><p>考虑正确性证明，首先后一半的贡献必须全来自$A_1$，前一半$A_0$会产生贡献，$A_0$每一项加上最高位对应$A_1$中的每一项也会产生贡献，所以就是$A_0 + A_1$</p><p>对应反变换也很好写$IFWT(A) = (IFWT(A_0 + A_1)，IFWT(A_1))$</p><h2 id="xor"><a href="#xor" class="headerlink" title="xor"></a>xor</h2><p>异或的构造是最难的，也是唯一没法从$FMT$角度解释的一个，可以说是真正的$FWT$。<br>这里给出构造$FWT(A) = (FWT(A_0 + A_1), FWT(A_0 - A_1))$</p><p>给出正确性证明：<br>$= FWT((A_0 \bigoplus B_0) + FWT(A_1 \bigoplus B_1), FWT(A_0 \bigoplus B_1) + FWT(A_1 \bigoplus B_0))$</p><script type="math/tex; mode=display">= (FWT(A_0 \bigoplus B_0 + A_1 \bigoplus B_1 + A_1 \bigoplus B_0 + A_0 \bigoplus B_1),</script><script type="math/tex; mode=display">FWT(A_0 \bigoplus B_0 + A_1 \bigoplus B_1 - A_1 \bigoplus B_0 - A_0 \bigoplus B_1))</script><script type="math/tex; mode=display">= ((FWT(A_0) + FWT(A_1)) * (FWT(B_0) + FWT(B_1)),</script><script type="math/tex; mode=display">(FWT(A_0) - FWT(A_1)) * (FWT(B_0) - FWT(B_1)))</script><script type="math/tex; mode=display">= (FWT(A_0 + A_1) * FWT(B_0 + B_1),</script><script type="math/tex; mode=display">FWT(A_0 - A_1) * FWT(B_0 - B_1))</script><script type="math/tex; mode=display">= (FWT(A_0 + A_1), FWT(A_0 - A_1)) * (FWT(B_0 + B_1),</script><script type="math/tex; mode=display">FWT(B_0 - B_1)) = FWT(A) * FWT(B)</script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;FFT&quot;&gt;&lt;a href=&quot;#FFT&quot; class=&quot;headerlink&quot; title=&quot;FFT&quot;&gt;&lt;/a&gt;FFT&lt;/h1&gt;&lt;p&gt;先咕&lt;/p&gt;
&lt;h1 id=&quot;NTT&quot;&gt;&lt;a href=&quot;#NTT&quot; class=&quot;headerlink&quot; title=&quot;NTT&quot;&gt;
      
    
    </summary>
    
      <category term="多项式" scheme="http://yoursite.com/categories/%E5%A4%9A%E9%A1%B9%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>论一类x次方计数问题的求解</title>
    <link href="http://yoursite.com/2020/04/09/%E8%AE%BA%E4%B8%80%E7%B1%BBx%E6%AC%A1%E6%96%B9%E8%AE%A1%E6%95%B0%E9%97%AE%E9%A2%98%E7%9A%84%E6%B1%82%E8%A7%A3/"/>
    <id>http://yoursite.com/2020/04/09/论一类x次方计数问题的求解/</id>
    <published>2020-04-09T03:56:46.000Z</published>
    <updated>2020-07-11T08:04:58.680Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文主要探究总结一类问题：统计某种情况下某个东西出现次数的x次方的问题的求解。</p><h1 id="一次方"><a href="#一次方" class="headerlink" title="一次方"></a>一次方</h1><p>我们先看一看一次方的情况我们一般怎么思考问题：</p><h2 id="CCPC-Wannafly-Winter-Camp-Day8-Div2-穗乃果的考试"><a href="#CCPC-Wannafly-Winter-Camp-Day8-Div2-穗乃果的考试" class="headerlink" title="CCPC-Wannafly Winter Camp Day8 Div2 穗乃果的考试"></a><a href="https://www.cometoj.com/contest/31/problem/G?problem_id=440" target="_blank" rel="noopener">CCPC-Wannafly Winter Camp Day8 Div2 穗乃果的考试</a></h2><p><strong>询问一个01矩形中，所有子矩形包含1的个数的总和。</strong><br>枚举子矩形需要一个左上角和一个右下角，发现复杂度非常高，故而不能直接枚举矩形。<br>考虑答案 = $\sum_{子矩形x}\sum a_{ij}$<br>我们变换求和顺序:$\sum_{原矩形中每一个元素a_{ij}且a_{ij} == 1}\sum_{子矩形x}[x包含a_{ij}]$<br>应该不难证明二者是等价的，我们发现枚举$a_{ij}$ 我们是可以接受的，且算有多少子矩形包含$a_{ij}$是非常容易的一件事情，那么问题就做完了。</p><p>一次好像非常显然，但是这只是给你开心开心的。</p><a id="more"></a><h1 id="2次方"><a href="#2次方" class="headerlink" title="2次方"></a>2次方</h1><p>还是先引入一个题目：</p><h2 id="CCPC-Wannafly-Winter-Camp-Day8-Div1-穗乃果的考试"><a href="#CCPC-Wannafly-Winter-Camp-Day8-Div1-穗乃果的考试" class="headerlink" title="CCPC-Wannafly Winter Camp Day8 Div1 穗乃果的考试"></a><a href="https://www.cometoj.com/contest/30/problem/G?problem_id=430" target="_blank" rel="noopener">CCPC-Wannafly Winter Camp Day8 Div1 穗乃果的考试</a></h2><p><strong>我家果果是真的喜欢组合数学啊，还都是这么难的</strong><br>发现跟上一题的变化就是1次变为了2次，但是一下子就难了不少呢。<br>我们还是冷静分析一波：<br>答案 = $\sum_{子矩形x}\sum^2_{a_{ij}}a_{ij}$<br>展开看一看：$\sum_{子矩形x}(a_n + a_{n + 1} + … + a_{m})(a_n + a_{n + 1} + … + a_{m})$<br>PS：$(a_n + a_{n + 1} + …. + a_{m})$指的是$子矩形x$中所有的元素。<br>还是变换求和顺序，我们看之前一次的时候，我们是从所有$a_{ij} == 1$中选一个出来，看有多少子矩形包含$a_{ij}$，本质是从后面每一个可能对答案产生贡献的项拿出来，看有多少情况包含它。<br>我们看二次的后面的项：$(a_n + a_{n + 1} + … + a_{m})(a_n + a_{n + 1} + … + a_{m})$，把乘法展开，相当于枚举每一个不为0的项，然后看有多少子矩形包含这两项。<br>那么答案 = $\sum_{(x = a_{ij}) == 1}\sum_{(y = a_{ij}) == 1} 包含x和y两个点的子矩形的数目$<br>然后枚举一个点，另一个点分为四个方向，前缀和维护一下就做完了。</p><div><div class="fold_hider"><div class="close hider_title">代码</div></div><div class="fold"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> db;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vi;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;ll&gt; vl;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;pii&gt; vp;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">const</span> ll INF = <span class="number">1e18</span>;</span><br><span class="line"><span class="keyword">const</span> db eps = <span class="number">1e-10</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> eb emplace_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ep emplace</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mem(a) memset(a, 0, sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> copy(a, b) memcpy(a, b, sizeof(b))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PA cout &lt;&lt; <span class="meta-string">"pass\n"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lowbit(x) (x &amp; -x)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(x) x.begin(), x.end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TM cout &lt;&lt; db(clock()) / CLOCKS_PER_SEC &lt;&lt; <span class="meta-string">'\n'</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">mt19937 <span class="title">mrand</span><span class="params">(chrono::high_resolution_clock::now().time_since_epoch().count())</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;<span class="title">inline</span> <span class="title">void</span> <span class="title">upmin</span>(<span class="title">T</span> &amp;<span class="title">x</span>, <span class="title">T</span> <span class="title">y</span>) &#123;</span>x = x &gt; y ? y : x;&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;<span class="title">inline</span> <span class="title">void</span> <span class="title">upmax</span>(<span class="title">T</span> &amp;<span class="title">x</span>, <span class="title">T</span> <span class="title">y</span>) &#123;</span>x = x &lt; y ? y : x;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2020</span>;</span><br><span class="line"><span class="keyword">char</span> s[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    x += y;</span><br><span class="line">    <span class="keyword">if</span>(x &gt;= mod) x -= mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sub</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    x -= y;</span><br><span class="line">    <span class="keyword">if</span>(x &lt; <span class="number">0</span>) x += mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> s3[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> s4[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> c1[maxn][maxn], c2[maxn][maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s[i] + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i][j] == <span class="string">'1'</span>)&#123;</span><br><span class="line">                add(s3[i][j], <span class="number">1l</span>l * i * j % mod);</span><br><span class="line">                add(s4[i][j], <span class="number">1l</span>l * i * (m - j + <span class="number">1</span>) % mod);</span><br><span class="line">                add(c1[i][j], <span class="number">1</span>);</span><br><span class="line">                add(c2[i][j], <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            add(s3[i][j], s3[i - <span class="number">1</span>][j]);</span><br><span class="line">            add(s3[i][j], s3[i][j - <span class="number">1</span>]);</span><br><span class="line">            sub(s3[i][j], s3[i - <span class="number">1</span>][j - <span class="number">1</span>]);</span><br><span class="line">            add(c1[i][j], c1[i - <span class="number">1</span>][j]);</span><br><span class="line">            add(c1[i][j], c1[i][j - <span class="number">1</span>]);</span><br><span class="line">            sub(c1[i][j], c1[i - <span class="number">1</span>][j - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = m; j; j--)&#123;</span><br><span class="line">            add(s4[i][j], s4[i - <span class="number">1</span>][j]);</span><br><span class="line">            add(s4[i][j], s4[i][j + <span class="number">1</span>]);</span><br><span class="line">            sub(s4[i][j], s4[i - <span class="number">1</span>][j + <span class="number">1</span>]);</span><br><span class="line">            add(c2[i][j], c2[i - <span class="number">1</span>][j]);</span><br><span class="line">            add(c2[i][j], c2[i][j + <span class="number">1</span>]);</span><br><span class="line">            sub(c2[i][j], c2[i - <span class="number">1</span>][j + <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i][j] == <span class="string">'0'</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> a = n - i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> b = m - j + <span class="number">1</span>;</span><br><span class="line">            add(res, <span class="number">1l</span>l * a * b % mod * s3[i - <span class="number">1</span>][j - <span class="number">1</span>] % mod);</span><br><span class="line">            b = j;</span><br><span class="line">            add(res, <span class="number">1l</span>l * a * b % mod * s4[i - <span class="number">1</span>][j + <span class="number">1</span>] % mod);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    add(res, res);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> pre = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i][j] == <span class="string">'0'</span>) <span class="keyword">continue</span>;</span><br><span class="line">            add(tmp, <span class="number">1l</span>l * (m - j + <span class="number">1</span>) * pre % mod);</span><br><span class="line">            add(pre, j);</span><br><span class="line">        &#125;</span><br><span class="line">        tmp = <span class="number">2l</span>l * tmp * i % mod * (n - i + <span class="number">1</span>) % mod;</span><br><span class="line">        add(res, tmp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)&#123;</span><br><span class="line">        <span class="keyword">int</span> pre = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i][j] == <span class="string">'0'</span>) <span class="keyword">continue</span>;</span><br><span class="line">            add(tmp, <span class="number">1l</span>l * (n - i + <span class="number">1</span>) * pre % mod);</span><br><span class="line">            add(pre, i);</span><br><span class="line">        &#125;</span><br><span class="line">        tmp = <span class="number">2l</span>l * tmp * j % mod * (m - j + <span class="number">1</span>) % mod;</span><br><span class="line">        add(res, tmp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i][j] == <span class="string">'1'</span>) add(res, <span class="number">1l</span>l * (n - i + <span class="number">1</span>) * i % mod * (m - j + <span class="number">1</span>) % mod * j % mod);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><h1 id="x次方"><a href="#x次方" class="headerlink" title="x次方"></a>x次方</h1><p>根据上面的做法我们可以看出，对于求某种情况下某个东西x次方的贡献，我们把符合条件的点提出来变成一个序列，然后复制x次，问题就变成了这x个序列每个选1个，然后求同时包含这x个的情况一共有多少种。</p><p>再来看一个稍微硬核一点的题</p><h2 id="Asia-Beijing-Regional-2014-F-Fluorescent"><a href="#Asia-Beijing-Regional-2014-F-Fluorescent" class="headerlink" title="Asia-Beijing Regional 2014 - F(Fluorescent)"></a><a href="http://opentrains.snarknews.info/~ejudge/team.cgi?SID=0ff216405c1f68d0&amp;action=2" target="_blank" rel="noopener">Asia-Beijing Regional 2014 - F(Fluorescent)</a></h2><p><strong>给定n栈灯，m个开关（n &lt;= 50, m &lt;= 50），每个开关连接一系列灯，并且能把这一系列灯的状态同时翻转，问所有情况下亮着灯数目三次方的期望是多少</strong></p><p>考虑答案 = $\sum_{情况x}(a_1 + a_2 + … + a_n)^3$<br>考虑变换求和顺序：对$(a_1 + a_2 + … + a_n)^3$中的每一组不为0的项，求有多少方案使得这三个位置最后都是亮着的。</p><p>这样我们就可以枚举三个位置，然后用状压dp求解了，最后求和就行了。</p><div><div class="fold_hider"><div class="close hider_title">代码</div></div><div class="fold"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> db;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vi;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;ll&gt; vl;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;pii&gt; vp;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">const</span> ll INF = <span class="number">1e18</span>;</span><br><span class="line"><span class="keyword">const</span> db eps = <span class="number">1e-10</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> eb emplace_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ep emplace</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mem(a) memset(a, 0, sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> copy(a, b) memcpy(a, b, sizeof(b))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PA cout &lt;&lt; <span class="meta-string">"pass\n"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lowbit(x) (x &amp; -x)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(x) x.begin(), x.end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TM cout &lt;&lt; db(clock()) / CLOCKS_PER_SEC &lt;&lt; <span class="meta-string">'\n'</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">mt19937 <span class="title">mrand</span><span class="params">(chrono::high_resolution_clock::now().time_since_epoch().count())</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;<span class="title">inline</span> <span class="title">void</span> <span class="title">upmin</span>(<span class="title">T</span> &amp;<span class="title">x</span>, <span class="title">T</span> <span class="title">y</span>) &#123;</span>x = x &gt; y ? y : x;&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;<span class="title">inline</span> <span class="title">void</span> <span class="title">upmax</span>(<span class="title">T</span> &amp;<span class="title">x</span>, <span class="title">T</span> <span class="title">y</span>) &#123;</span>x = x &lt; y ? y : x;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T;</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">55</span>][<span class="number">8</span>];</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">bool</span> vis[<span class="number">55</span>][<span class="number">55</span>];</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    x += y;</span><br><span class="line">    <span class="keyword">if</span>(x &gt;= mod) x -= mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>), <span class="built_in">cin</span>.tie(<span class="number">0</span>), <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; fixed &lt;&lt; setprecision(<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> kase = <span class="number">1</span>; kase &lt;= T; kase++)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">        mem(vis);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> len;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; len;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= len; j++)&#123;</span><br><span class="line">                <span class="keyword">int</span> x;</span><br><span class="line">                <span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">                vis[i][x] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; k++)&#123;</span><br><span class="line">                    mem(dp);</span><br><span class="line">                    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> p = <span class="number">1</span>; p &lt;= m; p++)&#123;</span><br><span class="line">                        <span class="keyword">int</span> t1 = <span class="number">0</span>, t2 = <span class="number">0</span>, t3 = <span class="number">0</span>;</span><br><span class="line">                        <span class="keyword">if</span>(vis[p][i]) t1 = <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">if</span>(vis[p][j]) t2 = <span class="number">2</span>;</span><br><span class="line">                        <span class="keyword">if</span>(vis[p][k]) t3 = <span class="number">4</span>;</span><br><span class="line">                        <span class="keyword">for</span>(<span class="keyword">int</span> mask = <span class="number">0</span>; mask &lt; <span class="number">8</span>; mask++)&#123;</span><br><span class="line">                            add(dp[p][mask ^ t1 ^ t2 ^ t3], dp[p - <span class="number">1</span>][mask]);</span><br><span class="line">                            add(dp[p][mask], dp[p - <span class="number">1</span>][mask]);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    add(res, dp[m][<span class="number">7</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Case #"</span> &lt;&lt; kase &lt;&lt; <span class="string">": "</span> &lt;&lt; res &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><p>再来个最难的</p><h2 id="2018-2019-ACM-ICPC-Asia-Xuzhou-Regional-Contest-D-Rikka-with-Subsequences"><a href="#2018-2019-ACM-ICPC-Asia-Xuzhou-Regional-Contest-D-Rikka-with-Subsequences" class="headerlink" title="2018-2019 ACM-ICPC, Asia Xuzhou Regional Contest - D(Rikka with Subsequences)"></a><a href="https://codeforces.com/gym/102012/problem/D" target="_blank" rel="noopener">2018-2019 ACM-ICPC, Asia Xuzhou Regional Contest - D(Rikka with Subsequences)</a></h2><p><strong>给定一种”好子序列”的定义，求所有本质相同好子序列个数三次方的和</strong></p><p>直接考虑问题转换，既然是求本质相同的好子序列出现次数三次方的和，我们可以等价于求把原序列复制三份，在三份上各取一个子序列，且子序列相同的情况数。</p><p>考虑$dp[i][j][k]$为第一个好子序列最后为$i$结尾，第二个好子序列最后以$j$结尾，第三个好子序列最后以$k$结尾。考虑转移，对于某一个$dp[i][j][k]$，我们找前面有多少$dp[i’][j’][k’]$ $(i’ &lt; i, j’ &lt; j, k’ &lt; k)$，但由于还有好子序列的限制，所以我们要找到所有$a[i’] = a[i]$的点，剩下的就是找$j’$, $k’$，这相当于是个二位前缀和（因为只用限制一个点，剩下$a[j]$，$a[k]$，$a[j’]$，$a[k’]$必然相等。）也就是对于每个$i$，我们对所有满足$a[j] = a[i]$的$j$，$k$求一次前缀和，然后加速转移，同时在这里统计方案即可。</p><div><div class="fold_hider"><div class="close hider_title">代码</div></div><div class="fold"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> db;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vi;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;ll&gt; vl;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;pii&gt; vp;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">const</span> ll INF = <span class="number">1e18</span>;</span><br><span class="line"><span class="keyword">const</span> db eps = <span class="number">1e-10</span>;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> eb emplace_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ep emplace</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mem(a) memset(a, 0, sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> copy(a, b) memcpy(a, b, sizeof(b))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PA cout &lt;&lt; <span class="meta-string">"pass\n"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lowbit(x) (x &amp; -x)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(x) x.begin(), x.end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TM cout &lt;&lt; db(clock()) / CLOCKS_PER_SEC &lt;&lt; <span class="meta-string">'\n'</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function">mt19937 <span class="title">mrand</span><span class="params">(chrono::high_resolution_clock::now().time_since_epoch().count())</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;<span class="title">inline</span> <span class="title">void</span> <span class="title">upmin</span>(<span class="title">T</span> &amp;<span class="title">x</span>, <span class="title">T</span> <span class="title">y</span>) &#123;</span>x = x &gt; y ? y : x;&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;<span class="title">inline</span> <span class="title">void</span> <span class="title">upmax</span>(<span class="title">T</span> &amp;<span class="title">x</span>, <span class="title">T</span> <span class="title">y</span>) &#123;</span>x = x &lt; y ? y : x;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> n, T;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">220</span>;</span><br><span class="line"><span class="keyword">int</span> dp[maxn][maxn], sum[maxn][maxn];</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    x += y;</span><br><span class="line">    <span class="keyword">if</span>(x &gt;= mod) x -= mod;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sub</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    x -= y;</span><br><span class="line">    <span class="keyword">if</span>(x &lt; <span class="number">0</span>) x += mod;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">char</span> s[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> a[maxn];</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= n; j++)&#123;</span><br><span class="line">                dp[i][j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s[i] + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; k++)&#123;</span><br><span class="line">                    sum[j][k] = s[a[j]][a[i]] == <span class="string">'1'</span> ? dp[j][k] : <span class="number">0</span>;</span><br><span class="line">                    add(sum[j][k], sum[j - <span class="number">1</span>][k]);</span><br><span class="line">                    add(sum[j][k], sum[j][k - <span class="number">1</span>]);</span><br><span class="line">                    sub(sum[j][k], sum[j - <span class="number">1</span>][k - <span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; k++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(a[i] == a[j] &amp;&amp; a[j] == a[k])&#123;</span><br><span class="line">                        <span class="keyword">int</span> tmp = <span class="number">1</span>;</span><br><span class="line">                        add(tmp, sum[j - <span class="number">1</span>][k - <span class="number">1</span>]);</span><br><span class="line">                        add(res, tmp);</span><br><span class="line">                        add(dp[j][k], tmp);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>对于统计中$x$次方求和的问题，转换为把原来的东西复制$x$次，每个里面选一种方案，求原来有多少方案能使这$x$个方案同时满足。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;本文主要探究总结一类问题：统计某种情况下某个东西出现次数的x次方的问题的求解。&lt;/p&gt;
&lt;h1 id=&quot;一次方&quot;&gt;&lt;a href=&quot;#一次方&quot; class=&quot;headerlink&quot; title=&quot;一次方&quot;&gt;&lt;/a&gt;一次方&lt;/h1&gt;&lt;p&gt;我们先看一看一次方的情况我们一般怎么思考问题：&lt;/p&gt;
&lt;h2 id=&quot;CCPC-Wannafly-Winter-Camp-Day8-Div2-穗乃果的考试&quot;&gt;&lt;a href=&quot;#CCPC-Wannafly-Winter-Camp-Day8-Div2-穗乃果的考试&quot; class=&quot;headerlink&quot; title=&quot;CCPC-Wannafly Winter Camp Day8 Div2 穗乃果的考试&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://www.cometoj.com/contest/31/problem/G?problem_id=440&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;CCPC-Wannafly Winter Camp Day8 Div2 穗乃果的考试&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;询问一个01矩形中，所有子矩形包含1的个数的总和。&lt;/strong&gt;&lt;br&gt;枚举子矩形需要一个左上角和一个右下角，发现复杂度非常高，故而不能直接枚举矩形。&lt;br&gt;考虑答案 = $\sum_{子矩形x}\sum a_{ij}$&lt;br&gt;我们变换求和顺序:$\sum_{原矩形中每一个元素a_{ij}且a_{ij} == 1}\sum_{子矩形x}[x包含a_{ij}]$&lt;br&gt;应该不难证明二者是等价的，我们发现枚举$a_{ij}$ 我们是可以接受的，且算有多少子矩形包含$a_{ij}$是非常容易的一件事情，那么问题就做完了。&lt;/p&gt;
&lt;p&gt;一次好像非常显然，但是这只是给你开心开心的。&lt;/p&gt;
    
    </summary>
    
      <category term="组合数学" scheme="http://yoursite.com/categories/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"/>
    
    
  </entry>
  
  <entry>
    <title>CNN学习笔记</title>
    <link href="http://yoursite.com/2020/04/05/CNN%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2020/04/05/CNN学习笔记/</id>
    <published>2020-04-05T03:41:51.000Z</published>
    <updated>2020-07-11T08:12:38.222Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CNN整体结构"><a href="#CNN整体结构" class="headerlink" title="CNN整体结构"></a>CNN整体结构</h1><p>之前学习了全连接层，我们先再看看全连接层的结构：<br><img src="/mlimg/AffineStruct.png" alt=""><br>简单总结一下，我们发现就是由一堆 <strong>输入 -&gt; Affine层 -&gt; 激活函数</strong> 组成的。<br>再来康康CNN的结构：<br><img src="/mlimg/CNNStruct.png" alt=""><br>我们发现前面的Affine层换成了Conv（卷积）层，并且多加入了一个Pooling（池化）层。当然最后还是保留了部分Affine层。</p><h1 id="卷积层"><a href="#卷积层" class="headerlink" title="卷积层"></a>卷积层</h1><h2 id="为什么要引入卷积层"><a href="#为什么要引入卷积层" class="headerlink" title="为什么要引入卷积层"></a>为什么要引入卷积层</h2><p>考虑引入卷积层，必然是以前的全连接层存在某些问题。首先，全连接层的运算量大，因为每两个点都必须有一个权值，所以边数是点数平方级别的。其次，CNN主要针对的是图像问题，在图像中，两个相距较远的像素可以认为是基本无关的，但全连接层中仍会考虑它们，相当于有很多无用的计算量。<br>基于此，我们考虑用卷积层替换全连接层，卷积层就可以改良上述缺点。</p><h2 id="卷积运算"><a href="#卷积运算" class="headerlink" title="卷积运算"></a>卷积运算</h2><p>因为之前学过图想处理，感觉卷积运算理解起来就非常容易。<br><img src="/mlimg/Conv.png" alt=""><br>直接看图吧，相当于就是拿一个窗口在图上滑动，然后对于每一个位置，直接做点积运算，得到的结果放到最终结果的对应位置（如果有偏置的话还要加上偏置的值）。</p><p>当然这只是一维情况，事实上只要不是黑白图片，一般都是三通道的，也就是三维的，那么卷积运算就是三个通道结果相加：<br><img src="/mlimg/3DConv.png" alt=""><br><img src="/mlimg/3DConv2.png" alt=""></p><h2 id="卷积层实现"><a href="#卷积层实现" class="headerlink" title="卷积层实现"></a>卷积层实现</h2><p>这个就比较偏编程技巧了，一般的想法是几层for循环就可以解决，然而这样效率比较慢。我们一般而言是先把数据向量化，也就是展开，也可以称作是降维：<br><img src="/mlimg/ConvProcess.png" alt=""><br>展开对应关系如下图所示：<br><img src="/mlimg/ConvProcess1.png" alt=""><br>同样我们也可以把滤波器的展开，最后发现，我们的卷积运算就可以转换为矩阵乘法了，最后再把结果还原为原来的形状：<br><img src="/mlimg/ConvProcess2.png" alt=""></p><h1 id="池化层"><a href="#池化层" class="headerlink" title="池化层"></a>池化层</h1><h2 id="为什么要引入卷积层-1"><a href="#为什么要引入卷积层-1" class="headerlink" title="为什么要引入卷积层"></a>为什么要引入卷积层</h2><p>池化是缩小高、长方向上的空间的运算。池化层可以增强对微小变化的鲁棒性。</p><h2 id="池化运算"><a href="#池化运算" class="headerlink" title="池化运算"></a>池化运算</h2><p><img src="/mlimg/Pooling.png" alt=""><br>其实跟卷积运算挺类似的，看图就能直接明白了。<br>池化也有很多种，比如Max池化，Average池化等，一般来说Max池化用的比较多。</p><h2 id="池化层实现"><a href="#池化层实现" class="headerlink" title="池化层实现"></a>池化层实现</h2><p>池化层实现思想差不多，先把原来数据展开，进行运算，然后再还原回去：<br><img src="/mlimg/PoolingProcess.png" alt=""><br>具体来说就是把每个滤波器能在的位置展开成一行，然后就可以变成对每一行进行操作，最后挨着还原回去就行了。<br><img src="/mlimg/PoolingProcess.png" alt=""></p><p>接下来去研究下pytorch去了。。。研究完再补。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;CNN整体结构&quot;&gt;&lt;a href=&quot;#CNN整体结构&quot; class=&quot;headerlink&quot; title=&quot;CNN整体结构&quot;&gt;&lt;/a&gt;CNN整体结构&lt;/h1&gt;&lt;p&gt;之前学习了全连接层，我们先再看看全连接层的结构：&lt;br&gt;&lt;img src=&quot;/mlimg/Affin
      
    
    </summary>
    
      <category term="机器学习" scheme="http://yoursite.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>仙人掌 &amp; 圆方树学习笔记</title>
    <link href="http://yoursite.com/2020/04/04/%E4%BB%99%E4%BA%BA%E6%8E%8C-%E5%9C%86%E6%96%B9%E6%A0%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2020/04/04/仙人掌-圆方树学习笔记/</id>
    <published>2020-04-04T15:33:41.000Z</published>
    <updated>2020-04-06T15:41:19.539Z</updated>
    
    <content type="html"><![CDATA[<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><p>你敢信我学完基础的圆方树后理解最深的居然是tarjan？<br>不知道这玩意有啥用，但据说很有用，但好像icpc都不太考这个东西？但感觉这个东西跟什么树问题都能有关系，而且还都是大码量题。。</p><h1 id="仙人掌"><a href="#仙人掌" class="headerlink" title="仙人掌"></a>仙人掌</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>仙人掌是一种特殊的无向图，具有如下性质：<br>1、图是连通的。<br>2、每条边最多属于一个简单环。<br><img src="/images/12.png" alt=""><br>因为有特殊性，所以也就有特殊的方法处理这一类题目。</p><h2 id="仙人掌的dfs生成树"><a href="#仙人掌的dfs生成树" class="headerlink" title="仙人掌的dfs生成树"></a>仙人掌的dfs生成树</h2><p>仙人掌dfs生成树也有着特殊的性质，我们将它的dfs生成树看成一个序列，返祖边看成一个区间，那么所有的区间都是不相交的。这样在用dfs生成树处理仙人掌的时候就能简化很多种复杂的情况。</p><h1 id="圆方树"><a href="#圆方树" class="headerlink" title="圆方树"></a>圆方树</h1><h2 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h2><p>圆方树是用来解决仙人掌问题的一种数据结构。<br>其实圆方树的原理不难想，考虑前面我们说过，仙人掌每条边只属于一个简单环，换言之各个环之间不会嵌套。那么我们在环上考虑问题是比较复杂的，我们喜欢转成树，我们想到给每个环新建一个点，把所有环上的点去掉，并且跟新点相连。这个新点就好像一个中转站一样，巧妙的把环变为了链，把一般图变为了树。树上解决问题，我们可以采用的方法就会更多。</p><p>我们把新建的点叫做方点，原来的点叫做圆点。</p><p>Upd:我发现我好像一直学的是广义圆方树，不过好像它应用更广泛，也可以直接用在仙人掌上。。。。</p><h2 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h2><p>圆方树有很多不错的性质：<br>1、方点和方点之间不会直接相连。<br>2、无论取哪个点为根，圆方树的形态是一样的。<br>3、<script type="math/tex">以r为根的仙人掌上p的子仙人掌就是圆方树中以r为根时，p子树中的所有圆点</script>（还没理解，先嫖着）。<br>4、方点儿子中的相邻的在原图环上也是相邻的（tarjan性质）。</p><a id="more"></a><h2 id="构建方法"><a href="#构建方法" class="headerlink" title="构建方法"></a>构建方法</h2><p>圆方树的构建方法是通过魔改tarjan点双开始的。我们知道点双里面一个点可能属于多个点双，这类点就是割点，所以tarjan的时候我们都是存边，因为每条边只会属于一个连通分量。但这里我们可以存点，需要稍微改一改。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    dfn[u] = low[u] = ++ntime;</span><br><span class="line">    sta[++sz] = u;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[u].size(); i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = G[u][i];</span><br><span class="line">        <span class="keyword">if</span> (!dfn[v]) &#123;</span><br><span class="line">            tarjan(v);</span><br><span class="line">            low[u] = min(low[u], low[v]);</span><br><span class="line">            <span class="keyword">if</span>(low[v] == dfn[u])&#123;</span><br><span class="line">                ++tot;</span><br><span class="line">                g[u].pb(tot);</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">0</span>; x != v; --sz)&#123;</span><br><span class="line">                    x = sta[sz];</span><br><span class="line">                    g[tot].pb(x);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> low[u] = min(low[u], dfn[v]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">find_bcc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sz = <span class="number">0</span>;</span><br><span class="line">        tot = n;</span><br><span class="line">        <span class="built_in">memset</span>(dfn, <span class="number">0</span>, <span class="keyword">sizeof</span>(dfn));</span><br><span class="line">        ntime = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)<span class="keyword">if</span> (!dfn[i])tarjan(i), --sz;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>研究一下，其实反而跟tarjan求强连通分量很像，但是强连通分量是要把$u$一起弹出去，这里构建圆方树时我们只能弹到$v，u$必须继续保留在栈中（因为上层递归回去时我们还需要用$u$来建树）。最后如果图不连通需要把$sz - 1$（顶点没弹出来）（虽然仙人掌是一定连通的，但是有些题可能是多个森林仙人掌）。</p><p>考虑建出来的树，我们就可以利用树的算法完成仙人掌上的问题了，对于环，我们只用找树上方点进行特殊考虑即可。</p><h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><h2 id="求仙人掌的最大独立集"><a href="#求仙人掌的最大独立集" class="headerlink" title="求仙人掌的最大独立集"></a>求仙人掌的最大独立集</h2><p><a href="http://www.lydsy.com/JudgeOnline/problem.php?id=4316" target="_blank" rel="noopener">bzoj-4316</a></p><p>考虑树的最大独立集，$dp[u][0]$表示u点不选，$dp[u][1]$表示$u$点要选，随便dp一下就解决了。对于仙人掌的最大独立集，我们对仙人掌建出圆方树，然后利用树的dp完成，圆点就直接同树的方法进行转移即可，我们需要着重考虑方点的计算方法。<br><img src="/images/13.png" alt=""><br>如图所示，当$x$选的时候，我们发现$u_1$和$u_4$不能选，也就是两端不能选，其它位置变成了序列上不能同时选相邻点的最大权问题（因为每个点所代表的权值是其子树最大的独立集大小）。对于方点，$dp[u][0]$表示它连的两端没有选，$dp[u][1]$表示它连的两端可以选的最大独立集。我们发现把方点问题转换为序列问题，然后再回到树上按照正常树形dp进行转移即可。</p><div><div class="fold_hider"><div class="close hider_title">代码</div></div><div class="fold"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> db;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vi;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;ll&gt; vl;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;pii&gt; vp;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">const</span> ll INF = <span class="number">1e18</span>;</span><br><span class="line"><span class="keyword">const</span> db eps = <span class="number">1e-10</span>;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> eb emplace_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ep emplace</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mem(a) memset(a, 0, sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> copy(a, b) memcpy(a, b, sizeof(b))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PA cout &lt;&lt; <span class="meta-string">"pass\n"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lowbit(x) (x &amp; -x)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(x) x.begin(), x.end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TM cout &lt;&lt; db(clock()) / CLOCKS_PER_SEC &lt;&lt; <span class="meta-string">'\n'</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;<span class="title">inline</span> <span class="title">void</span> <span class="title">upmin</span>(<span class="title">T</span> &amp;<span class="title">x</span>, <span class="title">T</span> <span class="title">y</span>) &#123;</span>x = x &gt; y ? y : x;&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;<span class="title">inline</span> <span class="title">void</span> <span class="title">upmax</span>(<span class="title">T</span> &amp;<span class="title">x</span>, <span class="title">T</span> <span class="title">y</span>) &#123;</span>x = x &lt; y ? y : x;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">233</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> dp1[maxn][<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> dp2[maxn][<span class="number">2</span>];</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Cactus</span> &#123;</span></span><br><span class="line">    vi G[maxn];</span><br><span class="line">    vi g[maxn * <span class="number">2</span>]; <span class="comment">// new Round_Square_Tree</span></span><br><span class="line">    <span class="keyword">int</span> dfn[maxn];</span><br><span class="line">    <span class="keyword">int</span> low[maxn];</span><br><span class="line">    <span class="keyword">int</span> ntime;</span><br><span class="line">    <span class="keyword">int</span> tot;</span><br><span class="line">    <span class="keyword">int</span> sta[maxn];</span><br><span class="line">    <span class="keyword">int</span> sz;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">        dfn[u] = low[u] = ++ntime;</span><br><span class="line">        sta[++sz] = u;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[u].size(); i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = G[u][i];</span><br><span class="line">            <span class="keyword">if</span> (!dfn[v]) &#123;</span><br><span class="line">                tarjan(v);</span><br><span class="line">                low[u] = min(low[u], low[v]);</span><br><span class="line">                <span class="keyword">if</span>(low[v] == dfn[u])&#123;</span><br><span class="line">                    ++tot;</span><br><span class="line">                    g[u].pb(tot);</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">0</span>; x != v; --sz)&#123;</span><br><span class="line">                        x = sta[sz];</span><br><span class="line">                        g[tot].pb(x);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> low[u] = min(low[u], dfn[v]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">find_bcc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sz = <span class="number">0</span>;</span><br><span class="line">        tot = n;</span><br><span class="line">        <span class="built_in">memset</span>(dfn, <span class="number">0</span>, <span class="keyword">sizeof</span>(dfn));</span><br><span class="line">        ntime = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)<span class="keyword">if</span> (!dfn[i])tarjan(i), --sz;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> now[maxn * <span class="number">2</span>];</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; g[u].size(); i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> v = g[u][i];</span><br><span class="line">            now[++cnt] = v;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        dp2[<span class="number">1</span>][<span class="number">0</span>] = dp1[now[<span class="number">1</span>]][<span class="number">0</span>];</span><br><span class="line">        dp2[<span class="number">1</span>][<span class="number">1</span>] = -inf;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= cnt; i++) &#123;</span><br><span class="line">            dp2[i][<span class="number">0</span>] = max(dp2[i - <span class="number">1</span>][<span class="number">0</span>], dp2[i - <span class="number">1</span>][<span class="number">1</span>]) + dp1[now[i]][<span class="number">0</span>];</span><br><span class="line">            dp2[i][<span class="number">1</span>] = dp2[i - <span class="number">1</span>][<span class="number">0</span>] + dp1[now[i]][<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        dp1[u][<span class="number">0</span>] = dp2[cnt][<span class="number">0</span>];</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; i++) &#123;</span><br><span class="line">            dp2[i][<span class="number">0</span>] = max(dp2[i - <span class="number">1</span>][<span class="number">0</span>], dp2[i - <span class="number">1</span>][<span class="number">1</span>]) + dp1[now[i]][<span class="number">0</span>];</span><br><span class="line">            dp2[i][<span class="number">1</span>] = dp2[i - <span class="number">1</span>][<span class="number">0</span>] + dp1[now[i]][<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        dp1[u][<span class="number">1</span>] = max(dp2[cnt][<span class="number">0</span>], dp2[cnt][<span class="number">1</span>]);</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">        dp1[u][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp1[u][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; g[u].size(); i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> v = g[u][i];</span><br><span class="line">            dfs(v);</span><br><span class="line">            <span class="keyword">if</span>(u &lt;= n)&#123;</span><br><span class="line">                dp1[u][<span class="number">0</span>] += max(dp1[v][<span class="number">0</span>], dp1[v][<span class="number">1</span>]);</span><br><span class="line">                dp1[u][<span class="number">1</span>] += dp1[v][<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span>(u &gt; n) solve(u);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;sol;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>), <span class="built_in">cin</span>.tie(<span class="number">0</span>), <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; fixed &lt;&lt; setprecision(<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> u, v;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v;</span><br><span class="line">        sol.G[u].pb(v);</span><br><span class="line">        sol.G[v].pb(u);</span><br><span class="line">    &#125;</span><br><span class="line">    sol.find_bcc();</span><br><span class="line">    sol.dfs(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; max(dp1[<span class="number">1</span>][<span class="number">0</span>], dp1[<span class="number">1</span>][<span class="number">1</span>]) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><h2 id="求仙人掌的直径"><a href="#求仙人掌的直径" class="headerlink" title="求仙人掌的直径"></a>求仙人掌的直径</h2><p><a href="http://www.lydsy.com/JudgeOnline/problem.php?id=1023" target="_blank" rel="noopener">bzoj-1023</a></p><p>还是先建出圆方树，按照树dp的方法求直径，圆点的方法还是一样的，只用特殊考虑方点的。<br>考虑两条链在某个方点合并，也就是方点儿子中的任意两个圆点都可能合并，假设是儿子$(u, v)$，他们在环上的顺序分别是$(i, j)(i &lt; j)$，那么贡献就是dp[u] + dp[v] + i - j，并且i，j之间的距离不能超过环长的一半（否则可以从环另一边绕过去），考虑破环为链，变为2倍，中间会空一个点（其实是方点的父亲，也是环上的一个点，但这里统计我们就不考虑），遇到这个点我们直接跳过，然后维护一个单调队列，统计方点的儿子对答案的贡献，统计后再把所有儿子的距离更新到方点上去，从两边较近的一方绕上去即可，其他的跟树形dp求直径都是完全一样的。</p><div><div class="fold_hider"><div class="close hider_title">代码</div></div><div class="fold"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> db;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vi;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;ll&gt; vl;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;pii&gt; vp;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">const</span> ll INF = <span class="number">1e18</span>;</span><br><span class="line"><span class="keyword">const</span> db eps = <span class="number">1e-10</span>;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> eb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ep emplace</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mem(a) memset(a, 0, sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> copy(a, b) memcpy(a, b, sizeof(b))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PA cout &lt;&lt; <span class="meta-string">"pass\n"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lowbit(x) (x &amp; -x)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(x) x.begin(), x.end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TM cout &lt;&lt; db(clock()) / CLOCKS_PER_SEC &lt;&lt; <span class="meta-string">'\n'</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;<span class="title">inline</span> <span class="title">void</span> <span class="title">upmin</span>(<span class="title">T</span> &amp;<span class="title">x</span>, <span class="title">T</span> <span class="title">y</span>) &#123;</span>x = x &gt; y ? y : x;&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;<span class="title">inline</span> <span class="title">void</span> <span class="title">upmax</span>(<span class="title">T</span> &amp;<span class="title">x</span>, <span class="title">T</span> <span class="title">y</span>) &#123;</span>x = x &lt; y ? y : x;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">233</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> dp[maxn];</span><br><span class="line"><span class="keyword">int</span> res;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Cactus</span> &#123;</span></span><br><span class="line">    vi G[maxn];</span><br><span class="line">    vi g[maxn * <span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> dfn[maxn];</span><br><span class="line">    <span class="keyword">int</span> low[maxn];</span><br><span class="line">    <span class="keyword">int</span> ntime;</span><br><span class="line">    <span class="keyword">int</span> tot;</span><br><span class="line">    <span class="keyword">int</span> sta[maxn];</span><br><span class="line">    <span class="keyword">int</span> sz;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">        dfn[u] = low[u] = ++ntime;</span><br><span class="line">        sta[++sz] = u;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[u].size(); i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = G[u][i];</span><br><span class="line">            <span class="keyword">if</span> (!dfn[v]) &#123;</span><br><span class="line">                tarjan(v);</span><br><span class="line">                low[u] = min(low[u], low[v]);</span><br><span class="line">                <span class="keyword">if</span>(low[v] == dfn[u])&#123;</span><br><span class="line">                    ++tot;</span><br><span class="line">                    g[u].pb(tot);</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">0</span>; x != v; --sz)&#123;</span><br><span class="line">                        x = sta[sz];</span><br><span class="line">                        g[tot].pb(x);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> low[u] = min(low[u], dfn[v]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">find_bcc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sz = <span class="number">0</span>;</span><br><span class="line">        tot = n;</span><br><span class="line">        <span class="built_in">memset</span>(dfn, <span class="number">0</span>, <span class="keyword">sizeof</span>(dfn));</span><br><span class="line">        ntime = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)<span class="keyword">if</span> (!dfn[i])tarjan(i), --sz;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> head = <span class="number">1</span>, tail = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> que[maxn * <span class="number">2</span>], now[maxn * <span class="number">2</span>];</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; g[u].size(); i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> v = g[u][i];</span><br><span class="line">            now[++cnt] = v;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">int</span> len = cnt + <span class="number">1</span> &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> stop = cnt + <span class="number">1</span>;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = cnt + <span class="number">2</span>; i &lt;= <span class="number">2</span> * cnt + <span class="number">1</span>; i++) now[i] = now[i - cnt - <span class="number">1</span>];</span><br><span class="line">        cnt = cnt * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(head &lt;= tail &amp;&amp; i - que[head] &gt; len) head++;</span><br><span class="line">            <span class="keyword">if</span>(i == stop) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(head &lt;= tail) &#123;</span><br><span class="line">                <span class="keyword">int</span> t = que[head];</span><br><span class="line">                upmax(res, i + dp[now[i]] + dp[now[t]] - t);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(head &lt;= tail &amp;&amp; dp[now[que[tail]]] - que[tail] &lt;= dp[now[i]] - i) tail--;</span><br><span class="line">            que[++tail] = i;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; stop; i++)&#123;</span><br><span class="line">            upmax(dp[u], dp[now[i]] + min(i, stop - i) - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; g[u].size(); i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> v = g[u][i];</span><br><span class="line">            dfs(v);</span><br><span class="line">            <span class="keyword">if</span>(u &lt;= n)&#123;</span><br><span class="line">                upmax(res, dp[u] + dp[v] + <span class="number">1</span>);</span><br><span class="line">                upmax(dp[u], dp[v] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(u &gt; n) solve(u);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;sol;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>), <span class="built_in">cin</span>.tie(<span class="number">0</span>), <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; fixed &lt;&lt; setprecision(<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> len;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; len;</span><br><span class="line">        <span class="keyword">int</span> last = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len; ++j) &#123;</span><br><span class="line">            <span class="keyword">int</span> x;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">            <span class="keyword">if</span>(j) sol.G[x].eb(last), sol.G[last].eb(x);</span><br><span class="line">            last = x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sol.find_bcc();</span><br><span class="line">    sol.dfs(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><h2 id="求仙人掌上的最短路"><a href="#求仙人掌上的最短路" class="headerlink" title="求仙人掌上的最短路"></a>求仙人掌上的最短路</h2><p><a href="http://www.lydsy.com/JudgeOnline/problem.php?id=2125" target="_blank" rel="noopener">bzoj-2125</a></p><p>建出圆方树，考虑树上求最短路，我们使用LCA就行了，还是要特殊考虑方点的情况。<br>考虑LCA为圆点，那没问题，直接按树那样求最短路即可。<br>考虑LCA为方点，我们发现我们需要找到两个点在方点下对应的圆点的位置，然后找两个圆点在环上的最小距离。<br>其实这里挺麻烦的，我们考虑建树的时候就要把环的每条边值分配到圆方树对应的位置，我是把最后一条找到的返祖边分配到方点和它父亲上，剩下的分配到方点和它的儿子圆点上。那么这里tarjan里就需要改一改（如果用map其实就很简单，但想把log给去掉）。考虑用一个栈来维护边权，我们发现到父亲的边我们不能加入栈中，得把父亲判掉。其次我们发现如果点双大小为2，我们只需要pop出一条边（点双个数 - 1），否则需要pop出点双个数条边（环），所以pop的时候我们还要记录一下点双大小，看它跟2的关系（实际上最上面那个点我们要保留，所以就是跟1的关系）。对于环上处理最小值，我们考虑给每个环开个vector记录点顺序，那么两个点在上面的顺序就等于两条路径取min，vector上找到对应位置直接正反取一下就可以得出结果。然后处理环的同时我们可以同时把圆点到方点的距离处理出来，把距离更新上去即可。<br>真的是码农题，细节也特别烦。。</p><div><div class="fold_hider"><div class="close hider_title">代码</div></div><div class="fold"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> db;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vi;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;ll&gt; vl;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;pii&gt; vp;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">const</span> ll INF = <span class="number">1e18</span>;</span><br><span class="line"><span class="keyword">const</span> db eps = <span class="number">1e-10</span>;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> eb emplace_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ep emplace</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mem(a) memset(a, 0, sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> copy(a, b) memcpy(a, b, sizeof(b))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PA cout &lt;&lt; <span class="meta-string">"pass\n"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lowbit(x) (x &amp; -x)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(x) x.begin(), x.end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TM cout &lt;&lt; db(clock()) / CLOCKS_PER_SEC &lt;&lt; <span class="meta-string">'\n'</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;<span class="title">inline</span> <span class="title">void</span> <span class="title">upmin</span>(<span class="title">T</span> &amp;<span class="title">x</span>, <span class="title">T</span> <span class="title">y</span>) &#123;</span>x = x &gt; y ? y : x;&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;<span class="title">inline</span> <span class="title">void</span> <span class="title">upmax</span>(<span class="title">T</span> &amp;<span class="title">x</span>, <span class="title">T</span> <span class="title">y</span>) &#123;</span>x = x &lt; y ? y : x;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">233</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, q;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Cactus</span> &#123;</span></span><br><span class="line">    vp G[maxn];</span><br><span class="line">    vp g[maxn * <span class="number">2</span>]; </span><br><span class="line">    <span class="keyword">int</span> f[maxn][<span class="number">20</span>];</span><br><span class="line">    ll dis[maxn];</span><br><span class="line">    <span class="keyword">int</span> dfn[maxn];</span><br><span class="line">    <span class="keyword">int</span> low[maxn];</span><br><span class="line">    <span class="keyword">int</span> ntime;</span><br><span class="line">    <span class="keyword">int</span> tot;</span><br><span class="line">    <span class="keyword">int</span> sta[maxn];</span><br><span class="line">    <span class="keyword">int</span> sz;</span><br><span class="line">    <span class="keyword">int</span> val[maxn];</span><br><span class="line">    <span class="keyword">int</span> idx;</span><br><span class="line">    <span class="keyword">int</span> d[maxn];</span><br><span class="line">    <span class="keyword">int</span> pre[maxn * <span class="number">2</span>];</span><br><span class="line">    ll all[maxn * <span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> ord[maxn * <span class="number">2</span>];</span><br><span class="line">    <span class="built_in">vector</span>&lt;pair&lt;ll, ll&gt; &gt; tmp[maxn * <span class="number">2</span>];</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">        dfn[u] = low[u] = ++ntime;</span><br><span class="line">        sta[++sz] = u;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[u].size(); i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = G[u][i].fi;</span><br><span class="line">            <span class="keyword">int</span> w = G[u][i].se;</span><br><span class="line">            <span class="keyword">if</span>(!dfn[v] || (dfn[u] &gt; dfn[v] &amp;&amp; v != fa)) val[++idx] = w;</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">if</span> (!dfn[v]) &#123;</span><br><span class="line">                tarjan(v, u);</span><br><span class="line">                low[u] = min(low[u], low[v]);</span><br><span class="line">                <span class="keyword">if</span>(low[v] == dfn[u])&#123;</span><br><span class="line">                    ++tot;</span><br><span class="line">                    pre[tot] = w;</span><br><span class="line">                    g[u].pb(pii(tot, w));</span><br><span class="line">                    <span class="keyword">int</span> ff = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">0</span>; x != v; --sz, --idx) &#123;</span><br><span class="line">                        x = sta[sz];</span><br><span class="line">                        ff++;</span><br><span class="line">                        g[tot].pb(pii(x, val[idx]));</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(ff &gt; <span class="number">1</span>) idx--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> low[u] = min(low[u], dfn[v]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">find_bcc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        d[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        sz = <span class="number">0</span>;</span><br><span class="line">        tot = n;</span><br><span class="line">        <span class="built_in">memset</span>(dfn, <span class="number">0</span>, <span class="keyword">sizeof</span>(dfn));</span><br><span class="line">        ntime = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)<span class="keyword">if</span> (!dfn[i])tarjan(i, <span class="number">0</span>), --sz;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">        <span class="keyword">static</span> pii now[maxn * <span class="number">2</span>];</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">19</span>; i++) f[u][i] = f[f[u][i - <span class="number">1</span>]][i - <span class="number">1</span>];</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span>(u &gt; n)&#123;</span><br><span class="line">            <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">            ll sum = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; g[u].size(); i++)&#123;</span><br><span class="line">                now[++cnt] = g[u][i];</span><br><span class="line">                sum += now[cnt].se;</span><br><span class="line">                tmp[u].pb(pair&lt;ll, ll&gt;&#123;now[cnt].fi, sum&#125;);</span><br><span class="line">                ord[now[cnt].fi] = i;</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            ll tt = <span class="number">0</span>;</span><br><span class="line">            all[u] = sum + pre[u];</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; i++)&#123;</span><br><span class="line">                tt += now[i].se;</span><br><span class="line">                dis[now[i].fi] = dis[u] + min(tt - pre[u], sum - tt);</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; g[u].size(); i++)&#123;</span><br><span class="line">                <span class="keyword">int</span> v = g[u][i].fi;</span><br><span class="line">                <span class="keyword">int</span> w = g[u][i].se;</span><br><span class="line">                dis[v] = dis[u] + w;</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; g[u].size(); i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> v = g[u][i].fi;</span><br><span class="line">            d[v] = d[u] + <span class="number">1</span>;</span><br><span class="line">            f[v][<span class="number">0</span>] = u;</span><br><span class="line">            dfs(v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lca</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(d[u] &gt; d[v]) swap(u, v);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">19</span>; i &gt;= <span class="number">0</span>; i--) <span class="keyword">if</span>(d[u] &lt;= d[f[v][i]]) v = f[v][i];</span><br><span class="line">        <span class="keyword">if</span>(u == v) <span class="keyword">return</span> u;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">19</span>; i &gt;= <span class="number">0</span>; i--) <span class="keyword">if</span>(f[u][i] != f[v][i]) u = f[u][i], v = f[v][i];</span><br><span class="line">        <span class="keyword">return</span> f[u][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function">pii <span class="title">lca2</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">        <span class="keyword">bool</span> ff = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(d[u] &gt; d[v]) swap(u, v), ff = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">19</span>; i &gt;= <span class="number">0</span>; i--) <span class="keyword">if</span>(d[u] &lt;= d[f[v][i]]) v = f[v][i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">19</span>; i &gt;= <span class="number">0</span>; i--) <span class="keyword">if</span>(f[u][i] != f[v][i]) u = f[u][i], v = f[v][i];</span><br><span class="line">        <span class="keyword">if</span>(ff) swap(u, v);</span><br><span class="line">        <span class="keyword">return</span> pii(u, v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;sol;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>), <span class="built_in">cin</span>.tie(<span class="number">0</span>), <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; fixed &lt;&lt; setprecision(<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> u, v, w;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">        sol.G[u].pb(pii(v, w));</span><br><span class="line">        sol.G[v].pb(pii(u, w));</span><br><span class="line">    &#125;</span><br><span class="line">    sol.find_bcc();</span><br><span class="line">    sol.dfs(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= q; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> x, y;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        <span class="keyword">int</span> lc = sol.lca(x, y);</span><br><span class="line">        <span class="keyword">if</span>(lc &lt;= n || lc == x || lc == y) <span class="built_in">cout</span> &lt;&lt; sol.dis[x] + sol.dis[y] - <span class="number">2</span> * sol.dis[lc] &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            pii t = sol.lca2(x, y);</span><br><span class="line">            ll res = sol.dis[x] - sol.dis[t.fi] + sol.dis[y] - sol.dis[t.se];</span><br><span class="line">            <span class="keyword">int</span> t1 = sol.ord[t.fi];</span><br><span class="line">            <span class="keyword">int</span> t2 = sol.ord[t.se];</span><br><span class="line">            <span class="keyword">if</span>(t1 &gt; t2) swap(t1, t2);</span><br><span class="line">            ll tt = sol.tmp[lc][t2].se - sol.tmp[lc][t1].se;</span><br><span class="line">            tt = min(tt, sol.all[lc] - tt);</span><br><span class="line">            res += tt;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;序言&quot;&gt;&lt;a href=&quot;#序言&quot; class=&quot;headerlink&quot; title=&quot;序言&quot;&gt;&lt;/a&gt;序言&lt;/h1&gt;&lt;p&gt;你敢信我学完基础的圆方树后理解最深的居然是tarjan？&lt;br&gt;不知道这玩意有啥用，但据说很有用，但好像icpc都不太考这个东西？但感觉这个东西跟什么树问题都能有关系，而且还都是大码量题。。&lt;/p&gt;
&lt;h1 id=&quot;仙人掌&quot;&gt;&lt;a href=&quot;#仙人掌&quot; class=&quot;headerlink&quot; title=&quot;仙人掌&quot;&gt;&lt;/a&gt;仙人掌&lt;/h1&gt;&lt;h2 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h2&gt;&lt;p&gt;仙人掌是一种特殊的无向图，具有如下性质：&lt;br&gt;1、图是连通的。&lt;br&gt;2、每条边最多属于一个简单环。&lt;br&gt;&lt;img src=&quot;/images/12.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;因为有特殊性，所以也就有特殊的方法处理这一类题目。&lt;/p&gt;
&lt;h2 id=&quot;仙人掌的dfs生成树&quot;&gt;&lt;a href=&quot;#仙人掌的dfs生成树&quot; class=&quot;headerlink&quot; title=&quot;仙人掌的dfs生成树&quot;&gt;&lt;/a&gt;仙人掌的dfs生成树&lt;/h2&gt;&lt;p&gt;仙人掌dfs生成树也有着特殊的性质，我们将它的dfs生成树看成一个序列，返祖边看成一个区间，那么所有的区间都是不相交的。这样在用dfs生成树处理仙人掌的时候就能简化很多种复杂的情况。&lt;/p&gt;
&lt;h1 id=&quot;圆方树&quot;&gt;&lt;a href=&quot;#圆方树&quot; class=&quot;headerlink&quot; title=&quot;圆方树&quot;&gt;&lt;/a&gt;圆方树&lt;/h1&gt;&lt;h2 id=&quot;概念-1&quot;&gt;&lt;a href=&quot;#概念-1&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h2&gt;&lt;p&gt;圆方树是用来解决仙人掌问题的一种数据结构。&lt;br&gt;其实圆方树的原理不难想，考虑前面我们说过，仙人掌每条边只属于一个简单环，换言之各个环之间不会嵌套。那么我们在环上考虑问题是比较复杂的，我们喜欢转成树，我们想到给每个环新建一个点，把所有环上的点去掉，并且跟新点相连。这个新点就好像一个中转站一样，巧妙的把环变为了链，把一般图变为了树。树上解决问题，我们可以采用的方法就会更多。&lt;/p&gt;
&lt;p&gt;我们把新建的点叫做方点，原来的点叫做圆点。&lt;/p&gt;
&lt;p&gt;Upd:我发现我好像一直学的是广义圆方树，不过好像它应用更广泛，也可以直接用在仙人掌上。。。。&lt;/p&gt;
&lt;h2 id=&quot;性质&quot;&gt;&lt;a href=&quot;#性质&quot; class=&quot;headerlink&quot; title=&quot;性质&quot;&gt;&lt;/a&gt;性质&lt;/h2&gt;&lt;p&gt;圆方树有很多不错的性质：&lt;br&gt;1、方点和方点之间不会直接相连。&lt;br&gt;2、无论取哪个点为根，圆方树的形态是一样的。&lt;br&gt;3、&lt;script type=&quot;math/tex&quot;&gt;以r为根的仙人掌上p的子仙人掌就是圆方树中以r为根时，p子树中的所有圆点&lt;/script&gt;（还没理解，先嫖着）。&lt;br&gt;4、方点儿子中的相邻的在原图环上也是相邻的（tarjan性质）。&lt;/p&gt;
    
    </summary>
    
      <category term="圆方树" scheme="http://yoursite.com/categories/%E5%9C%86%E6%96%B9%E6%A0%91/"/>
    
    
  </entry>
  
  <entry>
    <title>二分图通关全攻略</title>
    <link href="http://yoursite.com/2020/03/30/%E4%BA%8C%E5%88%86%E5%9B%BE%E9%80%9A%E5%85%B3%E5%85%A8%E6%94%BB%E7%95%A5/"/>
    <id>http://yoursite.com/2020/03/30/二分图通关全攻略/</id>
    <published>2020-03-30T12:54:22.000Z</published>
    <updated>2020-04-03T01:44:28.346Z</updated>
    
    <content type="html"><![CDATA[<h1 id="二分图概念"><a href="#二分图概念" class="headerlink" title="二分图概念"></a>二分图概念</h1><p>二分图简单来说，就是一个无向图，可以把点集分为两个，且边都是从一个点集指向另一个点集。<br><strong>二分图有另一个等价的定义：没有奇环。</strong>相对而言这个性质更加重要。<br><a id="more"></a></p><h1 id="二分图最大匹配"><a href="#二分图最大匹配" class="headerlink" title="二分图最大匹配"></a>二分图最大匹配</h1><p>二分图算法挺多的，说几个常见的吧，主要是复杂度有差异。</p><h2 id="匈牙利算法"><a href="#匈牙利算法" class="headerlink" title="匈牙利算法"></a>匈牙利算法</h2><p><strong>复杂度：O(nm)</strong><br>匈牙利算法比较暴力，每次对某一个点都暴力找增广路，因为找的时候可能把所有边都看一遍，所以找一次增广路的复杂度是<script type="math/tex">O(m)</script>的。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    vis[u] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[u].size(); i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = G[u][i];</span><br><span class="line">        <span class="keyword">if</span> (!vis[v]) &#123;</span><br><span class="line">            vis[v] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (link[v] == <span class="number">-1</span> || dfs(link[v])) &#123;</span><br><span class="line">                link[v] = u;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Dinic"><a href="#Dinic" class="headerlink" title="Dinic"></a>Dinic</h2><p><strong><script type="math/tex">复杂度：O(n\sqrt(m))</script></strong><br>这个就不讲了，正常网络流建图即可。复杂度相对来说是这几个里面看起来最好的一个。</p><h2 id="Hopcroft-Karp"><a href="#Hopcroft-Karp" class="headerlink" title="Hopcroft-Karp"></a>Hopcroft-Karp</h2><p><strong><script type="math/tex">复杂度：O(m\sqrt(n))</script></strong></p><h1 id="二分图的一些非常重要的定理"><a href="#二分图的一些非常重要的定理" class="headerlink" title="二分图的一些非常重要的定理"></a>二分图的一些非常重要的定理</h1><h2 id="Hall定理"><a href="#Hall定理" class="headerlink" title="Hall定理"></a>Hall定理</h2><h3 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h3><p>Hall定理可以说是匈牙利算法的基础，也是二分图中非常基本的一个定理。<br>Hall定理说的是这么个东西，假设二分图两个点集为<script type="math/tex">X，Y</script>。令<script type="math/tex">n = min(|X|, |Y|)</script>。如果二分图有完美匹配，则对于任意<script type="math/tex">X</script>中任意<script type="math/tex">k</script>个点的集合<script type="math/tex">1 \leq k \leq n</script>，他们能到达<script type="math/tex">Y</script>里的点的点集的大小一定大于等于<script type="math/tex">k</script>。反过来也是成立的。</p><h3 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h3><p>考虑反证法，首先如果不满足后面的条件：对于某一个<script type="math/tex">k</script>，到达的Y集合的点没有<script type="math/tex">k</script>个，显然不可能达成完美匹配，倒过来是成立的。<br>考虑正向：如果对于任意k都满足这个条件，没有完美匹配代表至少X集合中有一个点没有匹配，而它能到的Y中有一个点跟其他点匹配了，我们找到它匹配的那个其他点（<script type="math/tex">X</script>中的），这个点能到的一定还有其它点（不然它和前面那个没匹配的<script type="math/tex">X</script>中的点加起来就只能到一个地方，不满足条件），这样一直推下去发现最后一定会推出矛盾，所以正向也是成立的。</p><h2 id="最小点覆盖"><a href="#最小点覆盖" class="headerlink" title="最小点覆盖"></a>最小点覆盖</h2><h3 id="内容-1"><a href="#内容-1" class="headerlink" title="内容"></a>内容</h3><p>求最少的点集，使得每一条边至少都有端点在这个点集中。</p><h3 id="定理"><a href="#定理" class="headerlink" title="定理"></a>定理</h3><p><strong>最小点覆盖 = 最大匹配</strong></p><h3 id="方案求解"><a href="#方案求解" class="headerlink" title="方案求解"></a>方案求解</h3><p>从左边点集没出发的点开始，从左到右走没有流的边，从右到左走有流的边，沿着路径dfs打标记，左边点集中没打标记的所有点和右边点集中所有打了标记的点构成一个最小点覆盖集。<br>我们发现，对于一个联通块，我们必然是从左边开始，并且在左边结束。因为从左边点集到右边点集走的是没有匹配的边，如果在右边停下了，说明右边那个点没匹配边，明显可以跟左边点匹配，不符合完美匹配，所以一定是从左边开始到左边停止。那么这条交错路径，我们全部选位于右边标记过的点就好了，这时候发现匹配数 = 选的点数。</p><h3 id="证明-1"><a href="#证明-1" class="headerlink" title="证明"></a>证明</h3><p>首先我们证明最大匹配 <script type="math/tex">\leq</script> 最小点覆盖，我们在每个匹配边两端任意选一个点，如果还有边没被覆盖，说明那条边两端都没点被选过，这显然不可能，所以最大匹配 <script type="math/tex">\leq</script> 最小点覆盖，反过来也好证，把所有匹配边抽出来，一定不重复，这时最少就需要选这么多条边个点。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 求最小点覆盖，从s出发，左边没标记过的点和右边标记过的点构成最小点覆盖。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">    ok[u] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[u].size(); i++)&#123;</span><br><span class="line">        edge &amp;e = edges[G[u][i]];</span><br><span class="line">        <span class="keyword">if</span>(e.cap &gt; e.flow &amp;&amp; !ok[e.to]) dfs1(e.to);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最大独立集"><a href="#最大独立集" class="headerlink" title="最大独立集"></a>最大独立集</h2><h3 id="内容-2"><a href="#内容-2" class="headerlink" title="内容"></a>内容</h3><p>一个最大的点的集合，使得任意两个点之间没有直接边连接。</p><h3 id="定理-1"><a href="#定理-1" class="headerlink" title="定理"></a>定理</h3><p><strong>最大独立集 = 点数 - 最大匹配</strong></p><h3 id="方案求解-1"><a href="#方案求解-1" class="headerlink" title="方案求解"></a>方案求解</h3><p>同最小点覆盖，只不过左边取打了标记的点，右边取没打标记的点就行了。</p><h3 id="证明-2"><a href="#证明-2" class="headerlink" title="证明"></a>证明</h3><p>先证<script type="math/tex">最大独立集 \leq 点数 - 最大匹配</script>。最初没有边，独立集数目等于点数。考虑每有一个匹配，就会让独立集数目 - 1，证明完毕。<br>再证：<script type="math/tex">最大独立集 \geq 点数 - 最大匹配</script>，考虑构造出来的方案，我们发现<script type="math/tex">最大独立集 \geq 点数 - 最大匹配</script>。证明完毕<br>所以最后<script type="math/tex">最大独立集 = 点数 - 最大匹配</script>。证明完毕</p><h2 id="最大团"><a href="#最大团" class="headerlink" title="最大团"></a>最大团</h2><h3 id="内容-3"><a href="#内容-3" class="headerlink" title="内容"></a>内容</h3><p>一个最大的点的集合，该集合内的任意两点都有边相连。</p><h3 id="定理-2"><a href="#定理-2" class="headerlink" title="定理"></a>定理</h3><p><strong>二分图的最大团 = 二分图补图的最大独立集</strong></p><h3 id="方案求解-2"><a href="#方案求解-2" class="headerlink" title="方案求解"></a>方案求解</h3><p>找补图的最大独立集即可。。</p><h3 id="证明-3"><a href="#证明-3" class="headerlink" title="证明"></a>证明</h3><p>好像没啥好证明的吧，根据定义发现取补图后就完全相等了。</p><h2 id="有向无环图的最小链覆盖与最长反链"><a href="#有向无环图的最小链覆盖与最长反链" class="headerlink" title="有向无环图的最小链覆盖与最长反链"></a>有向无环图的最小链覆盖与最长反链</h2><h3 id="内容-4"><a href="#内容-4" class="headerlink" title="内容"></a>内容</h3><p><strong>图论角度</strong><br>最小链覆盖也称最小路径覆盖，要求每条路径上不能有重复的点。</p><p>最小链覆盖：从边中选出若干点不相交的链，使得这些链覆盖所有的点，并且链的条数最小。（链的定义是一条连续路径，并且不经过重复的点。路径可以只是一个单独的边，不包含边）<br>最长反链：首先纠正一下，反链不是链，而是集合。链代表的是一个集合内，任意两个点(u, v)，要嘛u能走到v，要嘛v能走到u。反链是指的一个点集，集合内两个点谁也不能走到谁。最长反链就是找一个点数最多的这样的集合。</p><p>这是从图的角度来解读的，我们再从<strong>偏序集的角度</strong>来解释一下。<br>设<script type="math/tex">\leq</script>是一个偏序关系，我们知道满足以下条件可以构成偏序集：<br>1、自反性：<script type="math/tex">\forall a \in A, a \leq a</script><br>2、反对称性：<script type="math/tex">\forall a, b \in A, 若a \leq b，b \leq a，则a = b</script><br>3、传递性：<script type="math/tex">\forall a, b, c \in A，若a \leq b，b \leq c 则a \leq c</script><br>全序集：若对于集合<script type="math/tex">\forall a, b \in B，都有a \leq b或 b \leq a（两元素互相可比）</script>，则称<script type="math/tex">(B, \leq)</script>为一个全序集。<br>反链：若偏序集<script type="math/tex">(B, \leq)</script>中的元素两两不可比，则称B为反链。</p><h3 id="定理-3"><a href="#定理-3" class="headerlink" title="定理"></a>定理</h3><p><strong>最长反链 = 最小链覆盖</strong></p><h3 id="Dilworth定理"><a href="#Dilworth定理" class="headerlink" title="Dilworth定理"></a>Dilworth定理</h3><p><strong>最少的全序集 = 最长反链</strong><br><strong>最少反链划分 = 最大全序集</strong></p><h4 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h4><p>问题：给定一个序列，求最少能将序列划分为多少个不单增的子序列。</p><p>考虑将序列拓展为二元关系（a，b），a代表下标，b代表数据的值。我们定义当两个对应位置都严格大于或者小于时，它们是可比的，否则是不可比的。我们发现按照定义，在一个不单增子序列中任意两个元素是不可比的，也就是说一个不单增的子序列构成一个反链，问题变为了求偏序集上的最少反链划分，根据定理可知等于最大全序集的大小，也就是最长上升子序列的大小，所以求一个最长上升子序列即可。</p><p>回到图上，考虑偏序集上因为是偏序关系，是不可能存在环的偏序关系的，这也就对应了为什么图上一定是DAG。</p><h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><p><strong>再强调一遍，必须是DAG才能做，并且是不重点的。</strong><br>将原图每个点拆为两个，分别位于二分图的两端。对于每一条边(u, v)，从新点中左边点集中的u连向右边点集中的v，最后答案等于点数 - 新二分图最大匹配。</p><h3 id="方案构造"><a href="#方案构造" class="headerlink" title="方案构造"></a>方案构造</h3><p>从每个没有访问过的点开始出发，沿着匹配边一直走，路上所有点打标记，走到不能走为止，便对应了一条路径。</p><h3 id="证明-4"><a href="#证明-4" class="headerlink" title="证明"></a>证明</h3><p>可以感性证明一下，假设一开始图没有边，最长反链为n，最小链覆盖此时也为n。考虑一个匹配边对应合并两个点，此时反链会 - 1，最小链覆盖数也会 - 1，感性认知二者是等价的。具体证明就不证了（主要是不太想看），有空再补吧。</p><h3 id="最小链覆盖中可作为链端点的点"><a href="#最小链覆盖中可作为链端点的点" class="headerlink" title="最小链覆盖中可作为链端点的点"></a>最小链覆盖中可作为链端点的点</h3><p>opentrain上的一个好题。<br>考虑一个点能作为起点，代表如果我们删去这个点，最小链覆盖的数目不会增加（如果是一个点就减少、否则不变）。我们先考虑起点（二分图左边的点），首先单独的未匹配点一定可以，考虑沿着它找一条交错路径，我们发现交错路径覆盖到的左边的点都可以作为起点（可以替换匹配边，使得它变为未匹配点）。那么我们从左半边找一次。考虑终点也是同样的，不过是从二分图右半边开始找未匹配点，然后走交错路径，给右边的覆盖的点打上标记，最后只要在这个点左边或者右边被覆盖过一次，它就可以作为端点。（记得如果是dinic先把s，t给标记了，不标记我也不知道会不会出错。）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    pre[s] = pre[t] = suf[s] = suf[t] = <span class="number">1</span>;</span><br><span class="line">    dfs2(s, pre, <span class="number">0</span>);</span><br><span class="line">    dfs2(t, suf, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(pre[i] || suf[i + n]) <span class="comment">//可以作为端点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">bool</span> *ok, <span class="keyword">bool</span> f)</span></span>&#123;</span><br><span class="line">    ok[u] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[u].size(); i++)&#123;</span><br><span class="line">        edge &amp;e = edges[G[u][i]];</span><br><span class="line">        <span class="keyword">if</span>(!ok[e.to] &amp;&amp; ((e.cap &gt; e.flow) ^ f)) dfs1(e.to, ok, f);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;二分图概念&quot;&gt;&lt;a href=&quot;#二分图概念&quot; class=&quot;headerlink&quot; title=&quot;二分图概念&quot;&gt;&lt;/a&gt;二分图概念&lt;/h1&gt;&lt;p&gt;二分图简单来说，就是一个无向图，可以把点集分为两个，且边都是从一个点集指向另一个点集。&lt;br&gt;&lt;strong&gt;二分图有另一个等价的定义：没有奇环。&lt;/strong&gt;相对而言这个性质更加重要。&lt;br&gt;
    
    </summary>
    
      <category term="二分图" scheme="http://yoursite.com/categories/%E4%BA%8C%E5%88%86%E5%9B%BE/"/>
    
    
  </entry>
  
  <entry>
    <title>Codeforces Round 366 (Div. 1)-B(Ant Man)</title>
    <link href="http://yoursite.com/2020/03/28/Codeforces-Round-366-Div-1-B-Ant-Man/"/>
    <id>http://yoursite.com/2020/03/28/Codeforces-Round-366-Div-1-B-Ant-Man/</id>
    <published>2020-03-28T15:32:48.000Z</published>
    <updated>2020-03-28T16:16:14.594Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://codeforces.com/contest/704/problem/B" target="_blank" rel="noopener">题目链接</a><br>思路：考虑按位置插入，原来位置是一个从小位置指向大位置的，插入后变成了两个小的指向一个大的，相当于有一个原来大的变成了小的。我们发现每次操作都是把一个原本是大的的转换为小的，所以我们每次取大的里面最大的，贪心即可。<br><a id="more"></a><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">5050</span>;</span><br><span class="line"><span class="keyword">int</span> ne[maxn];</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;ll, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">int</span> a[maxn], b[maxn], c[maxn], d[maxn], x[maxn], n, s, e;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">f</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(p &lt; q) <span class="keyword">return</span> <span class="number">1l</span>l * x[q] - x[p] + d[p] + a[q];</span><br><span class="line">   <span class="keyword">return</span> <span class="number">1l</span>l * x[p] - x[q] + c[p] + b[q];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>, &amp;n, &amp;s, &amp;e);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, x + i);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, a + i);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, b + i);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, c + i);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, d + i);</span><br><span class="line">ne[s] = e;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(i == s || i == e) <span class="keyword">continue</span>;</span><br><span class="line">pii t = pii(<span class="number">1e18</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = s; j != e; j = ne[j])&#123;</span><br><span class="line">t = min(t, pii(f(j, i) + f(i, ne[j]) - f(j, ne[j]), j));</span><br><span class="line">&#125;</span><br><span class="line">ne[i] = ne[t.second];</span><br><span class="line">ne[t.second] = i;</span><br><span class="line">&#125;</span><br><span class="line">ll res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = s; i != e; i = ne[i])&#123;</span><br><span class="line">res += f(i, ne[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, res);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>还有一个dp的做法，dp[i][j]表示考虑前i个点，形成了j条链。转移就四种方向：<br>1、i的出边从左到右，入边从右到左，那么会合并两条链，所以要求 <script type="math/tex">p \geq 2</script>，<script type="math/tex">dp_{i+1,p-1} +=  dp_{i,p}+a_i+c_i</script><br>2、的出边从右到左，入边从左到右，那么会形成一条新的链，所以<script type="math/tex">dp_{i+1,p+1} += dp_{i,p}+b_i+d_i</script><br>3、i 连边都是从左到右，链数没有变化，但是以 ee 结尾的链是不能连出边的，所以要求<script type="math/tex">p>[i>e]，dp_{i+1,p} += dp_{i,p}+a_i+d_i</script><br>4、i 连边都是从左到右，链数没有变化，但是以 ee 结尾的链是不能连出边的，所以要求<script type="math/tex">p>[i>e]，dp_{i+1,p} += dp_{i,p}+a_i+d_i</script><br>当有s和t的时候我们要特殊考虑，s的时候只考虑入边，t的时候只考虑出边即可。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> db;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vi;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;ll&gt; vl;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;pii&gt; vp;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">const</span> ll INF = <span class="number">1e18</span>;</span><br><span class="line"><span class="keyword">const</span> db eps = <span class="number">1e-10</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> eb emplace_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ep emplace</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mem(a) memset(a, 0, sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> copy(a, b) memcpy(a, b, sizeof(b))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PA cout &lt;&lt; <span class="meta-string">"pass\n"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lowbit(x) (x &amp; -x)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(x) x.begin(), x.end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TM cout &lt;&lt; db(clock()) / CLOCKS_PER_SEC &lt;&lt; <span class="meta-string">'\n'</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">mt19937 <span class="title">mrand</span><span class="params">(chrono::high_resolution_clock::now().time_since_epoch().count())</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;<span class="title">inline</span> <span class="title">void</span> <span class="title">upmin</span>(<span class="title">T</span> &amp;<span class="title">x</span>, <span class="title">T</span> <span class="title">y</span>) &#123;</span>x = x &gt; y ? y : x;&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;<span class="title">inline</span> <span class="title">void</span> <span class="title">upmax</span>(<span class="title">T</span> &amp;<span class="title">x</span>, <span class="title">T</span> <span class="title">y</span>) &#123;</span>x = x &lt; y ? y : x;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">5050</span>;</span><br><span class="line"><span class="keyword">int</span> n, s, e;</span><br><span class="line">ll f[maxn], g[maxn], a[maxn], b[maxn], c[maxn], d[maxn], x[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>), <span class="built_in">cin</span>.tie(<span class="number">0</span>), <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; fixed &lt;&lt; setprecision(<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; s &gt;&gt; e;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">cin</span> &gt;&gt; x[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">cin</span> &gt;&gt; b[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">cin</span> &gt;&gt; c[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">cin</span> &gt;&gt; d[i];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) g[i] = INF;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= n; j++) f[j] = INF;</span><br><span class="line">        <span class="keyword">if</span> (i == s) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = (i &gt; e); j &lt; n; j++) upmin(f[j + <span class="number">1</span>], g[j] + d[i] - x[i]);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) upmin(f[j], g[j] + x[i] + c[i]);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i == e) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = (i &gt; s); j &lt; n; j++) upmin(f[j + <span class="number">1</span>], g[j] + b[i] - x[i]);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) upmin(f[j], g[j] + a[i] + x[i]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = (i &gt; e) + <span class="number">1</span>; j &lt;= n; j++) upmin(f[j], g[j] + a[i] + d[i]);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = (i &gt; s) + <span class="number">1</span>; j &lt;= n; j++) upmin(f[j], g[j] + b[i] + c[i]);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = (i &gt; e) + (i &gt; s); j &lt;= n; j++) upmin(f[j + <span class="number">1</span>], g[j] + b[i] + d[i] - <span class="number">2</span> * x[i]);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span>; j &lt;= n; j++) upmin(f[j - <span class="number">1</span>], g[j] + <span class="number">2</span> * x[i] + a[i] + c[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        swap(f, g);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; g[<span class="number">1</span>] &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>​     </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://codeforces.com/contest/704/problem/B&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目链接&lt;/a&gt;&lt;br&gt;思路：考虑按位置插入，原来位置是一个从小位置指向大位置的，插入后变成了两个小的指向一个大的，相当于有一个原来大的变成了小的。我们发现每次操作都是把一个原本是大的的转换为小的，所以我们每次取大的里面最大的，贪心即可。&lt;br&gt;
    
    </summary>
    
      <category term="贪心" scheme="http://yoursite.com/categories/%E8%B4%AA%E5%BF%83/"/>
    
    
  </entry>
  
  <entry>
    <title>Codeforces Round 323 (Div. 1)-D(Number of Binominal Coefficients)</title>
    <link href="http://yoursite.com/2020/03/28/Codeforces-Round-323-Div-1-D-Number-of-Binominal-Coefficients/"/>
    <id>http://yoursite.com/2020/03/28/Codeforces-Round-323-Div-1-D-Number-of-Binominal-Coefficients/</id>
    <published>2020-03-28T14:33:25.000Z</published>
    <updated>2020-03-28T15:30:39.549Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://codeforces.com/contest/582/problem/D" target="_blank" rel="noopener">题目链接</a><br>思路：<br>先介绍一个定理，不然这个题做不了。</p><h3 id="库莫尔定理"><a href="#库莫尔定理" class="headerlink" title="库莫尔定理"></a>库莫尔定理</h3><p>设m, n为正整数，p为素数，则<script type="math/tex">C_{m + n}^m</script>喊p的幂次等于m + n在p进制下的进位次数。<br>证明：我们发现p是素数，我们知道<script type="math/tex">C_{m + n}^n = \frac{(m + n)!}{m!n!}</script>，那么<script type="math/tex">C_{m + n}^n</script>含有p的幂次等于<script type="math/tex">\sum_{i = 1}^{\infty}\lfloor\frac{n + m}{p^i}\rfloor - \lfloor\frac{n}{p^i}\rfloor - \lfloor\frac{m}{p^i}\rfloor</script><br>我们发现对于每一个i，答案不会超过1，考虑什么时候为1，可以发现是在p进制下第i位发生进位时取到。</p><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>这一类题目都是库莫尔定理 + 数位dp的，考虑dp[i][j][k][l]表示考虑了前i个位置，进了j次位，前面已经等于/小于边界，上一位是否需要进位。那么剩下的问题就是转移的时候的组合数，即我们要统计在这一位有多少对(k, n)满足条件（可能有进位，并且另一个位置还要在可行范围内），可以以p为边界分开计算，然后转移即可。<br><a id="more"></a><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> db;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vi;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;ll&gt; vl;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;pii&gt; vp;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">const</span> ll INF = <span class="number">1e18</span>;</span><br><span class="line"><span class="keyword">const</span> db eps = <span class="number">1e-10</span>;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> eb emplace_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ep emplace</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mem(a) memset(a, 0, sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> copy(a, b) memcpy(a, b, sizeof(b))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PA cout &lt;&lt; <span class="meta-string">"pass\n"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lowbit(x) (x &amp; -x)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(x) x.begin(), x.end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TM cout &lt;&lt; db(clock()) / CLOCKS_PER_SEC &lt;&lt; <span class="meta-string">'\n'</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function">mt19937 <span class="title">mrand</span><span class="params">(chrono::high_resolution_clock::now().time_since_epoch().count())</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;<span class="title">inline</span> <span class="title">void</span> <span class="title">upmin</span>(<span class="title">T</span> &amp;<span class="title">x</span>, <span class="title">T</span> <span class="title">y</span>) &#123;</span>x = x &gt; y ? y : x;&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;<span class="title">inline</span> <span class="title">void</span> <span class="title">upmax</span>(<span class="title">T</span> &amp;<span class="title">x</span>, <span class="title">T</span> <span class="title">y</span>) &#123;</span>x = x &lt; y ? y : x;&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 9999</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 500</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DLEN 4</span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BigNum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ll a[<span class="number">5000</span>];   </span><br><span class="line">    <span class="keyword">int</span> len;      </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    BigNum()&#123; len = <span class="number">1</span>;<span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="keyword">sizeof</span>(a)); &#125;   </span><br><span class="line">    BigNum(<span class="keyword">const</span> <span class="keyword">int</span>);       </span><br><span class="line">    BigNum(<span class="keyword">const</span> <span class="keyword">char</span>*);    </span><br><span class="line">    BigNum(<span class="keyword">const</span> BigNum &amp;);  </span><br><span class="line">    BigNum &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> BigNum &amp;);  </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">friend</span> istream&amp; <span class="keyword">operator</span>&gt;&gt;(istream&amp;,  BigNum&amp;);   </span><br><span class="line">    <span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp;,  BigNum&amp;);   </span><br><span class="line"> </span><br><span class="line">    BigNum <span class="keyword">operator</span>+(<span class="keyword">const</span> BigNum &amp;) <span class="keyword">const</span>;   </span><br><span class="line">    BigNum <span class="keyword">operator</span>-(<span class="keyword">const</span> BigNum &amp;) <span class="keyword">const</span>;   </span><br><span class="line">    BigNum <span class="keyword">operator</span>*(<span class="keyword">const</span> BigNum &amp;) <span class="keyword">const</span>;   </span><br><span class="line">    BigNum <span class="keyword">operator</span>/(<span class="keyword">const</span> <span class="keyword">int</span>   &amp;) <span class="keyword">const</span>;    </span><br><span class="line"> </span><br><span class="line">    BigNum <span class="keyword">operator</span>^(<span class="keyword">const</span> <span class="keyword">int</span>  &amp;) <span class="keyword">const</span>;    </span><br><span class="line">    ll    <span class="keyword">operator</span>%(<span class="keyword">const</span> <span class="keyword">int</span>  &amp;) <span class="keyword">const</span>;    </span><br><span class="line">    <span class="keyword">bool</span>   <span class="keyword">operator</span>&gt;(<span class="keyword">const</span> BigNum &amp; T)<span class="keyword">const</span>;   </span><br><span class="line">    <span class="keyword">bool</span>   <span class="keyword">operator</span>&gt;(<span class="keyword">const</span> <span class="keyword">int</span> &amp; t)<span class="keyword">const</span>;     </span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>;       </span><br><span class="line">&#125;;</span><br><span class="line">BigNum::BigNum(<span class="keyword">const</span> <span class="keyword">int</span> b)     </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> c,d = b;</span><br><span class="line">    len = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="keyword">sizeof</span>(a));</span><br><span class="line">    <span class="keyword">while</span>(d &gt; MAXN)</span><br><span class="line">    &#123;</span><br><span class="line">        c = d - (d / (MAXN + <span class="number">1</span>)) * (MAXN + <span class="number">1</span>);</span><br><span class="line">        d = d / (MAXN + <span class="number">1</span>);</span><br><span class="line">        a[len++] = c;</span><br><span class="line">    &#125;</span><br><span class="line">    a[len++] = d;</span><br><span class="line">&#125;</span><br><span class="line">BigNum::BigNum(<span class="keyword">const</span> <span class="keyword">char</span>*s)    </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> t,k,index,l,i;</span><br><span class="line">    <span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="keyword">sizeof</span>(a));</span><br><span class="line">    l=<span class="built_in">strlen</span>(s);</span><br><span class="line">    len=l/DLEN;</span><br><span class="line">    <span class="keyword">if</span>(l%DLEN)</span><br><span class="line">        len++;</span><br><span class="line">    index=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=l<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i-=DLEN)</span><br><span class="line">    &#123;</span><br><span class="line">        t=<span class="number">0</span>;</span><br><span class="line">        k=i-DLEN+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(k&lt;<span class="number">0</span>)</span><br><span class="line">            k=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=k;j&lt;=i;j++)</span><br><span class="line">            t=t*<span class="number">10</span>+s[j]-<span class="string">'0'</span>;</span><br><span class="line">        a[index++]=t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">BigNum::BigNum(<span class="keyword">const</span> BigNum &amp; T) : len(T.len) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="keyword">sizeof</span>(a));</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span> ; i &lt; len ; i++)</span><br><span class="line">        a[i] = T.a[i];</span><br><span class="line">&#125;</span><br><span class="line">BigNum &amp; BigNum::<span class="keyword">operator</span>=(<span class="keyword">const</span> BigNum &amp; n)   </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    len = n.len;</span><br><span class="line">    <span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="keyword">sizeof</span>(a));</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span> ; i &lt; len ; i++)</span><br><span class="line">        a[i] = n.a[i];</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">istream&amp; <span class="keyword">operator</span>&gt;&gt;(istream &amp; in,  BigNum &amp; b)   <span class="comment">//�������������</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">char</span> ch[MAXSIZE*<span class="number">4</span>];</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">-1</span>;</span><br><span class="line">    in&gt;&gt;ch;</span><br><span class="line">    <span class="keyword">int</span> l=<span class="built_in">strlen</span>(ch);</span><br><span class="line">    <span class="keyword">int</span> count=<span class="number">0</span>,sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=l<span class="number">-1</span>;i&gt;=<span class="number">0</span>;)</span><br><span class="line">    &#123;</span><br><span class="line">        sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> t=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">4</span>&amp;&amp;i&gt;=<span class="number">0</span>;j++,i--,t*=<span class="number">10</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            sum+=(ch[i]-<span class="string">'0'</span>)*t;</span><br><span class="line">        &#125;</span><br><span class="line">        b.a[count]=sum;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    b.len =count++;</span><br><span class="line">    <span class="keyword">return</span> in;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out,  BigNum&amp; b)   </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; b.a[b.len - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(i = b.len - <span class="number">2</span> ; i &gt;= <span class="number">0</span> ; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>.width(DLEN);</span><br><span class="line">        <span class="built_in">cout</span>.fill(<span class="string">'0'</span>);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; b.a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">BigNum BigNum::<span class="keyword">operator</span>+(<span class="keyword">const</span> BigNum &amp; T) <span class="keyword">const</span>   </span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">BigNum <span class="title">t</span><span class="params">(*<span class="keyword">this</span>)</span></span>;</span><br><span class="line">    <span class="keyword">int</span> i,big;      <span class="comment">//λ��</span></span><br><span class="line">    big = T.len &gt; len ? T.len : len;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span> ; i &lt; big ; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        t.a[i] +=T.a[i];</span><br><span class="line">        <span class="keyword">if</span>(t.a[i] &gt; MAXN)</span><br><span class="line">        &#123;</span><br><span class="line">            t.a[i + <span class="number">1</span>]++;</span><br><span class="line">            t.a[i] -=MAXN+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(t.a[big] != <span class="number">0</span>)</span><br><span class="line">        t.len = big + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        t.len = big;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line">BigNum BigNum::<span class="keyword">operator</span>-(<span class="keyword">const</span> BigNum &amp; T) <span class="keyword">const</span>   </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j,big;</span><br><span class="line">    <span class="keyword">bool</span> flag;</span><br><span class="line">    BigNum t1,t2;</span><br><span class="line">    <span class="keyword">if</span>(*<span class="keyword">this</span>&gt;T)</span><br><span class="line">    &#123;</span><br><span class="line">        t1=*<span class="keyword">this</span>;</span><br><span class="line">        t2=T;</span><br><span class="line">        flag=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        t1=T;</span><br><span class="line">        t2=*<span class="keyword">this</span>;</span><br><span class="line">        flag=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    big=t1.len;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span> ; i &lt; big ; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(t1.a[i] &lt; t2.a[i])</span><br><span class="line">        &#123;</span><br><span class="line">            j = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(t1.a[j] == <span class="number">0</span>)</span><br><span class="line">                j++;</span><br><span class="line">            t1.a[j--]--;</span><br><span class="line">            <span class="keyword">while</span>(j &gt; i)</span><br><span class="line">                t1.a[j--] += MAXN;</span><br><span class="line">            t1.a[i] += MAXN + <span class="number">1</span> - t2.a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            t1.a[i] -= t2.a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    t1.len = big;</span><br><span class="line">    <span class="keyword">while</span>(t1.a[t1.len - <span class="number">1</span>] == <span class="number">0</span> &amp;&amp; t1.len &gt; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        t1.len--;</span><br><span class="line">        big--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(flag)</span><br><span class="line">        t1.a[big<span class="number">-1</span>]=<span class="number">0</span>-t1.a[big<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">return</span> t1;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">BigNum BigNum::<span class="keyword">operator</span>*(<span class="keyword">const</span> BigNum &amp; T) <span class="keyword">const</span>   </span><br><span class="line">&#123;</span><br><span class="line">    BigNum ret;</span><br><span class="line">    <span class="keyword">int</span> i,j,up;</span><br><span class="line">    <span class="keyword">int</span> temp,temp1;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span> ; i &lt; len ; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        up = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span> ; j &lt; T.len ; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            temp = a[i] * T.a[j] + ret.a[i + j] + up;</span><br><span class="line">            <span class="keyword">if</span>(temp &gt; MAXN)</span><br><span class="line">            &#123;</span><br><span class="line">                temp1 = temp - temp / (MAXN + <span class="number">1</span>) * (MAXN + <span class="number">1</span>);</span><br><span class="line">                up = temp / (MAXN + <span class="number">1</span>);</span><br><span class="line">                ret.a[i + j] = temp1;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                up = <span class="number">0</span>;</span><br><span class="line">                ret.a[i + j] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(up != <span class="number">0</span>)</span><br><span class="line">            ret.a[i + j] = up;</span><br><span class="line">    &#125;</span><br><span class="line">    ret.len = i + j;</span><br><span class="line">    <span class="keyword">while</span>(ret.a[ret.len - <span class="number">1</span>] == <span class="number">0</span> &amp;&amp; ret.len &gt; <span class="number">1</span>)</span><br><span class="line">        ret.len--;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line">BigNum BigNum::<span class="keyword">operator</span>/(<span class="keyword">const</span> <span class="keyword">int</span> &amp; b) <span class="keyword">const</span>   </span><br><span class="line">&#123;</span><br><span class="line">    BigNum ret;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    ll down = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = len - <span class="number">1</span> ; i &gt;= <span class="number">0</span> ; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        ret.a[i] = (a[i] + down * (MAXN + <span class="number">1</span>)) / b;</span><br><span class="line">        down = a[i] + down * (MAXN + <span class="number">1</span>) - ret.a[i] * b;</span><br><span class="line">    &#125;</span><br><span class="line">    ret.len = len;</span><br><span class="line">    <span class="keyword">while</span>(ret.a[ret.len - <span class="number">1</span>] == <span class="number">0</span> &amp;&amp; ret.len &gt; <span class="number">1</span>)</span><br><span class="line">        ret.len--;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">ll BigNum::<span class="keyword">operator</span> %(<span class="keyword">const</span> <span class="keyword">int</span> &amp; b) <span class="keyword">const</span>    </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    ll d=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = len<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        d = ((d * (MAXN+<span class="number">1</span>))% b + a[i])% b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line">BigNum BigNum::<span class="keyword">operator</span>^(<span class="keyword">const</span> <span class="keyword">int</span> &amp; n) <span class="keyword">const</span>    </span><br><span class="line">&#123;</span><br><span class="line">    BigNum t,ret(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;<span class="number">0</span>)</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">int</span> m=n;</span><br><span class="line">    <span class="keyword">while</span>(m&gt;<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        t=*<span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">for</span>( i=<span class="number">1</span>;i&lt;&lt;<span class="number">1</span>&lt;=m;i&lt;&lt;=<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            t=t*t;</span><br><span class="line">        &#125;</span><br><span class="line">        m-=i;</span><br><span class="line">        ret=ret*t;</span><br><span class="line">        <span class="keyword">if</span>(m==<span class="number">1</span>)</span><br><span class="line">            ret=ret*(*<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">bool</span> BigNum::<span class="keyword">operator</span>&gt;(<span class="keyword">const</span> BigNum &amp; T) <span class="keyword">const</span>   </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> ln;</span><br><span class="line">    <span class="keyword">if</span>(len &gt; T.len)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(len == T.len)</span><br><span class="line">    &#123;</span><br><span class="line">        ln = len - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(a[ln] == T.a[ln] &amp;&amp; ln &gt;= <span class="number">0</span>)</span><br><span class="line">            ln--;</span><br><span class="line">        <span class="keyword">if</span>(ln &gt;= <span class="number">0</span> &amp;&amp; a[ln] &gt; T.a[ln])</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">bool</span> BigNum::<span class="keyword">operator</span> &gt;(<span class="keyword">const</span> <span class="keyword">int</span> &amp; t) <span class="keyword">const</span>    </span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">BigNum <span class="title">b</span><span class="params">(t)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>&gt;b;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">void</span> BigNum::print()   </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a[len - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(i = len - <span class="number">2</span> ; i &gt;= <span class="number">0</span> ; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>.width(DLEN);</span><br><span class="line">        <span class="built_in">cout</span>.fill(<span class="string">'0'</span>);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> p, a;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    x += y;</span><br><span class="line">    <span class="keyword">if</span>(x &gt;= mod) x -= mod;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">3500</span>;</span><br><span class="line"><span class="keyword">int</span> dp[maxn][maxn][<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line">ll b[maxn];</span><br><span class="line">BigNum tmp;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Sum</span><span class="params">(ll l,ll r)</span> </span>&#123; <span class="keyword">return</span> <span class="number">1l</span>l*(l+r)*(r-l+<span class="number">1</span>)/<span class="number">2</span>%mod; &#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">cal</span><span class="params">(ll l,ll r)</span> </span>&#123;</span><br><span class="line">    l = max(l, <span class="number">0l</span>l);</span><br><span class="line">    <span class="keyword">if</span> (l &gt; r) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    ll tot = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (r &gt;= p - <span class="number">1</span>) tot += (<span class="number">2</span> * p - <span class="number">1</span>) * (r - max(l, p - <span class="number">1l</span>l) + <span class="number">1</span>) - Sum(max(l, p - <span class="number">1l</span>l), r), r = p - <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (l &lt;= r) tot += Sum(l + <span class="number">1</span>, r + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> (tot % mod + mod) % mod;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> len, <span class="keyword">int</span> now, <span class="keyword">bool</span> z, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (len &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span> &amp;&amp; now &gt;= a) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dp[len][now][z][c] != <span class="number">-1</span>) <span class="keyword">return</span> dp[len][now][z][c];</span><br><span class="line">    <span class="keyword">int</span> e = !z ? p - <span class="number">1</span> : b[len];</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (!c) &#123;</span><br><span class="line">        add(res, <span class="number">1l</span>l * cal(<span class="number">0</span>, e - <span class="number">1</span>) * dfs(len - <span class="number">1</span>, now, <span class="number">0</span>, <span class="number">0</span>) % mod);</span><br><span class="line">        add(res, <span class="number">1l</span>l * cal(e, e) * dfs(len - <span class="number">1</span>, now, z, <span class="number">0</span>) % mod);</span><br><span class="line">        add(res, <span class="number">1l</span>l * cal(<span class="number">0</span>, e - <span class="number">2</span>) * dfs(len - <span class="number">1</span>, now, <span class="number">0</span>, <span class="number">1</span>) % mod);</span><br><span class="line">        add(res, <span class="number">1l</span>l * cal(e - <span class="number">1</span>, e - <span class="number">1</span>) * dfs(len - <span class="number">1</span>, now, z, <span class="number">1</span>) % mod);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        add(res, <span class="number">1l</span>l * cal(p, p + e - <span class="number">1</span>) * dfs(len - <span class="number">1</span>, now + <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>) % mod);</span><br><span class="line">        add(res, <span class="number">1l</span>l * cal(p + e, p + e) * dfs(len - <span class="number">1</span>, now + <span class="number">1</span>, z, <span class="number">0</span>) % mod);</span><br><span class="line">        add(res, <span class="number">1l</span>l * cal(p - <span class="number">1</span>, p + e - <span class="number">2</span>) * dfs(len - <span class="number">1</span>, now + <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>) % mod);</span><br><span class="line">        add(res, <span class="number">1l</span>l * cal(p + e - <span class="number">1</span>, p + e - <span class="number">1</span>) * dfs(len - <span class="number">1</span>, now + <span class="number">1</span>, z, <span class="number">1</span>) % mod);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    dp[len][now][z][c] = res;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> len;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    len = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">-1</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">    <span class="keyword">while</span>(tmp &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        b[len++] = tmp % p;</span><br><span class="line">        tmp = tmp / p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dfs(len - <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; p &gt;&gt; a &gt;&gt; tmp;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; solve() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://codeforces.com/contest/582/problem/D&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目链接&lt;/a&gt;&lt;br&gt;思路：&lt;br&gt;先介绍一个定理，不然这个题做不了。&lt;/p&gt;
&lt;h3 id=&quot;库莫尔定理&quot;&gt;&lt;a href=&quot;#库莫尔定理&quot; class=&quot;headerlink&quot; title=&quot;库莫尔定理&quot;&gt;&lt;/a&gt;库莫尔定理&lt;/h3&gt;&lt;p&gt;设m, n为正整数，p为素数，则&lt;script type=&quot;math/tex&quot;&gt;C_{m + n}^m&lt;/script&gt;喊p的幂次等于m + n在p进制下的进位次数。&lt;br&gt;证明：我们发现p是素数，我们知道&lt;script type=&quot;math/tex&quot;&gt;C_{m + n}^n = \frac{(m + n)!}{m!n!}&lt;/script&gt;，那么&lt;script type=&quot;math/tex&quot;&gt;C_{m + n}^n&lt;/script&gt;含有p的幂次等于&lt;script type=&quot;math/tex&quot;&gt;\sum_{i = 1}^{\infty}\lfloor\frac{n + m}{p^i}\rfloor - \lfloor\frac{n}{p^i}\rfloor - \lfloor\frac{m}{p^i}\rfloor&lt;/script&gt;&lt;br&gt;我们发现对于每一个i，答案不会超过1，考虑什么时候为1，可以发现是在p进制下第i位发生进位时取到。&lt;/p&gt;
&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;这一类题目都是库莫尔定理 + 数位dp的，考虑dp[i][j][k][l]表示考虑了前i个位置，进了j次位，前面已经等于/小于边界，上一位是否需要进位。那么剩下的问题就是转移的时候的组合数，即我们要统计在这一位有多少对(k, n)满足条件（可能有进位，并且另一个位置还要在可行范围内），可以以p为边界分开计算，然后转移即可。&lt;br&gt;
    
    </summary>
    
      <category term="数位dp" scheme="http://yoursite.com/categories/%E6%95%B0%E4%BD%8Ddp/"/>
    
    
  </entry>
  
</feed>

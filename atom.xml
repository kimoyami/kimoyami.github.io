<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>小雅米，来来往往这么多人，有多少是圆梦后才衣锦还乡的呢？</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-06-10T04:03:25.119Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>kimoyami</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>多变量线性回归</title>
    <link href="http://yoursite.com/2020/06/09/%E5%A4%9A%E5%8F%98%E9%87%8F%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/"/>
    <id>http://yoursite.com/2020/06/09/多变量线性回归/</id>
    <published>2020-06-09T07:30:43.000Z</published>
    <updated>2020-06-10T04:03:25.119Z</updated>
    
    <content type="html"><![CDATA[<h1 id="多功能"><a href="#多功能" class="headerlink" title="多功能"></a>多功能</h1><h2 id="一些定义"><a href="#一些定义" class="headerlink" title="一些定义"></a>一些定义</h2><ul><li>$x_i^{(j)}$:第$i$个样本的第$j$个特征</li></ul><h2 id="多变量形式"><a href="#多变量形式" class="headerlink" title="多变量形式"></a>多变量形式</h2><p>$h_{\theta}(x) = \theta_0 + \theta_1x_1 + \theta_2x_2 + \dots + \theta_nx_n$, 这里的$x_i$就代表第$i$个特征</p><h2 id="矩阵定义"><a href="#矩阵定义" class="headerlink" title="矩阵定义"></a>矩阵定义</h2><p>我们这里用矩阵来定义，后面我们将发现，运算过程可以变为矩阵的乘法。</p><ul><li><p>$\theta =<br>\left[<br>\begin{matrix}<br> \theta_0\\<br> \theta_1\\<br> \theta_2\\<br> .\\<br> .\\<br> \theta_n<br>\end{matrix}<br>\right]<br>$</p></li><li><p>$x =<br>\left[<br>\begin{matrix}<br> 1\\<br> x_1\\<br> x_2\\<br> .\\<br> .\\<br> x_n<br>\end{matrix}<br>\right]<br>$</p></li></ul><p>我们发现上面的$h_{\theta}(x)$可以写成$h_{\theta}(x) = \theta^Tx$</p><h1 id="多元梯度下降法"><a href="#多元梯度下降法" class="headerlink" title="多元梯度下降法"></a>多元梯度下降法</h1><p>其实就是把线性的拿来做了一个拓展，形式都完全一样</p><ul><li>$J(\theta_0, \theta_1, \theta_2\cdots, \theta_n) = \frac{1}{2m}\sum_{i = 1}^m(\theta_{i0} + \theta_1x_{i1} + \theta_2x_{i2} + \cdots + \theta_nx_{in} - y_i) ^ 2$</li></ul><p>那么我们有如下的更新方法：<br>$\theta_z = \theta_z - \alpha\frac{1}{m}\sum_{i = 1}^m(h_{\theta}(x^{(i)}) - y^{(i)})x_z{(i)}$，其中$x_0 = 1$</p><h1 id="特征放缩"><a href="#特征放缩" class="headerlink" title="特征放缩"></a>特征放缩</h1><p>在$h_{\theta}(x) = \theta_0 + \theta_1x_1 + \theta_2x_2 + \dots + \theta_nx_n$中，假设各个$x_i$的取值范围大小相差很大，在更新上会出现不稳定的问题。原因就是参数值大的出现的波动会更大，举个例子，假设各个参数$\theta_i$都增加0.01，那么取值范围较大的$x_i$特征就会使整个函数的波动更大，在等高线图上表现出来就是$x_i$越大$\theta_i$会显得越加扁平，会造成其他维度的更新较为缓慢。<strong>这样即造成迭代过程中很多轮次实际上是为了消除特征尺度上的不一致，</strong>故而增加了迭代的轮次，收敛速度变慢。<br><img src="\mlimg\equalheight1.png" alt=""></p><p>如果各个维度取值范围接近，那么在等高线图上看起来就会显得很均匀，比如二维平面上就是一个圆，三维平面上就是一个球。<br><img src="\mlimg\equalheight2.png" alt=""></p><p>明显从图中发现，越均匀就会减少很多”绕路”的更新，更直接的接近最小值。</p><p>特征放缩的方法有很多，最常用的是如下：<br>$x’ = \frac{x - \mu}{s}$，其中$s = max - min$，又称为标准差。<br>还有其他很多不同的方法，这里不赘述。</p><h1 id="多项式回归"><a href="#多项式回归" class="headerlink" title="多项式回归"></a>多项式回归</h1><p>多项式回归很简单，只需要把上述的多变量形式里面的$x_i$换成对应的幂次就行了。这个过程中要特别注意特征放缩的问题，因为多项式拟合里出现了幂次，很容易就使得某个原来$x$的取值范围变得很大。</p><h1 id="正规方程"><a href="#正规方程" class="headerlink" title="正规方程"></a>正规方程</h1><p>求解正规方程是不是就是最小二乘法的过程啊。。。</p><p>假设方程一共$n + 1$个特征，我们把每个训练的样本看作一个向量：<br>$x_i =<br>\left[<br>  \begin{matrix}<br>  x_i^{(0)}\\<br>  x_i^{(1)}\\<br>  x_i^{(2)}\\<br>  .\\<br>  .\\<br>  .\\<br>  x_i^{(n)}<br>  \end{matrix}<br>\right]<br>$ </p><p>我们就可以构造$X、y$矩阵:<br>$X =<br>\left[<br>  \begin{matrix}<br>  x_1\\<br>  x_2\\<br>  x_3\\<br>  .\\<br>  .\\<br>  .\\<br>  x_n<br>  \end{matrix}<br>\right]<br>$</p><p>$y =<br>\left[<br>  \begin{matrix}<br>  y_1\\<br>  y_2\\<br>  y_3\\<br>  .\\<br>  .\\<br>  .\\<br>  y_n<br>  \end{matrix}<br>\right]<br>$<br>最优化参数$\theta$矩阵就满足如下式子：<br>$\theta = (X^TX)^{-1}X^Ty$<br>这式子就跟最小二乘推导出的东西一毛一样嘛（应该说的就是一个东西）</p><p>关于梯度下降法和正规方程法的对比如下：<br><img src="/mlimg/comparegdandne.png" alt=""></p><h1 id="正规方程不可逆"><a href="#正规方程不可逆" class="headerlink" title="正规方程不可逆"></a>正规方程不可逆</h1><p>从上面式子看到，如果想要能求出正确结果，需要满足$X^TX$是可逆的，事实上可能会存在一些情况导致其不可逆，原因可能如下：</p><ul><li>特征太多，样本太少</li><li>特征之间不是独立关系</li></ul><p>第一点说的就是矩阵的秩太小，达不到满秩，自然就不可逆。<br>第二点说的是各个向量不是线性无关的，所以本质上秩在经过行列变换后会变小，达不到满秩。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;多功能&quot;&gt;&lt;a href=&quot;#多功能&quot; class=&quot;headerlink&quot; title=&quot;多功能&quot;&gt;&lt;/a&gt;多功能&lt;/h1&gt;&lt;h2 id=&quot;一些定义&quot;&gt;&lt;a href=&quot;#一些定义&quot; class=&quot;headerlink&quot; title=&quot;一些定义&quot;&gt;&lt;/a&gt;一些定
      
    
    </summary>
    
      <category term="机器学习" scheme="http://yoursite.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>单变量线性回归</title>
    <link href="http://yoursite.com/2020/06/08/%E5%8D%95%E5%8F%98%E9%87%8F%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/"/>
    <id>http://yoursite.com/2020/06/08/单变量线性回归/</id>
    <published>2020-06-08T02:31:51.000Z</published>
    <updated>2020-06-09T04:00:32.908Z</updated>
    
    <content type="html"><![CDATA[<h1 id="模型描述"><a href="#模型描述" class="headerlink" title="模型描述"></a>模型描述</h1><p>$y = \theta_0  +  \theta_1x$</p><h1 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h1><ul><li>$(x^{(i)}, y^{(i)})$表示训练集中第i对样本</li><li>$J(\theta_1, \theta_2  )$ $=$ $\frac{1}{2m}\sum_{i = 1}^m(h(x^{(i)})  - y^{(i)})^2$</li></ul><h1 id="梯度下降法"><a href="#梯度下降法" class="headerlink" title="梯度下降法"></a>梯度下降法</h1><ul><li>$\theta_i$ = $\theta_i$ - $\alpha \frac{\partial J(\theta_1, \theta_2)}{\theta_i}$，其中$\alpha$代表学习率</li></ul><p>其实根据高等数学知识可知，求偏导可以相当于把整个函数看作一元函数，我们已知一元导数表示在该点$x$增大，$y$增大的趋势。如果$x$增大$y$也增大，那么我们希望$x$减小，否则希望$x$增大，所以可以发现上面梯度下降的减号是很有道理的。<br>对于每一个变量我们都按上述操作进行更新，最后函数$J$就能往最小值逼近。</p><ul><li>梯度下降虽然是每次更新是让各个参数向着函数值减少值方向在变化，但并不一定是让各个参数一直在向最优的结果变化，举个例子：<br>$y = \theta_0  +  \theta_1x$<br>假设对于某个时刻，$\theta_1$很小，$\theta_0$很大，此时$loss$ $function$也很大，求导后发现$\theta_1$会继续减小，但实际上最优的情况比当前$\theta_1$要大。<br>但这并不影响什么，实际上只要迭代次数足够多，最后一定会绕回到非常靠近最优解的位置。</li></ul><p>附上一个小的test，拟合一条直线，数据随缘取的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">x = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">y = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>]</span><br><span class="line"></span><br><span class="line">w = [<span class="number">1000000</span>, <span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">lr = <span class="number">0.001</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1000000</span>):</span><br><span class="line">    k_sum = <span class="number">0</span></span><br><span class="line">    b_sum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(min(len(x), len(y))):</span><br><span class="line">        k_sum += (w[<span class="number">1</span>] * x[j] + w[<span class="number">0</span>] - y[j]) * x[j]</span><br><span class="line">        b_sum += (w[<span class="number">1</span>] * x[j] + w[<span class="number">0</span>] - y[j])</span><br><span class="line"></span><br><span class="line">    k_sum /= <span class="number">10</span></span><br><span class="line">    b_sum /= <span class="number">10</span></span><br><span class="line">    w[<span class="number">0</span>] = w[<span class="number">0</span>] - lr * b_sum</span><br><span class="line">    w[<span class="number">1</span>] = w[<span class="number">1</span>] - lr * k_sum</span><br><span class="line"></span><br><span class="line">print(w[<span class="number">0</span>], w[<span class="number">1</span>])</span><br></pre></td></tr></table></figure><p>最后得到k，b如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">k = <span class="number">1.9999999999994449</span></span><br><span class="line">b = <span class="number">1.0000000000011102</span></span><br></pre></td></tr></table></figure></p><p>发现非常接近准确值$y = 2x + 1$</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;模型描述&quot;&gt;&lt;a href=&quot;#模型描述&quot; class=&quot;headerlink&quot; title=&quot;模型描述&quot;&gt;&lt;/a&gt;模型描述&lt;/h1&gt;&lt;p&gt;$y = \theta_0  +  \theta_1x$&lt;/p&gt;
&lt;h1 id=&quot;损失函数&quot;&gt;&lt;a href=&quot;#损失函数&quot;
      
    
    </summary>
    
      <category term="机器学习" scheme="http://yoursite.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>初始机器学习</title>
    <link href="http://yoursite.com/2020/06/06/%E5%88%9D%E5%A7%8B%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    <id>http://yoursite.com/2020/06/06/初始机器学习/</id>
    <published>2020-06-06T01:54:32.000Z</published>
    <updated>2020-06-09T04:02:23.613Z</updated>
    
    <content type="html"><![CDATA[<h1 id="监督学习"><a href="#监督学习" class="headerlink" title="监督学习"></a>监督学习</h1><p>这一章好像没啥内容，主要是区分几个概念。</p><h2 id="监督学习-1"><a href="#监督学习-1" class="headerlink" title="监督学习"></a>监督学习</h2><p>利用一组已知类别的样本调整分类器的参数，使其达到所要求性能的过程</p><h2 id="分类问题与回归问题"><a href="#分类问题与回归问题" class="headerlink" title="分类问题与回归问题"></a>分类问题与回归问题</h2><p>由字面意思可得，分类问题解决的是把目标归属到某个类别当中，而回归问题解决的是通过一系列相关因素预测目标的一个值。</p><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><ul><li>分类问题的目标值是离散的，回归是连续的</li><li>二者$loss$ $function$函数性质不同，回归问题$loss$函数输出空间是度量空间，即可以”定量”，而分类问题$loss$函数输出空间不是度量空间，即只有正确和错误之分，只能”定性”</li></ul><h1 id="无监督学习"><a href="#无监督学习" class="headerlink" title="无监督学习"></a>无监督学习</h1><h2 id="无监督学习-1"><a href="#无监督学习-1" class="headerlink" title="无监督学习"></a>无监督学习</h2><p>根据类别未知(没有被标记)的训练样本解决模式识别中的各种问题</p><h2 id="无监督学习与有监督学习区别"><a href="#无监督学习与有监督学习区别" class="headerlink" title="无监督学习与有监督学习区别"></a>无监督学习与有监督学习区别</h2><ul><li>有监督学习有$y$，而无监督学习无$y$<br>上述说法只是表面现象，但感觉没有直击本质。搜集资料时看到一位网友的总结：标签$y$其实是一种施加于对$x$进行压缩过程中的约束。这就是有监督学习。换句话说，机器学习本质上是一种数据的压缩，有监督学习给了这种压缩一个约束，而无监督学习是让机器自己对数据进行重建，如下图：<br><img src="/mlimg/compare_superandunsuper.png" alt=""></li></ul><p>让我们来举两个例子：</p><ul><li>根据患者各方面情况判断是否得了某种病 有监督学习</li><li>根据新闻内容，内容相近的归为一个专题 无监督学习</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;监督学习&quot;&gt;&lt;a href=&quot;#监督学习&quot; class=&quot;headerlink&quot; title=&quot;监督学习&quot;&gt;&lt;/a&gt;监督学习&lt;/h1&gt;&lt;p&gt;这一章好像没啥内容，主要是区分几个概念。&lt;/p&gt;
&lt;h2 id=&quot;监督学习-1&quot;&gt;&lt;a href=&quot;#监督学习-1&quot; cla
      
    
    </summary>
    
      <category term="机器学习" scheme="http://yoursite.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>多项式，永远滴神</title>
    <link href="http://yoursite.com/2020/04/27/%E5%A4%9A%E9%A1%B9%E5%BC%8F%EF%BC%8C%E6%B0%B8%E8%BF%9C%E6%BB%B4%E7%A5%9E/"/>
    <id>http://yoursite.com/2020/04/27/多项式，永远滴神/</id>
    <published>2020-04-27T13:15:48.000Z</published>
    <updated>2020-04-27T15:42:15.173Z</updated>
    
    <content type="html"><![CDATA[<h1 id="FFT"><a href="#FFT" class="headerlink" title="FFT"></a>FFT</h1><p>先咕</p><h1 id="NTT"><a href="#NTT" class="headerlink" title="NTT"></a>NTT</h1><p>先咕</p><h1 id="FWT"><a href="#FWT" class="headerlink" title="FWT"></a>FWT</h1><p>FWT是解决形如<script type="math/tex">C_k = \sum_{i \ op \ j}A_i * B_j</script>，其中op可以是$\&amp;  | \bigoplus$等操作，普通方法肯定是$O(n^2)$的，考虑$FFT$是做了一种变化，然后变化后进行点乘，再逆变化回去，就可以把复杂度优化到$O(nlogn)$，$FWT$能不能采取类似的思路呢？答案是肯定的。<br>我们需要构造$FWT(A)$，使得$FWT(A  op  B) = FWT(A) * FWT(B)$<br>仔细观察，发现这个东西满足交换律：$FWT(A | B) = FWT(B | A)$<br>再观察，发现这玩意还满足结合律：$FWT((A + B) | C) = FWT(A | C) + FWT(B | C)$<br>我们对于一个多项式$A$，定义$A_0，A_1$，分别表示前一半和后一半多项式（二进制最高位为0和为1）。</p><h2 id="or"><a href="#or" class="headerlink" title="or"></a>or</h2><p>$FWT(A) = (FWT(A_0), FWT(A_0 + A_1))$<br>你问括号里的加法是什么意思？就是可以把他们看成一个维度相同的向量，对应位置相加。<br>你问括号里一个逗号什么意思，就是两个多项式拼起来。前面是前一半的结果，后面是后一半的结果。</p><p>考虑正确性，因为是或运算，FWT其实求的就是子集的前缀和（所有子集的和），首先前一半系数必然最高位都为0，所以只能是由$A_0$里面来产生的贡献。考虑后面，因为最高位必须为1，所以一部分贡献来自最高位为1的，同时考虑某个位置去掉最高位的1，会对应$A_0$中的某个位置，这部分贡献也会被包含，所以最终贡献就是$A_0 + A_1$<br>然后我们就可以递归去做求的$or的FWT$了（事实上实现的时候我们采用循环）</p><p>考虑怎么反变换回来，其实很简单$IFWT(A) = (IFWT(A_0)，IFWT(A_1 - A_0))$</p><h2 id="and"><a href="#and" class="headerlink" title="and"></a>and</h2><p>and刚好是跟or反过来的，or的$FWT$表示的是某个集合所有的子集的和，而and的$FWT$是表示的某个集合所有包含它的集合的和，相当于可以描述为后缀和？那么它的$FWT$我们考虑表示$FWT(A) = FWT(FWT(A_0 + A_1), FWT(A_1))$。</p><p>考虑正确性证明，首先后一半的贡献必须全来自$A_1$，前一半$A_0$会产生贡献，$A_0$每一项加上最高位对应$A_1$中的每一项也会产生贡献，所以就是$A_0 + A_1$</p><p>对应反变换也很好写$IFWT(A) = (IFWT(A_0 + A_1)，IFWT(A_1))$</p><h2 id="xor"><a href="#xor" class="headerlink" title="xor"></a>xor</h2><p>异或的构造是最难的，也是唯一没法从$FMT$角度解释的一个，可以说是真正的$FWT$。<br>这里给出构造$FWT(A) = (FWT(A_0 + A_1), FWT(A_0 - A_1))$</p><p>给出正确性证明：<br>$= FWT((A_0 \bigoplus B_0) + FWT(A_1 \bigoplus B_1), FWT(A_0 \bigoplus B_1) + FWT(A_1 \bigoplus B_0))$</p><script type="math/tex; mode=display">= (FWT(A_0 \bigoplus B_0 + A_1 \bigoplus B_1 + A_1 \bigoplus B_0 + A_0 \bigoplus B_1),</script><script type="math/tex; mode=display">FWT(A_0 \bigoplus B_0 + A_1 \bigoplus B_1 - A_1 \bigoplus B_0 - A_0 \bigoplus B_1))</script><script type="math/tex; mode=display">= ((FWT(A_0) + FWT(A_1)) * (FWT(B_0) + FWT(B_1)),</script><script type="math/tex; mode=display">(FWT(A_0) - FWT(A_1)) * (FWT(B_0) - FWT(B_1)))</script><script type="math/tex; mode=display">= (FWT(A_0 + A_1) * FWT(B_0 + B_1),</script><script type="math/tex; mode=display">FWT(A_0 - A_1) * FWT(B_0 - B_1))</script><script type="math/tex; mode=display">= (FWT(A_0 + A_1), FWT(A_0 - A_1)) * (FWT(B_0 + B_1),</script><script type="math/tex; mode=display">FWT(B_0 - B_1)) = FWT(A) * FWT(B)</script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;FFT&quot;&gt;&lt;a href=&quot;#FFT&quot; class=&quot;headerlink&quot; title=&quot;FFT&quot;&gt;&lt;/a&gt;FFT&lt;/h1&gt;&lt;p&gt;先咕&lt;/p&gt;
&lt;h1 id=&quot;NTT&quot;&gt;&lt;a href=&quot;#NTT&quot; class=&quot;headerlink&quot; title=&quot;NTT&quot;&gt;
      
    
    </summary>
    
      <category term="多项式" scheme="http://yoursite.com/categories/%E5%A4%9A%E9%A1%B9%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>论一类x次方计数问题的求解</title>
    <link href="http://yoursite.com/2020/04/09/%E8%AE%BA%E4%B8%80%E7%B1%BBx%E6%AC%A1%E6%96%B9%E8%AE%A1%E6%95%B0%E9%97%AE%E9%A2%98%E7%9A%84%E6%B1%82%E8%A7%A3/"/>
    <id>http://yoursite.com/2020/04/09/论一类x次方计数问题的求解/</id>
    <published>2020-04-09T03:56:46.000Z</published>
    <updated>2020-04-09T10:11:23.105Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文主要探究总结一类问题：统计某种情况下某个东西出现次数的x次方的问题的求解。</p><h1 id="一次方"><a href="#一次方" class="headerlink" title="一次方"></a>一次方</h1><p>我们先看一看一次方的情况我们一般怎么思考问题：</p><h2 id="CCPC-Wannafly-Winter-Camp-Day8-Div2-穗乃果的考试"><a href="#CCPC-Wannafly-Winter-Camp-Day8-Div2-穗乃果的考试" class="headerlink" title="CCPC-Wannafly Winter Camp Day8 Div2 穗乃果的考试"></a><a href="https://www.cometoj.com/contest/31/problem/G?problem_id=440" target="_blank" rel="noopener">CCPC-Wannafly Winter Camp Day8 Div2 穗乃果的考试</a></h2><p><strong>询问一个01矩形中，所有子矩形包含1的个数的总和。</strong><br>枚举子矩形需要一个左上角和一个右下角，发现复杂度非常高，故而不能直接枚举矩形。<br>考虑答案 = $\sum_{子矩形x}\sum a_{ij}$<br>我们变换求和顺序:$\sum_{原矩形中每一个元素a_{ij}且a_{ij} == 1}\sum_{子矩形x}[x包含a_{ij}]$<br>应该不难证明二者是等价的，我们发现枚举$a_{ij}$ 我们是可以接受的，且算有多少子矩形包含$a_{ij}$是非常容易的一件事情，那么问题就做完了。</p><p>一次好像非常显然，但是这只是给你开心开心的。</p><a id="more"></a><h1 id="2次方"><a href="#2次方" class="headerlink" title="2次方"></a>2次方</h1><p>还是先引入一个题目：</p><h2 id="CCPC-Wannafly-Winter-Camp-Day8-Div1-穗乃果的考试"><a href="#CCPC-Wannafly-Winter-Camp-Day8-Div1-穗乃果的考试" class="headerlink" title="CCPC-Wannafly Winter Camp Day8 Div1 穗乃果的考试"></a><a href="https://www.cometoj.com/contest/30/problem/G?problem_id=430" target="_blank" rel="noopener">CCPC-Wannafly Winter Camp Day8 Div1 穗乃果的考试</a></h2><p><strong>我家果果是真的喜欢组合数学啊，还都是这么难的</strong><br>发现跟上一题的变化就是1次变为了2次，但是一下子就难了不少呢。<br>我们还是冷静分析一波：<br>答案 = $\sum_{子矩形x}\sum^2_{a_{ij}}a_{ij}$<br>展开看一看：$\sum_{子矩形x}(a_n + a_{n + 1} + … + a_{m})(a_n + a_{n + 1} + … + a_{m})$<br>PS：$(a_n + a_{n + 1} + …. + a_{m})$指的是$子矩形x$中所有的元素。<br>还是变换求和顺序，我们看之前一次的时候，我们是从所有$a_{ij} == 1$中选一个出来，看有多少子矩形包含$a_{ij}$，本质是从后面每一个可能对答案产生贡献的项拿出来，看有多少情况包含它。<br>我们看二次的后面的项：$(a_n + a_{n + 1} + … + a_{m})(a_n + a_{n + 1} + … + a_{m})$，把乘法展开，相当于枚举每一个不为0的项，然后看有多少子矩形包含这两项。<br>那么答案 = $\sum_{(x = a_{ij}) == 1}\sum_{(y = a_{ij}) == 1} 包含x和y两个点的子矩形的数目$<br>然后枚举一个点，另一个点分为四个方向，前缀和维护一下就做完了。</p><div><div class="fold_hider"><div class="close hider_title">代码</div></div><div class="fold"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> db;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vi;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;ll&gt; vl;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;pii&gt; vp;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">const</span> ll INF = <span class="number">1e18</span>;</span><br><span class="line"><span class="keyword">const</span> db eps = <span class="number">1e-10</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> eb emplace_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ep emplace</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mem(a) memset(a, 0, sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> copy(a, b) memcpy(a, b, sizeof(b))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PA cout &lt;&lt; <span class="meta-string">"pass\n"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lowbit(x) (x &amp; -x)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(x) x.begin(), x.end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TM cout &lt;&lt; db(clock()) / CLOCKS_PER_SEC &lt;&lt; <span class="meta-string">'\n'</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">mt19937 <span class="title">mrand</span><span class="params">(chrono::high_resolution_clock::now().time_since_epoch().count())</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;<span class="title">inline</span> <span class="title">void</span> <span class="title">upmin</span>(<span class="title">T</span> &amp;<span class="title">x</span>, <span class="title">T</span> <span class="title">y</span>) &#123;</span>x = x &gt; y ? y : x;&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;<span class="title">inline</span> <span class="title">void</span> <span class="title">upmax</span>(<span class="title">T</span> &amp;<span class="title">x</span>, <span class="title">T</span> <span class="title">y</span>) &#123;</span>x = x &lt; y ? y : x;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2020</span>;</span><br><span class="line"><span class="keyword">char</span> s[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    x += y;</span><br><span class="line">    <span class="keyword">if</span>(x &gt;= mod) x -= mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sub</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    x -= y;</span><br><span class="line">    <span class="keyword">if</span>(x &lt; <span class="number">0</span>) x += mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> s3[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> s4[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> c1[maxn][maxn], c2[maxn][maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s[i] + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i][j] == <span class="string">'1'</span>)&#123;</span><br><span class="line">                add(s3[i][j], <span class="number">1l</span>l * i * j % mod);</span><br><span class="line">                add(s4[i][j], <span class="number">1l</span>l * i * (m - j + <span class="number">1</span>) % mod);</span><br><span class="line">                add(c1[i][j], <span class="number">1</span>);</span><br><span class="line">                add(c2[i][j], <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            add(s3[i][j], s3[i - <span class="number">1</span>][j]);</span><br><span class="line">            add(s3[i][j], s3[i][j - <span class="number">1</span>]);</span><br><span class="line">            sub(s3[i][j], s3[i - <span class="number">1</span>][j - <span class="number">1</span>]);</span><br><span class="line">            add(c1[i][j], c1[i - <span class="number">1</span>][j]);</span><br><span class="line">            add(c1[i][j], c1[i][j - <span class="number">1</span>]);</span><br><span class="line">            sub(c1[i][j], c1[i - <span class="number">1</span>][j - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = m; j; j--)&#123;</span><br><span class="line">            add(s4[i][j], s4[i - <span class="number">1</span>][j]);</span><br><span class="line">            add(s4[i][j], s4[i][j + <span class="number">1</span>]);</span><br><span class="line">            sub(s4[i][j], s4[i - <span class="number">1</span>][j + <span class="number">1</span>]);</span><br><span class="line">            add(c2[i][j], c2[i - <span class="number">1</span>][j]);</span><br><span class="line">            add(c2[i][j], c2[i][j + <span class="number">1</span>]);</span><br><span class="line">            sub(c2[i][j], c2[i - <span class="number">1</span>][j + <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i][j] == <span class="string">'0'</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> a = n - i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> b = m - j + <span class="number">1</span>;</span><br><span class="line">            add(res, <span class="number">1l</span>l * a * b % mod * s3[i - <span class="number">1</span>][j - <span class="number">1</span>] % mod);</span><br><span class="line">            b = j;</span><br><span class="line">            add(res, <span class="number">1l</span>l * a * b % mod * s4[i - <span class="number">1</span>][j + <span class="number">1</span>] % mod);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    add(res, res);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> pre = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i][j] == <span class="string">'0'</span>) <span class="keyword">continue</span>;</span><br><span class="line">            add(tmp, <span class="number">1l</span>l * (m - j + <span class="number">1</span>) * pre % mod);</span><br><span class="line">            add(pre, j);</span><br><span class="line">        &#125;</span><br><span class="line">        tmp = <span class="number">2l</span>l * tmp * i % mod * (n - i + <span class="number">1</span>) % mod;</span><br><span class="line">        add(res, tmp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)&#123;</span><br><span class="line">        <span class="keyword">int</span> pre = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i][j] == <span class="string">'0'</span>) <span class="keyword">continue</span>;</span><br><span class="line">            add(tmp, <span class="number">1l</span>l * (n - i + <span class="number">1</span>) * pre % mod);</span><br><span class="line">            add(pre, i);</span><br><span class="line">        &#125;</span><br><span class="line">        tmp = <span class="number">2l</span>l * tmp * j % mod * (m - j + <span class="number">1</span>) % mod;</span><br><span class="line">        add(res, tmp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i][j] == <span class="string">'1'</span>) add(res, <span class="number">1l</span>l * (n - i + <span class="number">1</span>) * i % mod * (m - j + <span class="number">1</span>) % mod * j % mod);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><h1 id="x次方"><a href="#x次方" class="headerlink" title="x次方"></a>x次方</h1><p>根据上面的做法我们可以看出，对于求某种情况下某个东西x次方的贡献，我们把符合条件的点提出来变成一个序列，然后复制x次，问题就变成了这x个序列每个选1个，然后求同时包含这x个的情况一共有多少种。</p><p>再来看一个稍微硬核一点的题</p><h2 id="Asia-Beijing-Regional-2014-F-Fluorescent"><a href="#Asia-Beijing-Regional-2014-F-Fluorescent" class="headerlink" title="Asia-Beijing Regional 2014 - F(Fluorescent)"></a><a href="http://opentrains.snarknews.info/~ejudge/team.cgi?SID=0ff216405c1f68d0&amp;action=2" target="_blank" rel="noopener">Asia-Beijing Regional 2014 - F(Fluorescent)</a></h2><p><strong>给定n栈灯，m个开关（n &lt;= 50, m &lt;= 50），每个开关连接一系列灯，并且能把这一系列灯的状态同时翻转，问所有情况下亮着灯数目三次方的期望是多少</strong></p><p>考虑答案 = $\sum_{情况x}(a_1 + a_2 + … + a_n)^3$<br>考虑变换求和顺序：对$(a_1 + a_2 + … + a_n)^3$中的每一组不为0的项，求有多少方案使得这三个位置最后都是亮着的。</p><p>这样我们就可以枚举三个位置，然后用状压dp求解了，最后求和就行了。</p><div><div class="fold_hider"><div class="close hider_title">代码</div></div><div class="fold"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> db;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vi;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;ll&gt; vl;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;pii&gt; vp;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">const</span> ll INF = <span class="number">1e18</span>;</span><br><span class="line"><span class="keyword">const</span> db eps = <span class="number">1e-10</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> eb emplace_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ep emplace</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mem(a) memset(a, 0, sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> copy(a, b) memcpy(a, b, sizeof(b))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PA cout &lt;&lt; <span class="meta-string">"pass\n"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lowbit(x) (x &amp; -x)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(x) x.begin(), x.end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TM cout &lt;&lt; db(clock()) / CLOCKS_PER_SEC &lt;&lt; <span class="meta-string">'\n'</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">mt19937 <span class="title">mrand</span><span class="params">(chrono::high_resolution_clock::now().time_since_epoch().count())</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;<span class="title">inline</span> <span class="title">void</span> <span class="title">upmin</span>(<span class="title">T</span> &amp;<span class="title">x</span>, <span class="title">T</span> <span class="title">y</span>) &#123;</span>x = x &gt; y ? y : x;&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;<span class="title">inline</span> <span class="title">void</span> <span class="title">upmax</span>(<span class="title">T</span> &amp;<span class="title">x</span>, <span class="title">T</span> <span class="title">y</span>) &#123;</span>x = x &lt; y ? y : x;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T;</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">55</span>][<span class="number">8</span>];</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">bool</span> vis[<span class="number">55</span>][<span class="number">55</span>];</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    x += y;</span><br><span class="line">    <span class="keyword">if</span>(x &gt;= mod) x -= mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>), <span class="built_in">cin</span>.tie(<span class="number">0</span>), <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; fixed &lt;&lt; setprecision(<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> kase = <span class="number">1</span>; kase &lt;= T; kase++)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">        mem(vis);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> len;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; len;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= len; j++)&#123;</span><br><span class="line">                <span class="keyword">int</span> x;</span><br><span class="line">                <span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">                vis[i][x] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; k++)&#123;</span><br><span class="line">                    mem(dp);</span><br><span class="line">                    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> p = <span class="number">1</span>; p &lt;= m; p++)&#123;</span><br><span class="line">                        <span class="keyword">int</span> t1 = <span class="number">0</span>, t2 = <span class="number">0</span>, t3 = <span class="number">0</span>;</span><br><span class="line">                        <span class="keyword">if</span>(vis[p][i]) t1 = <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">if</span>(vis[p][j]) t2 = <span class="number">2</span>;</span><br><span class="line">                        <span class="keyword">if</span>(vis[p][k]) t3 = <span class="number">4</span>;</span><br><span class="line">                        <span class="keyword">for</span>(<span class="keyword">int</span> mask = <span class="number">0</span>; mask &lt; <span class="number">8</span>; mask++)&#123;</span><br><span class="line">                            add(dp[p][mask ^ t1 ^ t2 ^ t3], dp[p - <span class="number">1</span>][mask]);</span><br><span class="line">                            add(dp[p][mask], dp[p - <span class="number">1</span>][mask]);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    add(res, dp[m][<span class="number">7</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Case #"</span> &lt;&lt; kase &lt;&lt; <span class="string">": "</span> &lt;&lt; res &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><p>再来个最难的</p><h2 id="2018-2019-ACM-ICPC-Asia-Xuzhou-Regional-Contest-D-Rikka-with-Subsequences"><a href="#2018-2019-ACM-ICPC-Asia-Xuzhou-Regional-Contest-D-Rikka-with-Subsequences" class="headerlink" title="2018-2019 ACM-ICPC, Asia Xuzhou Regional Contest - D(Rikka with Subsequences)"></a><a href="https://codeforces.com/gym/102012/problem/D" target="_blank" rel="noopener">2018-2019 ACM-ICPC, Asia Xuzhou Regional Contest - D(Rikka with Subsequences)</a></h2><p><strong>给定一种”好子序列”的定义，求所有本质相同好子序列个数三次方的和</strong></p><p>直接考虑问题转换，既然是求本质相同的好子序列出现次数三次方的和，我们可以等价于求把原序列复制三份，在三份上各取一个子序列，且子序列相同的情况数。</p><p>考虑$dp[i][j][k]$为第一个好子序列最后为$i$结尾，第二个好子序列最后以$j$结尾，第三个好子序列最后以$k$结尾。考虑转移，对于某一个$dp[i][j][k]$，我们找前面有多少$dp[i’][j’][k’]$ $(i’ &lt; i, j’ &lt; j, k’ &lt; k)$，但由于还有好子序列的限制，所以我们要找到所有$a[i’] = a[i]$的点，剩下的就是找$j’$, $k’$，这相当于是个二位前缀和（因为只用限制一个点，剩下$a[j]$，$a[k]$，$a[j’]$，$a[k’]$必然相等。）也就是对于每个$i$，我们对所有满足$a[j] = a[i]$的$j$，$k$求一次前缀和，然后加速转移，同时在这里统计方案即可。</p><div><div class="fold_hider"><div class="close hider_title">代码</div></div><div class="fold"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> db;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vi;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;ll&gt; vl;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;pii&gt; vp;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">const</span> ll INF = <span class="number">1e18</span>;</span><br><span class="line"><span class="keyword">const</span> db eps = <span class="number">1e-10</span>;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> eb emplace_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ep emplace</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mem(a) memset(a, 0, sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> copy(a, b) memcpy(a, b, sizeof(b))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PA cout &lt;&lt; <span class="meta-string">"pass\n"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lowbit(x) (x &amp; -x)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(x) x.begin(), x.end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TM cout &lt;&lt; db(clock()) / CLOCKS_PER_SEC &lt;&lt; <span class="meta-string">'\n'</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function">mt19937 <span class="title">mrand</span><span class="params">(chrono::high_resolution_clock::now().time_since_epoch().count())</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;<span class="title">inline</span> <span class="title">void</span> <span class="title">upmin</span>(<span class="title">T</span> &amp;<span class="title">x</span>, <span class="title">T</span> <span class="title">y</span>) &#123;</span>x = x &gt; y ? y : x;&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;<span class="title">inline</span> <span class="title">void</span> <span class="title">upmax</span>(<span class="title">T</span> &amp;<span class="title">x</span>, <span class="title">T</span> <span class="title">y</span>) &#123;</span>x = x &lt; y ? y : x;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> n, T;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">220</span>;</span><br><span class="line"><span class="keyword">int</span> dp[maxn][maxn], sum[maxn][maxn];</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    x += y;</span><br><span class="line">    <span class="keyword">if</span>(x &gt;= mod) x -= mod;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sub</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    x -= y;</span><br><span class="line">    <span class="keyword">if</span>(x &lt; <span class="number">0</span>) x += mod;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">char</span> s[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> a[maxn];</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= n; j++)&#123;</span><br><span class="line">                dp[i][j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s[i] + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; k++)&#123;</span><br><span class="line">                    sum[j][k] = s[a[j]][a[i]] == <span class="string">'1'</span> ? dp[j][k] : <span class="number">0</span>;</span><br><span class="line">                    add(sum[j][k], sum[j - <span class="number">1</span>][k]);</span><br><span class="line">                    add(sum[j][k], sum[j][k - <span class="number">1</span>]);</span><br><span class="line">                    sub(sum[j][k], sum[j - <span class="number">1</span>][k - <span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; k++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(a[i] == a[j] &amp;&amp; a[j] == a[k])&#123;</span><br><span class="line">                        <span class="keyword">int</span> tmp = <span class="number">1</span>;</span><br><span class="line">                        add(tmp, sum[j - <span class="number">1</span>][k - <span class="number">1</span>]);</span><br><span class="line">                        add(res, tmp);</span><br><span class="line">                        add(dp[j][k], tmp);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>对于统计中$x$次方求和的问题，转换为把原来的东西复制$x$次，每个里面选一种方案，求原来有多少方案能使这$x$个方案同时满足。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;本文主要探究总结一类问题：统计某种情况下某个东西出现次数的x次方的问题的求解。&lt;/p&gt;
&lt;h1 id=&quot;一次方&quot;&gt;&lt;a href=&quot;#一次方&quot; class=&quot;headerlink&quot; title=&quot;一次方&quot;&gt;&lt;/a&gt;一次方&lt;/h1&gt;&lt;p&gt;我们先看一看一次方的情况我们一般怎么思考问题：&lt;/p&gt;
&lt;h2 id=&quot;CCPC-Wannafly-Winter-Camp-Day8-Div2-穗乃果的考试&quot;&gt;&lt;a href=&quot;#CCPC-Wannafly-Winter-Camp-Day8-Div2-穗乃果的考试&quot; class=&quot;headerlink&quot; title=&quot;CCPC-Wannafly Winter Camp Day8 Div2 穗乃果的考试&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://www.cometoj.com/contest/31/problem/G?problem_id=440&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;CCPC-Wannafly Winter Camp Day8 Div2 穗乃果的考试&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;询问一个01矩形中，所有子矩形包含1的个数的总和。&lt;/strong&gt;&lt;br&gt;枚举子矩形需要一个左上角和一个右下角，发现复杂度非常高，故而不能直接枚举矩形。&lt;br&gt;考虑答案 = $\sum_{子矩形x}\sum a_{ij}$&lt;br&gt;我们变换求和顺序:$\sum_{原矩形中每一个元素a_{ij}且a_{ij} == 1}\sum_{子矩形x}[x包含a_{ij}]$&lt;br&gt;应该不难证明二者是等价的，我们发现枚举$a_{ij}$ 我们是可以接受的，且算有多少子矩形包含$a_{ij}$是非常容易的一件事情，那么问题就做完了。&lt;/p&gt;
&lt;p&gt;一次好像非常显然，但是这只是给你开心开心的。&lt;/p&gt;
    
    </summary>
    
      <category term="组合数学" scheme="http://yoursite.com/categories/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"/>
    
    
  </entry>
  
  <entry>
    <title>CNN学习笔记</title>
    <link href="http://yoursite.com/2020/04/05/CNN%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2020/04/05/CNN学习笔记/</id>
    <published>2020-04-05T03:41:51.000Z</published>
    <updated>2020-04-05T13:31:23.290Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CNN整体结构"><a href="#CNN整体结构" class="headerlink" title="CNN整体结构"></a>CNN整体结构</h1><p>之前学习了全连接层，我们先再看看全连接层的结构：<br><img src="/mlimg/AffineStruct.png" alt=""><br>简单总结一下，我们发现就是由一堆 <strong>输入 -&gt; Affine层 -&gt; 激活函数</strong> 组成的。<br>再来康康CNN的结构：<br><img src="/mlimg/CNNStruct.png" alt=""><br>我们发现前面的Affine层换成了Conv（卷积）层，并且多加入了一个Pooling（池化）层。当然最后还是保留了部分Affine层。</p><h1 id="卷积层"><a href="#卷积层" class="headerlink" title="卷积层"></a>卷积层</h1><h2 id="为什么要引入卷积层"><a href="#为什么要引入卷积层" class="headerlink" title="为什么要引入卷积层"></a>为什么要引入卷积层</h2><p>考虑引入卷积层，必然是以前的全连接层存在某些问题。首先，全连接层的运算量大，因为每两个点都必须有一个权值，所以边数是点数平方级别的。其次，CNN主要针对的是图像问题，在图像中，两个相距较远的像素可以认为是基本无关的，但全连接层中仍会考虑它们，相当于有很多无用的计算量。<br>基于此，我们考虑用卷积层替换全连接层，卷积层就可以改良上述缺点。</p><h2 id="卷积运算"><a href="#卷积运算" class="headerlink" title="卷积运算"></a>卷积运算</h2><p>因为之前学过图想处理，感觉卷积运算理解起来就非常容易。<br><img src="/mlimg/Conv.png" alt=""><br>直接看图吧，相当于就是拿一个窗口在图上滑动，然后对于每一个位置，直接做点积运算，得到的结果放到最终结果的对应位置（如果有偏置的话还要加上偏置的值）。</p><p>当然这只是一维情况，事实上只要不是黑白图片，一般都是三通道的，也就是三维的，那么卷积运算就是三个通道结果相加：<br><img src="/mlimg/3DConv.png" alt=""><br><img src="/mlimg/3DConv2.png" alt=""></p><h2 id="卷积层实现"><a href="#卷积层实现" class="headerlink" title="卷积层实现"></a>卷积层实现</h2><p>这个就比较偏编程技巧了，一般的想法是几层for循环就可以解决，然而这样效率比较慢。我们一般而言是先把数据向量化，也就是展开，也可以称作是降维：<br><img src="/mlimg/ConvProcess.png" alt=""><br>展开对应关系如下图所示：<br><img src="/mlimg/ConvProcess1.png" alt=""><br>同样我们也可以把滤波器的展开，最后发现，我们的卷积运算就可以转换为矩阵乘法了，最后再把结果还原为原来的形状：<br><img src="/mlimg/ConvProcess2.png" alt=""></p><h1 id="池化层"><a href="#池化层" class="headerlink" title="池化层"></a>池化层</h1><h2 id="为什么要引入卷积层-1"><a href="#为什么要引入卷积层-1" class="headerlink" title="为什么要引入卷积层"></a>为什么要引入卷积层</h2><p>池化是缩小高、长方向上的空间的运算。池化层可以增强对微小变化的鲁棒性。</p><h2 id="池化运算"><a href="#池化运算" class="headerlink" title="池化运算"></a>池化运算</h2><p><img src="/mlimg/Pooling.png" alt=""><br>其实跟卷积运算挺类似的，看图就能直接明白了。<br>池化也有很多种，比如Max池化，Average池化等，一般来说Max池化用的比较多。</p><h2 id="池化层实现"><a href="#池化层实现" class="headerlink" title="池化层实现"></a>池化层实现</h2><p>池化层实现思想差不多，先把原来数据展开，进行运算，然后再还原回去：<br><img src="/mlimg/PoolingProcess.png" alt=""><br>具体来说就是把每个滤波器能在的位置展开成一行，然后就可以变成对每一行进行操作，最后挨着还原回去就行了。<br><img src="/mlimg/PoolingProcess.png" alt=""></p><p>接下来去研究下pytorch去了。。。研究完再补。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;CNN整体结构&quot;&gt;&lt;a href=&quot;#CNN整体结构&quot; class=&quot;headerlink&quot; title=&quot;CNN整体结构&quot;&gt;&lt;/a&gt;CNN整体结构&lt;/h1&gt;&lt;p&gt;之前学习了全连接层，我们先再看看全连接层的结构：&lt;br&gt;&lt;img src=&quot;/mlimg/Affin
      
    
    </summary>
    
      <category term="机器学习" scheme="http://yoursite.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>仙人掌 &amp; 圆方树学习笔记</title>
    <link href="http://yoursite.com/2020/04/04/%E4%BB%99%E4%BA%BA%E6%8E%8C-%E5%9C%86%E6%96%B9%E6%A0%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2020/04/04/仙人掌-圆方树学习笔记/</id>
    <published>2020-04-04T15:33:41.000Z</published>
    <updated>2020-04-06T15:41:19.539Z</updated>
    
    <content type="html"><![CDATA[<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><p>你敢信我学完基础的圆方树后理解最深的居然是tarjan？<br>不知道这玩意有啥用，但据说很有用，但好像icpc都不太考这个东西？但感觉这个东西跟什么树问题都能有关系，而且还都是大码量题。。</p><h1 id="仙人掌"><a href="#仙人掌" class="headerlink" title="仙人掌"></a>仙人掌</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>仙人掌是一种特殊的无向图，具有如下性质：<br>1、图是连通的。<br>2、每条边最多属于一个简单环。<br><img src="/images/12.png" alt=""><br>因为有特殊性，所以也就有特殊的方法处理这一类题目。</p><h2 id="仙人掌的dfs生成树"><a href="#仙人掌的dfs生成树" class="headerlink" title="仙人掌的dfs生成树"></a>仙人掌的dfs生成树</h2><p>仙人掌dfs生成树也有着特殊的性质，我们将它的dfs生成树看成一个序列，返祖边看成一个区间，那么所有的区间都是不相交的。这样在用dfs生成树处理仙人掌的时候就能简化很多种复杂的情况。</p><h1 id="圆方树"><a href="#圆方树" class="headerlink" title="圆方树"></a>圆方树</h1><h2 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h2><p>圆方树是用来解决仙人掌问题的一种数据结构。<br>其实圆方树的原理不难想，考虑前面我们说过，仙人掌每条边只属于一个简单环，换言之各个环之间不会嵌套。那么我们在环上考虑问题是比较复杂的，我们喜欢转成树，我们想到给每个环新建一个点，把所有环上的点去掉，并且跟新点相连。这个新点就好像一个中转站一样，巧妙的把环变为了链，把一般图变为了树。树上解决问题，我们可以采用的方法就会更多。</p><p>我们把新建的点叫做方点，原来的点叫做圆点。</p><p>Upd:我发现我好像一直学的是广义圆方树，不过好像它应用更广泛，也可以直接用在仙人掌上。。。。</p><h2 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h2><p>圆方树有很多不错的性质：<br>1、方点和方点之间不会直接相连。<br>2、无论取哪个点为根，圆方树的形态是一样的。<br>3、<script type="math/tex">以r为根的仙人掌上p的子仙人掌就是圆方树中以r为根时，p子树中的所有圆点</script>（还没理解，先嫖着）。<br>4、方点儿子中的相邻的在原图环上也是相邻的（tarjan性质）。</p><a id="more"></a><h2 id="构建方法"><a href="#构建方法" class="headerlink" title="构建方法"></a>构建方法</h2><p>圆方树的构建方法是通过魔改tarjan点双开始的。我们知道点双里面一个点可能属于多个点双，这类点就是割点，所以tarjan的时候我们都是存边，因为每条边只会属于一个连通分量。但这里我们可以存点，需要稍微改一改。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    dfn[u] = low[u] = ++ntime;</span><br><span class="line">    sta[++sz] = u;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[u].size(); i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = G[u][i];</span><br><span class="line">        <span class="keyword">if</span> (!dfn[v]) &#123;</span><br><span class="line">            tarjan(v);</span><br><span class="line">            low[u] = min(low[u], low[v]);</span><br><span class="line">            <span class="keyword">if</span>(low[v] == dfn[u])&#123;</span><br><span class="line">                ++tot;</span><br><span class="line">                g[u].pb(tot);</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">0</span>; x != v; --sz)&#123;</span><br><span class="line">                    x = sta[sz];</span><br><span class="line">                    g[tot].pb(x);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> low[u] = min(low[u], dfn[v]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">find_bcc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sz = <span class="number">0</span>;</span><br><span class="line">        tot = n;</span><br><span class="line">        <span class="built_in">memset</span>(dfn, <span class="number">0</span>, <span class="keyword">sizeof</span>(dfn));</span><br><span class="line">        ntime = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)<span class="keyword">if</span> (!dfn[i])tarjan(i), --sz;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>研究一下，其实反而跟tarjan求强连通分量很像，但是强连通分量是要把$u$一起弹出去，这里构建圆方树时我们只能弹到$v，u$必须继续保留在栈中（因为上层递归回去时我们还需要用$u$来建树）。最后如果图不连通需要把$sz - 1$（顶点没弹出来）（虽然仙人掌是一定连通的，但是有些题可能是多个森林仙人掌）。</p><p>考虑建出来的树，我们就可以利用树的算法完成仙人掌上的问题了，对于环，我们只用找树上方点进行特殊考虑即可。</p><h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><h2 id="求仙人掌的最大独立集"><a href="#求仙人掌的最大独立集" class="headerlink" title="求仙人掌的最大独立集"></a>求仙人掌的最大独立集</h2><p><a href="http://www.lydsy.com/JudgeOnline/problem.php?id=4316" target="_blank" rel="noopener">bzoj-4316</a></p><p>考虑树的最大独立集，$dp[u][0]$表示u点不选，$dp[u][1]$表示$u$点要选，随便dp一下就解决了。对于仙人掌的最大独立集，我们对仙人掌建出圆方树，然后利用树的dp完成，圆点就直接同树的方法进行转移即可，我们需要着重考虑方点的计算方法。<br><img src="/images/13.png" alt=""><br>如图所示，当$x$选的时候，我们发现$u_1$和$u_4$不能选，也就是两端不能选，其它位置变成了序列上不能同时选相邻点的最大权问题（因为每个点所代表的权值是其子树最大的独立集大小）。对于方点，$dp[u][0]$表示它连的两端没有选，$dp[u][1]$表示它连的两端可以选的最大独立集。我们发现把方点问题转换为序列问题，然后再回到树上按照正常树形dp进行转移即可。</p><div><div class="fold_hider"><div class="close hider_title">代码</div></div><div class="fold"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> db;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vi;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;ll&gt; vl;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;pii&gt; vp;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">const</span> ll INF = <span class="number">1e18</span>;</span><br><span class="line"><span class="keyword">const</span> db eps = <span class="number">1e-10</span>;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> eb emplace_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ep emplace</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mem(a) memset(a, 0, sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> copy(a, b) memcpy(a, b, sizeof(b))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PA cout &lt;&lt; <span class="meta-string">"pass\n"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lowbit(x) (x &amp; -x)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(x) x.begin(), x.end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TM cout &lt;&lt; db(clock()) / CLOCKS_PER_SEC &lt;&lt; <span class="meta-string">'\n'</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;<span class="title">inline</span> <span class="title">void</span> <span class="title">upmin</span>(<span class="title">T</span> &amp;<span class="title">x</span>, <span class="title">T</span> <span class="title">y</span>) &#123;</span>x = x &gt; y ? y : x;&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;<span class="title">inline</span> <span class="title">void</span> <span class="title">upmax</span>(<span class="title">T</span> &amp;<span class="title">x</span>, <span class="title">T</span> <span class="title">y</span>) &#123;</span>x = x &lt; y ? y : x;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">233</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> dp1[maxn][<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> dp2[maxn][<span class="number">2</span>];</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Cactus</span> &#123;</span></span><br><span class="line">    vi G[maxn];</span><br><span class="line">    vi g[maxn * <span class="number">2</span>]; <span class="comment">// new Round_Square_Tree</span></span><br><span class="line">    <span class="keyword">int</span> dfn[maxn];</span><br><span class="line">    <span class="keyword">int</span> low[maxn];</span><br><span class="line">    <span class="keyword">int</span> ntime;</span><br><span class="line">    <span class="keyword">int</span> tot;</span><br><span class="line">    <span class="keyword">int</span> sta[maxn];</span><br><span class="line">    <span class="keyword">int</span> sz;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">        dfn[u] = low[u] = ++ntime;</span><br><span class="line">        sta[++sz] = u;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[u].size(); i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = G[u][i];</span><br><span class="line">            <span class="keyword">if</span> (!dfn[v]) &#123;</span><br><span class="line">                tarjan(v);</span><br><span class="line">                low[u] = min(low[u], low[v]);</span><br><span class="line">                <span class="keyword">if</span>(low[v] == dfn[u])&#123;</span><br><span class="line">                    ++tot;</span><br><span class="line">                    g[u].pb(tot);</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">0</span>; x != v; --sz)&#123;</span><br><span class="line">                        x = sta[sz];</span><br><span class="line">                        g[tot].pb(x);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> low[u] = min(low[u], dfn[v]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">find_bcc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sz = <span class="number">0</span>;</span><br><span class="line">        tot = n;</span><br><span class="line">        <span class="built_in">memset</span>(dfn, <span class="number">0</span>, <span class="keyword">sizeof</span>(dfn));</span><br><span class="line">        ntime = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)<span class="keyword">if</span> (!dfn[i])tarjan(i), --sz;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> now[maxn * <span class="number">2</span>];</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; g[u].size(); i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> v = g[u][i];</span><br><span class="line">            now[++cnt] = v;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        dp2[<span class="number">1</span>][<span class="number">0</span>] = dp1[now[<span class="number">1</span>]][<span class="number">0</span>];</span><br><span class="line">        dp2[<span class="number">1</span>][<span class="number">1</span>] = -inf;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= cnt; i++) &#123;</span><br><span class="line">            dp2[i][<span class="number">0</span>] = max(dp2[i - <span class="number">1</span>][<span class="number">0</span>], dp2[i - <span class="number">1</span>][<span class="number">1</span>]) + dp1[now[i]][<span class="number">0</span>];</span><br><span class="line">            dp2[i][<span class="number">1</span>] = dp2[i - <span class="number">1</span>][<span class="number">0</span>] + dp1[now[i]][<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        dp1[u][<span class="number">0</span>] = dp2[cnt][<span class="number">0</span>];</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; i++) &#123;</span><br><span class="line">            dp2[i][<span class="number">0</span>] = max(dp2[i - <span class="number">1</span>][<span class="number">0</span>], dp2[i - <span class="number">1</span>][<span class="number">1</span>]) + dp1[now[i]][<span class="number">0</span>];</span><br><span class="line">            dp2[i][<span class="number">1</span>] = dp2[i - <span class="number">1</span>][<span class="number">0</span>] + dp1[now[i]][<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        dp1[u][<span class="number">1</span>] = max(dp2[cnt][<span class="number">0</span>], dp2[cnt][<span class="number">1</span>]);</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">        dp1[u][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp1[u][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; g[u].size(); i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> v = g[u][i];</span><br><span class="line">            dfs(v);</span><br><span class="line">            <span class="keyword">if</span>(u &lt;= n)&#123;</span><br><span class="line">                dp1[u][<span class="number">0</span>] += max(dp1[v][<span class="number">0</span>], dp1[v][<span class="number">1</span>]);</span><br><span class="line">                dp1[u][<span class="number">1</span>] += dp1[v][<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span>(u &gt; n) solve(u);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;sol;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>), <span class="built_in">cin</span>.tie(<span class="number">0</span>), <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; fixed &lt;&lt; setprecision(<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> u, v;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v;</span><br><span class="line">        sol.G[u].pb(v);</span><br><span class="line">        sol.G[v].pb(u);</span><br><span class="line">    &#125;</span><br><span class="line">    sol.find_bcc();</span><br><span class="line">    sol.dfs(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; max(dp1[<span class="number">1</span>][<span class="number">0</span>], dp1[<span class="number">1</span>][<span class="number">1</span>]) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><h2 id="求仙人掌的直径"><a href="#求仙人掌的直径" class="headerlink" title="求仙人掌的直径"></a>求仙人掌的直径</h2><p><a href="http://www.lydsy.com/JudgeOnline/problem.php?id=1023" target="_blank" rel="noopener">bzoj-1023</a></p><p>还是先建出圆方树，按照树dp的方法求直径，圆点的方法还是一样的，只用特殊考虑方点的。<br>考虑两条链在某个方点合并，也就是方点儿子中的任意两个圆点都可能合并，假设是儿子$(u, v)$，他们在环上的顺序分别是$(i, j)(i &lt; j)$，那么贡献就是dp[u] + dp[v] + i - j，并且i，j之间的距离不能超过环长的一半（否则可以从环另一边绕过去），考虑破环为链，变为2倍，中间会空一个点（其实是方点的父亲，也是环上的一个点，但这里统计我们就不考虑），遇到这个点我们直接跳过，然后维护一个单调队列，统计方点的儿子对答案的贡献，统计后再把所有儿子的距离更新到方点上去，从两边较近的一方绕上去即可，其他的跟树形dp求直径都是完全一样的。</p><div><div class="fold_hider"><div class="close hider_title">代码</div></div><div class="fold"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> db;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vi;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;ll&gt; vl;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;pii&gt; vp;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">const</span> ll INF = <span class="number">1e18</span>;</span><br><span class="line"><span class="keyword">const</span> db eps = <span class="number">1e-10</span>;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> eb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ep emplace</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mem(a) memset(a, 0, sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> copy(a, b) memcpy(a, b, sizeof(b))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PA cout &lt;&lt; <span class="meta-string">"pass\n"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lowbit(x) (x &amp; -x)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(x) x.begin(), x.end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TM cout &lt;&lt; db(clock()) / CLOCKS_PER_SEC &lt;&lt; <span class="meta-string">'\n'</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;<span class="title">inline</span> <span class="title">void</span> <span class="title">upmin</span>(<span class="title">T</span> &amp;<span class="title">x</span>, <span class="title">T</span> <span class="title">y</span>) &#123;</span>x = x &gt; y ? y : x;&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;<span class="title">inline</span> <span class="title">void</span> <span class="title">upmax</span>(<span class="title">T</span> &amp;<span class="title">x</span>, <span class="title">T</span> <span class="title">y</span>) &#123;</span>x = x &lt; y ? y : x;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">233</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> dp[maxn];</span><br><span class="line"><span class="keyword">int</span> res;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Cactus</span> &#123;</span></span><br><span class="line">    vi G[maxn];</span><br><span class="line">    vi g[maxn * <span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> dfn[maxn];</span><br><span class="line">    <span class="keyword">int</span> low[maxn];</span><br><span class="line">    <span class="keyword">int</span> ntime;</span><br><span class="line">    <span class="keyword">int</span> tot;</span><br><span class="line">    <span class="keyword">int</span> sta[maxn];</span><br><span class="line">    <span class="keyword">int</span> sz;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">        dfn[u] = low[u] = ++ntime;</span><br><span class="line">        sta[++sz] = u;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[u].size(); i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = G[u][i];</span><br><span class="line">            <span class="keyword">if</span> (!dfn[v]) &#123;</span><br><span class="line">                tarjan(v);</span><br><span class="line">                low[u] = min(low[u], low[v]);</span><br><span class="line">                <span class="keyword">if</span>(low[v] == dfn[u])&#123;</span><br><span class="line">                    ++tot;</span><br><span class="line">                    g[u].pb(tot);</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">0</span>; x != v; --sz)&#123;</span><br><span class="line">                        x = sta[sz];</span><br><span class="line">                        g[tot].pb(x);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> low[u] = min(low[u], dfn[v]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">find_bcc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sz = <span class="number">0</span>;</span><br><span class="line">        tot = n;</span><br><span class="line">        <span class="built_in">memset</span>(dfn, <span class="number">0</span>, <span class="keyword">sizeof</span>(dfn));</span><br><span class="line">        ntime = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)<span class="keyword">if</span> (!dfn[i])tarjan(i), --sz;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> head = <span class="number">1</span>, tail = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> que[maxn * <span class="number">2</span>], now[maxn * <span class="number">2</span>];</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; g[u].size(); i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> v = g[u][i];</span><br><span class="line">            now[++cnt] = v;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">int</span> len = cnt + <span class="number">1</span> &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> stop = cnt + <span class="number">1</span>;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = cnt + <span class="number">2</span>; i &lt;= <span class="number">2</span> * cnt + <span class="number">1</span>; i++) now[i] = now[i - cnt - <span class="number">1</span>];</span><br><span class="line">        cnt = cnt * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(head &lt;= tail &amp;&amp; i - que[head] &gt; len) head++;</span><br><span class="line">            <span class="keyword">if</span>(i == stop) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(head &lt;= tail) &#123;</span><br><span class="line">                <span class="keyword">int</span> t = que[head];</span><br><span class="line">                upmax(res, i + dp[now[i]] + dp[now[t]] - t);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(head &lt;= tail &amp;&amp; dp[now[que[tail]]] - que[tail] &lt;= dp[now[i]] - i) tail--;</span><br><span class="line">            que[++tail] = i;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; stop; i++)&#123;</span><br><span class="line">            upmax(dp[u], dp[now[i]] + min(i, stop - i) - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; g[u].size(); i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> v = g[u][i];</span><br><span class="line">            dfs(v);</span><br><span class="line">            <span class="keyword">if</span>(u &lt;= n)&#123;</span><br><span class="line">                upmax(res, dp[u] + dp[v] + <span class="number">1</span>);</span><br><span class="line">                upmax(dp[u], dp[v] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(u &gt; n) solve(u);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;sol;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>), <span class="built_in">cin</span>.tie(<span class="number">0</span>), <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; fixed &lt;&lt; setprecision(<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> len;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; len;</span><br><span class="line">        <span class="keyword">int</span> last = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len; ++j) &#123;</span><br><span class="line">            <span class="keyword">int</span> x;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">            <span class="keyword">if</span>(j) sol.G[x].eb(last), sol.G[last].eb(x);</span><br><span class="line">            last = x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sol.find_bcc();</span><br><span class="line">    sol.dfs(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><h2 id="求仙人掌上的最短路"><a href="#求仙人掌上的最短路" class="headerlink" title="求仙人掌上的最短路"></a>求仙人掌上的最短路</h2><p><a href="http://www.lydsy.com/JudgeOnline/problem.php?id=2125" target="_blank" rel="noopener">bzoj-2125</a></p><p>建出圆方树，考虑树上求最短路，我们使用LCA就行了，还是要特殊考虑方点的情况。<br>考虑LCA为圆点，那没问题，直接按树那样求最短路即可。<br>考虑LCA为方点，我们发现我们需要找到两个点在方点下对应的圆点的位置，然后找两个圆点在环上的最小距离。<br>其实这里挺麻烦的，我们考虑建树的时候就要把环的每条边值分配到圆方树对应的位置，我是把最后一条找到的返祖边分配到方点和它父亲上，剩下的分配到方点和它的儿子圆点上。那么这里tarjan里就需要改一改（如果用map其实就很简单，但想把log给去掉）。考虑用一个栈来维护边权，我们发现到父亲的边我们不能加入栈中，得把父亲判掉。其次我们发现如果点双大小为2，我们只需要pop出一条边（点双个数 - 1），否则需要pop出点双个数条边（环），所以pop的时候我们还要记录一下点双大小，看它跟2的关系（实际上最上面那个点我们要保留，所以就是跟1的关系）。对于环上处理最小值，我们考虑给每个环开个vector记录点顺序，那么两个点在上面的顺序就等于两条路径取min，vector上找到对应位置直接正反取一下就可以得出结果。然后处理环的同时我们可以同时把圆点到方点的距离处理出来，把距离更新上去即可。<br>真的是码农题，细节也特别烦。。</p><div><div class="fold_hider"><div class="close hider_title">代码</div></div><div class="fold"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> db;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vi;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;ll&gt; vl;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;pii&gt; vp;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">const</span> ll INF = <span class="number">1e18</span>;</span><br><span class="line"><span class="keyword">const</span> db eps = <span class="number">1e-10</span>;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> eb emplace_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ep emplace</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mem(a) memset(a, 0, sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> copy(a, b) memcpy(a, b, sizeof(b))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PA cout &lt;&lt; <span class="meta-string">"pass\n"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lowbit(x) (x &amp; -x)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(x) x.begin(), x.end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TM cout &lt;&lt; db(clock()) / CLOCKS_PER_SEC &lt;&lt; <span class="meta-string">'\n'</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;<span class="title">inline</span> <span class="title">void</span> <span class="title">upmin</span>(<span class="title">T</span> &amp;<span class="title">x</span>, <span class="title">T</span> <span class="title">y</span>) &#123;</span>x = x &gt; y ? y : x;&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;<span class="title">inline</span> <span class="title">void</span> <span class="title">upmax</span>(<span class="title">T</span> &amp;<span class="title">x</span>, <span class="title">T</span> <span class="title">y</span>) &#123;</span>x = x &lt; y ? y : x;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">233</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, q;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Cactus</span> &#123;</span></span><br><span class="line">    vp G[maxn];</span><br><span class="line">    vp g[maxn * <span class="number">2</span>]; </span><br><span class="line">    <span class="keyword">int</span> f[maxn][<span class="number">20</span>];</span><br><span class="line">    ll dis[maxn];</span><br><span class="line">    <span class="keyword">int</span> dfn[maxn];</span><br><span class="line">    <span class="keyword">int</span> low[maxn];</span><br><span class="line">    <span class="keyword">int</span> ntime;</span><br><span class="line">    <span class="keyword">int</span> tot;</span><br><span class="line">    <span class="keyword">int</span> sta[maxn];</span><br><span class="line">    <span class="keyword">int</span> sz;</span><br><span class="line">    <span class="keyword">int</span> val[maxn];</span><br><span class="line">    <span class="keyword">int</span> idx;</span><br><span class="line">    <span class="keyword">int</span> d[maxn];</span><br><span class="line">    <span class="keyword">int</span> pre[maxn * <span class="number">2</span>];</span><br><span class="line">    ll all[maxn * <span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> ord[maxn * <span class="number">2</span>];</span><br><span class="line">    <span class="built_in">vector</span>&lt;pair&lt;ll, ll&gt; &gt; tmp[maxn * <span class="number">2</span>];</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">        dfn[u] = low[u] = ++ntime;</span><br><span class="line">        sta[++sz] = u;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[u].size(); i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = G[u][i].fi;</span><br><span class="line">            <span class="keyword">int</span> w = G[u][i].se;</span><br><span class="line">            <span class="keyword">if</span>(!dfn[v] || (dfn[u] &gt; dfn[v] &amp;&amp; v != fa)) val[++idx] = w;</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">if</span> (!dfn[v]) &#123;</span><br><span class="line">                tarjan(v, u);</span><br><span class="line">                low[u] = min(low[u], low[v]);</span><br><span class="line">                <span class="keyword">if</span>(low[v] == dfn[u])&#123;</span><br><span class="line">                    ++tot;</span><br><span class="line">                    pre[tot] = w;</span><br><span class="line">                    g[u].pb(pii(tot, w));</span><br><span class="line">                    <span class="keyword">int</span> ff = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">0</span>; x != v; --sz, --idx) &#123;</span><br><span class="line">                        x = sta[sz];</span><br><span class="line">                        ff++;</span><br><span class="line">                        g[tot].pb(pii(x, val[idx]));</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(ff &gt; <span class="number">1</span>) idx--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> low[u] = min(low[u], dfn[v]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">find_bcc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        d[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        sz = <span class="number">0</span>;</span><br><span class="line">        tot = n;</span><br><span class="line">        <span class="built_in">memset</span>(dfn, <span class="number">0</span>, <span class="keyword">sizeof</span>(dfn));</span><br><span class="line">        ntime = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)<span class="keyword">if</span> (!dfn[i])tarjan(i, <span class="number">0</span>), --sz;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">        <span class="keyword">static</span> pii now[maxn * <span class="number">2</span>];</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">19</span>; i++) f[u][i] = f[f[u][i - <span class="number">1</span>]][i - <span class="number">1</span>];</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span>(u &gt; n)&#123;</span><br><span class="line">            <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">            ll sum = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; g[u].size(); i++)&#123;</span><br><span class="line">                now[++cnt] = g[u][i];</span><br><span class="line">                sum += now[cnt].se;</span><br><span class="line">                tmp[u].pb(pair&lt;ll, ll&gt;&#123;now[cnt].fi, sum&#125;);</span><br><span class="line">                ord[now[cnt].fi] = i;</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            ll tt = <span class="number">0</span>;</span><br><span class="line">            all[u] = sum + pre[u];</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; i++)&#123;</span><br><span class="line">                tt += now[i].se;</span><br><span class="line">                dis[now[i].fi] = dis[u] + min(tt - pre[u], sum - tt);</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; g[u].size(); i++)&#123;</span><br><span class="line">                <span class="keyword">int</span> v = g[u][i].fi;</span><br><span class="line">                <span class="keyword">int</span> w = g[u][i].se;</span><br><span class="line">                dis[v] = dis[u] + w;</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; g[u].size(); i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> v = g[u][i].fi;</span><br><span class="line">            d[v] = d[u] + <span class="number">1</span>;</span><br><span class="line">            f[v][<span class="number">0</span>] = u;</span><br><span class="line">            dfs(v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lca</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(d[u] &gt; d[v]) swap(u, v);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">19</span>; i &gt;= <span class="number">0</span>; i--) <span class="keyword">if</span>(d[u] &lt;= d[f[v][i]]) v = f[v][i];</span><br><span class="line">        <span class="keyword">if</span>(u == v) <span class="keyword">return</span> u;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">19</span>; i &gt;= <span class="number">0</span>; i--) <span class="keyword">if</span>(f[u][i] != f[v][i]) u = f[u][i], v = f[v][i];</span><br><span class="line">        <span class="keyword">return</span> f[u][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function">pii <span class="title">lca2</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">        <span class="keyword">bool</span> ff = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(d[u] &gt; d[v]) swap(u, v), ff = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">19</span>; i &gt;= <span class="number">0</span>; i--) <span class="keyword">if</span>(d[u] &lt;= d[f[v][i]]) v = f[v][i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">19</span>; i &gt;= <span class="number">0</span>; i--) <span class="keyword">if</span>(f[u][i] != f[v][i]) u = f[u][i], v = f[v][i];</span><br><span class="line">        <span class="keyword">if</span>(ff) swap(u, v);</span><br><span class="line">        <span class="keyword">return</span> pii(u, v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;sol;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>), <span class="built_in">cin</span>.tie(<span class="number">0</span>), <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; fixed &lt;&lt; setprecision(<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> u, v, w;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">        sol.G[u].pb(pii(v, w));</span><br><span class="line">        sol.G[v].pb(pii(u, w));</span><br><span class="line">    &#125;</span><br><span class="line">    sol.find_bcc();</span><br><span class="line">    sol.dfs(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= q; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> x, y;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        <span class="keyword">int</span> lc = sol.lca(x, y);</span><br><span class="line">        <span class="keyword">if</span>(lc &lt;= n || lc == x || lc == y) <span class="built_in">cout</span> &lt;&lt; sol.dis[x] + sol.dis[y] - <span class="number">2</span> * sol.dis[lc] &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            pii t = sol.lca2(x, y);</span><br><span class="line">            ll res = sol.dis[x] - sol.dis[t.fi] + sol.dis[y] - sol.dis[t.se];</span><br><span class="line">            <span class="keyword">int</span> t1 = sol.ord[t.fi];</span><br><span class="line">            <span class="keyword">int</span> t2 = sol.ord[t.se];</span><br><span class="line">            <span class="keyword">if</span>(t1 &gt; t2) swap(t1, t2);</span><br><span class="line">            ll tt = sol.tmp[lc][t2].se - sol.tmp[lc][t1].se;</span><br><span class="line">            tt = min(tt, sol.all[lc] - tt);</span><br><span class="line">            res += tt;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;序言&quot;&gt;&lt;a href=&quot;#序言&quot; class=&quot;headerlink&quot; title=&quot;序言&quot;&gt;&lt;/a&gt;序言&lt;/h1&gt;&lt;p&gt;你敢信我学完基础的圆方树后理解最深的居然是tarjan？&lt;br&gt;不知道这玩意有啥用，但据说很有用，但好像icpc都不太考这个东西？但感觉这个东西跟什么树问题都能有关系，而且还都是大码量题。。&lt;/p&gt;
&lt;h1 id=&quot;仙人掌&quot;&gt;&lt;a href=&quot;#仙人掌&quot; class=&quot;headerlink&quot; title=&quot;仙人掌&quot;&gt;&lt;/a&gt;仙人掌&lt;/h1&gt;&lt;h2 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h2&gt;&lt;p&gt;仙人掌是一种特殊的无向图，具有如下性质：&lt;br&gt;1、图是连通的。&lt;br&gt;2、每条边最多属于一个简单环。&lt;br&gt;&lt;img src=&quot;/images/12.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;因为有特殊性，所以也就有特殊的方法处理这一类题目。&lt;/p&gt;
&lt;h2 id=&quot;仙人掌的dfs生成树&quot;&gt;&lt;a href=&quot;#仙人掌的dfs生成树&quot; class=&quot;headerlink&quot; title=&quot;仙人掌的dfs生成树&quot;&gt;&lt;/a&gt;仙人掌的dfs生成树&lt;/h2&gt;&lt;p&gt;仙人掌dfs生成树也有着特殊的性质，我们将它的dfs生成树看成一个序列，返祖边看成一个区间，那么所有的区间都是不相交的。这样在用dfs生成树处理仙人掌的时候就能简化很多种复杂的情况。&lt;/p&gt;
&lt;h1 id=&quot;圆方树&quot;&gt;&lt;a href=&quot;#圆方树&quot; class=&quot;headerlink&quot; title=&quot;圆方树&quot;&gt;&lt;/a&gt;圆方树&lt;/h1&gt;&lt;h2 id=&quot;概念-1&quot;&gt;&lt;a href=&quot;#概念-1&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h2&gt;&lt;p&gt;圆方树是用来解决仙人掌问题的一种数据结构。&lt;br&gt;其实圆方树的原理不难想，考虑前面我们说过，仙人掌每条边只属于一个简单环，换言之各个环之间不会嵌套。那么我们在环上考虑问题是比较复杂的，我们喜欢转成树，我们想到给每个环新建一个点，把所有环上的点去掉，并且跟新点相连。这个新点就好像一个中转站一样，巧妙的把环变为了链，把一般图变为了树。树上解决问题，我们可以采用的方法就会更多。&lt;/p&gt;
&lt;p&gt;我们把新建的点叫做方点，原来的点叫做圆点。&lt;/p&gt;
&lt;p&gt;Upd:我发现我好像一直学的是广义圆方树，不过好像它应用更广泛，也可以直接用在仙人掌上。。。。&lt;/p&gt;
&lt;h2 id=&quot;性质&quot;&gt;&lt;a href=&quot;#性质&quot; class=&quot;headerlink&quot; title=&quot;性质&quot;&gt;&lt;/a&gt;性质&lt;/h2&gt;&lt;p&gt;圆方树有很多不错的性质：&lt;br&gt;1、方点和方点之间不会直接相连。&lt;br&gt;2、无论取哪个点为根，圆方树的形态是一样的。&lt;br&gt;3、&lt;script type=&quot;math/tex&quot;&gt;以r为根的仙人掌上p的子仙人掌就是圆方树中以r为根时，p子树中的所有圆点&lt;/script&gt;（还没理解，先嫖着）。&lt;br&gt;4、方点儿子中的相邻的在原图环上也是相邻的（tarjan性质）。&lt;/p&gt;
    
    </summary>
    
      <category term="圆方树" scheme="http://yoursite.com/categories/%E5%9C%86%E6%96%B9%E6%A0%91/"/>
    
    
  </entry>
  
  <entry>
    <title>二分图通关全攻略</title>
    <link href="http://yoursite.com/2020/03/30/%E4%BA%8C%E5%88%86%E5%9B%BE%E9%80%9A%E5%85%B3%E5%85%A8%E6%94%BB%E7%95%A5/"/>
    <id>http://yoursite.com/2020/03/30/二分图通关全攻略/</id>
    <published>2020-03-30T12:54:22.000Z</published>
    <updated>2020-04-03T01:44:28.346Z</updated>
    
    <content type="html"><![CDATA[<h1 id="二分图概念"><a href="#二分图概念" class="headerlink" title="二分图概念"></a>二分图概念</h1><p>二分图简单来说，就是一个无向图，可以把点集分为两个，且边都是从一个点集指向另一个点集。<br><strong>二分图有另一个等价的定义：没有奇环。</strong>相对而言这个性质更加重要。<br><a id="more"></a></p><h1 id="二分图最大匹配"><a href="#二分图最大匹配" class="headerlink" title="二分图最大匹配"></a>二分图最大匹配</h1><p>二分图算法挺多的，说几个常见的吧，主要是复杂度有差异。</p><h2 id="匈牙利算法"><a href="#匈牙利算法" class="headerlink" title="匈牙利算法"></a>匈牙利算法</h2><p><strong>复杂度：O(nm)</strong><br>匈牙利算法比较暴力，每次对某一个点都暴力找增广路，因为找的时候可能把所有边都看一遍，所以找一次增广路的复杂度是<script type="math/tex">O(m)</script>的。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    vis[u] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[u].size(); i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = G[u][i];</span><br><span class="line">        <span class="keyword">if</span> (!vis[v]) &#123;</span><br><span class="line">            vis[v] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (link[v] == <span class="number">-1</span> || dfs(link[v])) &#123;</span><br><span class="line">                link[v] = u;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Dinic"><a href="#Dinic" class="headerlink" title="Dinic"></a>Dinic</h2><p><strong><script type="math/tex">复杂度：O(n\sqrt(m))</script></strong><br>这个就不讲了，正常网络流建图即可。复杂度相对来说是这几个里面看起来最好的一个。</p><h2 id="Hopcroft-Karp"><a href="#Hopcroft-Karp" class="headerlink" title="Hopcroft-Karp"></a>Hopcroft-Karp</h2><p><strong><script type="math/tex">复杂度：O(m\sqrt(n))</script></strong></p><h1 id="二分图的一些非常重要的定理"><a href="#二分图的一些非常重要的定理" class="headerlink" title="二分图的一些非常重要的定理"></a>二分图的一些非常重要的定理</h1><h2 id="Hall定理"><a href="#Hall定理" class="headerlink" title="Hall定理"></a>Hall定理</h2><h3 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h3><p>Hall定理可以说是匈牙利算法的基础，也是二分图中非常基本的一个定理。<br>Hall定理说的是这么个东西，假设二分图两个点集为<script type="math/tex">X，Y</script>。令<script type="math/tex">n = min(|X|, |Y|)</script>。如果二分图有完美匹配，则对于任意<script type="math/tex">X</script>中任意<script type="math/tex">k</script>个点的集合<script type="math/tex">1 \leq k \leq n</script>，他们能到达<script type="math/tex">Y</script>里的点的点集的大小一定大于等于<script type="math/tex">k</script>。反过来也是成立的。</p><h3 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h3><p>考虑反证法，首先如果不满足后面的条件：对于某一个<script type="math/tex">k</script>，到达的Y集合的点没有<script type="math/tex">k</script>个，显然不可能达成完美匹配，倒过来是成立的。<br>考虑正向：如果对于任意k都满足这个条件，没有完美匹配代表至少X集合中有一个点没有匹配，而它能到的Y中有一个点跟其他点匹配了，我们找到它匹配的那个其他点（<script type="math/tex">X</script>中的），这个点能到的一定还有其它点（不然它和前面那个没匹配的<script type="math/tex">X</script>中的点加起来就只能到一个地方，不满足条件），这样一直推下去发现最后一定会推出矛盾，所以正向也是成立的。</p><h2 id="最小点覆盖"><a href="#最小点覆盖" class="headerlink" title="最小点覆盖"></a>最小点覆盖</h2><h3 id="内容-1"><a href="#内容-1" class="headerlink" title="内容"></a>内容</h3><p>求最少的点集，使得每一条边至少都有端点在这个点集中。</p><h3 id="定理"><a href="#定理" class="headerlink" title="定理"></a>定理</h3><p><strong>最小点覆盖 = 最大匹配</strong></p><h3 id="方案求解"><a href="#方案求解" class="headerlink" title="方案求解"></a>方案求解</h3><p>从左边点集没出发的点开始，从左到右走没有流的边，从右到左走有流的边，沿着路径dfs打标记，左边点集中没打标记的所有点和右边点集中所有打了标记的点构成一个最小点覆盖集。<br>我们发现，对于一个联通块，我们必然是从左边开始，并且在左边结束。因为从左边点集到右边点集走的是没有匹配的边，如果在右边停下了，说明右边那个点没匹配边，明显可以跟左边点匹配，不符合完美匹配，所以一定是从左边开始到左边停止。那么这条交错路径，我们全部选位于右边标记过的点就好了，这时候发现匹配数 = 选的点数。</p><h3 id="证明-1"><a href="#证明-1" class="headerlink" title="证明"></a>证明</h3><p>首先我们证明最大匹配 <script type="math/tex">\leq</script> 最小点覆盖，我们在每个匹配边两端任意选一个点，如果还有边没被覆盖，说明那条边两端都没点被选过，这显然不可能，所以最大匹配 <script type="math/tex">\leq</script> 最小点覆盖，反过来也好证，把所有匹配边抽出来，一定不重复，这时最少就需要选这么多条边个点。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 求最小点覆盖，从s出发，左边没标记过的点和右边标记过的点构成最小点覆盖。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">    ok[u] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[u].size(); i++)&#123;</span><br><span class="line">        edge &amp;e = edges[G[u][i]];</span><br><span class="line">        <span class="keyword">if</span>(e.cap &gt; e.flow &amp;&amp; !ok[e.to]) dfs1(e.to);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最大独立集"><a href="#最大独立集" class="headerlink" title="最大独立集"></a>最大独立集</h2><h3 id="内容-2"><a href="#内容-2" class="headerlink" title="内容"></a>内容</h3><p>一个最大的点的集合，使得任意两个点之间没有直接边连接。</p><h3 id="定理-1"><a href="#定理-1" class="headerlink" title="定理"></a>定理</h3><p><strong>最大独立集 = 点数 - 最大匹配</strong></p><h3 id="方案求解-1"><a href="#方案求解-1" class="headerlink" title="方案求解"></a>方案求解</h3><p>同最小点覆盖，只不过左边取打了标记的点，右边取没打标记的点就行了。</p><h3 id="证明-2"><a href="#证明-2" class="headerlink" title="证明"></a>证明</h3><p>先证<script type="math/tex">最大独立集 \leq 点数 - 最大匹配</script>。最初没有边，独立集数目等于点数。考虑每有一个匹配，就会让独立集数目 - 1，证明完毕。<br>再证：<script type="math/tex">最大独立集 \geq 点数 - 最大匹配</script>，考虑构造出来的方案，我们发现<script type="math/tex">最大独立集 \geq 点数 - 最大匹配</script>。证明完毕<br>所以最后<script type="math/tex">最大独立集 = 点数 - 最大匹配</script>。证明完毕</p><h2 id="最大团"><a href="#最大团" class="headerlink" title="最大团"></a>最大团</h2><h3 id="内容-3"><a href="#内容-3" class="headerlink" title="内容"></a>内容</h3><p>一个最大的点的集合，该集合内的任意两点都有边相连。</p><h3 id="定理-2"><a href="#定理-2" class="headerlink" title="定理"></a>定理</h3><p><strong>二分图的最大团 = 二分图补图的最大独立集</strong></p><h3 id="方案求解-2"><a href="#方案求解-2" class="headerlink" title="方案求解"></a>方案求解</h3><p>找补图的最大独立集即可。。</p><h3 id="证明-3"><a href="#证明-3" class="headerlink" title="证明"></a>证明</h3><p>好像没啥好证明的吧，根据定义发现取补图后就完全相等了。</p><h2 id="有向无环图的最小链覆盖与最长反链"><a href="#有向无环图的最小链覆盖与最长反链" class="headerlink" title="有向无环图的最小链覆盖与最长反链"></a>有向无环图的最小链覆盖与最长反链</h2><h3 id="内容-4"><a href="#内容-4" class="headerlink" title="内容"></a>内容</h3><p><strong>图论角度</strong><br>最小链覆盖也称最小路径覆盖，要求每条路径上不能有重复的点。</p><p>最小链覆盖：从边中选出若干点不相交的链，使得这些链覆盖所有的点，并且链的条数最小。（链的定义是一条连续路径，并且不经过重复的点。路径可以只是一个单独的边，不包含边）<br>最长反链：首先纠正一下，反链不是链，而是集合。链代表的是一个集合内，任意两个点(u, v)，要嘛u能走到v，要嘛v能走到u。反链是指的一个点集，集合内两个点谁也不能走到谁。最长反链就是找一个点数最多的这样的集合。</p><p>这是从图的角度来解读的，我们再从<strong>偏序集的角度</strong>来解释一下。<br>设<script type="math/tex">\leq</script>是一个偏序关系，我们知道满足以下条件可以构成偏序集：<br>1、自反性：<script type="math/tex">\forall a \in A, a \leq a</script><br>2、反对称性：<script type="math/tex">\forall a, b \in A, 若a \leq b，b \leq a，则a = b</script><br>3、传递性：<script type="math/tex">\forall a, b, c \in A，若a \leq b，b \leq c 则a \leq c</script><br>全序集：若对于集合<script type="math/tex">\forall a, b \in B，都有a \leq b或 b \leq a（两元素互相可比）</script>，则称<script type="math/tex">(B, \leq)</script>为一个全序集。<br>反链：若偏序集<script type="math/tex">(B, \leq)</script>中的元素两两不可比，则称B为反链。</p><h3 id="定理-3"><a href="#定理-3" class="headerlink" title="定理"></a>定理</h3><p><strong>最长反链 = 最小链覆盖</strong></p><h3 id="Dilworth定理"><a href="#Dilworth定理" class="headerlink" title="Dilworth定理"></a>Dilworth定理</h3><p><strong>最少的全序集 = 最长反链</strong><br><strong>最少反链划分 = 最大全序集</strong></p><h4 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h4><p>问题：给定一个序列，求最少能将序列划分为多少个不单增的子序列。</p><p>考虑将序列拓展为二元关系（a，b），a代表下标，b代表数据的值。我们定义当两个对应位置都严格大于或者小于时，它们是可比的，否则是不可比的。我们发现按照定义，在一个不单增子序列中任意两个元素是不可比的，也就是说一个不单增的子序列构成一个反链，问题变为了求偏序集上的最少反链划分，根据定理可知等于最大全序集的大小，也就是最长上升子序列的大小，所以求一个最长上升子序列即可。</p><p>回到图上，考虑偏序集上因为是偏序关系，是不可能存在环的偏序关系的，这也就对应了为什么图上一定是DAG。</p><h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><p><strong>再强调一遍，必须是DAG才能做，并且是不重点的。</strong><br>将原图每个点拆为两个，分别位于二分图的两端。对于每一条边(u, v)，从新点中左边点集中的u连向右边点集中的v，最后答案等于点数 - 新二分图最大匹配。</p><h3 id="方案构造"><a href="#方案构造" class="headerlink" title="方案构造"></a>方案构造</h3><p>从每个没有访问过的点开始出发，沿着匹配边一直走，路上所有点打标记，走到不能走为止，便对应了一条路径。</p><h3 id="证明-4"><a href="#证明-4" class="headerlink" title="证明"></a>证明</h3><p>可以感性证明一下，假设一开始图没有边，最长反链为n，最小链覆盖此时也为n。考虑一个匹配边对应合并两个点，此时反链会 - 1，最小链覆盖数也会 - 1，感性认知二者是等价的。具体证明就不证了（主要是不太想看），有空再补吧。</p><h3 id="最小链覆盖中可作为链端点的点"><a href="#最小链覆盖中可作为链端点的点" class="headerlink" title="最小链覆盖中可作为链端点的点"></a>最小链覆盖中可作为链端点的点</h3><p>opentrain上的一个好题。<br>考虑一个点能作为起点，代表如果我们删去这个点，最小链覆盖的数目不会增加（如果是一个点就减少、否则不变）。我们先考虑起点（二分图左边的点），首先单独的未匹配点一定可以，考虑沿着它找一条交错路径，我们发现交错路径覆盖到的左边的点都可以作为起点（可以替换匹配边，使得它变为未匹配点）。那么我们从左半边找一次。考虑终点也是同样的，不过是从二分图右半边开始找未匹配点，然后走交错路径，给右边的覆盖的点打上标记，最后只要在这个点左边或者右边被覆盖过一次，它就可以作为端点。（记得如果是dinic先把s，t给标记了，不标记我也不知道会不会出错。）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    pre[s] = pre[t] = suf[s] = suf[t] = <span class="number">1</span>;</span><br><span class="line">    dfs2(s, pre, <span class="number">0</span>);</span><br><span class="line">    dfs2(t, suf, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(pre[i] || suf[i + n]) <span class="comment">//可以作为端点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">bool</span> *ok, <span class="keyword">bool</span> f)</span></span>&#123;</span><br><span class="line">    ok[u] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[u].size(); i++)&#123;</span><br><span class="line">        edge &amp;e = edges[G[u][i]];</span><br><span class="line">        <span class="keyword">if</span>(!ok[e.to] &amp;&amp; ((e.cap &gt; e.flow) ^ f)) dfs1(e.to, ok, f);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;二分图概念&quot;&gt;&lt;a href=&quot;#二分图概念&quot; class=&quot;headerlink&quot; title=&quot;二分图概念&quot;&gt;&lt;/a&gt;二分图概念&lt;/h1&gt;&lt;p&gt;二分图简单来说，就是一个无向图，可以把点集分为两个，且边都是从一个点集指向另一个点集。&lt;br&gt;&lt;strong&gt;二分图有另一个等价的定义：没有奇环。&lt;/strong&gt;相对而言这个性质更加重要。&lt;br&gt;
    
    </summary>
    
      <category term="二分图" scheme="http://yoursite.com/categories/%E4%BA%8C%E5%88%86%E5%9B%BE/"/>
    
    
  </entry>
  
  <entry>
    <title>Codeforces Round 366 (Div. 1)-B(Ant Man)</title>
    <link href="http://yoursite.com/2020/03/28/Codeforces-Round-366-Div-1-B-Ant-Man/"/>
    <id>http://yoursite.com/2020/03/28/Codeforces-Round-366-Div-1-B-Ant-Man/</id>
    <published>2020-03-28T15:32:48.000Z</published>
    <updated>2020-03-28T16:16:14.594Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://codeforces.com/contest/704/problem/B" target="_blank" rel="noopener">题目链接</a><br>思路：考虑按位置插入，原来位置是一个从小位置指向大位置的，插入后变成了两个小的指向一个大的，相当于有一个原来大的变成了小的。我们发现每次操作都是把一个原本是大的的转换为小的，所以我们每次取大的里面最大的，贪心即可。<br><a id="more"></a><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">5050</span>;</span><br><span class="line"><span class="keyword">int</span> ne[maxn];</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;ll, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">int</span> a[maxn], b[maxn], c[maxn], d[maxn], x[maxn], n, s, e;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">f</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(p &lt; q) <span class="keyword">return</span> <span class="number">1l</span>l * x[q] - x[p] + d[p] + a[q];</span><br><span class="line">   <span class="keyword">return</span> <span class="number">1l</span>l * x[p] - x[q] + c[p] + b[q];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>, &amp;n, &amp;s, &amp;e);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, x + i);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, a + i);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, b + i);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, c + i);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, d + i);</span><br><span class="line">ne[s] = e;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(i == s || i == e) <span class="keyword">continue</span>;</span><br><span class="line">pii t = pii(<span class="number">1e18</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = s; j != e; j = ne[j])&#123;</span><br><span class="line">t = min(t, pii(f(j, i) + f(i, ne[j]) - f(j, ne[j]), j));</span><br><span class="line">&#125;</span><br><span class="line">ne[i] = ne[t.second];</span><br><span class="line">ne[t.second] = i;</span><br><span class="line">&#125;</span><br><span class="line">ll res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = s; i != e; i = ne[i])&#123;</span><br><span class="line">res += f(i, ne[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, res);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>还有一个dp的做法，dp[i][j]表示考虑前i个点，形成了j条链。转移就四种方向：<br>1、i的出边从左到右，入边从右到左，那么会合并两条链，所以要求 <script type="math/tex">p \geq 2</script>，<script type="math/tex">dp_{i+1,p-1} +=  dp_{i,p}+a_i+c_i</script><br>2、的出边从右到左，入边从左到右，那么会形成一条新的链，所以<script type="math/tex">dp_{i+1,p+1} += dp_{i,p}+b_i+d_i</script><br>3、i 连边都是从左到右，链数没有变化，但是以 ee 结尾的链是不能连出边的，所以要求<script type="math/tex">p>[i>e]，dp_{i+1,p} += dp_{i,p}+a_i+d_i</script><br>4、i 连边都是从左到右，链数没有变化，但是以 ee 结尾的链是不能连出边的，所以要求<script type="math/tex">p>[i>e]，dp_{i+1,p} += dp_{i,p}+a_i+d_i</script><br>当有s和t的时候我们要特殊考虑，s的时候只考虑入边，t的时候只考虑出边即可。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> db;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vi;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;ll&gt; vl;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;pii&gt; vp;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">const</span> ll INF = <span class="number">1e18</span>;</span><br><span class="line"><span class="keyword">const</span> db eps = <span class="number">1e-10</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> eb emplace_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ep emplace</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mem(a) memset(a, 0, sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> copy(a, b) memcpy(a, b, sizeof(b))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PA cout &lt;&lt; <span class="meta-string">"pass\n"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lowbit(x) (x &amp; -x)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(x) x.begin(), x.end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TM cout &lt;&lt; db(clock()) / CLOCKS_PER_SEC &lt;&lt; <span class="meta-string">'\n'</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">mt19937 <span class="title">mrand</span><span class="params">(chrono::high_resolution_clock::now().time_since_epoch().count())</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;<span class="title">inline</span> <span class="title">void</span> <span class="title">upmin</span>(<span class="title">T</span> &amp;<span class="title">x</span>, <span class="title">T</span> <span class="title">y</span>) &#123;</span>x = x &gt; y ? y : x;&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;<span class="title">inline</span> <span class="title">void</span> <span class="title">upmax</span>(<span class="title">T</span> &amp;<span class="title">x</span>, <span class="title">T</span> <span class="title">y</span>) &#123;</span>x = x &lt; y ? y : x;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">5050</span>;</span><br><span class="line"><span class="keyword">int</span> n, s, e;</span><br><span class="line">ll f[maxn], g[maxn], a[maxn], b[maxn], c[maxn], d[maxn], x[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>), <span class="built_in">cin</span>.tie(<span class="number">0</span>), <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; fixed &lt;&lt; setprecision(<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; s &gt;&gt; e;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">cin</span> &gt;&gt; x[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">cin</span> &gt;&gt; b[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">cin</span> &gt;&gt; c[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">cin</span> &gt;&gt; d[i];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) g[i] = INF;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= n; j++) f[j] = INF;</span><br><span class="line">        <span class="keyword">if</span> (i == s) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = (i &gt; e); j &lt; n; j++) upmin(f[j + <span class="number">1</span>], g[j] + d[i] - x[i]);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) upmin(f[j], g[j] + x[i] + c[i]);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i == e) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = (i &gt; s); j &lt; n; j++) upmin(f[j + <span class="number">1</span>], g[j] + b[i] - x[i]);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) upmin(f[j], g[j] + a[i] + x[i]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = (i &gt; e) + <span class="number">1</span>; j &lt;= n; j++) upmin(f[j], g[j] + a[i] + d[i]);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = (i &gt; s) + <span class="number">1</span>; j &lt;= n; j++) upmin(f[j], g[j] + b[i] + c[i]);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = (i &gt; e) + (i &gt; s); j &lt;= n; j++) upmin(f[j + <span class="number">1</span>], g[j] + b[i] + d[i] - <span class="number">2</span> * x[i]);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span>; j &lt;= n; j++) upmin(f[j - <span class="number">1</span>], g[j] + <span class="number">2</span> * x[i] + a[i] + c[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        swap(f, g);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; g[<span class="number">1</span>] &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>​     </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://codeforces.com/contest/704/problem/B&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目链接&lt;/a&gt;&lt;br&gt;思路：考虑按位置插入，原来位置是一个从小位置指向大位置的，插入后变成了两个小的指向一个大的，相当于有一个原来大的变成了小的。我们发现每次操作都是把一个原本是大的的转换为小的，所以我们每次取大的里面最大的，贪心即可。&lt;br&gt;
    
    </summary>
    
      <category term="贪心" scheme="http://yoursite.com/categories/%E8%B4%AA%E5%BF%83/"/>
    
    
  </entry>
  
  <entry>
    <title>Codeforces Round 323 (Div. 1)-D(Number of Binominal Coefficients)</title>
    <link href="http://yoursite.com/2020/03/28/Codeforces-Round-323-Div-1-D-Number-of-Binominal-Coefficients/"/>
    <id>http://yoursite.com/2020/03/28/Codeforces-Round-323-Div-1-D-Number-of-Binominal-Coefficients/</id>
    <published>2020-03-28T14:33:25.000Z</published>
    <updated>2020-03-28T15:30:39.549Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://codeforces.com/contest/582/problem/D" target="_blank" rel="noopener">题目链接</a><br>思路：<br>先介绍一个定理，不然这个题做不了。</p><h3 id="库莫尔定理"><a href="#库莫尔定理" class="headerlink" title="库莫尔定理"></a>库莫尔定理</h3><p>设m, n为正整数，p为素数，则<script type="math/tex">C_{m + n}^m</script>喊p的幂次等于m + n在p进制下的进位次数。<br>证明：我们发现p是素数，我们知道<script type="math/tex">C_{m + n}^n = \frac{(m + n)!}{m!n!}</script>，那么<script type="math/tex">C_{m + n}^n</script>含有p的幂次等于<script type="math/tex">\sum_{i = 1}^{\infty}\lfloor\frac{n + m}{p^i}\rfloor - \lfloor\frac{n}{p^i}\rfloor - \lfloor\frac{m}{p^i}\rfloor</script><br>我们发现对于每一个i，答案不会超过1，考虑什么时候为1，可以发现是在p进制下第i位发生进位时取到。</p><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>这一类题目都是库莫尔定理 + 数位dp的，考虑dp[i][j][k][l]表示考虑了前i个位置，进了j次位，前面已经等于/小于边界，上一位是否需要进位。那么剩下的问题就是转移的时候的组合数，即我们要统计在这一位有多少对(k, n)满足条件（可能有进位，并且另一个位置还要在可行范围内），可以以p为边界分开计算，然后转移即可。<br><a id="more"></a><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> db;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vi;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;ll&gt; vl;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;pii&gt; vp;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">const</span> ll INF = <span class="number">1e18</span>;</span><br><span class="line"><span class="keyword">const</span> db eps = <span class="number">1e-10</span>;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> eb emplace_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ep emplace</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mem(a) memset(a, 0, sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> copy(a, b) memcpy(a, b, sizeof(b))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PA cout &lt;&lt; <span class="meta-string">"pass\n"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lowbit(x) (x &amp; -x)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(x) x.begin(), x.end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TM cout &lt;&lt; db(clock()) / CLOCKS_PER_SEC &lt;&lt; <span class="meta-string">'\n'</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function">mt19937 <span class="title">mrand</span><span class="params">(chrono::high_resolution_clock::now().time_since_epoch().count())</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;<span class="title">inline</span> <span class="title">void</span> <span class="title">upmin</span>(<span class="title">T</span> &amp;<span class="title">x</span>, <span class="title">T</span> <span class="title">y</span>) &#123;</span>x = x &gt; y ? y : x;&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;<span class="title">inline</span> <span class="title">void</span> <span class="title">upmax</span>(<span class="title">T</span> &amp;<span class="title">x</span>, <span class="title">T</span> <span class="title">y</span>) &#123;</span>x = x &lt; y ? y : x;&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 9999</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 500</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DLEN 4</span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BigNum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ll a[<span class="number">5000</span>];   </span><br><span class="line">    <span class="keyword">int</span> len;      </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    BigNum()&#123; len = <span class="number">1</span>;<span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="keyword">sizeof</span>(a)); &#125;   </span><br><span class="line">    BigNum(<span class="keyword">const</span> <span class="keyword">int</span>);       </span><br><span class="line">    BigNum(<span class="keyword">const</span> <span class="keyword">char</span>*);    </span><br><span class="line">    BigNum(<span class="keyword">const</span> BigNum &amp;);  </span><br><span class="line">    BigNum &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> BigNum &amp;);  </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">friend</span> istream&amp; <span class="keyword">operator</span>&gt;&gt;(istream&amp;,  BigNum&amp;);   </span><br><span class="line">    <span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp;,  BigNum&amp;);   </span><br><span class="line"> </span><br><span class="line">    BigNum <span class="keyword">operator</span>+(<span class="keyword">const</span> BigNum &amp;) <span class="keyword">const</span>;   </span><br><span class="line">    BigNum <span class="keyword">operator</span>-(<span class="keyword">const</span> BigNum &amp;) <span class="keyword">const</span>;   </span><br><span class="line">    BigNum <span class="keyword">operator</span>*(<span class="keyword">const</span> BigNum &amp;) <span class="keyword">const</span>;   </span><br><span class="line">    BigNum <span class="keyword">operator</span>/(<span class="keyword">const</span> <span class="keyword">int</span>   &amp;) <span class="keyword">const</span>;    </span><br><span class="line"> </span><br><span class="line">    BigNum <span class="keyword">operator</span>^(<span class="keyword">const</span> <span class="keyword">int</span>  &amp;) <span class="keyword">const</span>;    </span><br><span class="line">    ll    <span class="keyword">operator</span>%(<span class="keyword">const</span> <span class="keyword">int</span>  &amp;) <span class="keyword">const</span>;    </span><br><span class="line">    <span class="keyword">bool</span>   <span class="keyword">operator</span>&gt;(<span class="keyword">const</span> BigNum &amp; T)<span class="keyword">const</span>;   </span><br><span class="line">    <span class="keyword">bool</span>   <span class="keyword">operator</span>&gt;(<span class="keyword">const</span> <span class="keyword">int</span> &amp; t)<span class="keyword">const</span>;     </span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>;       </span><br><span class="line">&#125;;</span><br><span class="line">BigNum::BigNum(<span class="keyword">const</span> <span class="keyword">int</span> b)     </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> c,d = b;</span><br><span class="line">    len = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="keyword">sizeof</span>(a));</span><br><span class="line">    <span class="keyword">while</span>(d &gt; MAXN)</span><br><span class="line">    &#123;</span><br><span class="line">        c = d - (d / (MAXN + <span class="number">1</span>)) * (MAXN + <span class="number">1</span>);</span><br><span class="line">        d = d / (MAXN + <span class="number">1</span>);</span><br><span class="line">        a[len++] = c;</span><br><span class="line">    &#125;</span><br><span class="line">    a[len++] = d;</span><br><span class="line">&#125;</span><br><span class="line">BigNum::BigNum(<span class="keyword">const</span> <span class="keyword">char</span>*s)    </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> t,k,index,l,i;</span><br><span class="line">    <span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="keyword">sizeof</span>(a));</span><br><span class="line">    l=<span class="built_in">strlen</span>(s);</span><br><span class="line">    len=l/DLEN;</span><br><span class="line">    <span class="keyword">if</span>(l%DLEN)</span><br><span class="line">        len++;</span><br><span class="line">    index=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=l<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i-=DLEN)</span><br><span class="line">    &#123;</span><br><span class="line">        t=<span class="number">0</span>;</span><br><span class="line">        k=i-DLEN+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(k&lt;<span class="number">0</span>)</span><br><span class="line">            k=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=k;j&lt;=i;j++)</span><br><span class="line">            t=t*<span class="number">10</span>+s[j]-<span class="string">'0'</span>;</span><br><span class="line">        a[index++]=t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">BigNum::BigNum(<span class="keyword">const</span> BigNum &amp; T) : len(T.len) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="keyword">sizeof</span>(a));</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span> ; i &lt; len ; i++)</span><br><span class="line">        a[i] = T.a[i];</span><br><span class="line">&#125;</span><br><span class="line">BigNum &amp; BigNum::<span class="keyword">operator</span>=(<span class="keyword">const</span> BigNum &amp; n)   </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    len = n.len;</span><br><span class="line">    <span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="keyword">sizeof</span>(a));</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span> ; i &lt; len ; i++)</span><br><span class="line">        a[i] = n.a[i];</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">istream&amp; <span class="keyword">operator</span>&gt;&gt;(istream &amp; in,  BigNum &amp; b)   <span class="comment">//�������������</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">char</span> ch[MAXSIZE*<span class="number">4</span>];</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">-1</span>;</span><br><span class="line">    in&gt;&gt;ch;</span><br><span class="line">    <span class="keyword">int</span> l=<span class="built_in">strlen</span>(ch);</span><br><span class="line">    <span class="keyword">int</span> count=<span class="number">0</span>,sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=l<span class="number">-1</span>;i&gt;=<span class="number">0</span>;)</span><br><span class="line">    &#123;</span><br><span class="line">        sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> t=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">4</span>&amp;&amp;i&gt;=<span class="number">0</span>;j++,i--,t*=<span class="number">10</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            sum+=(ch[i]-<span class="string">'0'</span>)*t;</span><br><span class="line">        &#125;</span><br><span class="line">        b.a[count]=sum;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    b.len =count++;</span><br><span class="line">    <span class="keyword">return</span> in;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out,  BigNum&amp; b)   </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; b.a[b.len - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(i = b.len - <span class="number">2</span> ; i &gt;= <span class="number">0</span> ; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>.width(DLEN);</span><br><span class="line">        <span class="built_in">cout</span>.fill(<span class="string">'0'</span>);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; b.a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">BigNum BigNum::<span class="keyword">operator</span>+(<span class="keyword">const</span> BigNum &amp; T) <span class="keyword">const</span>   </span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">BigNum <span class="title">t</span><span class="params">(*<span class="keyword">this</span>)</span></span>;</span><br><span class="line">    <span class="keyword">int</span> i,big;      <span class="comment">//λ��</span></span><br><span class="line">    big = T.len &gt; len ? T.len : len;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span> ; i &lt; big ; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        t.a[i] +=T.a[i];</span><br><span class="line">        <span class="keyword">if</span>(t.a[i] &gt; MAXN)</span><br><span class="line">        &#123;</span><br><span class="line">            t.a[i + <span class="number">1</span>]++;</span><br><span class="line">            t.a[i] -=MAXN+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(t.a[big] != <span class="number">0</span>)</span><br><span class="line">        t.len = big + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        t.len = big;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line">BigNum BigNum::<span class="keyword">operator</span>-(<span class="keyword">const</span> BigNum &amp; T) <span class="keyword">const</span>   </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j,big;</span><br><span class="line">    <span class="keyword">bool</span> flag;</span><br><span class="line">    BigNum t1,t2;</span><br><span class="line">    <span class="keyword">if</span>(*<span class="keyword">this</span>&gt;T)</span><br><span class="line">    &#123;</span><br><span class="line">        t1=*<span class="keyword">this</span>;</span><br><span class="line">        t2=T;</span><br><span class="line">        flag=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        t1=T;</span><br><span class="line">        t2=*<span class="keyword">this</span>;</span><br><span class="line">        flag=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    big=t1.len;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span> ; i &lt; big ; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(t1.a[i] &lt; t2.a[i])</span><br><span class="line">        &#123;</span><br><span class="line">            j = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(t1.a[j] == <span class="number">0</span>)</span><br><span class="line">                j++;</span><br><span class="line">            t1.a[j--]--;</span><br><span class="line">            <span class="keyword">while</span>(j &gt; i)</span><br><span class="line">                t1.a[j--] += MAXN;</span><br><span class="line">            t1.a[i] += MAXN + <span class="number">1</span> - t2.a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            t1.a[i] -= t2.a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    t1.len = big;</span><br><span class="line">    <span class="keyword">while</span>(t1.a[t1.len - <span class="number">1</span>] == <span class="number">0</span> &amp;&amp; t1.len &gt; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        t1.len--;</span><br><span class="line">        big--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(flag)</span><br><span class="line">        t1.a[big<span class="number">-1</span>]=<span class="number">0</span>-t1.a[big<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">return</span> t1;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">BigNum BigNum::<span class="keyword">operator</span>*(<span class="keyword">const</span> BigNum &amp; T) <span class="keyword">const</span>   </span><br><span class="line">&#123;</span><br><span class="line">    BigNum ret;</span><br><span class="line">    <span class="keyword">int</span> i,j,up;</span><br><span class="line">    <span class="keyword">int</span> temp,temp1;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span> ; i &lt; len ; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        up = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span> ; j &lt; T.len ; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            temp = a[i] * T.a[j] + ret.a[i + j] + up;</span><br><span class="line">            <span class="keyword">if</span>(temp &gt; MAXN)</span><br><span class="line">            &#123;</span><br><span class="line">                temp1 = temp - temp / (MAXN + <span class="number">1</span>) * (MAXN + <span class="number">1</span>);</span><br><span class="line">                up = temp / (MAXN + <span class="number">1</span>);</span><br><span class="line">                ret.a[i + j] = temp1;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                up = <span class="number">0</span>;</span><br><span class="line">                ret.a[i + j] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(up != <span class="number">0</span>)</span><br><span class="line">            ret.a[i + j] = up;</span><br><span class="line">    &#125;</span><br><span class="line">    ret.len = i + j;</span><br><span class="line">    <span class="keyword">while</span>(ret.a[ret.len - <span class="number">1</span>] == <span class="number">0</span> &amp;&amp; ret.len &gt; <span class="number">1</span>)</span><br><span class="line">        ret.len--;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line">BigNum BigNum::<span class="keyword">operator</span>/(<span class="keyword">const</span> <span class="keyword">int</span> &amp; b) <span class="keyword">const</span>   </span><br><span class="line">&#123;</span><br><span class="line">    BigNum ret;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    ll down = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = len - <span class="number">1</span> ; i &gt;= <span class="number">0</span> ; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        ret.a[i] = (a[i] + down * (MAXN + <span class="number">1</span>)) / b;</span><br><span class="line">        down = a[i] + down * (MAXN + <span class="number">1</span>) - ret.a[i] * b;</span><br><span class="line">    &#125;</span><br><span class="line">    ret.len = len;</span><br><span class="line">    <span class="keyword">while</span>(ret.a[ret.len - <span class="number">1</span>] == <span class="number">0</span> &amp;&amp; ret.len &gt; <span class="number">1</span>)</span><br><span class="line">        ret.len--;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">ll BigNum::<span class="keyword">operator</span> %(<span class="keyword">const</span> <span class="keyword">int</span> &amp; b) <span class="keyword">const</span>    </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    ll d=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = len<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        d = ((d * (MAXN+<span class="number">1</span>))% b + a[i])% b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line">BigNum BigNum::<span class="keyword">operator</span>^(<span class="keyword">const</span> <span class="keyword">int</span> &amp; n) <span class="keyword">const</span>    </span><br><span class="line">&#123;</span><br><span class="line">    BigNum t,ret(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;<span class="number">0</span>)</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">int</span> m=n;</span><br><span class="line">    <span class="keyword">while</span>(m&gt;<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        t=*<span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">for</span>( i=<span class="number">1</span>;i&lt;&lt;<span class="number">1</span>&lt;=m;i&lt;&lt;=<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            t=t*t;</span><br><span class="line">        &#125;</span><br><span class="line">        m-=i;</span><br><span class="line">        ret=ret*t;</span><br><span class="line">        <span class="keyword">if</span>(m==<span class="number">1</span>)</span><br><span class="line">            ret=ret*(*<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">bool</span> BigNum::<span class="keyword">operator</span>&gt;(<span class="keyword">const</span> BigNum &amp; T) <span class="keyword">const</span>   </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> ln;</span><br><span class="line">    <span class="keyword">if</span>(len &gt; T.len)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(len == T.len)</span><br><span class="line">    &#123;</span><br><span class="line">        ln = len - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(a[ln] == T.a[ln] &amp;&amp; ln &gt;= <span class="number">0</span>)</span><br><span class="line">            ln--;</span><br><span class="line">        <span class="keyword">if</span>(ln &gt;= <span class="number">0</span> &amp;&amp; a[ln] &gt; T.a[ln])</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">bool</span> BigNum::<span class="keyword">operator</span> &gt;(<span class="keyword">const</span> <span class="keyword">int</span> &amp; t) <span class="keyword">const</span>    </span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">BigNum <span class="title">b</span><span class="params">(t)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>&gt;b;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">void</span> BigNum::print()   </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a[len - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(i = len - <span class="number">2</span> ; i &gt;= <span class="number">0</span> ; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>.width(DLEN);</span><br><span class="line">        <span class="built_in">cout</span>.fill(<span class="string">'0'</span>);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> p, a;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    x += y;</span><br><span class="line">    <span class="keyword">if</span>(x &gt;= mod) x -= mod;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">3500</span>;</span><br><span class="line"><span class="keyword">int</span> dp[maxn][maxn][<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line">ll b[maxn];</span><br><span class="line">BigNum tmp;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Sum</span><span class="params">(ll l,ll r)</span> </span>&#123; <span class="keyword">return</span> <span class="number">1l</span>l*(l+r)*(r-l+<span class="number">1</span>)/<span class="number">2</span>%mod; &#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">cal</span><span class="params">(ll l,ll r)</span> </span>&#123;</span><br><span class="line">    l = max(l, <span class="number">0l</span>l);</span><br><span class="line">    <span class="keyword">if</span> (l &gt; r) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    ll tot = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (r &gt;= p - <span class="number">1</span>) tot += (<span class="number">2</span> * p - <span class="number">1</span>) * (r - max(l, p - <span class="number">1l</span>l) + <span class="number">1</span>) - Sum(max(l, p - <span class="number">1l</span>l), r), r = p - <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (l &lt;= r) tot += Sum(l + <span class="number">1</span>, r + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> (tot % mod + mod) % mod;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> len, <span class="keyword">int</span> now, <span class="keyword">bool</span> z, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (len &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span> &amp;&amp; now &gt;= a) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dp[len][now][z][c] != <span class="number">-1</span>) <span class="keyword">return</span> dp[len][now][z][c];</span><br><span class="line">    <span class="keyword">int</span> e = !z ? p - <span class="number">1</span> : b[len];</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (!c) &#123;</span><br><span class="line">        add(res, <span class="number">1l</span>l * cal(<span class="number">0</span>, e - <span class="number">1</span>) * dfs(len - <span class="number">1</span>, now, <span class="number">0</span>, <span class="number">0</span>) % mod);</span><br><span class="line">        add(res, <span class="number">1l</span>l * cal(e, e) * dfs(len - <span class="number">1</span>, now, z, <span class="number">0</span>) % mod);</span><br><span class="line">        add(res, <span class="number">1l</span>l * cal(<span class="number">0</span>, e - <span class="number">2</span>) * dfs(len - <span class="number">1</span>, now, <span class="number">0</span>, <span class="number">1</span>) % mod);</span><br><span class="line">        add(res, <span class="number">1l</span>l * cal(e - <span class="number">1</span>, e - <span class="number">1</span>) * dfs(len - <span class="number">1</span>, now, z, <span class="number">1</span>) % mod);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        add(res, <span class="number">1l</span>l * cal(p, p + e - <span class="number">1</span>) * dfs(len - <span class="number">1</span>, now + <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>) % mod);</span><br><span class="line">        add(res, <span class="number">1l</span>l * cal(p + e, p + e) * dfs(len - <span class="number">1</span>, now + <span class="number">1</span>, z, <span class="number">0</span>) % mod);</span><br><span class="line">        add(res, <span class="number">1l</span>l * cal(p - <span class="number">1</span>, p + e - <span class="number">2</span>) * dfs(len - <span class="number">1</span>, now + <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>) % mod);</span><br><span class="line">        add(res, <span class="number">1l</span>l * cal(p + e - <span class="number">1</span>, p + e - <span class="number">1</span>) * dfs(len - <span class="number">1</span>, now + <span class="number">1</span>, z, <span class="number">1</span>) % mod);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    dp[len][now][z][c] = res;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> len;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    len = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">-1</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">    <span class="keyword">while</span>(tmp &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        b[len++] = tmp % p;</span><br><span class="line">        tmp = tmp / p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dfs(len - <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; p &gt;&gt; a &gt;&gt; tmp;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; solve() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://codeforces.com/contest/582/problem/D&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目链接&lt;/a&gt;&lt;br&gt;思路：&lt;br&gt;先介绍一个定理，不然这个题做不了。&lt;/p&gt;
&lt;h3 id=&quot;库莫尔定理&quot;&gt;&lt;a href=&quot;#库莫尔定理&quot; class=&quot;headerlink&quot; title=&quot;库莫尔定理&quot;&gt;&lt;/a&gt;库莫尔定理&lt;/h3&gt;&lt;p&gt;设m, n为正整数，p为素数，则&lt;script type=&quot;math/tex&quot;&gt;C_{m + n}^m&lt;/script&gt;喊p的幂次等于m + n在p进制下的进位次数。&lt;br&gt;证明：我们发现p是素数，我们知道&lt;script type=&quot;math/tex&quot;&gt;C_{m + n}^n = \frac{(m + n)!}{m!n!}&lt;/script&gt;，那么&lt;script type=&quot;math/tex&quot;&gt;C_{m + n}^n&lt;/script&gt;含有p的幂次等于&lt;script type=&quot;math/tex&quot;&gt;\sum_{i = 1}^{\infty}\lfloor\frac{n + m}{p^i}\rfloor - \lfloor\frac{n}{p^i}\rfloor - \lfloor\frac{m}{p^i}\rfloor&lt;/script&gt;&lt;br&gt;我们发现对于每一个i，答案不会超过1，考虑什么时候为1，可以发现是在p进制下第i位发生进位时取到。&lt;/p&gt;
&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;这一类题目都是库莫尔定理 + 数位dp的，考虑dp[i][j][k][l]表示考虑了前i个位置，进了j次位，前面已经等于/小于边界，上一位是否需要进位。那么剩下的问题就是转移的时候的组合数，即我们要统计在这一位有多少对(k, n)满足条件（可能有进位，并且另一个位置还要在可行范围内），可以以p为边界分开计算，然后转移即可。&lt;br&gt;
    
    </summary>
    
      <category term="数位dp" scheme="http://yoursite.com/categories/%E6%95%B0%E4%BD%8Ddp/"/>
    
    
  </entry>
  
  <entry>
    <title>XX Open Cup named after E.V. Pankratiev. Grand Prix of Korea, Division 1-I(Minimum Diameter Spanning Tree)</title>
    <link href="http://yoursite.com/2020/03/25/XX-Open-Cup-named-after-E-V-Pankratiev-Grand-Prix-of-Korea-Division-1-I-Minimum-Diameter-Spanning-Tree/"/>
    <id>http://yoursite.com/2020/03/25/XX-Open-Cup-named-after-E-V-Pankratiev-Grand-Prix-of-Korea-Division-1-I-Minimum-Diameter-Spanning-Tree/</id>
    <published>2020-03-25T14:03:49.000Z</published>
    <updated>2020-03-25T15:03:13.703Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://opentrains.snarknews.info/~ejudge/team.cgi?SID=31680f20e424e9b8&amp;action=2" target="_blank" rel="noopener">题目链接</a><br>思路：最小直径生成树也算是一个比较固定的东西了。考虑要求最小直径。一个比较容易想到的做法是求某个点，剩下点中最短路最大的两个点组成直径。但是发现显然是错的，因为最大的两个最短路可能共用了一些边，不符合直径的定义。最小直径生成树其实其实有一个等价的定义，图的绝对中心，就是图上到各点距离最大值最小的点，这个绝对中心可以在边上。很显然，绝对中心到其他点的距离最大值会出现两次。最小直径生成树的直径就是绝对中心到其他点的距离最大值*2。那么我们只要求出绝对中心，这题就解决了。<br>我们考虑枚举一条边(u, v)，找两个点x, y到u, v。首先我们可以发现，如果某个点到u, v的距离均大于另一个点到u, v的距离，那么另一个点就不可能成为x或者y，换言之，成为决策的点中，按到u距离从小到大排序，那么它们到v的距离一定是从大到小的。<br>那么考虑另一个问题，就是怎么判断x, y是否共用了一些边作为它们的最短路呢，我们发现，如果x到u的距离大于y到u的距离，x到v的距离却小于y到v的距离，那么它们一定是从边(u, v)两侧过来的，不会共用最短路边。而我们要求的是加起来最大的值，前面又说过，它们到u，v距离增减性是刚好反过来的。所以我们只需要枚举相邻的即可。<br>另一种理解可以看这个图：<br><img src="images/11.png" alt=""><br>这是已经删掉无用点后的图，其实也就是求每个峰对应的答案。<br>写代码的时候并不用真的删点，只需要记录一下上一次用过的在哪里就行了。<br>还有一个问题就是求出了最小直径生成树的直径，怎么求最小直径生成树呢？答案就是从<strong>绝对中心</strong>开始跑一边最短路径树就行了，记住是绝对中心不是u或者v开始跑。<br><a id="more"></a><br>代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> db;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vi;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;ll&gt; vl;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;pii&gt; vp;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">const</span> ll INF = <span class="number">1e18</span>;</span><br><span class="line"><span class="keyword">const</span> db eps = <span class="number">1e-10</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> eb emplace_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ep emplace</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mem(a) memset(a, 0, sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> copy(a, b) memcpy(a, b, sizeof(b))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PA cout &lt;&lt; <span class="meta-string">"pass\n"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lowbit(x) (x &amp; -x)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(x) x.begin(), x.end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TM cout &lt;&lt; db(clock()) / CLOCKS_PER_SEC &lt;&lt; <span class="meta-string">'\n'</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">mt19937 <span class="title">mrand</span><span class="params">(chrono::high_resolution_clock::now().time_since_epoch().count())</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;<span class="title">inline</span> <span class="title">void</span> <span class="title">upmin</span>(<span class="title">T</span> &amp;<span class="title">x</span>, <span class="title">T</span> <span class="title">y</span>) &#123;</span>x = x &gt; y ? y : x;&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;<span class="title">inline</span> <span class="title">void</span> <span class="title">upmax</span>(<span class="title">T</span> &amp;<span class="title">x</span>, <span class="title">T</span> <span class="title">y</span>) &#123;</span>x = x &lt; y ? y : x;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">505</span>;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">MSDT</span>&#123;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pdi pair<span class="meta-string">&lt;double, int&gt;</span></span></span><br><span class="line"></span><br><span class="line">    T dp[maxn][maxn];</span><br><span class="line">    <span class="keyword">int</span> ord[maxn][maxn];</span><br><span class="line">    <span class="keyword">int</span> mp[maxn][maxn];</span><br><span class="line">    <span class="keyword">double</span> d[maxn];</span><br><span class="line">    <span class="keyword">int</span> s, t;</span><br><span class="line">    T infinity;</span><br><span class="line">    <span class="keyword">int</span> pre[maxn];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(T infinity)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;infinity = infinity;</span><br><span class="line">        <span class="built_in">memset</span>(mp, <span class="number">-1</span>, <span class="keyword">sizeof</span>(mp));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)&#123;</span><br><span class="line">                dp[i][j] = infinity;</span><br><span class="line">            &#125;</span><br><span class="line">            dp[i][i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">floyd</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; k++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)&#123;</span><br><span class="line">                    dp[i][j] = min(dp[i][j], dp[i][k] + dp[k][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">T <span class="title">center</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) ord[i][j] = j;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = j + <span class="number">1</span>; k &lt;= n; k++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(dp[i][ord[i][j]] &gt; dp[i][ord[i][k]]) swap(ord[i][j], ord[i][k]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        T ans = infinity;</span><br><span class="line">        s = t = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dp[i][ord[i][n]] * <span class="number">2</span> &lt; ans)&#123;</span><br><span class="line">                ans = dp[i][ord[i][n]] * <span class="number">2</span>;</span><br><span class="line">                s = t = i;</span><br><span class="line">                d[s] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(mp[i][j] != <span class="number">-1</span>)&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> cmp = n, k = n - <span class="number">1</span>; k &gt;= <span class="number">1</span>; k--)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(dp[j][ord[i][k]] &gt; dp[j][ord[i][cmp]])&#123;</span><br><span class="line">                            T tmp = dp[i][ord[i][k]] + dp[j][ord[i][cmp]] + mp[i][j];</span><br><span class="line">                            <span class="keyword">if</span>(tmp &lt; ans)&#123;</span><br><span class="line">                                ans = tmp;</span><br><span class="line">                                s = i;</span><br><span class="line">                                t = j;</span><br><span class="line">                                d[s] = (<span class="keyword">double</span>)tmp / <span class="number">2</span> - dp[i][ord[i][k]];</span><br><span class="line">                                d[t] = (<span class="keyword">double</span>)mp[i][j] - d[s];</span><br><span class="line">                            &#125;</span><br><span class="line">                            cmp = k;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dijskra</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i != s &amp;&amp; i != t) d[i] = infinity;</span><br><span class="line">        &#125;</span><br><span class="line">        priority_queue&lt;pdi, <span class="built_in">vector</span>&lt;pdi&gt;, greater&lt;pdi&gt; &gt; q;</span><br><span class="line">        <span class="built_in">memset</span>(pre, <span class="number">-1</span>, <span class="keyword">sizeof</span>(pre));</span><br><span class="line">        q.ep(d[s], s);</span><br><span class="line">        <span class="keyword">if</span>(s != t)&#123;</span><br><span class="line">            q.ep(d[t], t);</span><br><span class="line">            pre[t] = s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">            pdi now = q.top();</span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="keyword">int</span> u = now.se;</span><br><span class="line">            <span class="keyword">if</span>(d[u] &lt; now.fi) <span class="keyword">continue</span>;</span><br><span class="line">            d[u] = now.fi;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> v = <span class="number">1</span>; v &lt;= n; v++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(mp[u][v] != <span class="number">-1</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(d[v] &gt; d[u] + mp[u][v])&#123;</span><br><span class="line">                        d[v] = d[u] + mp[u][v];</span><br><span class="line">                        pre[v] = u;</span><br><span class="line">                        q.ep(d[v], v);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(pre[i] != <span class="number">-1</span>) <span class="built_in">cout</span> &lt;&lt; pre[i] &lt;&lt; <span class="string">' '</span> &lt;&lt; i &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">        floyd();</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; center() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">        dijskra();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">MSDT&lt;ll&gt; sol;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>), <span class="built_in">cin</span>.tie(<span class="number">0</span>), <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; fixed &lt;&lt; setprecision(<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    sol.init(INF);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> u, v, w;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">        sol.mp[u][v] = sol.mp[v][u] = sol.dp[u][v] = sol.dp[v][u] = w;</span><br><span class="line">    &#125;</span><br><span class="line">    sol.solve();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://opentrains.snarknews.info/~ejudge/team.cgi?SID=31680f20e424e9b8&amp;amp;action=2&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目链接&lt;/a&gt;&lt;br&gt;思路：最小直径生成树也算是一个比较固定的东西了。考虑要求最小直径。一个比较容易想到的做法是求某个点，剩下点中最短路最大的两个点组成直径。但是发现显然是错的，因为最大的两个最短路可能共用了一些边，不符合直径的定义。最小直径生成树其实其实有一个等价的定义，图的绝对中心，就是图上到各点距离最大值最小的点，这个绝对中心可以在边上。很显然，绝对中心到其他点的距离最大值会出现两次。最小直径生成树的直径就是绝对中心到其他点的距离最大值*2。那么我们只要求出绝对中心，这题就解决了。&lt;br&gt;我们考虑枚举一条边(u, v)，找两个点x, y到u, v。首先我们可以发现，如果某个点到u, v的距离均大于另一个点到u, v的距离，那么另一个点就不可能成为x或者y，换言之，成为决策的点中，按到u距离从小到大排序，那么它们到v的距离一定是从大到小的。&lt;br&gt;那么考虑另一个问题，就是怎么判断x, y是否共用了一些边作为它们的最短路呢，我们发现，如果x到u的距离大于y到u的距离，x到v的距离却小于y到v的距离，那么它们一定是从边(u, v)两侧过来的，不会共用最短路边。而我们要求的是加起来最大的值，前面又说过，它们到u，v距离增减性是刚好反过来的。所以我们只需要枚举相邻的即可。&lt;br&gt;另一种理解可以看这个图：&lt;br&gt;&lt;img src=&quot;images/11.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;这是已经删掉无用点后的图，其实也就是求每个峰对应的答案。&lt;br&gt;写代码的时候并不用真的删点，只需要记录一下上一次用过的在哪里就行了。&lt;br&gt;还有一个问题就是求出了最小直径生成树的直径，怎么求最小直径生成树呢？答案就是从&lt;strong&gt;绝对中心&lt;/strong&gt;开始跑一边最短路径树就行了，记住是绝对中心不是u或者v开始跑。&lt;br&gt;
    
    </summary>
    
      <category term="最小生成树" scheme="http://yoursite.com/categories/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"/>
    
    
  </entry>
  
  <entry>
    <title>深入浅出欧拉回路</title>
    <link href="http://yoursite.com/2020/03/25/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E6%AC%A7%E6%8B%89%E5%9B%9E%E8%B7%AF/"/>
    <id>http://yoursite.com/2020/03/25/深入浅出欧拉回路/</id>
    <published>2020-03-25T13:42:36.000Z</published>
    <updated>2020-03-25T13:59:44.985Z</updated>
    
    <content type="html"><![CDATA[<h3 id="欧拉回路"><a href="#欧拉回路" class="headerlink" title="欧拉回路"></a>欧拉回路</h3><p>欧拉回路简单来说就是一笔画问题，要求一条路径使得每条边都刚好经过一次。</p><h4 id="无向图"><a href="#无向图" class="headerlink" title="无向图"></a>无向图</h4><p>无向图有欧拉回路当且仅当每个顶点度数为偶数</p><h4 id="有向图"><a href="#有向图" class="headerlink" title="有向图"></a>有向图</h4><p>无向图有欧拉回路当且仅当每个点入度等于出度</p><h3 id="Hierholzer算法"><a href="#Hierholzer算法" class="headerlink" title="Hierholzer算法"></a>Hierholzer算法</h3><p>Hierholzer算法是一种高效求解欧拉回路的算法，复杂度为<script type="math/tex">O(E)</script>。</p><h4 id="Hierholzer算法流程"><a href="#Hierholzer算法流程" class="headerlink" title="Hierholzer算法流程"></a>Hierholzer算法流程</h4><p>1、随便选择一个点作为初始点。<br>2、进行dfs，将走过的点标记，只能走没有标记过的边（无向图需要来回都标记）。<br>3、当做完所有边后，将该点压栈。<br>4、将栈从栈底到栈顶输出，即是一条欧拉回路。</p><p>感觉也没啥正确性证明的，因为算法本身模拟的路径就是欧拉回路。。。</p><h4 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h4><p>dfs的时候对边要进行当前弧优化！看了网上一半以上的板子都是错的，估计也是很少被卡。但是不进行弧优化的复杂度确实是错的。</p><a id="more"></a><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(; cur[u] &lt; G[u].size(); cur[u]++)&#123;</span><br><span class="line">        <span class="keyword">int</span> i = G[u][cur[u]];</span><br><span class="line">        edge &amp;e = edges[i];</span><br><span class="line">        <span class="keyword">if</span>(vis[i] || vis[i ^ <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">        vis[i] = <span class="number">1</span>;</span><br><span class="line">        dfs(e.to);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Fluery"><a href="#Fluery" class="headerlink" title="Fluery"></a>Fluery</h3><p>不想写了，感觉这算法听弱智的，复杂度也高，没啥必要。。。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;欧拉回路&quot;&gt;&lt;a href=&quot;#欧拉回路&quot; class=&quot;headerlink&quot; title=&quot;欧拉回路&quot;&gt;&lt;/a&gt;欧拉回路&lt;/h3&gt;&lt;p&gt;欧拉回路简单来说就是一笔画问题，要求一条路径使得每条边都刚好经过一次。&lt;/p&gt;
&lt;h4 id=&quot;无向图&quot;&gt;&lt;a href=&quot;#无向图&quot; class=&quot;headerlink&quot; title=&quot;无向图&quot;&gt;&lt;/a&gt;无向图&lt;/h4&gt;&lt;p&gt;无向图有欧拉回路当且仅当每个顶点度数为偶数&lt;/p&gt;
&lt;h4 id=&quot;有向图&quot;&gt;&lt;a href=&quot;#有向图&quot; class=&quot;headerlink&quot; title=&quot;有向图&quot;&gt;&lt;/a&gt;有向图&lt;/h4&gt;&lt;p&gt;无向图有欧拉回路当且仅当每个点入度等于出度&lt;/p&gt;
&lt;h3 id=&quot;Hierholzer算法&quot;&gt;&lt;a href=&quot;#Hierholzer算法&quot; class=&quot;headerlink&quot; title=&quot;Hierholzer算法&quot;&gt;&lt;/a&gt;Hierholzer算法&lt;/h3&gt;&lt;p&gt;Hierholzer算法是一种高效求解欧拉回路的算法，复杂度为&lt;script type=&quot;math/tex&quot;&gt;O(E)&lt;/script&gt;。&lt;/p&gt;
&lt;h4 id=&quot;Hierholzer算法流程&quot;&gt;&lt;a href=&quot;#Hierholzer算法流程&quot; class=&quot;headerlink&quot; title=&quot;Hierholzer算法流程&quot;&gt;&lt;/a&gt;Hierholzer算法流程&lt;/h4&gt;&lt;p&gt;1、随便选择一个点作为初始点。&lt;br&gt;2、进行dfs，将走过的点标记，只能走没有标记过的边（无向图需要来回都标记）。&lt;br&gt;3、当做完所有边后，将该点压栈。&lt;br&gt;4、将栈从栈底到栈顶输出，即是一条欧拉回路。&lt;/p&gt;
&lt;p&gt;感觉也没啥正确性证明的，因为算法本身模拟的路径就是欧拉回路。。。&lt;/p&gt;
&lt;h4 id=&quot;注意点&quot;&gt;&lt;a href=&quot;#注意点&quot; class=&quot;headerlink&quot; title=&quot;注意点&quot;&gt;&lt;/a&gt;注意点&lt;/h4&gt;&lt;p&gt;dfs的时候对边要进行当前弧优化！看了网上一半以上的板子都是错的，估计也是很少被卡。但是不进行弧优化的复杂度确实是错的。&lt;/p&gt;
    
    </summary>
    
      <category term="欧拉回路" scheme="http://yoursite.com/categories/%E6%AC%A7%E6%8B%89%E5%9B%9E%E8%B7%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>各种最优化方法总结</title>
    <link href="http://yoursite.com/2020/03/22/%E5%90%84%E7%A7%8D%E6%9C%80%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2020/03/22/各种最优化方法总结/</id>
    <published>2020-03-22T08:56:10.000Z</published>
    <updated>2020-03-22T16:23:46.655Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要记录各种最优化方法的原理</p><h3 id="GD"><a href="#GD" class="headerlink" title="GD"></a>GD</h3><h4 id="随机梯度下降法（SGD）"><a href="#随机梯度下降法（SGD）" class="headerlink" title="随机梯度下降法（SGD）"></a>随机梯度下降法（SGD）</h4><script type="math/tex; mode=display">W \leftarrow W - \eta\frac{\partial L}{\partial W}</script><p>SGD其实跟我们最直接的想法一样。梯度是函数在某点指向最大值的向量，那么我们要想要一个W，使得Loss函数值最小，我们就沿着梯度的反方向更新（远离最大值）。<script type="math/tex">\eta</script>是一个参数，用来限制每次更新影响的大小。<br><img src="/mlimg/SGD.png" alt=""><br><img src="/mlimg/SGD1.png" alt=""><br>缺点如上图，因为是固定的参数，所以会绕很多路，最后才能走到最小值点。</p><h4 id="批量梯度下降法（BGD）"><a href="#批量梯度下降法（BGD）" class="headerlink" title="批量梯度下降法（BGD）"></a>批量梯度下降法（BGD）</h4><script type="math/tex; mode=display">W \leftarrow W - \eta\frac{1}{m}\sum_{i = 1}^m\frac{\partial L_i}{\partial W}</script><p>假设一共有m个数据，BGD就是用所有数据直接做一次SGD，换言之就是一次拿一批数据去做SGD的更新。<br>批量的优点是不会绕很多路，但是一次训练要全部数据，花费时间太久。</p><h4 id="小批量梯度下降法（SBGD）"><a href="#小批量梯度下降法（SBGD）" class="headerlink" title="小批量梯度下降法（SBGD）"></a>小批量梯度下降法（SBGD）</h4><p>那有没有方法将前面两种的优点结合一下呢。显然做法是一次用一个小数据集来训练，这样既避免了绕很多路，训练时间也相对可以接受一点。式子与BGD是一样的，不过m代表一个mini_batch的数据大小。<br><img src="/mlimg/SBGD.png" alt=""></p><h3 id="Momentum"><a href="#Momentum" class="headerlink" title="Momentum"></a>Momentum</h3><h4 id="普通Momentum"><a href="#普通Momentum" class="headerlink" title="普通Momentum"></a>普通Momentum</h4><p>Momentum也成为动量法，它借鉴了物理上关于位移-速度-加速度的原理，L相当于是位移，W相当于是加速度。位移和加速度实际上是没有本质上的联系，必须通过速度建立连接。</p><script type="math/tex; mode=display">v\leftarrow\alpha v - \eta\frac{\partial L}{\partial W}</script><script type="math/tex; mode=display">W \leftarrow W + v</script><p><img src="/mlimg/Momentum.png" alt=""><br>看图可知与SGD相比，Momentum绕路的程度有所改善。</p><h4 id="Nesterov"><a href="#Nesterov" class="headerlink" title="Nesterov"></a>Nesterov</h4><p>普通动量就是算当前点的梯度，但Nesterov认为即使当前梯度为0，由于动量存在，梯度依然会更新。就好像物理中即使速度为0，但由于加速度不为0，所以物体还是会运动。</p><script type="math/tex; mode=display">now\_x \leftarrow x + \alpha v</script><script type="math/tex; mode=display">v\leftarrow\alpha v - \eta\frac{\partial L}{\partial W}(now\_x处)</script><script type="math/tex; mode=display">W \leftarrow W + v</script><h3 id="AdaGrad-amp-RMSProp-amp-ADAM"><a href="#AdaGrad-amp-RMSProp-amp-ADAM" class="headerlink" title="AdaGrad &amp; RMSProp &amp; ADAM"></a>AdaGrad &amp; RMSProp &amp; ADAM</h3><h4 id="AdaGrad"><a href="#AdaGrad" class="headerlink" title="AdaGrad"></a>AdaGrad</h4><p>之前式子中的<script type="math/tex">\eta</script>，实际上是被称为学习率。神经网络学习中，学习率是个非常重要的参数。学习率过小，会花费过多时间学习，学习率过大，会导致学习发散不能正确学习。<br>AdaGrad采用了学习率衰减的方法，即越早学习率越高，越晚学习率越低。其实这个很好理解，就好比我先给你指一个大概的方向，你往这个方法大步走，保证大方向不会错。当越接近目标时，就走的越来越小心，即学习得越来越慢。</p><script type="math/tex; mode=display">h \leftarrow h + \frac{\partial L}{\partial W} \odot \frac{\partial L}{\partial W}</script><script type="math/tex; mode=display">W \leftarrow W - \eta\frac{1}{\sqrt(h)}\frac{\partial L}{\partial W}</script><p><img src="/mlimg/AdaGrad.png" alt=""><br>也可以参考原论文的方式，大同小异。<br>当更新次数越多，h就越大，W的学习率就越小。<br><img src="/mlimg/AdaGrad1.png" alt=""><br>如图所示，绕路现象基本已经很微弱了。</p><h4 id="RMSProp"><a href="#RMSProp" class="headerlink" title="RMSProp"></a>RMSProp</h4><p>RMSProp是对AdaGrad的一种改进。</p><script type="math/tex; mode=display">h \leftarrow \rho h + (1 - \rho)\frac{\partial L}{\partial W} \odot \frac{\partial L}{\partial W}</script><script type="math/tex; mode=display">W \leftarrow W - \eta\frac{1}{\sqrt(h)}\frac{\partial L}{\partial W}</script><p><img src="/mlimg/RMSProp.png" alt=""><br>RMSProp算法不是像AdaGrad算法那样暴力直接的累加平方梯度，而是加了一个衰减系数来控制历史信息的获取多少。<br>据说RMSProp在非凸条件下表现非常好，而神经网络都是非凸的，不是很懂为什么。。。<br>起到的效果是在参数空间更为平缓的方向，会取得更大的进步（因为平缓，所以历史梯度平方和较小，对应学习下降的幅度较小），并且能够使得陡峭的方向变得平缓，从而加快训练速度。</p><h4 id="ADAM"><a href="#ADAM" class="headerlink" title="ADAM"></a>ADAM</h4><p>ADAM是RMSProp和AdaGrad的一个结合，综合了二者的优点。<br><img src="/mlimg/ADAM.png" alt=""><br>原论文描述<br><img src="/mlimg/ADAM1.png" alt=""><br>具体原理不是很懂，挖坑，先意会一下。。。<br>整体来说，ADAM是现在最主流使用的方法。<br><img src="/mlimg/ADAM2.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文主要记录各种最优化方法的原理&lt;/p&gt;
&lt;h3 id=&quot;GD&quot;&gt;&lt;a href=&quot;#GD&quot; class=&quot;headerlink&quot; title=&quot;GD&quot;&gt;&lt;/a&gt;GD&lt;/h3&gt;&lt;h4 id=&quot;随机梯度下降法（SGD）&quot;&gt;&lt;a href=&quot;#随机梯度下降法（SGD）&quot; cla
      
    
    </summary>
    
      <category term="机器学习" scheme="http://yoursite.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>Codeforces Round 290 (Div. 1)-D(Fox And Travelling)</title>
    <link href="http://yoursite.com/2020/03/20/Codeforces-Round-290-Div-1-D-Fox-And-Travelling/"/>
    <id>http://yoursite.com/2020/03/20/Codeforces-Round-290-Div-1-D-Fox-And-Travelling/</id>
    <published>2020-03-20T15:47:40.000Z</published>
    <updated>2020-03-20T15:52:52.944Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://codeforces.com/contest/512/problem/D" target="_blank" rel="noopener">题目链接</a><br>思路：考虑能到的点抽出来构成一个森林，并且每个树分为两种，有根和无根。有根我们发现直接树形dp，树上背包合并一下即可。无根的考虑把每一个点当成根，我们发现，一种方案有x个点，会被统计sz - x次(x &lt; sz)，x = sz时刚好会被统计一次。所以我们把一整个树拿出来，每个点来树形dp，然后再合并到答案上去即可。关于合并时的方法数计算，可以用组合公式推，但一个更简单的方法是可以预处理f[i][j]表示i个和j个合并的方案数，这个非常好递推。<br><a id="more"></a><br>代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> db;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vi;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;ll&gt; vl;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;pii&gt; vp;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">const</span> ll INF = <span class="number">1e18</span>;</span><br><span class="line"><span class="keyword">const</span> db eps = <span class="number">1e-10</span>;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> eb emplace_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ep emplace</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mem(a) memset(a, 0, sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> copy(a, b) memcpy(a, b, sizeof(b))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PA cout &lt;&lt; <span class="meta-string">"pass\n"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lowbit(x) (x &amp; -x)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(x) x.begin(), x.end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TM cout &lt;&lt; db(clock()) / CLOCKS_PER_SEC &lt;&lt; <span class="meta-string">'\n'</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function">mt19937 <span class="title">mrand</span><span class="params">(chrono::high_resolution_clock::now().time_since_epoch().count())</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;<span class="title">inline</span> <span class="title">void</span> <span class="title">upmin</span>(<span class="title">T</span> &amp;<span class="title">x</span>, <span class="title">T</span> <span class="title">y</span>) &#123;</span>x = x &gt; y ? y : x;&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;<span class="title">inline</span> <span class="title">void</span> <span class="title">upmax</span>(<span class="title">T</span> &amp;<span class="title">x</span>, <span class="title">T</span> <span class="title">y</span>) &#123;</span>x = x &lt; y ? y : x;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">105</span>;</span><br><span class="line"><span class="keyword">int</span> f[maxn][maxn], dp[maxn][maxn];</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">9</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    x += y;</span><br><span class="line">    <span class="keyword">if</span>(x &gt;= mod) x -= mod;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pow_mod</span><span class="params">(<span class="keyword">int</span> q, <span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(w)&#123;</span><br><span class="line">        <span class="keyword">if</span>(w &amp; <span class="number">1</span>) ret = <span class="number">1l</span>l * ret * q % mod;</span><br><span class="line">        q = <span class="number">1l</span>l * q * q % mod;</span><br><span class="line">        w &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line">vi G[maxn];</span><br><span class="line"><span class="keyword">int</span> deg[maxn];</span><br><span class="line"><span class="keyword">bool</span> vis[maxn], ok[maxn];</span><br><span class="line"><span class="keyword">int</span> sz[maxn];</span><br><span class="line"><span class="keyword">int</span> res[maxn];</span><br><span class="line"><span class="keyword">int</span> ans[maxn];</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="keyword">if</span>(deg[i] &lt;= <span class="number">1</span>) q.ep(i);</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> x = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">if</span>(vis[x]) <span class="keyword">continue</span>;</span><br><span class="line">        vis[x] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : G[x])&#123;</span><br><span class="line">            --deg[v];</span><br><span class="line">            <span class="keyword">if</span>(deg[v] == <span class="number">1</span>) q.ep(v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa, <span class="keyword">bool</span> z)</span></span>&#123;</span><br><span class="line">    sz[u] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(z) ok[u] = <span class="number">1</span>;</span><br><span class="line">    dp[u][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> v : G[u])&#123;</span><br><span class="line">        <span class="keyword">if</span>(v == fa || !vis[v]) <span class="keyword">continue</span>;</span><br><span class="line">        dfs(v, u, z);</span><br><span class="line">        sz[u] += sz[v];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = sz[u]; j &gt;= <span class="number">0</span>; j--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= min(sz[v], j); k++)&#123;</span><br><span class="line">                add(dp[u][j], <span class="number">1l</span>l * dp[u][j - k] * dp[v][k] % mod * f[j - k][k] % mod);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    add(dp[u][sz[u]], dp[u][sz[u] - <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getans</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">    mem(dp);</span><br><span class="line">    dfs(u, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= n; j++) add(ans[j], dp[u][j]);</span><br><span class="line">    ok[u] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> v : G[u])&#123;</span><br><span class="line">        <span class="keyword">if</span>(v == fa) <span class="keyword">continue</span>;</span><br><span class="line">        cnt += getans(v, u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>), <span class="built_in">cin</span>.tie(<span class="number">0</span>), <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; fixed &lt;&lt; setprecision(<span class="number">10</span>);</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; maxn; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; maxn; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i) add(f[i][j], f[i - <span class="number">1</span>][j]);</span><br><span class="line">            <span class="keyword">if</span>(j) add(f[i][j], f[i][j - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> u, v;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v;</span><br><span class="line">        G[u].eb(v);</span><br><span class="line">        G[v].eb(u);</span><br><span class="line">        deg[u]++, deg[v]++;</span><br><span class="line">    &#125;</span><br><span class="line">    bfs();</span><br><span class="line">    res[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(vis[i]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : G[i])&#123;</span><br><span class="line">            <span class="keyword">if</span>(ok[v] || !vis[v]) <span class="keyword">continue</span>;</span><br><span class="line">            dfs(v, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = n; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= min(sz[v], j); k++)&#123;</span><br><span class="line">                    add(res[j], <span class="number">1l</span>l * res[j - k] * dp[v][k] % mod * f[j - k][k] % mod);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ok[i] || !vis[i]) <span class="keyword">continue</span>;</span><br><span class="line">        mem(ans);</span><br><span class="line">        <span class="keyword">int</span> cnt = getans(i, <span class="number">0</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cnt; j++) ans[j] = <span class="number">1l</span>l * ans[j] * pow_mod(cnt - j, mod - <span class="number">2</span>) % mod;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = n; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= min(cnt, j); k++)&#123;</span><br><span class="line">                add(res[j], <span class="number">1l</span>l * res[j - k] * ans[k] % mod * f[j - k][k] % mod);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; res[i] &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://codeforces.com/contest/512/problem/D&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目链接&lt;/a&gt;&lt;br&gt;思路：考虑能到的点抽出来构成一个森林，并且每个树分为两种，有根和无根。有根我们发现直接树形dp，树上背包合并一下即可。无根的考虑把每一个点当成根，我们发现，一种方案有x个点，会被统计sz - x次(x &amp;lt; sz)，x = sz时刚好会被统计一次。所以我们把一整个树拿出来，每个点来树形dp，然后再合并到答案上去即可。关于合并时的方法数计算，可以用组合公式推，但一个更简单的方法是可以预处理f[i][j]表示i个和j个合并的方案数，这个非常好递推。&lt;br&gt;
    
    </summary>
    
      <category term="树形dp" scheme="http://yoursite.com/categories/%E6%A0%91%E5%BD%A2dp/"/>
    
    
  </entry>
  
  <entry>
    <title>深入SAM &amp; 广义SAM</title>
    <link href="http://yoursite.com/2020/03/19/%E6%B7%B1%E5%85%A5SAM-%E5%B9%BF%E4%B9%89SAM/"/>
    <id>http://yoursite.com/2020/03/19/深入SAM-广义SAM/</id>
    <published>2020-03-19T13:02:39.000Z</published>
    <updated>2020-03-19T14:06:25.283Z</updated>
    
    <content type="html"><![CDATA[<p>一直想借个契机重新了解下认真学下SAM，终于板子出问题了不得不深入探究一下。</p><h3 id="SAM"><a href="#SAM" class="headerlink" title="SAM"></a>SAM</h3><h4 id="SAM的构造"><a href="#SAM的构造" class="headerlink" title="SAM的构造"></a>SAM的构造</h4><p>基本内容先暂时不写吧，以后有空再补</p><h4 id="fail树的性质"><a href="#fail树的性质" class="headerlink" title="fail树的性质"></a>fail树的性质</h4><p>fail树是SAM中最重要的东西（应该是一切自动机算法上最重要的东西）。所以熟悉掌握fail树的性质很有必要。<br>1、树上每个点代表了根据right集合划分出的一个等价类。<br>2、某个点的right集合等于他所有儿子的right集合或者他所有儿子的right集合 + 1（自身）（但广义SAM中不一定，广义SAM正确的写法一个点就可能有多次）。<br>3、两个串的最长公共后缀对应fail树上两节点的lca点内的某个串。<br>4、求某个字串出现了多少次，就是求该串对应点的子树的right集合的大小。<br>5、对于每个点都暴力跳fail链，总复杂度是$O(n\sqrt(n))$</p><h3 id="广义SAM"><a href="#广义SAM" class="headerlink" title="广义SAM"></a>广义SAM</h3><p>其实本文的重点是广义SAM，因为广义SAM各种乱七八糟的写法，大多数都不能完全应对所有情况，主要分析每种写法的问题在哪里。</p><h4 id="间隔符"><a href="#间隔符" class="headerlink" title="间隔符"></a>间隔符</h4><p>简而言之就是SA留下的后遗症，用间隔符把多个串串起来，然后就变成了单串SAM了。这个方法主要是可能会存在各种特判问题，所以非常不推荐，我写不会去写这玩意。。。</p><h4 id="直接last-1"><a href="#直接last-1" class="headerlink" title="直接last = 1"></a>直接last = 1</h4><p>大多数都是直接在不同串插入以前，将last重置为1，然后就按照单串插入去做了，我们先来看看会有什么问题。<br>假设加入两个串：3201和0<br><img src="/images/8.png" alt=""><br>结束后last = 6，很明显我们发现不对，没有任何路径能到6。原因是因为单串SAM构造时，last点一定不可能通过当前加入的点转移到最新的点，因为整个串一定是最新的没有被加入过的，但是多串的时候可能就存在已经加入过的问题，那么当有不连续情况存在时，就会新建节点，将fail上所有关于c的转移全部给到新建节点上，最后就会得到如图情况。<br>如果要做right集合线段树合并等需要在树上对应点操作的事情，就会出问题了，你可能构造的时候做到了点6上，但是最后访问到的是点7，就会出错误。<br>怎么办呢，发现复制的新建点是我们想要的last点，所以特判一下last节点应该是哪个点即可。</p><p>假设加入两个串：3201、0、0<br><img src="/images/9.png" alt=""><br>发现最后6、8都是多余的状态，所以还可能产生某些多余的状态。</p><p>如果我们要统计各个点出现次数，只要我们不用基数排序，dfs或者拓扑排序都不会出现问题，因为他的链接是对的，只是出现了多余的状态，但不会有路径能走的到多余的状态。</p><p>正确如下：<br><img src="/images/10.png" alt=""><br>last最后是7不是6，也不会产生多余状态，这样就需要在SAM里多两个特判就行了。</p><p>好像还有关于bfs和dfs建广义SAM的区别，后面有空再补。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一直想借个契机重新了解下认真学下SAM，终于板子出问题了不得不深入探究一下。&lt;/p&gt;
&lt;h3 id=&quot;SAM&quot;&gt;&lt;a href=&quot;#SAM&quot; class=&quot;headerlink&quot; title=&quot;SAM&quot;&gt;&lt;/a&gt;SAM&lt;/h3&gt;&lt;h4 id=&quot;SAM的构造&quot;&gt;&lt;a href
      
    
    </summary>
    
      <category term="后缀自动机" scheme="http://yoursite.com/categories/%E5%90%8E%E7%BC%80%E8%87%AA%E5%8A%A8%E6%9C%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>Codeforces Round 286 (Div. 1)-C(Mr. Kitayuta vs. Bamboos)</title>
    <link href="http://yoursite.com/2020/03/16/Codeforces-Round-286-Div-1-C-Mr-Kitayuta-vs-Bamboos/"/>
    <id>http://yoursite.com/2020/03/16/Codeforces-Round-286-Div-1-C-Mr-Kitayuta-vs-Bamboos/</id>
    <published>2020-03-16T15:26:44.000Z</published>
    <updated>2020-03-16T15:34:10.992Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://codeforces.com/contest/506/problem/C" target="_blank" rel="noopener">题目链接</a><br>思路：因为有小于0就取0的限制，使得这个题非常不好做。考虑小于0取0，实际上是让你赚了一部分，如果二分答案mid，最后如果每一根都小于某个值，我们发现他最多赚了mid - x，我们将赚的这部分放到最后去，再倒过来做，那么这时我们发现整个过程就不能有小于0的时候，因为一旦有代表那个位置你必须变为0，最后结果一定会大于mid，所以我们发现这样做就把小于0取0的限制去掉了，原问题变成了从mid开始逆过程，不能有小于0的部分，最后结果要大于等于它给你的初始值，我们发现这样的话，每次我们选择最近快要到0的点进行拔高是最优的，一旦后面不需要再拔它就能满足要求了，我们就把它扔掉，最后看集合是否为空即可，用优先队列模拟一下就行了。思想就是通过放缩可以忽略掉某一种操作/某一维的限制。<br><a id="more"></a></p><h1 id="include"><a href="#include" class="headerlink" title="include"></a>include<bits stdc++.h=""></bits></h1><p>using namespace std;</p><p>typedef long long ll;<br>typedef unsigned long long ull;<br>typedef double db;<br>typedef pair<int, int=""> pii;<br>typedef vector<int> vi;<br>typedef vector<ll> vl;<br>typedef vector<pii> vp;<br>const int inf = 1e9;<br>const ll INF = 1e18;<br>const db eps = 1e-10;</pii></ll></int></int,></p><h1 id="define-fi-first"><a href="#define-fi-first" class="headerlink" title="define fi first"></a>define fi first</h1><h1 id="define-se-second"><a href="#define-se-second" class="headerlink" title="define se second"></a>define se second</h1><h1 id="define-pb-push-back"><a href="#define-pb-push-back" class="headerlink" title="define pb push_back"></a>define pb push_back</h1><h1 id="define-eb-emplace-back"><a href="#define-eb-emplace-back" class="headerlink" title="define eb emplace_back"></a>define eb emplace_back</h1><h1 id="define-ep-emplace"><a href="#define-ep-emplace" class="headerlink" title="define ep emplace"></a>define ep emplace</h1><h1 id="define-mem-a-memset-a-0-sizeof-a"><a href="#define-mem-a-memset-a-0-sizeof-a" class="headerlink" title="define mem(a) memset(a, 0, sizeof(a))"></a>define mem(a) memset(a, 0, sizeof(a))</h1><h1 id="define-copy-a-b-memcpy-a-b-sizeof-b"><a href="#define-copy-a-b-memcpy-a-b-sizeof-b" class="headerlink" title="define copy(a, b) memcpy(a, b, sizeof(b))"></a>define copy(a, b) memcpy(a, b, sizeof(b))</h1><h1 id="define-PA-cout-lt-lt-“pass-n”"><a href="#define-PA-cout-lt-lt-“pass-n”" class="headerlink" title="define PA cout &lt;&lt; “pass\n”"></a>define PA cout &lt;&lt; “pass\n”</h1><h1 id="define-lowbit-x-x-amp-x"><a href="#define-lowbit-x-x-amp-x" class="headerlink" title="define lowbit(x) (x &amp; -x)"></a>define lowbit(x) (x &amp; -x)</h1><h1 id="define-all-x-x-begin-x-end"><a href="#define-all-x-x-begin-x-end" class="headerlink" title="define all(x) x.begin(), x.end()"></a>define all(x) x.begin(), x.end()</h1><h1 id="define-TM-cout-lt-lt-db-clock-CLOCKS-PER-SEC-lt-lt-‘-n’"><a href="#define-TM-cout-lt-lt-db-clock-CLOCKS-PER-SEC-lt-lt-‘-n’" class="headerlink" title="define TM cout &lt;&lt; db(clock()) / CLOCKS_PER_SEC &lt;&lt; ‘\n’"></a>define TM cout &lt;&lt; db(clock()) / CLOCKS_PER_SEC &lt;&lt; ‘\n’</h1><p>mt19937 mrand(chrono::high_resolution_clock::now().time_since_epoch().count());</p><p>template<class t="">inline void upmin(T &amp;x, T y) {x = x &gt; y ? y : x;}<br>template<class t="">inline void upmax(T &amp;x, T y) {x = x &lt; y ? y : x;}</class></class></p><p>int now;<br>ll mid;<br>int n, m, p, k;</p><p>struct node{<br>    ll c, cnt, id;<br>    bool operator &lt;(const node &amp;r) const{<br>        return cnt &gt; r.cnt;<br>    }<br>};<br>const int maxn = 1e5 + 233;<br>ll a[maxn], h[maxn];</p><p>bool check(ll x){<br>    priority_queue<node> q;<br>    for (int i = 1; i &lt;= n; ++i) {<br>        if(x - 1ll <em> m </em> a[i] &lt; h[i]) q.push(node{0, x / a[i], i});<br>    }<br>    for(int i = 1; i &lt;= m; i++){<br>        if(q.empty()) return true;<br>        int c = k;<br>        while(!q.empty() &amp;&amp; c—){<br>            node t = q.top();<br>            q.pop();<br>            if(x + t.c <em> p - i </em> a[t.id] &lt; 0) return false;<br>            t.c++;<br>            if(x + t.c <em> p - m </em> a[t.id] &gt;= h[t.id]) continue;<br>            t.cnt = (x + t.c * p) / a[t.id];<br>            q.push(t);<br>        }<br>    }<br>    return q.empty();<br>}</node></p><p>int main(){<br>    ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);<br>    cout &lt;&lt; fixed &lt;&lt; setprecision(10);<br>    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k &gt;&gt; p;<br>    for (int i = 1; i &lt;= n; ++i) {<br>        cin &gt;&gt; h[i] &gt;&gt; a[i];<br>    }<br>    ll l = 0, r = INF, ans = INF;<br>    while(r &gt;= l){<br>        ll mid = r + l &gt;&gt; 1;<br>        if(check(mid)) r = mid - 1, ans = mid;<br>        else l = mid + 1;<br>    }<br>    cout &lt;&lt; ans &lt;&lt; ‘\n’;<br>    return 0;<br>}<br>~~~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://codeforces.com/contest/506/problem/C&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目链接&lt;/a&gt;&lt;br&gt;思路：因为有小于0就取0的限制，使得这个题非常不好做。考虑小于0取0，实际上是让你赚了一部分，如果二分答案mid，最后如果每一根都小于某个值，我们发现他最多赚了mid - x，我们将赚的这部分放到最后去，再倒过来做，那么这时我们发现整个过程就不能有小于0的时候，因为一旦有代表那个位置你必须变为0，最后结果一定会大于mid，所以我们发现这样做就把小于0取0的限制去掉了，原问题变成了从mid开始逆过程，不能有小于0的部分，最后结果要大于等于它给你的初始值，我们发现这样的话，每次我们选择最近快要到0的点进行拔高是最优的，一旦后面不需要再拔它就能满足要求了，我们就把它扔掉，最后看集合是否为空即可，用优先队列模拟一下就行了。思想就是通过放缩可以忽略掉某一种操作/某一维的限制。&lt;br&gt;
    
    </summary>
    
      <category term="贪心" scheme="http://yoursite.com/categories/%E8%B4%AA%E5%BF%83/"/>
    
    
  </entry>
  
  <entry>
    <title>Codeforces Round 310 (Div. 1)-E(Case of Computer Network)</title>
    <link href="http://yoursite.com/2020/03/16/Codeforces-Round-310-Div-1-E-Case-of-Computer-Network/"/>
    <id>http://yoursite.com/2020/03/16/Codeforces-Round-310-Div-1-E-Case-of-Computer-Network/</id>
    <published>2020-03-16T15:19:02.000Z</published>
    <updated>2020-03-16T15:25:29.094Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://codeforces.com/contest/555/problem/E" target="_blank" rel="noopener">题目链接</a><br>思路：考虑如果能形成环，我们肯定愿意形成环，而且环上两点可以任意到达，所以我们发现如果做双连通分量，同一个分量内的两个点一定能满足，问题变成了给一个森林，然后多对起点和终点，让你判断是否能给边定向使得能满足到达。一开始想树剖，后来发现不需要，直接用两个数组树上差分即可，只要不同时大于0就能满足，否则就不能满足。<br>马上要修一下tarjan的板子了。。。<br><a id="more"></a><br>代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> db;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vi;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;ll&gt; vl;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;pii&gt; vp;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">const</span> ll INF = <span class="number">1e18</span>;</span><br><span class="line"><span class="keyword">const</span> db eps = <span class="number">1e-10</span>;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> eb emplace_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ep emplace</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mem(a) memset(a, 0, sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> copy(a, b) memcpy(a, b, sizeof(b))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PA cout &lt;&lt; <span class="meta-string">"pass\n"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lowbit(x) (x &amp; -x)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(x) x.begin(), x.end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TM cout &lt;&lt; db(clock()) / CLOCKS_PER_SEC &lt;&lt; <span class="meta-string">'\n'</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e5</span> + <span class="number">233</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> q, n, m;</span><br><span class="line">vi G[maxn], g[maxn];</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">EBCC</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> dfn[maxn];</span><br><span class="line">    <span class="keyword">int</span> low[maxn];</span><br><span class="line">    <span class="keyword">int</span> sccno[maxn];</span><br><span class="line">    <span class="keyword">int</span> scount[maxn];</span><br><span class="line">    <span class="keyword">int</span> ntime;</span><br><span class="line">    <span class="keyword">int</span> bcc_cnt;</span><br><span class="line">    <span class="keyword">int</span> sta[maxn];</span><br><span class="line">    <span class="keyword">int</span> sz;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">        dfn[u] = low[u] = ++ntime;</span><br><span class="line">        sta[sz++] = u;</span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[u].size(); i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = G[u][i];</span><br><span class="line">            <span class="keyword">if</span>(v == f) &#123;</span><br><span class="line">                flag++;</span><br><span class="line">                <span class="keyword">if</span>(flag == <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!dfn[v]) &#123;</span><br><span class="line">                tarjan(v, u);</span><br><span class="line">                low[u] = min(low[u], low[v]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> low[u] = min(low[u], dfn[v]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (low[u] == dfn[u]) &#123;</span><br><span class="line">            bcc_cnt++;</span><br><span class="line">            <span class="keyword">int</span> tmp;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                --sz;</span><br><span class="line">                tmp = sta[sz];</span><br><span class="line">                sccno[tmp] = bcc_cnt;</span><br><span class="line">                scount[bcc_cnt]++;</span><br><span class="line">            &#125; <span class="keyword">while</span> (tmp != u);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">find_bcc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sz = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(sccno, <span class="number">0</span>, <span class="keyword">sizeof</span>(sccno));</span><br><span class="line">        <span class="built_in">memset</span>(dfn, <span class="number">0</span>, <span class="keyword">sizeof</span>(dfn));</span><br><span class="line">        <span class="built_in">memset</span>(scount, <span class="number">0</span>, <span class="keyword">sizeof</span>(scount));</span><br><span class="line">        ntime = bcc_cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)<span class="keyword">if</span> (!dfn[i]) tarjan(i, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;sol;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> f[maxn][<span class="number">20</span>];</span><br><span class="line"><span class="keyword">int</span> bel[maxn], idx;</span><br><span class="line"><span class="keyword">int</span> d[maxn];</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">19</span>; i++) f[u][i] = f[f[u][i - <span class="number">1</span>]][i - <span class="number">1</span>];</span><br><span class="line">    bel[u] = idx;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;v : g[u])&#123;</span><br><span class="line">        <span class="keyword">if</span>(!bel[v])d[v] = d[u] + <span class="number">1</span>, f[v][<span class="number">0</span>] = u, dfs(v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lca</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(d[x] &gt; d[y]) swap(x, y);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">19</span>; i &gt;= <span class="number">0</span>; i--) <span class="keyword">if</span>(d[f[y][i]] &gt;= d[x]) y = f[y][i];</span><br><span class="line">    <span class="keyword">if</span>(x == y) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">19</span>; i &gt;= <span class="number">0</span>; i--) <span class="keyword">if</span>(f[x][i] != f[y][i]) x = f[x][i], y = f[y][i];</span><br><span class="line">    <span class="keyword">return</span> f[x][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> a[maxn], b[maxn];</span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getans</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">    vis[u] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;v : g[u])&#123;</span><br><span class="line">        <span class="keyword">if</span>(!vis[v]) getans(v), a[u] += a[v], b[u] += b[v];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> u[maxn], v[maxn];</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>), <span class="built_in">cin</span>.tie(<span class="number">0</span>), <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; fixed &lt;&lt; setprecision(<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; u[i] &gt;&gt; v[i];</span><br><span class="line">        G[u[i]].eb(v[i]);</span><br><span class="line">        G[v[i]].eb(u[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    sol.find_bcc();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(sol.sccno[u[i]] == sol.sccno[v[i]]) <span class="keyword">continue</span>;</span><br><span class="line">        g[sol.sccno[u[i]]].eb(sol.sccno[v[i]]);</span><br><span class="line">        g[sol.sccno[v[i]]].eb(sol.sccno[u[i]]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= sol.bcc_cnt; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!bel[i]) ++idx, d[i] = <span class="number">1</span>, dfs(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">        <span class="keyword">int</span> x, y;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        x = sol.sccno[x];</span><br><span class="line">        y = sol.sccno[y];</span><br><span class="line">        <span class="keyword">if</span>(x == y) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(bel[x] != bel[y])&#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"No\n"</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> lc = lca(x, y);</span><br><span class="line">        a[x]++;</span><br><span class="line">        a[lc]--;</span><br><span class="line">        b[y]++;</span><br><span class="line">        b[lc]--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= sol.bcc_cnt; i++) <span class="keyword">if</span>(!vis[i]) getans(i);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= sol.bcc_cnt; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i] &amp;&amp; b[i])&#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"No\n"</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Yes\n"</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://codeforces.com/contest/555/problem/E&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目链接&lt;/a&gt;&lt;br&gt;思路：考虑如果能形成环，我们肯定愿意形成环，而且环上两点可以任意到达，所以我们发现如果做双连通分量，同一个分量内的两个点一定能满足，问题变成了给一个森林，然后多对起点和终点，让你判断是否能给边定向使得能满足到达。一开始想树剖，后来发现不需要，直接用两个数组树上差分即可，只要不同时大于0就能满足，否则就不能满足。&lt;br&gt;马上要修一下tarjan的板子了。。。&lt;br&gt;
    
    </summary>
    
      <category term="tarjan强连通分量" scheme="http://yoursite.com/categories/tarjan%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>Codeforces Round 319 (Div. 1)-D(Flights for Regular Customers)</title>
    <link href="http://yoursite.com/2020/03/16/Codeforces-Round-319-Div-1-D-Flights-for-Regular-Customers/"/>
    <id>http://yoursite.com/2020/03/16/Codeforces-Round-319-Div-1-D-Flights-for-Regular-Customers/</id>
    <published>2020-03-16T15:11:36.000Z</published>
    <updated>2020-03-16T15:36:06.218Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://codeforces.com/contest/576/problem/D" target="_blank" rel="noopener">题目链接</a><br>思路：已经忘了最基本的邻接矩阵的性质了，真的服了自己了。。<br>可达矩阵中的$A_{ij}为1表示从i可以走到j$，$A^n_{ij}为1表示从i可以走恰好n步走到j$，如果是从某一些点出发，我们需要维护一个初始矩阵，能作为出发点的$i，base_{ii} = 1$，转移矩阵就是用来维护走x步后能从哪些点走到哪些点。<br>考虑本题，转移矩阵最多有m种，每种我们都可以得到从1开始能到达的位置，然后从这些位置bfs一下更新最小值，不同种转移矩阵用矩阵快速幂进行转移即可。考虑是可达矩阵，只有0/1两个值，所以可以用bitset优化，复杂度$O(\frac{n^3mlog(m)}{w})$<br><a id="more"></a><br>代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> db;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vi;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;ll&gt; vl;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;pii&gt; vp;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">1e9</span> + <span class="number">100000</span>;</span><br><span class="line"><span class="keyword">const</span> ll INF = <span class="number">1e18</span>;</span><br><span class="line"><span class="keyword">const</span> db eps = <span class="number">1e-10</span>;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> eb emplace_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ep emplace</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mem(a) memset(a, 0, sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> copy(a, b) memcpy(a, b, sizeof(b))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PA cout &lt;&lt; <span class="meta-string">"pass\n"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lowbit(x) (x &amp; -x)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(x) x.begin(), x.end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TM cout &lt;&lt; db(clock()) / CLOCKS_PER_SEC &lt;&lt; <span class="meta-string">'\n'</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function">mt19937 <span class="title">mrand</span><span class="params">(chrono::high_resolution_clock::now().time_since_epoch().count())</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;<span class="title">inline</span> <span class="title">void</span> <span class="title">upmin</span>(<span class="title">T</span> &amp;<span class="title">x</span>, <span class="title">T</span> <span class="title">y</span>) &#123;</span>x = x &gt; y ? y : x;&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;<span class="title">inline</span> <span class="title">void</span> <span class="title">upmax</span>(<span class="title">T</span> &amp;<span class="title">x</span>, <span class="title">T</span> <span class="title">y</span>) &#123;</span>x = x &lt; y ? y : x;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">155</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> u, v, w;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> node &amp;r) <span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> w &lt; r.w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;e[maxn];</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">matrix</span>&#123;</span></span><br><span class="line">    <span class="built_in">bitset</span>&lt;maxn&gt; v[maxn];</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function">matrix <span class="title">rotate</span><span class="params">(matrix a)</span></span>&#123;</span><br><span class="line">    matrix c;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)&#123;</span><br><span class="line">            c.v[i][j] = a.v[j][i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">matrix <span class="keyword">operator</span> *(matrix a, matrix b)&#123;</span><br><span class="line">    matrix c;</span><br><span class="line">    b = rotate(b);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)&#123;</span><br><span class="line">            c.v[i][j] = (a.v[i] &amp; b.v[j]).any();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">matrix <span class="title">quick_pow</span><span class="params">(matrix q, <span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">    matrix res;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) res.v[i][i] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(w)&#123;</span><br><span class="line">        <span class="keyword">if</span>(w &amp; <span class="number">1</span>) res = res * q;</span><br><span class="line">        q = q * q;</span><br><span class="line">        w &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"><span class="keyword">int</span> f[maxn];</span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line">matrix base, now;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">    mem(vis);</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> x = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">if</span>(vis[x]) <span class="keyword">continue</span>;</span><br><span class="line">        vis[x] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(vis[i] || !now.v[x][i]) <span class="keyword">continue</span>;</span><br><span class="line">            upmin(f[i], f[x] + <span class="number">1</span>);</span><br><span class="line">            q.ep(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f[n];</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> res;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>), <span class="built_in">cin</span>.tie(<span class="number">0</span>), <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; fixed &lt;&lt; setprecision(<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; e[i].u &gt;&gt; e[i].v &gt;&gt; e[i].w;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(e + <span class="number">1</span>, e + m + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(e[<span class="number">1</span>].w)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Impossible\n"</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    base.v[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    res = inf;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)  f[i] = inf;</span><br><span class="line">    e[m + <span class="number">1</span>].w = inf;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m + <span class="number">1</span>; i++) &#123;</span><br><span class="line">        matrix tmp = base * quick_pow(now, e[i].w - e[i - <span class="number">1</span>].w);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (base.v[<span class="number">1</span>][j]) q.ep(j), f[j] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> f[j] = inf;</span><br><span class="line">        &#125;</span><br><span class="line">        upmin(res, e[i - <span class="number">1</span>].w + bfs());</span><br><span class="line">        base = tmp;</span><br><span class="line">        now.v[e[i].u][e[i].v] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(res == inf) <span class="built_in">cout</span> &lt;&lt; <span class="string">"Impossible\n"</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://codeforces.com/contest/576/problem/D&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目链接&lt;/a&gt;&lt;br&gt;思路：已经忘了最基本的邻接矩阵的性质了，真的服了自己了。。&lt;br&gt;可达矩阵中的$A_{ij}为1表示从i可以走到j$，$A^n_{ij}为1表示从i可以走恰好n步走到j$，如果是从某一些点出发，我们需要维护一个初始矩阵，能作为出发点的$i，base_{ii} = 1$，转移矩阵就是用来维护走x步后能从哪些点走到哪些点。&lt;br&gt;考虑本题，转移矩阵最多有m种，每种我们都可以得到从1开始能到达的位置，然后从这些位置bfs一下更新最小值，不同种转移矩阵用矩阵快速幂进行转移即可。考虑是可达矩阵，只有0/1两个值，所以可以用bitset优化，复杂度$O(\frac{n^3mlog(m)}{w})$&lt;br&gt;
    
    </summary>
    
      <category term="矩阵快速幂" scheme="http://yoursite.com/categories/%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82/"/>
    
    
  </entry>
  
  <entry>
    <title>误差反向传播法</title>
    <link href="http://yoursite.com/2020/03/08/%E8%AF%AF%E5%B7%AE%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD%E6%B3%95/"/>
    <id>http://yoursite.com/2020/03/08/误差反向传播法/</id>
    <published>2020-03-08T14:24:56.000Z</published>
    <updated>2020-03-09T09:32:25.664Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>误差反向传播法相对于数值微分而言，是一种高效计算权重参数的梯度的方法。<br><img src="/mlimg/bpcal.png" alt=""><br>上图是计算图，每个点都表示一个不可再拆分的运算，表明了整个运算的流程。通过正向运算得到我们的输出结果，将运算结果由反向带回，再根据每个点的导数，根据链式法则，我们就可以由结果回推出每个点的梯度。由于链式法则是非常基本的东西，这里就不再赘述了。</p><h3 id="几个比较重要的运算-函数"><a href="#几个比较重要的运算-函数" class="headerlink" title="几个比较重要的运算/函数"></a>几个比较重要的运算/函数</h3><h4 id="ReLU"><a href="#ReLU" class="headerlink" title="ReLU"></a>ReLU</h4><p>ReLU函数如图所示表达式为：</p><script type="math/tex; mode=display">f(x)=\left\{\begin{aligned}x \ &(x > 0)\\0 \ &(x \leq 0)\end{aligned}\right.</script><p><img src="/mlimg/relu.png" alt=""><br>考虑求导：</p><script type="math/tex; mode=display">\frac{\partial y}{\partial x} = \left\{\begin{aligned}1 \ &(x > 0)\\0 \ &(x \leq 0)\end{aligned}\right.</script><p>发现如果小于等于0，则停止反向传播，否则原封不动将后面内容传给前面</p><h4 id="Sigmoid"><a href="#Sigmoid" class="headerlink" title="Sigmoid"></a>Sigmoid</h4><p>ReLU函数如图所示表达式为：</p><script type="math/tex; mode=display">f(x)=\frac{1}{1 + e^{-x}}</script><p><img src="/mlimg/sigmoid.png" alt=""><br>考虑求导：</p><script type="math/tex; mode=display">f'(x)=y(1 - y)</script><h4 id="Affine"><a href="#Affine" class="headerlink" title="Affine"></a>Affine</h4><p>Affine就涉及矩阵的求导运算了，我好像不是很会矩阵的求导运算，但是如果看成变量的求导形式上发现差不多。。<br><img src="/mlimg/affine.png" alt=""></p><script type="math/tex; mode=display">Y = XW + B</script><p>考虑求导：</p><script type="math/tex; mode=display">\frac{\partial L}{\partial X} = \frac{\partial L}{\partial Y} \cdot W^T</script><script type="math/tex; mode=display">\frac{\partial L}{\partial W} = X^T \cdot \frac{\partial L}{\partial Y}</script><script type="math/tex; mode=display">\frac{\partial L}{\partial B} = \frac{\partial L}{\partial Y}</script><p>证明以后会了回来补。。。。</p><h4 id="Softmax"><a href="#Softmax" class="headerlink" title="Softmax"></a>Softmax</h4><p>个人理解softmax有点类似于归一化的一个函数，可以算出每个离散点的概率</p><script type="math/tex; mode=display">y_i=\frac{e^{z_i}}{\sum_t e^{z_t}}</script><p>考虑求导：</p><script type="math/tex; mode=display">\frac{\partial y_i}{\partial z_j} = \frac{\partial \frac{e^{z_i}}{\sum_t e^{z_t}}}{\partial z_j}</script><p>$当i = j时：$</p><script type="math/tex; mode=display">\frac{e_{z_i} \cdot \sum_t e^{z_t} - e^{z_i} \cdot e^{z_j}}{(\sum_t e_{z_t})^2} = y_i(1 - y_i)</script><p>$当i != j时：$</p><script type="math/tex; mode=display">\frac{0 \cdot \sum_t e^{z_t} - e^{z_i} \cdot e^{z_j}}{(\sum_t e_{z_t})^2} = -y_iy_j</script><h4 id="Cross-entropy"><a href="#Cross-entropy" class="headerlink" title="Cross-entropy"></a>Cross-entropy</h4><p>我觉得讲交叉熵之前，其实有必要说说跟它相关的几个东西。</p><h5 id="信息熵"><a href="#信息熵" class="headerlink" title="信息熵"></a>信息熵</h5><p>大学物理里面学过一点，不过讲的比较理论，这玩意说的比较通俗一点，就是用来衡量一个事情所包含的信息量。举个例子，今天太阳会下山，这句话就是句废话，因为人人都知道太阳每天会下山，所以这句话的信息量为0。简而言之，越不可能发生的事情，包含的信息量越大。我们给出信息熵的定义：</p><script type="math/tex; mode=display">s(x) = -\sum_iP(x_i)logP(x_i)</script><p>我们发现当概率为1时，信息熵为0。</p><h5 id="Cross-entropy-1"><a href="#Cross-entropy-1" class="headerlink" title="Cross-entropy"></a>Cross-entropy</h5><p>交叉熵用来衡量两个信息之间的相似程度，给出定义：</p><script type="math/tex; mode=display">H(p, q) = -\sum p(x)log q(x)</script><p>我们来推导一下交叉熵的求导:</p><script type="math/tex; mode=display">\frac{\partial H(y, t)}{\partial y_i} = \frac{\partial (-\sum t_ilogy_i)}{\partial y_i} = -\frac{t_i}{y_i}</script><h5 id="Softmax-Cross-entropy"><a href="#Softmax-Cross-entropy" class="headerlink" title="Softmax + Cross-entropy"></a>Softmax + Cross-entropy</h5><p>很多时候这两个函数搭配使用，前者用来归一化为概率，后者用来作为损失函数，效果就非常好，而且它求导出来的结果非常简单！</p><script type="math/tex; mode=display">\frac{\partial H(t, y)}{\partial z_j} = \sum_i \frac{\partial H(y, t)}{\partial y_i} \cdot \frac{\partial y_i}{\partial z_j} = \sum_i -\frac{t_i}{y_i} \cdot((y_i(1 - y_i))_{i == j} - (y_iy_j)_{i != j})</script><script type="math/tex; mode=display">= -t_j + t_jy_j + \sum_{i != j} t_i = -t_j + y_j \sum_i t_i = y_j - t_j</script><p>发现最后就是真实值和推测值之间的差。</p><h5 id="KL散度"><a href="#KL散度" class="headerlink" title="KL散度"></a>KL散度</h5><p>KL散度来计算两个分布间的不同，简单理解就是相对差距。<br>KL散度 = 交叉熵 - 信息熵，给出定义：</p><script type="math/tex; mode=display">D_{KL}(A || B) = H(A, B) - S(A)</script><p>展开后如下：</p><script type="math/tex; mode=display">D_{KL}(A || B) = \sum_i P_A(x_i)logP_A(x_i) - P_A(x_i)logP_B(x_i)</script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h3&gt;&lt;p&gt;误差反向传播法相对于数值微分而言，是一种高效计算权重参数的梯度的方法。&lt;br&gt;&lt;img src=&quot;/mlimg/bpcal.png&quot; alt
      
    
    </summary>
    
      <category term="机器学习" scheme="http://yoursite.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>初探圆的反演</title>
    <link href="http://yoursite.com/2020/03/03/%E5%88%9D%E6%8E%A2%E5%9C%86%E7%9A%84%E5%8F%8D%E6%BC%94/"/>
    <id>http://yoursite.com/2020/03/03/初探圆的反演/</id>
    <published>2020-03-03T13:22:04.000Z</published>
    <updated>2020-03-03T13:48:21.136Z</updated>
    
    <content type="html"><![CDATA[<h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><p>反演变换适用于题目中存在多个圆/直线之间的相切关系的情况。利用反演变换的性质，在反演空间求解问题，可以大幅简化计算。</p><h3 id="圆的反演定义"><a href="#圆的反演定义" class="headerlink" title="圆的反演定义"></a>圆的反演定义</h3><p>给定反演中心O和反演半径R，平面上点$P和反演点P’$满足如下性质：<br>$P’在OP的射线上$<br>$|OP| \cdot |OP’| = R^2$<br>其中R可以任意指定。</p><h3 id="圆的反演性质"><a href="#圆的反演性质" class="headerlink" title="圆的反演性质"></a>圆的反演性质</h3><p>1、$圆O外的点的反演点在圆O内，反之亦然；圆O上的点的反演点为其自身。$<br>2、$不过点O的圆，其反演图形也是不过点O的圆。$<br><strong>过点O的圆，其反演图形是不过点O的直线。</strong><br><strong>两个图形相切，则他们的反演图形也相切</strong><br>其中3、4点非常重要，是一般圆反演题目求解的核心。</p><h3 id="变换"><a href="#变换" class="headerlink" title="变换"></a>变换</h3><p>记圆A半径为$r_1$，反演圆半径为$r_2$，则有：<br>$r_2 = \frac{r_1R^2}{|OA|^2 - r_1^2}$<br>$|OB| = \frac{|OA|r_b}{r_a}$<br>如反演点坐标为$O(x_0, y_0)$，A上一坐标为$x_1, y_1$，则反演圆B上对应坐标为<br>$x_2 = x_0 + \frac{|OB|}{|OA|}(x_1 - x_0)$<br>$y_2 = y_0 + \frac{|OB|}{|OA|}(y_1 - y_0)$<br><a id="more"></a></p><h3 id="一些题目"><a href="#一些题目" class="headerlink" title="一些题目"></a>一些题目</h3><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=4773" target="_blank" rel="noopener">icpc 2013 杭州赛区 Problem of Apollonius</a><br>这个题发现直接求外切列方程不好解，考虑反演，由于是圆外一个点，反演后两个圆仍然是圆，公切圆变成了直线，问题变成了在反演空间求两圆的公切线。再根据位置关系观察得到要求的是外公切线，且两圆和反演点必须在直线同一侧（原来离反演中心越远，反演后越近），随便叉积判一下就行了。<br><div><div class="fold_hider"><div class="close hider_title">代码</div></div><div class="fold"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> db;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vi;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;ll&gt; vl;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;pii&gt; vp;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">const</span> ll INF = <span class="number">1e18</span>;</span><br><span class="line"><span class="keyword">const</span> db eps = <span class="number">1e-10</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> eb emplace_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ep emplace</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mem(a) memset(a, 0, sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> copy(a, b) memcpy(a, b, sizeof(b))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PA cout &lt;&lt; <span class="meta-string">"pass\n"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lowbit(x) (x &amp; -x)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(x) x.begin(), x.end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TM cout &lt;&lt; db(clock()) / CLOCKS_PER_SEC &lt;&lt; <span class="meta-string">'\n'</span></span></span><br><span class="line"><span class="keyword">const</span> db pi = <span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dcmp</span><span class="params">(db x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x&lt;-eps?<span class="number">-1</span>:x&gt;eps;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">db <span class="title">myacos</span><span class="params">(db x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;<span class="number">-1</span>) x = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;<span class="number">1</span>) x = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">acos</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">db <span class="title">myasin</span><span class="params">(db x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;<span class="number">-1</span>) x = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;<span class="number">1</span>) x = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">asin</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">db <span class="title">mysqrt</span><span class="params">(db x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x&lt;<span class="number">0</span>?<span class="number">0</span>:<span class="built_in">sqrt</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">P</span> &#123;</span></span><br><span class="line">    db x, y;</span><br><span class="line">    P(db x = <span class="number">0</span>, db y = <span class="number">0</span>) : x(x), y(y) &#123;&#125;</span><br><span class="line">    P <span class="keyword">operator</span>+(P r)&#123;<span class="keyword">return</span> P(x+r.x,y+r.y);&#125;</span><br><span class="line">    P <span class="keyword">operator</span>-(P r)&#123;<span class="keyword">return</span> P(x-r.x,y-r.y);&#125;</span><br><span class="line">    P <span class="keyword">operator</span>*(db r)&#123;<span class="keyword">return</span> P(x*r,y*r);&#125;</span><br><span class="line">    P <span class="keyword">operator</span>/(db r)&#123;<span class="keyword">return</span> P(x/r,y/r);&#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> P &amp;r)<span class="keyword">const</span>&#123;<span class="keyword">return</span> x&lt;r.x||(x==r.x&amp;&amp;y&lt;r.y);&#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> P &amp;r)<span class="keyword">const</span>&#123;<span class="keyword">return</span> dcmp(x-r.x)==<span class="number">0</span>&amp;&amp;dcmp(y-r.y)==<span class="number">0</span>;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">upper</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> y &gt; <span class="number">0</span> || (y == <span class="number">0</span> &amp;&amp; x &gt; <span class="number">0</span>);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">()</span></span>&#123; <span class="built_in">scanf</span>(<span class="string">"%lf %lf"</span>, &amp;x, &amp;y); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123; <span class="built_in">printf</span>(<span class="string">"%.2f %.2f\n"</span>, x, y);&#125;</span><br><span class="line">&#125;V;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Circle</span> &#123;</span></span><br><span class="line">    P c;</span><br><span class="line">    db r;</span><br><span class="line">    Circle()&#123;&#125;</span><br><span class="line">    Circle(P c, db r) : c(c), r(r) &#123;&#125;</span><br><span class="line">    <span class="comment">//通过圆心角确定圆上坐标</span></span><br><span class="line">    <span class="function">P <span class="title">point</span><span class="params">(db a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> P(c.x + <span class="built_in">cos</span>(a)*r, c.y + <span class="built_in">sin</span>(a)*r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//向量点积</span></span><br><span class="line"><span class="function">db <span class="title">Dot</span><span class="params">(V A, V B)</span> </span>&#123; <span class="keyword">return</span> A.x*B.x + A.y*B.y; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//向量长度</span></span><br><span class="line"><span class="function">db <span class="title">Length</span><span class="params">(V A)</span> </span>&#123; <span class="keyword">return</span> mysqrt(Dot(A, A)); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//向量夹角</span></span><br><span class="line"><span class="function">db <span class="title">Angle</span><span class="params">(V A, V B)</span> </span>&#123; <span class="keyword">return</span> myacos(Dot(A, B) / Length(A) / Length(B)); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//向量叉积</span></span><br><span class="line"><span class="function">db <span class="title">Cross</span><span class="params">(V A, V B)</span> </span>&#123; <span class="keyword">return</span> A.x*B.y - A.y*B.x; &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetTangents</span><span class="params">(Circle A, Circle B, P *a, P *b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(A.r &lt; B.r) &#123;</span><br><span class="line">        swap(A, B); swap(a, b);</span><br><span class="line">    &#125;</span><br><span class="line">    db d2 = (A.c.x - B.c.x)*(A.c.x - B.c.x) + (A.c.y - B.c.y)*(A.c.y - B.c.y);</span><br><span class="line">    db rdiff = A.r - B.r;</span><br><span class="line">    db rsum = A.r + B.r;</span><br><span class="line">    <span class="keyword">if</span>(dcmp(d2 - rdiff*rdiff) &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;   <span class="comment">//内含</span></span><br><span class="line">    db base = <span class="built_in">atan2</span>(B.c.y - A.c.y, B.c.x - A.c.x);</span><br><span class="line">    <span class="keyword">if</span>(dcmp(d2) == <span class="number">0</span> &amp;&amp; dcmp(A.r - B.r) == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;   <span class="comment">//无限多条切线</span></span><br><span class="line">    <span class="keyword">if</span>(dcmp(d2 - rdiff*rdiff) == <span class="number">0</span>) &#123;         <span class="comment">//内切一条切线</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        a[cnt] = A.point(base);</span><br><span class="line">        b[cnt] = B.point(base);</span><br><span class="line">        cnt++;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//有外共切线</span></span><br><span class="line">    db ang = myacos((A.r-B.r) / mysqrt(d2));</span><br><span class="line">    a[cnt] = A.point(base+ang); b[cnt] = B.point(base+ang); cnt++;</span><br><span class="line">    a[cnt] = A.point(base-ang); b[cnt] = B.point(base-ang); cnt++;</span><br><span class="line">   <span class="comment">/* if(dcmp(d2 - rsum*rsum) == 0) &#123;  //一条内公切线</span></span><br><span class="line"><span class="comment">        a[cnt] = A.point(base);</span></span><br><span class="line"><span class="comment">        b[cnt] = B.point(pi+base);</span></span><br><span class="line"><span class="comment">        cnt++;</span></span><br><span class="line"><span class="comment">    &#125; else if(dcmp(d2 - rsum*rsum) &gt; 0) &#123;   //两条内公切线</span></span><br><span class="line"><span class="comment">        db ang = myacos((A.r + B.r) / mysqrt(d2));</span></span><br><span class="line"><span class="comment">        a[cnt] = A.point(base+ang); b[cnt] = B.point(pi+base+ang); cnt++;</span></span><br><span class="line"><span class="comment">        a[cnt] = A.point(base-ang); b[cnt] = B.point(pi+base-ang); cnt++;</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">P <span class="title">GetLineProjection</span><span class="params">(P p, P A, P B)</span> </span>&#123;</span><br><span class="line">    V v = B - A;</span><br><span class="line">    <span class="keyword">return</span> A + v * (Dot(v, p - A) / Dot(v, v));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> db R = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">db <span class="title">getdis</span><span class="params">(P a, P b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Length(a - b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Circle <span class="title">invcir</span><span class="params">(Circle now, P o)</span></span>&#123;</span><br><span class="line">    Circle res;</span><br><span class="line">    db oa = getdis(o, now.c);</span><br><span class="line">    res.r = now.r * R * R / (oa * oa - now.r * now.r);</span><br><span class="line">    db ob = oa * res.r / now.r;</span><br><span class="line">    res.c = o + (now.c - o) * (ob / oa );</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Circle <span class="title">invline</span><span class="params">(P o, P a, P b)</span> </span>&#123;</span><br><span class="line">    P p = GetLineProjection(o, a, b);</span><br><span class="line">    db d = getdis(p, o);</span><br><span class="line">    db rb = R * R / <span class="number">2</span> / d;</span><br><span class="line">    V v = (p - o) / d * rb;</span><br><span class="line">    <span class="keyword">return</span> Circle(o + v, rb);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Circle a, b;</span><br><span class="line"><span class="keyword">int</span> T;</span><br><span class="line">P t;</span><br><span class="line"></span><br><span class="line">P t1[<span class="number">10</span>], t2[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;Circle&gt; ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>), <span class="built_in">cin</span>.tie(<span class="number">0</span>), <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; fixed &lt;&lt; setprecision(<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        ans.clear();</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a.c.x &gt;&gt; a.c.y &gt;&gt; a.r &gt;&gt; b.c.x &gt;&gt; b.c.y &gt;&gt; b.r &gt;&gt; t.x &gt;&gt; t.y;</span><br><span class="line">        Circle ta = invcir(a, t);</span><br><span class="line">        Circle tb = invcir(b, t);</span><br><span class="line">        <span class="keyword">int</span> len = GetTangents(ta, tb, t1, t2);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dcmp(Cross(t - t1[i], t2[i] - t1[i])) * dcmp(Cross(ta.c - t1[i], t2[i] - t1[i])) &gt; <span class="number">0</span>) ans.eb(invline(t, t1[i], t2[i]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans.size() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;it : ans)&#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; it.c.x &lt;&lt; <span class="string">' '</span> &lt;&lt; it.c.y &lt;&lt; <span class="string">' '</span> &lt;&lt; it.r &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></p><p><a href="https://nanti.jisuanke.com/t/A1283" target="_blank" rel="noopener">icpc 2017 南宁赛区网络赛 Finding the Radius for an Inserted Circle</a><br>第一个圆的圆心可以建系计算出来，我们以最上面的交点为中心反演，两个相切圆变成了两条直线，这一系列圆反演后都是一样的大小，与两条直线相切，半径都完全一样，我们只需要递推就可以算出每个圆的半径了。<br><div><div class="fold_hider"><div class="close hider_title">代码</div></div><div class="fold"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> db;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vi;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;ll&gt; vl;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;pii&gt; vp;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">const</span> ll INF = <span class="number">1e18</span>;</span><br><span class="line"><span class="keyword">const</span> db eps = <span class="number">1e-10</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> eb emplace_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ep emplace</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mem(a) memset(a, 0, sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> copy(a, b) memcpy(a, b, sizeof(b))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PA cout &lt;&lt; <span class="meta-string">"pass\n"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lowbit(x) (x &amp; -x)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(x) x.begin(), x.end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TM cout &lt;&lt; db(clock()) / CLOCKS_PER_SEC &lt;&lt; <span class="meta-string">'\n'</span></span></span><br><span class="line"><span class="keyword">const</span> db pi = <span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dcmp</span><span class="params">(db x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x&lt;-eps?<span class="number">-1</span>:x&gt;eps;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">db <span class="title">myacos</span><span class="params">(db x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;<span class="number">-1</span>) x = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;<span class="number">1</span>) x = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">acos</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">db <span class="title">myasin</span><span class="params">(db x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;<span class="number">-1</span>) x = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;<span class="number">1</span>) x = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">asin</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">db <span class="title">mysqrt</span><span class="params">(db x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x&lt;<span class="number">0</span>?<span class="number">0</span>:<span class="built_in">sqrt</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">P</span> &#123;</span></span><br><span class="line">    db x, y;</span><br><span class="line">    P(db x = <span class="number">0</span>, db y = <span class="number">0</span>) : x(x), y(y) &#123;&#125;</span><br><span class="line">    P <span class="keyword">operator</span>+(P r)&#123;<span class="keyword">return</span> P(x+r.x,y+r.y);&#125;</span><br><span class="line">    P <span class="keyword">operator</span>-(P r)&#123;<span class="keyword">return</span> P(x-r.x,y-r.y);&#125;</span><br><span class="line">    P <span class="keyword">operator</span>*(db r)&#123;<span class="keyword">return</span> P(x*r,y*r);&#125;</span><br><span class="line">    P <span class="keyword">operator</span>/(db r)&#123;<span class="keyword">return</span> P(x/r,y/r);&#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> P &amp;r)<span class="keyword">const</span>&#123;<span class="keyword">return</span> x&lt;r.x||(x==r.x&amp;&amp;y&lt;r.y);&#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> P &amp;r)<span class="keyword">const</span>&#123;<span class="keyword">return</span> dcmp(x-r.x)==<span class="number">0</span>&amp;&amp;dcmp(y-r.y)==<span class="number">0</span>;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">upper</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> y &gt; <span class="number">0</span> || (y == <span class="number">0</span> &amp;&amp; x &gt; <span class="number">0</span>);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">()</span></span>&#123; <span class="built_in">scanf</span>(<span class="string">"%lf %lf"</span>, &amp;x, &amp;y); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123; <span class="built_in">printf</span>(<span class="string">"%.2f %.2f\n"</span>, x, y);&#125;</span><br><span class="line">&#125;V;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Circle</span> &#123;</span></span><br><span class="line">    P c;</span><br><span class="line">    db r;</span><br><span class="line">    Circle()&#123;&#125;</span><br><span class="line">    Circle(P c, db r) : c(c), r(r) &#123;&#125;</span><br><span class="line">    <span class="comment">//通过圆心角确定圆上坐标</span></span><br><span class="line">    <span class="function">P <span class="title">point</span><span class="params">(db a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> P(c.x + <span class="built_in">cos</span>(a)*r, c.y + <span class="built_in">sin</span>(a)*r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//向量点积</span></span><br><span class="line"><span class="function">db <span class="title">Dot</span><span class="params">(V A, V B)</span> </span>&#123; <span class="keyword">return</span> A.x*B.x + A.y*B.y; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//向量长度</span></span><br><span class="line"><span class="function">db <span class="title">Length</span><span class="params">(V A)</span> </span>&#123; <span class="keyword">return</span> mysqrt(Dot(A, A)); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//向量夹角</span></span><br><span class="line"><span class="function">db <span class="title">Angle</span><span class="params">(V A, V B)</span> </span>&#123; <span class="keyword">return</span> myacos(Dot(A, B) / Length(A) / Length(B)); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//向量叉积</span></span><br><span class="line"><span class="function">db <span class="title">Cross</span><span class="params">(V A, V B)</span> </span>&#123; <span class="keyword">return</span> A.x*B.y - A.y*B.x; &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetTangents</span><span class="params">(Circle A, Circle B, P *a, P *b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(A.r &lt; B.r) &#123;</span><br><span class="line">        swap(A, B); swap(a, b);</span><br><span class="line">    &#125;</span><br><span class="line">    db d2 = (A.c.x - B.c.x)*(A.c.x - B.c.x) + (A.c.y - B.c.y)*(A.c.y - B.c.y);</span><br><span class="line">    db rdiff = A.r - B.r;</span><br><span class="line">    db rsum = A.r + B.r;</span><br><span class="line">    <span class="keyword">if</span>(dcmp(d2 - rdiff*rdiff) &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;   <span class="comment">//内含</span></span><br><span class="line">    db base = <span class="built_in">atan2</span>(B.c.y - A.c.y, B.c.x - A.c.x);</span><br><span class="line">    <span class="keyword">if</span>(dcmp(d2) == <span class="number">0</span> &amp;&amp; dcmp(A.r - B.r) == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;   <span class="comment">//无限多条切线</span></span><br><span class="line">    <span class="keyword">if</span>(dcmp(d2 - rdiff*rdiff) == <span class="number">0</span>) &#123;         <span class="comment">//内切一条切线</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        a[cnt] = A.point(base);</span><br><span class="line">        b[cnt] = B.point(base);</span><br><span class="line">        cnt++;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//有外共切线</span></span><br><span class="line">    db ang = myacos((A.r-B.r) / mysqrt(d2));</span><br><span class="line">    a[cnt] = A.point(base+ang); b[cnt] = B.point(base+ang); cnt++;</span><br><span class="line">    a[cnt] = A.point(base-ang); b[cnt] = B.point(base-ang); cnt++;</span><br><span class="line">   <span class="comment">/* if(dcmp(d2 - rsum*rsum) == 0) &#123;  //一条内公切线</span></span><br><span class="line"><span class="comment">        a[cnt] = A.point(base);</span></span><br><span class="line"><span class="comment">        b[cnt] = B.point(pi+base);</span></span><br><span class="line"><span class="comment">        cnt++;</span></span><br><span class="line"><span class="comment">    &#125; else if(dcmp(d2 - rsum*rsum) &gt; 0) &#123;   //两条内公切线</span></span><br><span class="line"><span class="comment">        db ang = myacos((A.r + B.r) / mysqrt(d2));</span></span><br><span class="line"><span class="comment">        a[cnt] = A.point(base+ang); b[cnt] = B.point(pi+base+ang); cnt++;</span></span><br><span class="line"><span class="comment">        a[cnt] = A.point(base-ang); b[cnt] = B.point(pi+base-ang); cnt++;</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">P <span class="title">GetLineProjection</span><span class="params">(P p, P A, P B)</span> </span>&#123;</span><br><span class="line">    V v = B - A;</span><br><span class="line">    <span class="keyword">return</span> A + v * (Dot(v, p - A) / Dot(v, v));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> db R = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">db <span class="title">getdis</span><span class="params">(P a, P b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Length(a - b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Circle <span class="title">invcir</span><span class="params">(Circle now, P o)</span></span>&#123;</span><br><span class="line">    Circle res;</span><br><span class="line">    db oa = getdis(o, now.c);</span><br><span class="line">    res.r = now.r * R * R / (oa * oa - now.r * now.r);</span><br><span class="line">    db ob = oa * res.r / now.r;</span><br><span class="line">    res.c = o + (now.c - o) * (ob / oa );</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Circle <span class="title">invline</span><span class="params">(P o, P a, P b)</span> </span>&#123;</span><br><span class="line">    P p = GetLineProjection(o, a, b);</span><br><span class="line">    db d = getdis(p, o);</span><br><span class="line">    db rb = R * R / <span class="number">2</span> / d;</span><br><span class="line">    V v = (p - o) / d * rb;</span><br><span class="line">    <span class="keyword">return</span> Circle(o + v, rb);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> T;</span><br><span class="line">db r;</span><br><span class="line"><span class="keyword">int</span> k;</span><br><span class="line">P o;</span><br><span class="line">db res[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>), <span class="built_in">cin</span>.tie(<span class="number">0</span>), <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; fixed &lt;&lt; setprecision(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T &gt;&gt; r;</span><br><span class="line">    P m = P(<span class="number">0</span>, -<span class="built_in">sqrt</span>(<span class="number">3</span>) * r) / <span class="number">3</span>;</span><br><span class="line">    res[<span class="number">1</span>] = getdis(m, P(<span class="number">0</span>, -<span class="built_in">sqrt</span>(<span class="number">3</span>) * r + r));</span><br><span class="line">    o = P(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    db nr = R * R / r / <span class="number">2</span>;</span><br><span class="line">    db now = <span class="built_in">sqrt</span>(<span class="number">3</span>) * r - r - <span class="number">2</span> * res[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= <span class="number">10</span>; i++)&#123;</span><br><span class="line">        res[i] = nr * now * now / (<span class="number">2</span> * nr * now + R * R);</span><br><span class="line">        now -= <span class="number">2</span> * res[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; k;</span><br><span class="line">        <span class="keyword">if</span>(k == <span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; k &lt;&lt; <span class="string">' '</span> &lt;&lt; <span class="built_in">floor</span>(res[k]) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;适用场景&quot;&gt;&lt;a href=&quot;#适用场景&quot; class=&quot;headerlink&quot; title=&quot;适用场景&quot;&gt;&lt;/a&gt;适用场景&lt;/h3&gt;&lt;p&gt;反演变换适用于题目中存在多个圆/直线之间的相切关系的情况。利用反演变换的性质，在反演空间求解问题，可以大幅简化计算。&lt;/p&gt;
&lt;h3 id=&quot;圆的反演定义&quot;&gt;&lt;a href=&quot;#圆的反演定义&quot; class=&quot;headerlink&quot; title=&quot;圆的反演定义&quot;&gt;&lt;/a&gt;圆的反演定义&lt;/h3&gt;&lt;p&gt;给定反演中心O和反演半径R，平面上点$P和反演点P’$满足如下性质：&lt;br&gt;$P’在OP的射线上$&lt;br&gt;$|OP| \cdot |OP’| = R^2$&lt;br&gt;其中R可以任意指定。&lt;/p&gt;
&lt;h3 id=&quot;圆的反演性质&quot;&gt;&lt;a href=&quot;#圆的反演性质&quot; class=&quot;headerlink&quot; title=&quot;圆的反演性质&quot;&gt;&lt;/a&gt;圆的反演性质&lt;/h3&gt;&lt;p&gt;1、$圆O外的点的反演点在圆O内，反之亦然；圆O上的点的反演点为其自身。$&lt;br&gt;2、$不过点O的圆，其反演图形也是不过点O的圆。$&lt;br&gt;&lt;strong&gt;过点O的圆，其反演图形是不过点O的直线。&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;两个图形相切，则他们的反演图形也相切&lt;/strong&gt;&lt;br&gt;其中3、4点非常重要，是一般圆反演题目求解的核心。&lt;/p&gt;
&lt;h3 id=&quot;变换&quot;&gt;&lt;a href=&quot;#变换&quot; class=&quot;headerlink&quot; title=&quot;变换&quot;&gt;&lt;/a&gt;变换&lt;/h3&gt;&lt;p&gt;记圆A半径为$r_1$，反演圆半径为$r_2$，则有：&lt;br&gt;$r_2 = \frac{r_1R^2}{|OA|^2 - r_1^2}$&lt;br&gt;$|OB| = \frac{|OA|r_b}{r_a}$&lt;br&gt;如反演点坐标为$O(x_0, y_0)$，A上一坐标为$x_1, y_1$，则反演圆B上对应坐标为&lt;br&gt;$x_2 = x_0 + \frac{|OB|}{|OA|}(x_1 - x_0)$&lt;br&gt;$y_2 = y_0 + \frac{|OB|}{|OA|}(y_1 - y_0)$&lt;br&gt;
    
    </summary>
    
      <category term="计算几何" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/"/>
    
    
  </entry>
  
</feed>

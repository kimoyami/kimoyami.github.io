<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>小雅米，来来往往这么多人，有多少是圆梦后才衣锦还乡的呢？</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-11-04T07:48:21.155Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>kimoyami</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>整数划分与五边形定理</title>
    <link href="http://yoursite.com/2020/11/04/%E6%95%B4%E6%95%B0%E5%88%92%E5%88%86%E4%B8%8E%E4%BA%94%E8%BE%B9%E5%BD%A2%E5%AE%9A%E7%90%86/"/>
    <id>http://yoursite.com/2020/11/04/整数划分与五边形定理/</id>
    <published>2020-11-04T03:20:47.000Z</published>
    <updated>2020-11-04T07:48:21.155Z</updated>
    
    <content type="html"><![CDATA[<p>去年沈阳栽的跟头，白送一个题没有拿到，结果现在才补。</p><h1 id="整数划分"><a href="#整数划分" class="headerlink" title="整数划分"></a>整数划分</h1><p>整数划分有很多变种，一般来说通过二维dp以及控制dp的转移策略都可以在<script type="math/tex">n^2</script>的复杂度完成。下面讨论一部分：</p><a id="more"></a><h2 id="划分成k个整数"><a href="#划分成k个整数" class="headerlink" title="划分成k个整数"></a>划分成k个整数</h2><p>设<script type="math/tex">f_{i, j}</script>为把<script type="math/tex">i</script>划分成<script type="math/tex">j</script>个数的方案，得:<script type="math/tex">f_{i, j} = f_{i - j, j} + f_{i - 1, j - 1}</script>，即整体加1或者新划分1</p><h2 id="划分成k个不重复的整数"><a href="#划分成k个不重复的整数" class="headerlink" title="划分成k个不重复的整数"></a>划分成k个不重复的整数</h2><p>设<script type="math/tex">f_{i, j}</script>为把<script type="math/tex">i</script>划分成<script type="math/tex">j</script>个数的方案，得<script type="math/tex">f_{i, j} = f_{i - j, j} + f_{i - j, j - 1}</script>，即整体加1或者整体加1后再新划分1</p><h2 id="划分成不大于m的正整数"><a href="#划分成不大于m的正整数" class="headerlink" title="划分成不大于m的正整数"></a>划分成不大于m的正整数</h2><p>设<script type="math/tex">f_{i, j}</script>为把<script type="math/tex">i</script>划分成最大数不超过<script type="math/tex">j</script>的划分数，得：<script type="math/tex">f_{i, j} = f_{i - j, j} + f_{i, j - 1}</script></p><h2 id="划分成不小于m的正整数"><a href="#划分成不小于m的正整数" class="headerlink" title="划分成不小于m的正整数"></a>划分成不小于m的正整数</h2><p>设<script type="math/tex">f_{i, j}</script>为把<script type="math/tex">i</script>划分成最小数不小于<script type="math/tex">j</script>的划分数，得：<script type="math/tex">f_{i, j} = f_{i - j, j} + f_{i, j + 1}</script></p><h2 id="划分成不大于m的不重复正整数个数"><a href="#划分成不大于m的不重复正整数个数" class="headerlink" title="划分成不大于m的不重复正整数个数"></a>划分成不大于m的不重复正整数个数</h2><p>设<script type="math/tex">f_{i, j}</script>为把<script type="math/tex">i</script>划分成最大数不超过<script type="math/tex">j</script>的划分数，得：<script type="math/tex">f_{i, j} = f_{i - j, j - 1} + f_{i, j - 1}</script></p><h2 id="划分成不小于m的不重复正整数个数"><a href="#划分成不小于m的不重复正整数个数" class="headerlink" title="划分成不小于m的不重复正整数个数"></a>划分成不小于m的不重复正整数个数</h2><p>设<script type="math/tex">f_{i, j}</script>为把<script type="math/tex">i</script>划分成最小数不小于<script type="math/tex">j</script>的划分数，得：<script type="math/tex">f_{i, j} = f_{i - j, j + 1} + f_{i, j + 1}</script></p><h2 id="划分成不大于m的不重复k个正整数"><a href="#划分成不大于m的不重复k个正整数" class="headerlink" title="划分成不大于m的不重复k个正整数"></a>划分成不大于m的不重复k个正整数</h2><p>设<script type="math/tex">f_{i, j}</script>为把<script type="math/tex">i</script>划分成<script type="math/tex">j</script>个数的方案，得<script type="math/tex">f_{i, j} = f_{i - j, j} + f_{i - j, j - 1} - f_{i - (m + 1), j - 1}</script>，整体加 1 和整体加1后再新划分1。当<script type="math/tex">i</script>大于<script type="math/tex">m</script>的时候减去最后一项，因为每次转移最多有一个大于<script type="math/tex">m</script>的数，直接扣掉贡献即可。</p><h2 id="划分成若干个奇数"><a href="#划分成若干个奇数" class="headerlink" title="划分成若干个奇数"></a>划分成若干个奇数</h2><p>设<script type="math/tex">f_{i, j}</script>为把<script type="math/tex">i</script>划分成最大数不超过<script type="math/tex">j</script>的划分数，得：</p><script type="math/tex; mode=display">f_{i, j} = f_{i - j, j - 1} + f_{i, j} \ \ \  (j \% 2 == 1)\\f_{i, j} = f_{i - j, j - 1}  \ \ \ \ \ (j \% 2 == 0)</script><h2 id="划分成k个奇数"><a href="#划分成k个奇数" class="headerlink" title="划分成k个奇数"></a>划分成k个奇数</h2><p>设<script type="math/tex">f_{i, j}</script>为把<script type="math/tex">i</script>划分成<script type="math/tex">j</script>个奇数的方案，<script type="math/tex">g_{i, j}</script>为把<script type="math/tex">i</script>划分成<script type="math/tex">j</script>个偶数的方案，得：</p><script type="math/tex; mode=display">f_{i, j} = g_{i - j, j} + f_{i - 1, j - 1}</script><script type="math/tex; mode=display">g_{i, j} = f_{i - j, j}</script><p>以上都是<script type="math/tex">n^2dp</script><br>但对于某些没限制或者弱限制的，我们可以在更好的复杂度内完成。</p><h2 id="划分成若干整数"><a href="#划分成若干整数" class="headerlink" title="划分成若干整数"></a>划分成若干整数</h2><p>考虑分块背包，<script type="math/tex">S = \sqrt(n)</script>，分为<script type="math/tex">[1, S - 1]和[S, n]</script>两部分，<br>前面直接完全背包<br>后面考虑选的数不会超过<script type="math/tex">\sqrt(n)</script>个，令<script type="math/tex">f_{i, j}</script>表示<script type="math/tex">i</script>划分成j个整数，因为这里最小整数是<script type="math/tex">S</script>，得：<script type="math/tex">f_{i, j} = f_{i - j, j} + f_{i - S, j - 1}</script><br>复杂度<script type="math/tex">O(n\sqrt(n))</script></p><h1 id="五边形数"><a href="#五边形数" class="headerlink" title="五边形数"></a>五边形数</h1><p>五边形数满足一个递推式：<script type="math/tex">f_i = f_{i - 1} + 3n - 2</script><br>可以直接得到公式:<script type="math/tex">f_i = \frac{n(3n - 1)}{2}</script><br>前几个五边形数：<script type="math/tex">1, 5, 12, 22, 35, 51, 70, 92, 117, 145, 176, 210...</script></p><h1 id="广义五边形数"><a href="#广义五边形数" class="headerlink" title="广义五边形数"></a>广义五边形数</h1><p>上述是在<script type="math/tex">n</script>取正数的时候，广义五边形数允许<script type="math/tex">n</script>取负数，值取绝对值，最后得到序列：<script type="math/tex">0, 1, 2, 5, 7, 12, 15, 22, 26, 35, 40, 51, 57, 70...</script></p><h1 id="欧拉函数"><a href="#欧拉函数" class="headerlink" title="欧拉函数"></a>欧拉函数</h1><p>欧拉函数<script type="math/tex">\phi(x) = \prod_{i = 1}^{+ \infty}(1 - x^i)</script><br>这很好理解，每一个<script type="math/tex">i</script>对应的式子代表选数<script type="math/tex">i</script>的生成函数，乘起来就是最后的划分方案数。</p><p>最后的方案数<script type="math/tex">G(x) = \prod_{i = 1}^{+ \infty}\frac{1}{1 - x^i}</script><br>于是有<script type="math/tex">G(x)\phi(x) = 1</script>。</p><p>得：<script type="math/tex">\phi(x) = \prod_{i = 1}^{+ \infty}(1 - x^i) = \sum_{-\infty}^{+\infty}(-1)^kx^{\frac{k(3k-1)}{2}} = 1 + \sum_{1}^{+\infty}(-1)^i(x^{\frac{k(3k-1)}{2}} + x^{\frac{k(3k+1)}{2}})</script></p><p>展开得<script type="math/tex">\phi(x) = (1 - x - x^2 + x^5 + x^7 - x^{12} - x^{15}....)</script></p><p>有<script type="math/tex">(1 + p_1x + p_2x^2 + p_3x^3 + ... + p_nx^n)(1 - x - x^2 + x^5 + x^7 - x^{12} - x^{15}...) = 1</script></p><p>对比<script type="math/tex">x^n</script>的系数，我们得到<script type="math/tex">p_n - p_{n - 1} - p_{n - 2} + p_{n - 5} + p_{n - 7} + ... = 0</script>，就可以得到<script type="math/tex">p_n</script>的递推式。</p><p>由五边形数的递推数我们看出大小数量级是<script type="math/tex">n^2</script>的，所以<script type="math/tex">n</script>以内五边形数个数的数量级在<script type="math/tex">\sqrt(n)</script>个，转移复杂度<script type="math/tex">O(n\sqrt(n))</script></p><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=4651" target="_blank" rel="noopener">HDU-4651 Partition</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> db;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vi;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;ll&gt; vl;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;pii&gt; vp;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">const</span> ll INF = <span class="number">1e18</span>;</span><br><span class="line"><span class="keyword">const</span> db eps = <span class="number">1e-10</span>;</span><br><span class="line"><span class="keyword">const</span> db pi = <span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> eb emplace_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ep emplace</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mem(a) memset(a, 0, sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> copy(a, b) memcpy(a, b, sizeof(b))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PA cout &lt;&lt; <span class="meta-string">"pass\n"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lowbit(x) (x &amp; -x)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(x) x.begin(), x.end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TM cout &lt;&lt; db(clock()) / CLOCKS_PER_SEC &lt;&lt; <span class="meta-string">'\n'</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">mt19937 <span class="title">mrand</span><span class="params">(chrono::high_resolution_clock::now().time_since_epoch().count())</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;<span class="title">inline</span> <span class="title">void</span> <span class="title">upmin</span>(<span class="title">T</span> &amp;<span class="title">x</span>, <span class="title">T</span> <span class="title">y</span>) &#123;</span>x = x &gt; y ? y : x;&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;<span class="title">inline</span> <span class="title">void</span> <span class="title">upmax</span>(<span class="title">T</span> &amp;<span class="title">x</span>, <span class="title">T</span> <span class="title">y</span>) &#123;</span>x = x &lt; y ? y : x;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e5</span> + <span class="number">233</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    x += y;</span><br><span class="line">    <span class="keyword">if</span>(x &gt;= mod) x -= mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sub</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    x -= y;</span><br><span class="line">    <span class="keyword">if</span>(x &lt; <span class="number">0</span>) x += mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; f;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(maxn);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i * (<span class="number">3</span> * i + <span class="number">1</span>) / <span class="number">2</span> &lt; maxn; i++)&#123;</span><br><span class="line">        f.eb(i * (<span class="number">3</span> * i - <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">        f.eb(i * (<span class="number">3</span> * i + <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; maxn; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; f.size() &amp;&amp; f[j] &lt;= i; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>((j / <span class="number">2</span>) &amp; <span class="number">1</span>) sub(sum, dp[i - f[j]]);</span><br><span class="line">            <span class="keyword">else</span> add(sum, dp[i - f[j]]);</span><br><span class="line">        &#125;</span><br><span class="line">        dp[i] = sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T, n;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>), <span class="built_in">cin</span>.tie(<span class="number">0</span>), <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; fixed &lt;&lt; setprecision(<span class="number">10</span>);</span><br><span class="line">    init();</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; dp[n] &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="每个数选择次数小于k次"><a href="#每个数选择次数小于k次" class="headerlink" title="每个数选择次数小于k次"></a>每个数选择次数小于k次</h1><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=4658" target="_blank" rel="noopener">HDU-4658 Integer Partition</a><br>考虑<script type="math/tex">G'(x) = \prod_{i = 1}^{\infty}\frac{1 - x^{ik}}{1 - x^i} = \frac{\phi(x^k)}{\phi(x)} = \phi(x^k)G(x)</script><br>展开后得<script type="math/tex">(1 - x^{k} - x^{2k} + x^{5k} + x^{7k}....)(1 + p_1x + p_2x^2 + p_3x^3 + ... + p_nx^n)</script><br>其中<script type="math/tex">x^n</script>的系数就是答案，答案为<script type="math/tex">p_n - p_{n - k} - p_{n - 2k} + p_{n + 5k} + p_{n + 7k} + ...</script></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> db;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vi;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;ll&gt; vl;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;pii&gt; vp;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">const</span> ll INF = <span class="number">1e18</span>;</span><br><span class="line"><span class="keyword">const</span> db eps = <span class="number">1e-10</span>;</span><br><span class="line"><span class="keyword">const</span> db pi = <span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> eb emplace_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ep emplace</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mem(a) memset(a, 0, sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> copy(a, b) memcpy(a, b, sizeof(b))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PA cout &lt;&lt; <span class="meta-string">"pass\n"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lowbit(x) (x &amp; -x)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(x) x.begin(), x.end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TM cout &lt;&lt; db(clock()) / CLOCKS_PER_SEC &lt;&lt; <span class="meta-string">'\n'</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">mt19937 <span class="title">mrand</span><span class="params">(chrono::high_resolution_clock::now().time_since_epoch().count())</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;<span class="title">inline</span> <span class="title">void</span> <span class="title">upmin</span>(<span class="title">T</span> &amp;<span class="title">x</span>, <span class="title">T</span> <span class="title">y</span>) &#123;</span>x = x &gt; y ? y : x;&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;<span class="title">inline</span> <span class="title">void</span> <span class="title">upmax</span>(<span class="title">T</span> &amp;<span class="title">x</span>, <span class="title">T</span> <span class="title">y</span>) &#123;</span>x = x &lt; y ? y : x;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e5</span> + <span class="number">233</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    x += y;</span><br><span class="line">    <span class="keyword">if</span>(x &gt;= mod) x -= mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sub</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    x -= y;</span><br><span class="line">    <span class="keyword">if</span>(x &lt; <span class="number">0</span>) x += mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; f;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(maxn);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i * (<span class="number">3</span> * i + <span class="number">1</span>) / <span class="number">2</span> &lt; maxn; i++)&#123;</span><br><span class="line">        f.eb(i * (<span class="number">3</span> * i - <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">        f.eb(i * (<span class="number">3</span> * i + <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; maxn; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; f.size() &amp;&amp; f[j] &lt;= i; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>((j / <span class="number">2</span>) &amp; <span class="number">1</span>) sub(sum, dp[i - f[j]]);</span><br><span class="line">            <span class="keyword">else</span> add(sum, dp[i - f[j]]);</span><br><span class="line">        &#125;</span><br><span class="line">        dp[i] = sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = dp[n];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; f.size() &amp;&amp; f[i] * k &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>((i / <span class="number">2</span>) &amp; <span class="number">1</span>) add(res, dp[n - k * f[i]]);</span><br><span class="line">        <span class="keyword">else</span> sub(res, dp[n - k * f[i]]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T, n, k;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>), <span class="built_in">cin</span>.tie(<span class="number">0</span>), <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; fixed &lt;&lt; setprecision(<span class="number">10</span>);</span><br><span class="line">    init();</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; solve(n, k) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有一种多项式的做法，但跑的巨慢无比，比根号还慢很多，就不学了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;去年沈阳栽的跟头，白送一个题没有拿到，结果现在才补。&lt;/p&gt;
&lt;h1 id=&quot;整数划分&quot;&gt;&lt;a href=&quot;#整数划分&quot; class=&quot;headerlink&quot; title=&quot;整数划分&quot;&gt;&lt;/a&gt;整数划分&lt;/h1&gt;&lt;p&gt;整数划分有很多变种，一般来说通过二维dp以及控制dp的转移策略都可以在&lt;script type=&quot;math/tex&quot;&gt;n^2&lt;/script&gt;的复杂度完成。下面讨论一部分：&lt;/p&gt;
    
    </summary>
    
      <category term="组合数学" scheme="http://yoursite.com/categories/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"/>
    
    
  </entry>
  
  <entry>
    <title>同余大杂烩</title>
    <link href="http://yoursite.com/2020/10/29/%E5%90%8C%E4%BD%99%E5%A4%A7%E6%9D%82%E7%83%A9/"/>
    <id>http://yoursite.com/2020/10/29/同余大杂烩/</id>
    <published>2020-10-29T12:07:38.000Z</published>
    <updated>2020-10-30T03:35:13.747Z</updated>
    
    <content type="html"><![CDATA[<h1 id="exgcd"><a href="#exgcd" class="headerlink" title="exgcd"></a>exgcd</h1><p>拓展欧几里得<script type="math/tex">exgcd</script>用来求方程<script type="math/tex">ax + by = gcd(a, b)</script>的一组特解，考虑运用辗转相除，假设我们得到了<script type="math/tex">a_1x_1 + b_1y_1 = gcd(a, b)</script>的解<script type="math/tex">x_1, y_1</script>，<script type="math/tex">(a_1 = b, b_1 = a - \lfloor\frac{a}{b}\rfloor * b)</script>，可以得到<script type="math/tex">y = x_1 - \lfloor\frac{a}{b}\rfloor * y_1</script>，<script type="math/tex">x = y_1</script>，所以我们可以直接交换<script type="math/tex">x, y</script>，再减去<script type="math/tex">\lfloor\frac{a}{b}\rfloor * y_1</script>即可，代码如下：<br><a id="more"></a><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ll <span class="title">exgcd</span><span class="params">(ll a, ll b, ll &amp;x, ll &amp;y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!b) &#123;</span><br><span class="line">        x = <span class="number">1</span>, y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    ll g = exgcd(b, a % b, y, x);</span><br><span class="line">    y -= x * (a / b);</span><br><span class="line">    <span class="keyword">return</span> g;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果给方程<script type="math/tex">ax + by = c</script>判断是否有解，只用判断是否有<script type="math/tex">gcd(a, b) | c</script>，求解出来后直接把<script type="math/tex">x, y</script>乘上<script type="math/tex">c / gcd(a, b)</script>即可。</p><h2 id="最小自然数解"><a href="#最小自然数解" class="headerlink" title="最小自然数解"></a>最小自然数解</h2><p>可能有些情况需要我们保证<script type="math/tex">x</script>或者<script type="math/tex">y</script>是正整数，我们先考虑通解形式。<br>我们知道每次变化都是以<script type="math/tex">gcd(a, b)</script>为最小单位，感知我们可以发现，每次改变一个单位的<script type="math/tex">x</script>，会增加<script type="math/tex">\frac{a}{gcd(a, b)}</script>个<script type="math/tex">gcd</script>，改变一个单位的<script type="math/tex">y</script>，会增加<script type="math/tex">\frac{b}{gcd(a, b)}</script>个<script type="math/tex">gcd</script>，为了保证二者能够相互约掉，最小的改变的一步应该为<script type="math/tex">\frac{ab}{gcd(a, b)}</script>，那么通解形式为：</p><script type="math/tex; mode=display">x = a(x_0 + \frac{b}{gcd(a, b)}), y = b(y_0 + \frac{a}{gcd(a, b)})</script><p>换句话说，对于<script type="math/tex">x</script>的解空间，它们在模<script type="math/tex">\frac{b}{gcd(a, b)}</script>下是一个等价类，对于<script type="math/tex">y</script>的解空间，它们在模<script type="math/tex">\frac{a}{gcd(a, b)}</script>下是一个等价类。</p><p>于是我们可以求最小自然数解，如<script type="math/tex">x</script>，直接拿特解对<script type="math/tex">\frac{b}{gcd(a, b)}</script>求模意义下的最小自然数等价类，算出对应的<script type="math/tex">y</script>即可得到答案</p><h2 id="求逆元"><a href="#求逆元" class="headerlink" title="求逆元"></a>求逆元</h2><p>求逆元我们习惯用费马小定理，但当<script type="math/tex">p</script>不是质数但是与<script type="math/tex">a</script>互质的时候，这时候存在逆元，却不能用费马小定理求逆元了，于是我们考虑用<script type="math/tex">exgcd</script>求逆元。<br>方程<script type="math/tex">a_x \equiv (1 \ mod \ p)</script>等价于存在一个<script type="math/tex">b使得ax - bp = 1</script>，于是只需要用<script type="math/tex">exgcd</script>求方程的解就行了，注意求出来后<script type="math/tex">x</script>可能是负数，需要对<script type="math/tex">p</script>取模求模意义下的最小自然数等价类。</p><h1 id="中国剩余定理"><a href="#中国剩余定理" class="headerlink" title="中国剩余定理"></a>中国剩余定理</h1><h2 id="中国剩余定理-1"><a href="#中国剩余定理-1" class="headerlink" title="中国剩余定理"></a>中国剩余定理</h2><p>中国剩余定理用来求解同余方程组</p><script type="math/tex; mode=display">\begin{cases}x \equiv a_1(mod \ m_1)\\x \equiv a_2(mod \ m_2)\\x \equiv a_3(mod \ m_3)\\... \\x \equiv a_n(mod \ m_n)\\\end{cases}</script><p>其中<script type="math/tex">m_1, m_2, m_3, \cdots, m_n</script>是两两互质的数<br>一般是求<script type="math/tex">x</script>的最小正整数解</p><h3 id="定理"><a href="#定理" class="headerlink" title="定理"></a>定理</h3><p>令<script type="math/tex">M = \prod_{i = 1}^n m_i</script>, <script type="math/tex">\frac{M}{m_i}t_i \equiv 1</script><br>有一个特解为<script type="math/tex">x = \sum_{i = 1}^na_i\frac{M}{m_i}t_i</script><br>最小非负整数解为<script type="math/tex">(x \% M + M) % M</script><br>证明非常容易，代入原来的<script type="math/tex">n</script>个条件发现都满足。</p><p>中国剩余定理常用来辅助解决一些题目，一些题目对合数取模不好做的时候，可以对其所有质因子次方项取模求答案，最后再用<script type="math/tex">crt</script>合并答案。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ll <span class="title">crt</span><span class="params">(<span class="built_in">vector</span>&lt;ll&gt; &amp;m, <span class="built_in">vector</span>&lt;ll&gt; &amp;a)</span></span>&#123;</span><br><span class="line">    ll M = <span class="number">1</span>, res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m.size(); i++) M *= m[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m.size(); i++)&#123;</span><br><span class="line">        ll w = M / m[i];</span><br><span class="line">        ll t = Ex_gcd::inv(w, m[i]);</span><br><span class="line">        <span class="comment">//res = (res + t * w * a[i]) % M;</span></span><br><span class="line">        res = (res + mul(mul(t, w, M), a[i], M)) % M; <span class="comment">//防止爆long long</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (res % M + M) % M;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="拓展中国剩余定理"><a href="#拓展中国剩余定理" class="headerlink" title="拓展中国剩余定理"></a>拓展中国剩余定理</h2><p>当所有<script type="math/tex">m_i</script>之间不满足两两互质的情况，这时候就要用到拓展中国剩余定理。</p><h3 id="定理-1"><a href="#定理-1" class="headerlink" title="定理"></a>定理</h3><p>假设我们求出前<script type="math/tex">k - 1</script>个方程的解为<script type="math/tex">x</script>，且<script type="math/tex">M = lcm(\prod_{i = 1}^{k - 1}m_i)</script>，则前<script type="math/tex">k - 1</script>个方程的通解为<script type="math/tex">x + iM</script>。<br>考虑加入第<script type="math/tex">k</script>个方程，需要求一个<script type="math/tex">t</script>满足<script type="math/tex">x + tM \equiv (a_k \ mod \ m_k)</script>，转换一下即求<script type="math/tex">bm_k + tM \equiv(a_k - x \ mod \ m_k)</script>，这玩意可以用<script type="math/tex">exgcd</script>求解，当<script type="math/tex">gcd(m_k, M) | a_k - x</script>满足时才有解。求出对应的<script type="math/tex">t</script>后，我们需要将其扩大<script type="math/tex">\frac{a_k - x}{gcd(m_k, M)}</script>倍，且根据上面我们知道它的最小周期为<script type="math/tex">\frac{M}{gcd(M, m_i)}</script>，直接对其取模即可（注意过程中可能爆，所以用龟速乘）。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ll <span class="title">mul</span><span class="params">(ll q, ll w, ll mod)</span></span>&#123;</span><br><span class="line">    ll ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(w)&#123;</span><br><span class="line">        <span class="keyword">if</span>(w &amp; <span class="number">1</span>) ret = (ret + q) % mod;</span><br><span class="line">        q = (q + q) % mod;</span><br><span class="line">        w &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">excrt</span><span class="params">(<span class="built_in">vector</span>&lt;ll&gt; &amp;m, <span class="built_in">vector</span>&lt;ll&gt; &amp;a)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    ll M = m[<span class="number">0</span>], res = a[<span class="number">0</span>], x, y;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m.size(); i++)&#123;</span><br><span class="line">        ll c = (a[i] - res % m[i] + m[i]) % m[i];</span><br><span class="line">        ll g = Ex_gcd::exgcd(M, m[i], x, y);</span><br><span class="line">        <span class="keyword">if</span>(c % g) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        ll bg = m[i] / g;</span><br><span class="line">        x = mul(x, c / g, bg);</span><br><span class="line">        res += x * M;</span><br><span class="line">        M *= bg;</span><br><span class="line">        res = (res % M + M) % M;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (res % M + M) % M;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="卢卡斯定理"><a href="#卢卡斯定理" class="headerlink" title="卢卡斯定理"></a>卢卡斯定理</h1><p>对于一般的组合数满足<script type="math/tex">n, m << p</script>的<script type="math/tex">C_n^m \ mod \ p</script>，我们预处理阶乘，然后用阶乘及逆元去做。但是当<script type="math/tex">n, m > p</script>的时候，预处理阶乘就不行了，这时候阶乘永远求出来结果是0，但是可能真实答案不是0。<br>卢卡斯定理用来计算这一类问题。</p><h2 id="卢卡斯定理-1"><a href="#卢卡斯定理-1" class="headerlink" title="卢卡斯定理"></a>卢卡斯定理</h2><p>当<script type="math/tex">p</script>是质数的时候，有如下性质：</p><script type="math/tex; mode=display">C_n^m \ mod \ p = C_{n \% p}^{m \% p}C_{n / p}^{m / p}</script><p>证明略过。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ll <span class="title">C</span><span class="params">(ll n, ll m, ll p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt; <span class="number">0</span> || n &lt; m || m &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> fac[n] * inv[m] % p * inv[n - m] % p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">lucas</span><span class="params">(ll n, ll m, ll p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!m) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> C(n % p, m % p, p) * lucas(n / p, m / p, p) % p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="拓展卢卡斯定理"><a href="#拓展卢卡斯定理" class="headerlink" title="拓展卢卡斯定理"></a>拓展卢卡斯定理</h2><p>当<script type="math/tex">p</script>不是质数，上面的性质就不成立了，我们只能来冷静分析一波。<br>这时候就要用上<script type="math/tex">crt</script>的套路了，考虑把<script type="math/tex">p</script>分解成一部分因子相乘，每个因子都只包含一种质数，这样各个因子之间就是互质的，我们对这些因子求答案，再用<script type="math/tex">crt</script>合并。</p><h3 id="求解-C-n-m-mod-p-i-k"><a href="#求解-C-n-m-mod-p-i-k" class="headerlink" title="求解$C_n^m  mod  p_i^k$"></a>求解$C_n^m  mod  p_i^k$</h3><p>这玩意也不能直接套用卢卡斯定理，我们考虑将<script type="math/tex">C_n^m</script>里面所有<script type="math/tex">p_i</script>的因子提出来，算剩下部分的贡献，即变为<script type="math/tex">\frac{\frac{n!}{p_i^a}}{\frac{m!}{p_i^b}\frac{(n - m)!}{p_i^c}}p_i^{a - b - c}</script></p><p>问题变成了求<script type="math/tex">\frac{n!}{p_i^a} \ mod \ p_i^k \ mod \ p_i^k</script></p><h3 id="求解-frac-n-p-i-a-mod-p-i-k"><a href="#求解-frac-n-p-i-a-mod-p-i-k" class="headerlink" title="求解$\frac{n!}{p_i^a}  mod  p_i^k$"></a>求解$\frac{n!}{p_i^a}  mod  p_i^k$</h3><p>我们把<script type="math/tex">n!</script>贡献分为三部分：</p><ul><li><script type="math/tex">p_i</script>的次方</li><li><script type="math/tex">\lfloor\frac{n}{p_i}\rfloor</script>!</li><li>非<script type="math/tex">p_i</script>倍数部分的余数</li></ul><p>举个例子<script type="math/tex">n = 22, p = 3</script></p><script type="math/tex; mode=display">22! = 3^7 * (7!) * (1 * 2 * 4 * 5 * 7 * 8 * 10 * 11 * 13 * 14 * 16 * 17 * 19 * 20 * 22)</script><p>第一部分就是<script type="math/tex">3^7</script>，因为我们在外面会去掉所有<script type="math/tex">p_i</script>，所以没有贡献。<br>第二部分是<script type="math/tex">7!</script>，直接递归下去做。<br>第三部分分为两个part，一个是完整的模<script type="math/tex">p_i</script>周期内，所有完整周期内非<script type="math/tex">p_i</script>倍数的乘积的余数都是一样的，直接算一个周期然后快速幂即可，最后可能还剩一部分非完整的，剩下的部分直接暴力算即可。<br><strong>tips</strong>:预处理阶乘会快很多</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> Lucas&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;ll&gt; fac;</span><br><span class="line"></span><br><span class="line">    <span class="function">ll <span class="title">pow_mod</span><span class="params">(ll q, ll w, ll mod)</span></span>&#123;</span><br><span class="line">        ll ret = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(w)&#123;</span><br><span class="line">            <span class="keyword">if</span>(w &amp; <span class="number">1</span>) ret = ret * q % mod;</span><br><span class="line">            q = q * q % mod;</span><br><span class="line">            w &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ll <span class="title">solve_fac</span><span class="params">(ll n, ll p, ll pk)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!n) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> pow_mod(fac[pk], n / pk, pk) * fac[n % pk] % pk * solve_fac(n / p, p, pk) % pk;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ll <span class="title">cal</span><span class="params">(ll n, ll m, ll p)</span></span>&#123;</span><br><span class="line">        ll cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(ll i = n; i; i /= p) cnt += i / p;</span><br><span class="line">        <span class="keyword">for</span>(ll i = m; i; i /= p) cnt -= i / p;</span><br><span class="line">        <span class="keyword">for</span>(ll i = n - m; i; i /= p) cnt -= i / p;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ll <span class="title">C</span><span class="params">(ll n, ll m, ll p, ll pk)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt; m) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        fac.resize(pk + <span class="number">1</span>);</span><br><span class="line">        fac[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= pk; i++)&#123;</span><br><span class="line">            fac[i] = fac[i - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(i % p) fac[i] = fac[i] * i % pk;</span><br><span class="line">        &#125;</span><br><span class="line">        ll a = solve_fac(n, p, pk);</span><br><span class="line">        ll b = solve_fac(m, p, pk);</span><br><span class="line">        ll c = solve_fac(n - m, p, pk);</span><br><span class="line">        ll cnt = cal(n, m, p);</span><br><span class="line">        <span class="keyword">return</span> a * Ex_gcd::inv(b, pk) % pk * Ex_gcd::inv(c, pk) % pk * pow_mod(p, cnt, pk) % pk;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ll <span class="title">exlucas</span><span class="params">(ll n, ll m, ll mod)</span></span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;ll&gt; a, b;</span><br><span class="line">        <span class="keyword">for</span>(ll i = <span class="number">2</span>; i * i &lt;= mod &amp;&amp; mod &gt; <span class="number">1</span>; i++)&#123;</span><br><span class="line">            ll tmp = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(mod % i == <span class="number">0</span>) mod /= i, tmp *= i;</span><br><span class="line">            <span class="keyword">if</span>(tmp &gt; <span class="number">1</span>) b.push_back(C(n, m, i, tmp)), a.push_back(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(mod &gt; <span class="number">1</span>) b.push_back(C(n, m, mod, mod)), a.push_back(mod);</span><br><span class="line">        <span class="keyword">return</span> CRT::crt(a, b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;exgcd&quot;&gt;&lt;a href=&quot;#exgcd&quot; class=&quot;headerlink&quot; title=&quot;exgcd&quot;&gt;&lt;/a&gt;exgcd&lt;/h1&gt;&lt;p&gt;拓展欧几里得&lt;script type=&quot;math/tex&quot;&gt;exgcd&lt;/script&gt;用来求方程&lt;script type=&quot;math/tex&quot;&gt;ax + by = gcd(a, b)&lt;/script&gt;的一组特解，考虑运用辗转相除，假设我们得到了&lt;script type=&quot;math/tex&quot;&gt;a_1x_1 + b_1y_1 = gcd(a, b)&lt;/script&gt;的解&lt;script type=&quot;math/tex&quot;&gt;x_1, y_1&lt;/script&gt;，&lt;script type=&quot;math/tex&quot;&gt;(a_1 = b, b_1 = a - \lfloor\frac{a}{b}\rfloor * b)&lt;/script&gt;，可以得到&lt;script type=&quot;math/tex&quot;&gt;y = x_1 - \lfloor\frac{a}{b}\rfloor * y_1&lt;/script&gt;，&lt;script type=&quot;math/tex&quot;&gt;x = y_1&lt;/script&gt;，所以我们可以直接交换&lt;script type=&quot;math/tex&quot;&gt;x, y&lt;/script&gt;，再减去&lt;script type=&quot;math/tex&quot;&gt;\lfloor\frac{a}{b}\rfloor * y_1&lt;/script&gt;即可，代码如下：&lt;br&gt;
    
    </summary>
    
      <category term="数论" scheme="http://yoursite.com/categories/%E6%95%B0%E8%AE%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>Polya定理, Start Dash!</title>
    <link href="http://yoursite.com/2020/10/10/Polya%E5%AE%9A%E7%90%86-Start-Dash/"/>
    <id>http://yoursite.com/2020/10/10/Polya定理-Start-Dash/</id>
    <published>2020-10-10T08:09:58.000Z</published>
    <updated>2020-10-11T18:54:36.736Z</updated>
    
    <content type="html"><![CDATA[<p><strong>如果能为了某个人变强，对于悲伤我也心存感激~</strong></p><h1 id="Polya简介"><a href="#Polya简介" class="headerlink" title="Polya简介"></a>Polya简介</h1><p>Polya定理用来解决旋转，对称同构的计数问题，其定理形式简单，但变种问题十分多且有趣。</p><h2 id="前置"><a href="#前置" class="headerlink" title="前置"></a>前置</h2><ul><li>置换</li><li>数论<br>本文不打算讲前置内容以及定理的证明</li></ul><h2 id="定理内容"><a href="#定理内容" class="headerlink" title="定理内容"></a>定理内容</h2><script type="math/tex; mode=display">M = \frac{1}{G}\sum_{i = 1}^gf(c_i)</script><p>其中<script type="math/tex">c_i</script>表示第i种置换中循环节的个数。</p><p>用简单的话来说，<script type="math/tex">Polya</script>就是找到所有的置换，然后对每一种置换找到循环节个数，同一个循环节看成一个不动点（如染色问题中循环节内的所有点必须是同一种颜色），算出该置换下的方案数，对所有置换的方案数求和后平均。</p><p>那么问题很明显可以划分为两个步骤：</p><ul><li>找到置换</li><li>算出置换下的方案数</li></ul><p>难题可能是在这两个步骤的某一步中比较不好处理，但所有的<script type="math/tex">Polya</script>题目无外乎都要这么考虑</p><a id="more"></a><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="http://poj.org/problem?id=2154" target="_blank" rel="noopener">poj-2154</a><br>将正n边形的n个顶点用n种颜色染色，问有多少种方案？<br>考虑置换，可能是旋转，有n种情况(旋转1,2,3<script type="math/tex">\cdots</script>n个点)。本题说了不考虑翻转，所以就没有翻转对应的置换。<br>考虑旋转长度为i，此时循环节的个数就为<script type="math/tex">gcd(n, i)</script>，那么问题变成了求<script type="math/tex">\sum_{i = 1}^nn^{gcd(n, i) - 1}</script>。由于n很大，直接枚举就起飞了，考虑数论优化。</p><script type="math/tex; mode=display">\sum_{i = 1}^nn^{gcd(n, i)} = \sum_{d | n}n^d\sum_{i = 1}^{\frac{n}{d}}[gcd(i, \frac{n}{d}) == 1]</script><p>我们发现<script type="math/tex">\sum_{i = 1}^{\frac{n}{d}}[gcd(i, \frac{n}{d}) == 1] = \phi(\frac{n}{d})</script><br>于是有<script type="math/tex">\sum_{i = 1}^nn^{gcd(i, n)} = \sum_{d | n}n^d\phi(\frac{n}{d})</script><br>枚举因子，直接暴力算<script type="math/tex">phi</script>函数即可优化到<script type="math/tex">O(\sqrt(n))</script></p><div><div class="fold_hider"><div class="close hider_title">代码</div></div><div class="fold"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> db;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vi;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;ll&gt; vl;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;pii&gt; vp;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">const</span> ll INF = <span class="number">1e18</span>;</span><br><span class="line"><span class="keyword">const</span> db eps = <span class="number">1e-10</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> eb emplace_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ep emplace</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mem(a) memset(a, 0, sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> copy(a, b) memcpy(a, b, sizeof(b))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PA cout &lt;&lt; <span class="meta-string">"pass\n"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lowbit(x) (x &amp; -x)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(x) x.begin(), x.end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TM cout &lt;&lt; db(clock()) / CLOCKS_PER_SEC &lt;&lt; <span class="meta-string">'\n'</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;<span class="title">inline</span> <span class="title">void</span> <span class="title">upmin</span>(<span class="title">T</span> &amp;<span class="title">x</span>, <span class="title">T</span> <span class="title">y</span>) &#123;</span>x = x &gt; y ? y : x;&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;<span class="title">inline</span> <span class="title">void</span> <span class="title">upmax</span>(<span class="title">T</span> &amp;<span class="title">x</span>, <span class="title">T</span> <span class="title">y</span>) &#123;</span>x = x &lt; y ? y : x;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">euler</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = n, a = n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i * i &lt;= a; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a % i == <span class="number">0</span>) &#123;</span><br><span class="line">            res = res / i * (i - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">while</span> (a % i == <span class="number">0</span>) a /= i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (a &gt; <span class="number">1</span>) res = res / a * (a - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T, n, p;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pow_mod</span><span class="params">(<span class="keyword">int</span> q, <span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">1</span>;</span><br><span class="line">    q %= p;</span><br><span class="line">    <span class="keyword">while</span>(w)&#123;</span><br><span class="line">        <span class="keyword">if</span>(w &amp; <span class="number">1</span>) ret = ret * q % p;</span><br><span class="line">        q = q * q % p;</span><br><span class="line">        w &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>), <span class="built_in">cin</span>.tie(<span class="number">0</span>), <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; p;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i * i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(n % i == <span class="number">0</span>)&#123;</span><br><span class="line">                res = (res + euler(n / i) % p * pow_mod(n, i - <span class="number">1</span>)) % p;</span><br><span class="line">                <span class="keyword">if</span>(n / i != i)&#123;</span><br><span class="line">                    res = (res + euler(i) % p * pow_mod(n, n / i - <span class="number">1</span>)) % p;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><p><a href="https://ac.nowcoder.com/acm/problem/54301" target="_blank" rel="noopener">远山的占卜</a><br>把对角的提出来算好方案数，然后就变成跟上一个题一模一样的题了，数据范围有些不一样，所以预处理好<script type="math/tex">phi</script>函数即可。<br><div><div class="fold_hider"><div class="close hider_title">代码</div></div><div class="fold"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> db;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vi;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;ll&gt; vl;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;pii&gt; vp;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">const</span> ll INF = <span class="number">1e18</span>;</span><br><span class="line"><span class="keyword">const</span> db eps = <span class="number">1e-10</span>;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> eb emplace_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ep emplace</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mem(a) memset(a, 0, sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> copy(a, b) memcpy(a, b, sizeof(b))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PA cout &lt;&lt; <span class="meta-string">"pass\n"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lowbit(x) (x &amp; -x)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(x) x.begin(), x.end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TM cout &lt;&lt; db(clock()) / CLOCKS_PER_SEC &lt;&lt; <span class="meta-string">'\n'</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> T, n, k;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">19260817</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = mod;</span><br><span class="line"><span class="keyword">int</span> phi[maxn];</span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line">vi prime;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    phi[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; maxn; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!vis[i]) prime.eb(i), phi[i] = i - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; prime.size() &amp;&amp; i * prime[j] &lt; maxn; ++j) &#123;</span><br><span class="line">            vis[i * prime[j]] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(i % prime[j] == <span class="number">0</span>) &#123;</span><br><span class="line">                phi[i * prime[j]] = phi[i] * prime[j];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            phi[i * prime[j]] = phi[i] * phi[prime[j]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">ll <span class="title">pow_mod</span><span class="params">(ll q, ll w)</span></span>&#123;</span><br><span class="line">    ll ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(w)&#123;</span><br><span class="line">        <span class="keyword">if</span>(w &amp; <span class="number">1</span>) ret = <span class="number">1l</span>l * ret * q % mod;</span><br><span class="line">        q = <span class="number">1l</span>l * q * q % mod;</span><br><span class="line">        w &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>), <span class="built_in">cin</span>.tie(<span class="number">0</span>), <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    init();</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k;</span><br><span class="line">        ll res = <span class="number">0</span>, base = <span class="number">1l</span>l * k * (k + <span class="number">1</span>) / <span class="number">2</span> % mod;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i * i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(n % i) <span class="keyword">continue</span>;</span><br><span class="line">            res = (res + <span class="number">1l</span>l * phi[n / i] * pow_mod(base, i)) % mod;</span><br><span class="line">            <span class="keyword">if</span>(i * i == n) <span class="keyword">continue</span>;</span><br><span class="line">            res = (res + <span class="number">1l</span>l * phi[i] * pow_mod(base, n / i)) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; res * pow_mod(n, mod - 2) % mod &lt;&lt; '\n';</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></p><p><a href="http://poj.org/problem?id=2888" target="_blank" rel="noopener">poj-2888</a><br>还是项链问题，但是有些被颜色不能相邻，求方案数。</p><p>还是依次枚举置换，找到置换的循环节个数，问题就变成了求长度为x的带限制的项链问题的方案数。<br>考虑dp，当前点选了什么颜色，可以通过dp构建一个矩阵来转移，通过矩阵快速幂即可算出方案数，最后求和就行了。</p><div><div class="fold_hider"><div class="close hider_title">代码</div></div><div class="fold"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> db;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vi;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;ll&gt; vl;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;pii&gt; vp;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">const</span> ll INF = <span class="number">1e18</span>;</span><br><span class="line"><span class="keyword">const</span> db eps = <span class="number">1e-10</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> eb emplace_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ep emplace</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mem(a) memset(a, 0, sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> copy(a, b) memcpy(a, b, sizeof(b))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PA cout &lt;&lt; <span class="meta-string">"pass\n"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lowbit(x) (x &amp; -x)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(x) x.begin(), x.end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TM cout &lt;&lt; db(clock()) / CLOCKS_PER_SEC &lt;&lt; <span class="meta-string">'\n'</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;<span class="title">inline</span> <span class="title">void</span> <span class="title">upmin</span>(<span class="title">T</span> &amp;<span class="title">x</span>, <span class="title">T</span> <span class="title">y</span>) &#123;</span>x = x &gt; y ? y : x;&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;<span class="title">inline</span> <span class="title">void</span> <span class="title">upmax</span>(<span class="title">T</span> &amp;<span class="title">x</span>, <span class="title">T</span> <span class="title">y</span>) &#123;</span>x = x &lt; y ? y : x;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T, n, m, k;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">matrix</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> mp[<span class="number">10</span>][<span class="number">10</span>];</span><br><span class="line">    matrix()&#123;</span><br><span class="line">        mem(mp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) mp[i][i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;base;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">9973</span>;</span><br><span class="line"></span><br><span class="line">matrix <span class="keyword">operator</span> * (<span class="keyword">const</span> matrix a, <span class="keyword">const</span> matrix b)&#123;</span><br><span class="line">    matrix c;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> t = <span class="number">0</span>; t &lt; m; t++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; ++j) &#123;</span><br><span class="line">                c.mp[i][j] = (c.mp[i][j] + a.mp[i][t] * b.mp[t][j]) % mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">matrix <span class="title">pow_mod</span><span class="params">(matrix q, <span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">    matrix ret;</span><br><span class="line">    ret.init();</span><br><span class="line">    <span class="keyword">while</span>(w)&#123;</span><br><span class="line">        <span class="keyword">if</span>(w &amp; <span class="number">1</span>) ret = ret * q;</span><br><span class="line">        q = q * q;</span><br><span class="line">        w &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pow_mod</span><span class="params">(<span class="keyword">int</span> q, <span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">1</span>;</span><br><span class="line">    q %= mod;</span><br><span class="line">    <span class="keyword">while</span>(w)&#123;</span><br><span class="line">        <span class="keyword">if</span>(w &amp; <span class="number">1</span>) ret = ret * q % mod;</span><br><span class="line">        q = q * q % mod;</span><br><span class="line">        w &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">euler</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = n, a = n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i * i &lt;= a; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a % i == <span class="number">0</span>) &#123;</span><br><span class="line">            res = res / i * (i - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">while</span> (a % i == <span class="number">0</span>) a /= i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (a &gt; <span class="number">1</span>) res = res / a * (a - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    matrix c = pow_mod(base, x);</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) res = (res + c.mp[i][i]) % mod;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>), <span class="built_in">cin</span>.tie(<span class="number">0</span>), <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++)&#123;</span><br><span class="line">                base.mp[i][j] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> x, y;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y;</span><br><span class="line">            x--, y--;</span><br><span class="line">            base.mp[x][y] = base.mp[y][x] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i * i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(n % i == <span class="number">0</span>)&#123;</span><br><span class="line">                res = (res + euler(n / i) % mod * solve(i)) % mod;</span><br><span class="line">                <span class="keyword">if</span>(n / i != i)&#123;</span><br><span class="line">                    res = (res + euler(i) % mod * solve(n / i)) % mod;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; res * pow_mod(n, mod - 2) % mod &lt;&lt; '\n';</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><p><a href="https://codeforces.com/gym/259514/problem/J" target="_blank" rel="noopener">2019 ICPC Asia Nanchang Onsite-J Summon</a><br>然后你就发现这个题就是上个题的加强版，限制从相邻变成了连续四个，其它的思路基本完全一样。只是注意复杂度，如果用快速幂复杂度为<script type="math/tex">O(64 * 64 * 64 * \sqrt(100000) * log)</script>会T，得想办法把log去掉，于是我们预处理分块，对于某一个幂次只需要<script type="math/tex">O(64^3)</script>即可计算得出，记得枚举因子或者记忆化求解即可。</p><div><div class="fold_hider"><div class="close hider_title">代码</div></div><div class="fold"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> db;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vi;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;ll&gt; vl;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;pii&gt; vp;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">const</span> ll INF = <span class="number">1e18</span>;</span><br><span class="line"><span class="keyword">const</span> db eps = <span class="number">1e-10</span>;</span><br><span class="line"><span class="keyword">const</span> db pi = <span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> eb emplace_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ep emplace</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mem(a) memset(a, 0, sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> copy(a, b) memcpy(a, b, sizeof(b))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PA cout &lt;&lt; <span class="meta-string">"pass\n"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lowbit(x) (x &amp; -x)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(x) x.begin(), x.end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TM cout &lt;&lt; db(clock()) / CLOCKS_PER_SEC &lt;&lt; <span class="meta-string">'\n'</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">mt19937 <span class="title">mrand</span><span class="params">(chrono::high_resolution_clock::now().time_since_epoch().count())</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;<span class="title">inline</span> <span class="title">void</span> <span class="title">upmin</span>(<span class="title">T</span> &amp;<span class="title">x</span>, <span class="title">T</span> <span class="title">y</span>) &#123;</span>x = x &gt; y ? y : x;&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;<span class="title">inline</span> <span class="title">void</span> <span class="title">upmax</span>(<span class="title">T</span> &amp;<span class="title">x</span>, <span class="title">T</span> <span class="title">y</span>) &#123;</span>x = x &lt; y ? y : x;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">400</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">matrix</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> mp[<span class="number">70</span>][<span class="number">70</span>];</span><br><span class="line"></span><br><span class="line">    matrix()&#123;</span><br><span class="line">        mem(mp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">64</span>; i++) mp[i][i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;a[maxn + <span class="number">10</span>], b[maxn + <span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">matrix <span class="keyword">operator</span> * (<span class="keyword">const</span> matrix a, <span class="keyword">const</span> matrix b)&#123;</span><br><span class="line">    matrix c;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">64</span>; k++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">64</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">64</span>; j++)&#123;</span><br><span class="line">                c.mp[i][j] = (c.mp[i][j] + <span class="number">1l</span>l * a.mp[i][k] * b.mp[k][j]) % mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ban[<span class="number">4</span>][<span class="number">4</span>][<span class="number">4</span>][<span class="number">4</span>];</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> res[<span class="number">100005</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> i * <span class="number">4</span> * <span class="number">4</span> + j * <span class="number">4</span> + k;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(res[x] != <span class="number">-1</span>) <span class="keyword">return</span> res[x];</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    matrix c = b[x / maxn] * a[x % maxn];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">64</span>; i++) ans = (ans + c.mp[i][i]) % mod;</span><br><span class="line">    res[x] = ans;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pow_mod</span><span class="params">(<span class="keyword">int</span> q, <span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(w)&#123;</span><br><span class="line">        <span class="keyword">if</span>(w &amp; <span class="number">1</span>) ret = <span class="number">1l</span>l * ret * q % mod;</span><br><span class="line">        q = <span class="number">1l</span>l * q * q % mod;</span><br><span class="line">        w &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>), <span class="built_in">cin</span>.tie(<span class="number">0</span>), <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; fixed &lt;&lt; setprecision(<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> q, w, e, r;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; q &gt;&gt; w &gt;&gt; e &gt;&gt; r;</span><br><span class="line">        ban[q][w][e][r] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; k++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> p = <span class="number">0</span>; p &lt; <span class="number">4</span>; p++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(!ban[i][j][k][p])a[<span class="number">1</span>].mp[get(i, j, k)][get(j, k, p)] = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(res, <span class="number">-1</span>, <span class="keyword">sizeof</span>(res));</span><br><span class="line">    a[<span class="number">0</span>].init();</span><br><span class="line">    b[<span class="number">0</span>].init();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= maxn; i++)&#123;</span><br><span class="line">        a[i] = a[i - <span class="number">1</span>] * a[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    b[<span class="number">1</span>] = a[maxn];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= maxn; i++)&#123;</span><br><span class="line">        b[i] = b[i - <span class="number">1</span>] * b[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        ans = (ans + solve(__gcd(n, i))) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; 1ll * ans * pow_mod(n, mod - 2) % mod &lt;&lt; '\n';</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=2481" target="_blank" rel="noopener">hdu-2481</a><br>还是旋转，考虑旋转后变成了求解<script type="math/tex">f(x)</script>的子问题，</p><p>关于<script type="math/tex">f(n)</script>有递推公式<script type="math/tex">f(n) = 3f(n - 1) - f(n - 2) + 2</script>（怎么来的后面再研究）<br>根据这个公示可以构造矩阵快速幂，于是跟poj-2888基本一样了。</p><p>注意这里P不是质数，所以最后除以n的时候会比较难办，有一个办法是把P先乘上n，然后对这个P’取模，最后结果再除以n即可，这样就需要开__int128了。</p><div><div class="fold_hider"><div class="close hider_title">代码</div></div><div class="fold"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> __int128 i128;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> db;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vi;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;ll&gt; vl;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;pii&gt; vp;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">const</span> ll INF = <span class="number">1e18</span>;</span><br><span class="line"><span class="keyword">const</span> db eps = <span class="number">1e-10</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> eb emplace_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ep emplace</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mem(a) memset(a, 0, sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> copy(a, b) memcpy(a, b, sizeof(b))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PA cout &lt;&lt; <span class="meta-string">"pass\n"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lowbit(x) (x &amp; -x)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(x) x.begin(), x.end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TM cout &lt;&lt; db(clock()) / CLOCKS_PER_SEC &lt;&lt; <span class="meta-string">'\n'</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;<span class="title">inline</span> <span class="title">void</span> <span class="title">upmin</span>(<span class="title">T</span> &amp;<span class="title">x</span>, <span class="title">T</span> <span class="title">y</span>) &#123;</span>x = x &gt; y ? y : x;&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;<span class="title">inline</span> <span class="title">void</span> <span class="title">upmax</span>(<span class="title">T</span> &amp;<span class="title">x</span>, <span class="title">T</span> <span class="title">y</span>) &#123;</span>x = x &lt; y ? y : x;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">matrix</span>&#123;</span></span><br><span class="line">    ll mp[<span class="number">3</span>][<span class="number">3</span>];</span><br><span class="line">    matrix()&#123;</span><br><span class="line">        mem(mp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) mp[i][i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;base, s;</span><br><span class="line"></span><br><span class="line">ll mod;</span><br><span class="line"></span><br><span class="line">matrix <span class="keyword">operator</span> * (<span class="keyword">const</span> matrix a, <span class="keyword">const</span> matrix b)&#123;</span><br><span class="line">    matrix c;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> t = <span class="number">0</span>; t &lt; <span class="number">3</span>; t++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; ++j) &#123;</span><br><span class="line">                c.mp[i][j] = (c.mp[i][j] + i128(a.mp[i][t]) * b.mp[t][j]) % mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">matrix <span class="title">pow_mod</span><span class="params">(matrix q, ll w)</span></span>&#123;</span><br><span class="line">    matrix ret;</span><br><span class="line">    ret.init();</span><br><span class="line">    <span class="keyword">while</span>(w)&#123;</span><br><span class="line">        <span class="keyword">if</span>(w &amp; <span class="number">1</span>) ret = ret * q;</span><br><span class="line">        q = q * q;</span><br><span class="line">        w &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">euler</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = n, a = n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i * i &lt;= a; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a % i == <span class="number">0</span>) &#123;</span><br><span class="line">            res = res / i * (i - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">while</span> (a % i == <span class="number">0</span>) a /= i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (a &gt; <span class="number">1</span>) res = res / a * (a - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, p;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">solve</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">    matrix c = pow_mod(base, x - <span class="number">2</span>) * s;</span><br><span class="line">    <span class="keyword">return</span> c.mp[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>), <span class="built_in">cin</span>.tie(<span class="number">0</span>), <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    s.mp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">5</span>;</span><br><span class="line">    s.mp[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    s.mp[<span class="number">2</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; p)&#123;</span><br><span class="line">        mod = <span class="number">1l</span>l * n * p;</span><br><span class="line">        base.mp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">3</span>;</span><br><span class="line">        base.mp[<span class="number">0</span>][<span class="number">1</span>] = mod - <span class="number">1</span>;</span><br><span class="line">        base.mp[<span class="number">0</span>][<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">        base.mp[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        base.mp[<span class="number">2</span>][<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">        ll res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i * i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(n % i == <span class="number">0</span>)&#123;</span><br><span class="line">                res = (res + i128(euler(n / i)) * solve(i)) % mod;</span><br><span class="line">                <span class="keyword">if</span>(n / i != i)&#123;</span><br><span class="line">                    res = (res + i128(euler(i)) * solve(n / i)) % mod;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; res / n &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><p><a href="https://nanti.jisuanke.com/t/A1423" target="_blank" rel="noopener">ACM-ICPC 2017 Asia Qingdao-Floppy Cube</a><br>我们发现所有置换都可以由三种操作得到：沿正视图右选90°，向上翻转180°，沿俯视图右旋180°。<br>所以我们通过bfs找到所有置换，然后得到每个置换的循环节个数，即可算出最后的方案数。</p><div><div class="fold_hider"><div class="close hider_title">代码</div></div><div class="fold"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> __int128 i128;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> db;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vi;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;ll&gt; vl;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;pii&gt; vp;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">const</span> ll INF = <span class="number">1e18</span>;</span><br><span class="line"><span class="keyword">const</span> db eps = <span class="number">1e-10</span>;</span><br><span class="line"><span class="keyword">const</span> db pi = <span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> eb emplace_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ep emplace</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mem(a) memset(a, 0, sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> copy(a, b) memcpy(a, b, sizeof(b))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PA cout &lt;&lt; <span class="meta-string">"pass\n"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lowbit(x) (x &amp; -x)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(x) x.begin(), x.end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TM cout &lt;&lt; db(clock()) / CLOCKS_PER_SEC &lt;&lt; <span class="meta-string">'\n'</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">mt19937 <span class="title">mrand</span><span class="params">(chrono::high_resolution_clock::now().time_since_epoch().count())</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;<span class="title">inline</span> <span class="title">void</span> <span class="title">upmin</span>(<span class="title">T</span> &amp;<span class="title">x</span>, <span class="title">T</span> <span class="title">y</span>) &#123;</span>x = x &gt; y ? y : x;&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;<span class="title">inline</span> <span class="title">void</span> <span class="title">upmax</span>(<span class="title">T</span> &amp;<span class="title">x</span>, <span class="title">T</span> <span class="title">y</span>) &#123;</span>x = x &lt; y ? y : x;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">30</span>] = &#123;<span class="number">6</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">15</span>, <span class="number">12</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">13</span>, <span class="number">10</span>, <span class="number">17</span>, <span class="number">14</span>, <span class="number">11</span>, <span class="number">27</span>, <span class="number">28</span>, <span class="number">29</span>, <span class="number">18</span>, <span class="number">19</span>, <span class="number">20</span>, <span class="number">21</span>, <span class="number">22</span>, <span class="number">23</span>, <span class="number">24</span>, <span class="number">25</span>, <span class="number">26</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> b[<span class="number">30</span>] = &#123;<span class="number">15</span>, <span class="number">16</span>, <span class="number">17</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">26</span>, <span class="number">25</span>, <span class="number">24</span>, <span class="number">23</span>, <span class="number">22</span>, <span class="number">21</span>, <span class="number">20</span>, <span class="number">19</span>, <span class="number">18</span>, <span class="number">29</span>, <span class="number">28</span>, <span class="number">27</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> c[<span class="number">30</span>] = &#123;<span class="number">11</span>, <span class="number">10</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">16</span>, <span class="number">17</span>, <span class="number">20</span>, <span class="number">19</span>, <span class="number">18</span>, <span class="number">29</span>, <span class="number">22</span>, <span class="number">23</span>, <span class="number">24</span>, <span class="number">25</span>, <span class="number">26</span>, <span class="number">27</span>, <span class="number">28</span>, <span class="number">21</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">vi <span class="title">op1</span><span class="params">(vi x)</span></span>&#123;</span><br><span class="line">    <span class="function">vi <span class="title">r</span><span class="params">(<span class="number">30</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">30</span>; i++)&#123;</span><br><span class="line">        r[i] = x[a[i]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">vi <span class="title">op2</span><span class="params">(vi x)</span></span>&#123;</span><br><span class="line">    <span class="function">vi <span class="title">r</span><span class="params">(<span class="number">30</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">30</span>; i++)&#123;</span><br><span class="line">        r[i] = x[b[i]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">vi <span class="title">op3</span><span class="params">(vi x)</span></span>&#123;</span><br><span class="line">    <span class="function">vi <span class="title">r</span><span class="params">(<span class="number">30</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">30</span>; i++)&#123;</span><br><span class="line">        r[i] = x[c[i]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span>&lt;vi, <span class="keyword">int</span>&gt; vis;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, vi &amp;x, vi &amp;ok)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ok[u]) <span class="keyword">return</span>;</span><br><span class="line">    ok[u] = <span class="number">1</span>;</span><br><span class="line">    dfs(x[u], x, ok);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getcircle</span><span class="params">(vi x)</span></span>&#123;</span><br><span class="line">    <span class="function">vi <span class="title">ok</span><span class="params">(<span class="number">30</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">30</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ok[i]) <span class="keyword">continue</span>;</span><br><span class="line">        dfs(i, x, ok);</span><br><span class="line">        cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vi now;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">vi <span class="title">s</span><span class="params">(<span class="number">30</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">30</span>; i++) s[i] = i;</span><br><span class="line">    <span class="built_in">queue</span>&lt;vi&gt; q;</span><br><span class="line">    q.push(s);</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        vi t = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">if</span>(vis[t]) <span class="keyword">continue</span>;</span><br><span class="line">        vis[t] = <span class="number">1</span>;</span><br><span class="line">        vi r = op1(t);</span><br><span class="line">        <span class="keyword">if</span>(vis.find(r) == vis.end()) q.push(r);</span><br><span class="line">        r = op2(t);</span><br><span class="line">        <span class="keyword">if</span>(vis.find(r) == vis.end()) q.push(r);</span><br><span class="line">        r = op3(t);</span><br><span class="line">        <span class="keyword">if</span>(vis.find(r) == vis.end()) q.push(r);</span><br><span class="line">        now.eb(getcircle(t));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T, n, p;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">pow_mod</span><span class="params">(ll q, ll w, ll mod)</span></span>&#123;</span><br><span class="line">    ll ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(w)&#123;</span><br><span class="line">        <span class="keyword">if</span>(w &amp; <span class="number">1</span>) ret = i128(ret) * q % mod;</span><br><span class="line">        q = i128(q) * q % mod;</span><br><span class="line">        w &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll bin[<span class="number">40</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>), <span class="built_in">cin</span>.tie(<span class="number">0</span>), <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; fixed &lt;&lt; setprecision(<span class="number">10</span>);</span><br><span class="line">    bfs();</span><br><span class="line">    bin[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; p;</span><br><span class="line">        ll mod = <span class="number">1l</span>l * p * now.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">40</span>; i++) bin[i] = i128(bin[i - <span class="number">1</span>]) * n % mod;</span><br><span class="line">        ll res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it : now)&#123;</span><br><span class="line">            res = (res + bin[it]) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">        res /= now.size();</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><p><a href="https://vjudge.net/problem/SGU-282" target="_blank" rel="noopener">sgu-282</a><br>这个题就非常牛了，但想通也不难。<br>考虑不能直接枚举置换了，因为有n！种，但我们注意到是完全图，意味着很多置换有共同特征，所以我们直接考虑枚举循环节的划分，然后算把数填进去的方案数。<br>假设现在划分成了<script type="math/tex">L_1, L_2, \cdots, L_k(L_1 + L_2 + \cdots + L_k = n)</script>，把数放进去的方案数就是<script type="math/tex">\frac{n!}{L_1!L_2!\cdots L_k!}</script><br>每个循环节内的排列方案数是<script type="math/tex">(L_{i} - 1)!</script><br>但是如果有些循环节的长度相同，假设长度为x的有<script type="math/tex">d_x</script>个，方案数还得除以<script type="math/tex">d_x!</script><br>所以最后置换的方案数是<script type="math/tex">\frac{n!}{L_1L_2\cdots  L_nd_1!d_2!\cdots d_x!}</script></p><p>算完置换的方案数，还得算循环节的个数。我们现在枚举的是点循环节，因为是对边操作（对边染色），考虑要映射为边循环节。<br>如果两个点在一个点循环节内，可以容易看出一共有<script type="math/tex">\frac{L}{2}</script>个边循环节（边的跨点长度有这么多种）。<br>如果两个点在不同的点循环节内，可以发现每一个边循环节内包含<script type="math/tex">lcm(L_1, L_2)</script>条边，一共有<script type="math/tex">L_1 * L_2</script>条边，所以边循环节个数为<script type="math/tex">gcd(L_1, L-2)</script><br>求出边循环节个数后直接算染色方案即可。<br>复杂度<script type="math/tex">O(n的划分数 * n^2)</script></p><div><div class="fold_hider"><div class="close hider_title">代码</div></div><div class="fold"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> db;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vi;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;ll&gt; vl;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;pii&gt; vp;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">const</span> ll INF = <span class="number">1e18</span>;</span><br><span class="line"><span class="keyword">const</span> db eps = <span class="number">1e-10</span>;</span><br><span class="line"><span class="keyword">const</span> db pi = <span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> eb emplace_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ep emplace</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mem(a) memset(a, 0, sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> copy(a, b) memcpy(a, b, sizeof(b))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PA cout &lt;&lt; <span class="meta-string">"pass\n"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lowbit(x) (x &amp; -x)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(x) x.begin(), x.end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TM cout &lt;&lt; db(clock()) / CLOCKS_PER_SEC &lt;&lt; <span class="meta-string">'\n'</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">mt19937 <span class="title">mrand</span><span class="params">(chrono::high_resolution_clock::now().time_since_epoch().count())</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;<span class="title">inline</span> <span class="title">void</span> <span class="title">upmin</span>(<span class="title">T</span> &amp;<span class="title">x</span>, <span class="title">T</span> <span class="title">y</span>) &#123;</span>x = x &gt; y ? y : x;&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;<span class="title">inline</span> <span class="title">void</span> <span class="title">upmax</span>(<span class="title">T</span> &amp;<span class="title">x</span>, <span class="title">T</span> <span class="title">y</span>) &#123;</span>x = x &lt; y ? y : x;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, p;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">55</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fac[maxn], inv[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pow_mod</span><span class="params">(<span class="keyword">int</span> q, <span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(w)&#123;</span><br><span class="line">        <span class="keyword">if</span>(w &amp; <span class="number">1</span>) ret = <span class="number">1l</span>l * ret * q % p;</span><br><span class="line">        q = <span class="number">1l</span>l * q * q % p;</span><br><span class="line">        w &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> res;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> sum, vi &amp;t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(sum == n) &#123;</span><br><span class="line">        <span class="keyword">int</span> ret = fac[n];</span><br><span class="line">        <span class="keyword">int</span> now = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t.size(); i++) &#123;</span><br><span class="line">            ret = <span class="number">1l</span>l * ret * inv[t[i]] % p;</span><br><span class="line">            ret = <span class="number">1l</span>l * ret * fac[t[i] - <span class="number">1</span>] % p;</span><br><span class="line">            now += t[i] / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; t.size(); j++)&#123;</span><br><span class="line">                now += __gcd(t[i], t[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; t.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(t[i] == t[i - <span class="number">1</span>]) cnt++;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                ret = <span class="number">1l</span>l * ret * inv[cnt] % p;</span><br><span class="line">                cnt = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ret = <span class="number">1l</span>l * ret * inv[cnt] % p;</span><br><span class="line">        res = (res + <span class="number">1l</span>l * ret * pow_mod(m, now)) % p;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(sum + x &gt; n) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = x; i + sum &lt;= n; i++)&#123;</span><br><span class="line">        t.eb(i);</span><br><span class="line">        dfs(i, sum + i, t);</span><br><span class="line">        t.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>), <span class="built_in">cin</span>.tie(<span class="number">0</span>), <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; fixed &lt;&lt; setprecision(<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; p;</span><br><span class="line">    fac[<span class="number">0</span>] = inv[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        fac[i] = <span class="number">1l</span>l * fac[i - <span class="number">1</span>] * i % p;</span><br><span class="line">        inv[i] = pow_mod(fac[i], p - <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    vi t;</span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">0</span>, t);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="number">1l</span>l * res * inv[n] % p &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><p>总之关于Polya题目，可能会套上dp或者数论优化以及快速幂优化，是暴力算<script type="math/tex">\phi</script>还是预处理，分块快速幂还是直接求解都根据题目数据范围来决定。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;如果能为了某个人变强，对于悲伤我也心存感激~&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&quot;Polya简介&quot;&gt;&lt;a href=&quot;#Polya简介&quot; class=&quot;headerlink&quot; title=&quot;Polya简介&quot;&gt;&lt;/a&gt;Polya简介&lt;/h1&gt;&lt;p&gt;Polya定理用来解决旋转，对称同构的计数问题，其定理形式简单，但变种问题十分多且有趣。&lt;/p&gt;
&lt;h2 id=&quot;前置&quot;&gt;&lt;a href=&quot;#前置&quot; class=&quot;headerlink&quot; title=&quot;前置&quot;&gt;&lt;/a&gt;前置&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;置换&lt;/li&gt;
&lt;li&gt;数论&lt;br&gt;本文不打算讲前置内容以及定理的证明&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;定理内容&quot;&gt;&lt;a href=&quot;#定理内容&quot; class=&quot;headerlink&quot; title=&quot;定理内容&quot;&gt;&lt;/a&gt;定理内容&lt;/h2&gt;&lt;script type=&quot;math/tex; mode=display&quot;&gt;M = \frac{1}{G}\sum_{i = 1}^gf(c_i)&lt;/script&gt;&lt;p&gt;其中&lt;script type=&quot;math/tex&quot;&gt;c_i&lt;/script&gt;表示第i种置换中循环节的个数。&lt;/p&gt;
&lt;p&gt;用简单的话来说，&lt;script type=&quot;math/tex&quot;&gt;Polya&lt;/script&gt;就是找到所有的置换，然后对每一种置换找到循环节个数，同一个循环节看成一个不动点（如染色问题中循环节内的所有点必须是同一种颜色），算出该置换下的方案数，对所有置换的方案数求和后平均。&lt;/p&gt;
&lt;p&gt;那么问题很明显可以划分为两个步骤：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;找到置换&lt;/li&gt;
&lt;li&gt;算出置换下的方案数&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;难题可能是在这两个步骤的某一步中比较不好处理，但所有的&lt;script type=&quot;math/tex&quot;&gt;Polya&lt;/script&gt;题目无外乎都要这么考虑&lt;/p&gt;
    
    </summary>
    
      <category term="Polya" scheme="http://yoursite.com/categories/Polya/"/>
    
    
  </entry>
  
  <entry>
    <title>回文树及其应用</title>
    <link href="http://yoursite.com/2020/09/17/%E5%9B%9E%E6%96%87%E6%A0%91%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/"/>
    <id>http://yoursite.com/2020/09/17/回文树及其应用/</id>
    <published>2020-09-17T01:40:11.000Z</published>
    <updated>2020-10-02T07:27:18.681Z</updated>
    
    <content type="html"><![CDATA[<h1 id="回文树"><a href="#回文树" class="headerlink" title="回文树"></a>回文树</h1><p>回文树实际上跟后缀自动机非常类似，用来解决回文串的问题，一般能解决如下问题及其变形：</p><ul><li>求串S前缀0 ~ i内本质不同回文串的个数</li><li>求串S内每一个本质不同回文串出现的次数</li><li>求串S内回文串的个数</li><li>求以下标i结尾的回文串的个数</li></ul><p>我们先介绍一下回文树需要维护的变量：</p><ul><li>$len[i]: $表示编号为i的节点表示的回文串的长度</li><li>$ch[u][i]: $表示编号为i的节点表示的回文串在两边添加字符c以后变成的回文串的编号</li><li>$f[i]: $表示节点i失配以后跳转不等于自身的节点i表示的回文串的最长后缀回文串</li><li>$cnt[i]: $表示节点i表示的本质不同的串的个数（建树时求出的不是完全的，最后count()函数跑一遍以后才是正确的，这跟后缀自动机是一样的）</li><li>$num[i]:$表示以节点i表示的最长回文串的最右端点为回文串结尾的回文串个数 </li><li>$diff[i]: $表示该节点与父节点表示的回文串的长度差</li><li>$top[i]: $表示所在等差数列的首项位置</li><li>$last: $指向新添加一个字母后所形成的最长回文串表示的节点</li><li>$S[i]: $表示第i次添加的字符</li><li>$p: $表示添加的节点个数(0是偶回文树的根，1是奇回文树的根)</li><li>$n: $表示添加的字符个数</li></ul><p><img src="/images/15.png" alt=""><br><img src="/images/16.png" alt=""><br><img src="/images/17.png" alt=""><br>构造过程这里不解释，自行参考其它资料（其实是觉得不重要）</p><h2 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h2><ul><li><p>回文树跟后缀自动机不一样的地方，后缀自动机跳<script type="math/tex">fail</script>的复杂度均摊是<script type="math/tex">O(\sqrt(n))</script>的，但回文树均摊可能是<script type="math/tex">O(n)</script>的，比如全是一个字符的串，所以在回文树上一般不能直接跳<script type="math/tex">fail</script>来解决问题。</p></li><li><p>回文树其实分为两棵树，0是偶回文树的根，1是奇回文树的根，所以如果要树上计数别忘了0，1都需要开始dfs</p></li></ul><h1 id="回文树与border定理"><a href="#回文树与border定理" class="headerlink" title="回文树与border定理"></a>回文树与border定理</h1><p>border定理告诉我们，一个串的border可以由log个等差数列组成。<br>如果在回文串上，回文串的border还是回文串，所以回文树的任意一条<script type="math/tex">fail</script>链所表示的回文串的长度组成的序列也可以写成log段等差数列。<br>这有什么用呢，假设我们现在需要通过回文树来转移dp，一般dp形式如下:</p><script type="math/tex; mode=display">dp[i] <- dp[j - 1] (s(j, i)是回文串)</script><p>这时候如果在回文树上找到所有符合的$j$的复杂度是$O(n)$的，我们只好探究一下等差数列的性质。<br>假设回文树上有三个回文串长为:<script type="math/tex">b_1, b_2, b_3(b_1 > b_2 > b_3)</script>，它们的公差为$d$，当前dp位置为$i$<br><img src="/images/14.png" alt=""><br>可以发现$b_1$画虚线前面部分和$b_2$相等，$b_2$画虚线前面部分和$b_3$相等，即<script type="math/tex">S(i - b_1, i - d) = S(i - b_2, i)</script>，<script type="math/tex">S(i - b_2, i - d) = S(i - b_3)</script>。可以发现这两个值在<script type="math/tex">i - d</script>结尾的时候已经维护过了，所以我们只需要维护<script type="math/tex">S(i - b_3, i - d)</script>就行了，也就是在一个等差数列里，相当于整个维护的值循环后移了一位，你只需要补上最前面的那个最新的值就行了。<br>因为我们考虑用一个$g$来维护等差数列上的和，我们在每个等差数列的末尾来维护这一段等差数列的前缀状态（和，max，min之类的），然后往上跳到上一段等差数列，继续加上新的一个状态即可，边维护的过程中可以边统计答案。</p><a id="more"></a><p>最出名的莫过这个题了<br><a href="https://codeforces.com/problemset/problem/932/G" target="_blank" rel="noopener">ICM Technex 2018 and Codeforces Round #463 (Div. 1 + Div. 2, combined)</a></p><p>dp方程如下：</p><script type="math/tex; mode=display">dp[i] = dp[i] + dp[j - 1](S(i, j)是回文串并且i, j - 1都是偶数)</script><div><div class="fold_hider"><div class="close hider_title">代码</div></div><div class="fold"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxnode = <span class="number">1e6</span> + <span class="number">100</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> sigma_size = <span class="number">26</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> ch[maxnode][sigma_size];</span><br><span class="line"><span class="keyword">int</span> f[maxnode];</span><br><span class="line"><span class="keyword">int</span> cnt[maxnode];   </span><br><span class="line"><span class="keyword">int</span> num[maxnode];  </span><br><span class="line"><span class="keyword">int</span> len[maxnode];  </span><br><span class="line"><span class="keyword">int</span> s[maxnode];     </span><br><span class="line"><span class="keyword">int</span> diff[maxnode];   </span><br><span class="line"><span class="keyword">int</span> top[maxnode];    </span><br><span class="line"><span class="keyword">int</span> last;       </span><br><span class="line"><span class="keyword">int</span> sz;</span><br><span class="line"><span class="keyword">int</span> p;      </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">newnode</span><span class="params">(<span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sigma_size; i++)ch[p][i] = <span class="number">0</span>;</span><br><span class="line">    cnt[p] = <span class="number">0</span>;</span><br><span class="line">    num[p] = <span class="number">0</span>;</span><br><span class="line">    len[p] = w;</span><br><span class="line">    <span class="keyword">return</span> p++;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    p = <span class="number">0</span>;</span><br><span class="line">    newnode(<span class="number">0</span>);</span><br><span class="line">    newnode(<span class="number">-1</span>);</span><br><span class="line">    last = <span class="number">0</span>;</span><br><span class="line">    sz = <span class="number">0</span>;</span><br><span class="line">    s[sz] = <span class="number">-1</span>;</span><br><span class="line">    f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getfail</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (s[sz - len[x] - <span class="number">1</span>] != s[sz])x = f[x];</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    s[++sz] = c;</span><br><span class="line">    <span class="keyword">int</span> cur = getfail(last);</span><br><span class="line">    <span class="keyword">if</span> (!ch[cur][c]) &#123;</span><br><span class="line">        <span class="keyword">int</span> now = newnode(len[cur] + <span class="number">2</span>);</span><br><span class="line">        f[now] = ch[getfail(f[cur])][c];</span><br><span class="line">        ch[cur][c] = now;</span><br><span class="line">        diff[now] = len[now] - len[f[now]];</span><br><span class="line">        top[now] = diff[now] == diff[f[now]] ? top[f[now]] : f[now];</span><br><span class="line">        num[now] = num[f[now]] + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    last = ch[cur][c];</span><br><span class="line">    cnt[last]++;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">count</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = p<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        cnt[f[i]] += cnt[i];</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">char</span> str[maxnode];</span><br><span class="line"><span class="keyword">char</span> tmp[maxnode];</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> dp[maxnode];</span><br><span class="line"><span class="keyword">int</span> g[maxnode];</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, str + <span class="number">1</span>);</span><br><span class="line">    n = <span class="built_in">strlen</span>(str + <span class="number">1</span>);</span><br><span class="line">    init();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n / <span class="number">2</span>; i++)&#123;</span><br><span class="line">        tmp[<span class="number">2</span> * i - <span class="number">1</span>] = str[i];</span><br><span class="line">        tmp[<span class="number">2</span> * i] = str[n - i + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        add(tmp[i] - <span class="string">'a'</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> t = last; t &gt; <span class="number">1</span>; t = top[t])&#123;</span><br><span class="line">            g[t] = dp[i - len[top[t]] - diff[t]];</span><br><span class="line">            <span class="keyword">if</span>(diff[t] == diff[f[t]])&#123;</span><br><span class="line">                g[t] = (g[t] + g[f[t]]) % mod;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i % <span class="number">2</span> == <span class="number">0</span>) dp[i] = (dp[i] + g[t]) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, dp[n]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;回文树&quot;&gt;&lt;a href=&quot;#回文树&quot; class=&quot;headerlink&quot; title=&quot;回文树&quot;&gt;&lt;/a&gt;回文树&lt;/h1&gt;&lt;p&gt;回文树实际上跟后缀自动机非常类似，用来解决回文串的问题，一般能解决如下问题及其变形：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;求串S前缀0 ~ i内本质不同回文串的个数&lt;/li&gt;
&lt;li&gt;求串S内每一个本质不同回文串出现的次数&lt;/li&gt;
&lt;li&gt;求串S内回文串的个数&lt;/li&gt;
&lt;li&gt;求以下标i结尾的回文串的个数&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们先介绍一下回文树需要维护的变量：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$len[i]: $表示编号为i的节点表示的回文串的长度&lt;/li&gt;
&lt;li&gt;$ch[u][i]: $表示编号为i的节点表示的回文串在两边添加字符c以后变成的回文串的编号&lt;/li&gt;
&lt;li&gt;$f[i]: $表示节点i失配以后跳转不等于自身的节点i表示的回文串的最长后缀回文串&lt;/li&gt;
&lt;li&gt;$cnt[i]: $表示节点i表示的本质不同的串的个数（建树时求出的不是完全的，最后count()函数跑一遍以后才是正确的，这跟后缀自动机是一样的）&lt;/li&gt;
&lt;li&gt;$num[i]:$表示以节点i表示的最长回文串的最右端点为回文串结尾的回文串个数 &lt;/li&gt;
&lt;li&gt;$diff[i]: $表示该节点与父节点表示的回文串的长度差&lt;/li&gt;
&lt;li&gt;$top[i]: $表示所在等差数列的首项位置&lt;/li&gt;
&lt;li&gt;$last: $指向新添加一个字母后所形成的最长回文串表示的节点&lt;/li&gt;
&lt;li&gt;$S[i]: $表示第i次添加的字符&lt;/li&gt;
&lt;li&gt;$p: $表示添加的节点个数(0是偶回文树的根，1是奇回文树的根)&lt;/li&gt;
&lt;li&gt;$n: $表示添加的字符个数&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;/images/15.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;img src=&quot;/images/16.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;img src=&quot;/images/17.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;构造过程这里不解释，自行参考其它资料（其实是觉得不重要）&lt;/p&gt;
&lt;h2 id=&quot;性质&quot;&gt;&lt;a href=&quot;#性质&quot; class=&quot;headerlink&quot; title=&quot;性质&quot;&gt;&lt;/a&gt;性质&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;回文树跟后缀自动机不一样的地方，后缀自动机跳&lt;script type=&quot;math/tex&quot;&gt;fail&lt;/script&gt;的复杂度均摊是&lt;script type=&quot;math/tex&quot;&gt;O(\sqrt(n))&lt;/script&gt;的，但回文树均摊可能是&lt;script type=&quot;math/tex&quot;&gt;O(n)&lt;/script&gt;的，比如全是一个字符的串，所以在回文树上一般不能直接跳&lt;script type=&quot;math/tex&quot;&gt;fail&lt;/script&gt;来解决问题。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;回文树其实分为两棵树，0是偶回文树的根，1是奇回文树的根，所以如果要树上计数别忘了0，1都需要开始dfs&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;回文树与border定理&quot;&gt;&lt;a href=&quot;#回文树与border定理&quot; class=&quot;headerlink&quot; title=&quot;回文树与border定理&quot;&gt;&lt;/a&gt;回文树与border定理&lt;/h1&gt;&lt;p&gt;border定理告诉我们，一个串的border可以由log个等差数列组成。&lt;br&gt;如果在回文串上，回文串的border还是回文串，所以回文树的任意一条&lt;script type=&quot;math/tex&quot;&gt;fail&lt;/script&gt;链所表示的回文串的长度组成的序列也可以写成log段等差数列。&lt;br&gt;这有什么用呢，假设我们现在需要通过回文树来转移dp，一般dp形式如下:&lt;/p&gt;
&lt;script type=&quot;math/tex; mode=display&quot;&gt;dp[i] &lt;- dp[j - 1] (s(j, i)是回文串)&lt;/script&gt;&lt;p&gt;这时候如果在回文树上找到所有符合的$j$的复杂度是$O(n)$的，我们只好探究一下等差数列的性质。&lt;br&gt;假设回文树上有三个回文串长为:&lt;script type=&quot;math/tex&quot;&gt;b_1, b_2, b_3(b_1 &gt; b_2 &gt; b_3)&lt;/script&gt;，它们的公差为$d$，当前dp位置为$i$&lt;br&gt;&lt;img src=&quot;/images/14.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;可以发现$b_1$画虚线前面部分和$b_2$相等，$b_2$画虚线前面部分和$b_3$相等，即&lt;script type=&quot;math/tex&quot;&gt;S(i - b_1, i - d) = S(i - b_2, i)&lt;/script&gt;，&lt;script type=&quot;math/tex&quot;&gt;S(i - b_2, i - d) = S(i - b_3)&lt;/script&gt;。可以发现这两个值在&lt;script type=&quot;math/tex&quot;&gt;i - d&lt;/script&gt;结尾的时候已经维护过了，所以我们只需要维护&lt;script type=&quot;math/tex&quot;&gt;S(i - b_3, i - d)&lt;/script&gt;就行了，也就是在一个等差数列里，相当于整个维护的值循环后移了一位，你只需要补上最前面的那个最新的值就行了。&lt;br&gt;因为我们考虑用一个$g$来维护等差数列上的和，我们在每个等差数列的末尾来维护这一段等差数列的前缀状态（和，max，min之类的），然后往上跳到上一段等差数列，继续加上新的一个状态即可，边维护的过程中可以边统计答案。&lt;/p&gt;
    
    </summary>
    
      <category term="回文自动机" scheme="http://yoursite.com/categories/%E5%9B%9E%E6%96%87%E8%87%AA%E5%8A%A8%E6%9C%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>论积性函数与线性筛</title>
    <link href="http://yoursite.com/2020/09/13/%E8%AE%BA%E7%A7%AF%E6%80%A7%E5%87%BD%E6%95%B0%E4%B8%8E%E7%BA%BF%E6%80%A7%E7%AD%9B/"/>
    <id>http://yoursite.com/2020/09/13/论积性函数与线性筛/</id>
    <published>2020-09-13T03:15:25.000Z</published>
    <updated>2020-09-13T03:58:22.391Z</updated>
    
    <content type="html"><![CDATA[<p>草，这离上一次更新也不知道有多少了，有生之年系列？</p><a id="more"></a><h1 id="线性筛"><a href="#线性筛" class="headerlink" title="线性筛"></a>线性筛</h1><p>线性筛保证了每个数只被它最小的素因子筛到一次，模板如下：<br><div><div class="fold_hider"><div class="close hider_title">代码</div></div><div class="fold"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; maxn; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(!vis[i])&#123;</span><br><span class="line">        prime.eb(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; prime.size() &amp;&amp; i * prime[j] &lt; maxn; j++)&#123;</span><br><span class="line">        vis[i * prime[j]] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(i % prime[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><br>关键在为什么$i \% prime[j] == 0$的就会break掉，考虑$i * prime[j + 1]$一定会被$prime[j]和另一个i$相乘的时候筛掉，所以我们在这里break掉保证每个数只被筛掉一次。</p><h1 id="积性函数"><a href="#积性函数" class="headerlink" title="积性函数"></a>积性函数</h1><p>积性函数分为如下两类：</p><ul><li>完全积性函数：$f(ab) = f(a) * f(b)$</li><li>普通积性函数: $f(ab) = f(a) * f(b), gcd(a, b) = 1$<br>一般我们要讨论的就是普通积性函数。</li></ul><h1 id="线性筛积性函数"><a href="#线性筛积性函数" class="headerlink" title="线性筛积性函数"></a>线性筛积性函数</h1><p>一般来说，积性函数都是可以用线性筛来求解的，一般需要考虑如下最重要的部分：</p><ul><li>$f(p^k)$是否好求解<br>假设上面求解复杂度为$x$，那么线性筛该积性函数的复杂度就为$O(n + \frac{nx}{logn})$</li></ul><p>先给出一些定义：</p><ul><li>$low(i):$表示i最小素因子的乘积<br>例如$low(36) = 2^2 = 4， low(27) = 3^3 = 27$</li></ul><p>按照如下流程进行线性筛积性函数:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; maxn; i++)&#123;</span><br><span class="line">       <span class="keyword">if</span>(!vis[i])&#123;</span><br><span class="line">           prime.eb(i);</span><br><span class="line">           low[i] = i</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; prime.size() &amp;&amp; i * prime[j] &lt; maxn; j++)&#123;</span><br><span class="line">           vis[i * prime[j]] = <span class="number">1</span>;</span><br><span class="line">           low[i * prime[j]] = low[i] * prime[j]</span><br><span class="line">           <span class="keyword">if</span>(i % prime[j] == <span class="number">0</span>) &#123;</span><br><span class="line">               <span class="keyword">if</span>(low[i] == i) f[i * prime[j]] = 求解</span><br><span class="line">               <span class="keyword">else</span>&#123;</span><br><span class="line">                   f[i * prime[j]] = f[i / low[i]] * f[low[i * prime[j]]];</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">else</span>&#123;</span><br><span class="line">               f[i * prime[j]] = f[i] * f[prime[j]];</span><br><span class="line">               low[i * prime[j]] = prime[j] </span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>主要解释一下<script type="math/tex">i \% prime[j] == 0</script>里面的部分，考虑如果<script type="math/tex">prime[j]不是i的唯一素因子</script>，那么<script type="math/tex">i * prime[j]</script>可以分解为只包含<script type="math/tex">prime[j]</script>和剩下部分的两个因子组成，并且一定互质，这样可以推出来<script type="math/tex">f[i * prime[j]]</script>的值。<br>但如果<script type="math/tex">prime[j]是i的唯一素因子</script>，这样做就会有问题了，也就是前面所说的$f(p^k)$的答案我们需要单独求解。</p><h1 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h1><p>来看一个练习题<br><a href="https://ac.nowcoder.com/acm/contest/7329/F" target="_blank" rel="noopener">解方程</a></p><script type="math/tex; mode=display">f(n) * g_p(n) = g_q(n)</script><p>由莫比乌斯反演我们知道<script type="math/tex">g_p(n)^{-1} = g_p(n)\mu(n)</script></p><script type="math/tex; mode=display">f(n) = g_q(n) * (g_p(n)\mu(n))</script><p>右边两个都是积性函数，积性函数的迪利克雷卷积也是积性函数。<br>那么我们只用想办法求$f(p^k)$就可以了<br>由莫比乌斯函数我们知道，只有两项是有贡献的，所以很好求，求解复杂度是$log(n)$的<br>所以线性筛的复杂度$O(n + \frac{nlogn}{logn}) = O(n)$<br><div><div class="fold_hider"><div class="close hider_title">代码</div></div><div class="fold"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> db;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vi;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;ll&gt; vl;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;pii&gt; vp;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">const</span> ll INF = <span class="number">1e18</span>;</span><br><span class="line"><span class="keyword">const</span> db eps = <span class="number">1e-10</span>;</span><br><span class="line"><span class="keyword">const</span> db pi = <span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> eb emplace_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ep emplace</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mem(a) memset(a, 0, sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> copy(a, b) memcpy(a, b, sizeof(b))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PA cout &lt;&lt; <span class="meta-string">"pass\n"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lowbit(x) (x &amp; -x)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(x) x.begin(), x.end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TM cout &lt;&lt; db(clock()) / CLOCKS_PER_SEC &lt;&lt; <span class="meta-string">'\n'</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">mt19937 <span class="title">mrand</span><span class="params">(chrono::high_resolution_clock::now().time_since_epoch().count())</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;<span class="title">inline</span> <span class="title">void</span> <span class="title">upmin</span>(<span class="title">T</span> &amp;<span class="title">x</span>, <span class="title">T</span> <span class="title">y</span>) &#123;</span>x = x &gt; y ? y : x;&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;<span class="title">inline</span> <span class="title">void</span> <span class="title">upmax</span>(<span class="title">T</span> &amp;<span class="title">x</span>, <span class="title">T</span> <span class="title">y</span>) &#123;</span>x = x &lt; y ? y : x;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pow_mod</span><span class="params">(<span class="keyword">int</span> q, <span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(w)&#123;</span><br><span class="line">        <span class="keyword">if</span>(w &amp; <span class="number">1</span>) ret = <span class="number">1l</span>l * ret * q % mod;</span><br><span class="line">        q = <span class="number">1l</span>l * q * q % mod;</span><br><span class="line">        w &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e7</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> f[maxn], low[maxn];</span><br><span class="line">vi prime;</span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"><span class="keyword">int</span> n, p, q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    f[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; maxn; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!vis[i])&#123;</span><br><span class="line">            prime.eb(i);</span><br><span class="line">            f[i] = (pow_mod(i, q) + mod - pow_mod(i, p)) % mod;</span><br><span class="line">            low[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; prime.size() &amp;&amp; i * prime[j] &lt; maxn; j++)&#123;</span><br><span class="line">            vis[i * prime[j]] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(i % prime[j] == <span class="number">0</span>)&#123;</span><br><span class="line">                low[i * prime[j]] = low[i] * prime[j];</span><br><span class="line">                <span class="keyword">if</span>(i == low[i]) &#123;</span><br><span class="line">                    f[i * prime[j]] = (pow_mod(i * prime[j], q) - <span class="number">1l</span>l * pow_mod(i, q) * pow_mod(prime[j], p) % mod + mod) % mod;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    f[i * prime[j]] = <span class="number">1l</span>l * f[i / low[i]] * f[low[i * prime[j]]] % mod;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                f[i * prime[j]] = <span class="number">1l</span>l * f[i] * f[prime[j]] % mod;</span><br><span class="line">                low[i * prime[j]] = prime[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        res ^= f[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>), <span class="built_in">cin</span>.tie(<span class="number">0</span>), <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; fixed &lt;&lt; setprecision(<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; p &gt;&gt; q;</span><br><span class="line">    init();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></p><p>什么时候迪利克雷卷积也要系统学一下，未完待续~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;草，这离上一次更新也不知道有多少了，有生之年系列？&lt;/p&gt;
    
    </summary>
    
      <category term="积性函数" scheme="http://yoursite.com/categories/%E7%A7%AF%E6%80%A7%E5%87%BD%E6%95%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>集成学习</title>
    <link href="http://yoursite.com/2020/07/11/%E9%9B%86%E6%88%90%E5%AD%A6%E4%B9%A0/"/>
    <id>http://yoursite.com/2020/07/11/集成学习/</id>
    <published>2020-07-11T07:07:56.000Z</published>
    <updated>2020-07-11T09:48:12.129Z</updated>
    
    <content type="html"><![CDATA[<h1 id="集成学习简介"><a href="#集成学习简介" class="headerlink" title="集成学习简介"></a>集成学习简介</h1><p>集成学习通过构建多个个体学习器，并让他们单独产生结果，最后将它们的结果合并起来，给出一个整体的最终结果。这就好像如果每个人单独做一套题，可能不管是谁，都会做错一部分题。但如果有很多人一起做，最后根据大家的结果和一个合并策略，选出一个结果，后者的正确率一般来说会高很多。<br>集成学习通过将多个学习器结合，常可获得比单一学习器显著优越的泛化性能，这对弱学习器(泛化性能略优于随机猜测的学习器)尤为明显。<br>首先我们希望各个学习器本身要有准确性，如果各个学习器本身的准确度不够，最后出来的结果一定不好。其次我们希望各个学习器之间要有差异，即学习器要多样性。如果大部分学习器学习方法和参数都差不多的话，相当于它们都会做出一样的预测，那么集成学习就没有意义了。但事实上，准确性和多样性很多时候是冲突的，如何产生”好而不同”的个体学习器，是集成学习的核心。<br>根据个体学习器的生成方式，集成学习方法大致可分为两大类，即个体学习器间存在强依赖关系、必须串行生成的序列化方法，以及个体学习器间不存在强依赖关系，可同时生成的并行化方法；前者代表是$Boosting$，后者代表是$Bagging$和随机森林。</p><h1 id="Boosting"><a href="#Boosting" class="headerlink" title="Boosting"></a>Boosting</h1><p>$Boosting$是一族可将弱学习器提升为强学习器的算法。先从初始训练集训练出一个基学习器，再根据基学习器的表现对训练样本分布进行调整，使得先前基学习器做错的样本在后面得到更多的关注。</p><h2 id="AdaBoost"><a href="#AdaBoost" class="headerlink" title="AdaBoost"></a>AdaBoost</h2><p>$AdaBoost$的算法流程如下：<br><img src="/mlimg/Adaboost.png" alt=""><br>$AdaBoost$的核心是两个权重：数据集权重$D$和分类器权重$a$。前者为了在生成每一个分类器时，决定每个数据对损失函数的影响，即我们需要把重心放在之前分错类的那些数据上。后者是对测试数据进行预测时，各个分类器对最终结果影响的比重。<br>初始每个训练样本都具有相同的权重，每一次我们生成一个新的分类器，并用带权的数据对它进行训练，算出训练后的误差率，然后根据错误率确定这个分类器在最后决策中占的权重，然后更新数据集权重$D$，然后继续生成下一个分类器。<br>那么就会有如下问题：<br><strong>$a_t$的表达式是怎么推到来的？</strong><br>$AdaBoost$采用指数损失函数$l_{exp}(H | D) = E_{x \sim D}[e^{-f(x)H(x)}]$<br>我们知道最后结果由各个分类器线性加权得到：<script type="math/tex">H(x) = \sum_{t = 1}^Ta_th_t(x)</script><br>所以如果我们要确定当前分类器的$a_t$，考虑对其求偏导：<script type="math/tex">\frac{\partial l_{exp}(a_th_t | D_t)}{\partial a_t} = -e^{-a_t}(1 - \epsilon_t) + e^{a_t}\epsilon_t</script><br>令其等于0即可得出<script type="math/tex">a_t = \frac{1}{2}ln(\frac{1 - \epsilon_t}{\epsilon_t})</script></p><p><strong>$Z_t$是干嘛的，怎么计算出来的？</strong><br>$Z_t$是归一化常数，为了保证所有$D_i$的和加起来为1，<script type="math/tex">Z_t = \sum_{i}D_t(i)e^{-a_ty_ih_t(x_i)} = \sum_{h_t(x_i) = y_i}D_t(i)e^{-a_i} + \sum_{h_t(x_i) \neq y_i}D_t(i)e^{a_i}</script>。<br>代入$a_t$，得<script type="math/tex">Z_t = 2\sqrt{\epsilon_t(1 - \epsilon_t)}</script></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;集成学习简介&quot;&gt;&lt;a href=&quot;#集成学习简介&quot; class=&quot;headerlink&quot; title=&quot;集成学习简介&quot;&gt;&lt;/a&gt;集成学习简介&lt;/h1&gt;&lt;p&gt;集成学习通过构建多个个体学习器，并让他们单独产生结果，最后将它们的结果合并起来，给出一个整体的最终结果。这就
      
    
    </summary>
    
      <category term="机器学习" scheme="http://yoursite.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>决策树</title>
    <link href="http://yoursite.com/2020/07/10/%E5%86%B3%E7%AD%96%E6%A0%91/"/>
    <id>http://yoursite.com/2020/07/10/决策树/</id>
    <published>2020-07-10T01:22:55.000Z</published>
    <updated>2020-07-11T08:05:42.550Z</updated>
    
    <content type="html"><![CDATA[<h1 id="决策树简介"><a href="#决策树简介" class="headerlink" title="决策树简介"></a>决策树简介</h1><p>决策树(Decision Tree)是在已知各种情况发生概率的基础上，通过构成决策树来求取净现值的期望值大于等于零的概率，评价项目风险，判断其可行性的决策分析方法，是直观运用概率分析的一种图解法。由于这种决策分支画成图形很像一棵树的枝干，故称决策树。</p><h1 id="划分选择"><a href="#划分选择" class="headerlink" title="划分选择"></a>划分选择</h1><h2 id="信息增益"><a href="#信息增益" class="headerlink" title="信息增益"></a>信息增益</h2><p>信息熵是度量样本集合纯度最常用的一种指标。假设当前样本集合$D$中第$k$类样本所占比例为$p_k(k = 1, 2, \dots, |\gamma|)$,则$D$的信息熵定义为：<script type="math/tex">Ent(D) = -\sum_{k = 1}^{|\gamma|}p_klog_2p_k</script>。信息熵的值越小，信息的纯度越高。<br>假设某个样本的属性$a$的$V$个可能取值${a^1, a^2, a^3, \dots, a^V}$，若使用$a$来对样本集合$D$进行划分，则会在这里产生$V$个分支结点。其中第$v$个结点包含了$D$中所有在属性$a$上取值为$a^v$的样本，记为$D^v$。我们利用属性$a$对样本集$D$进行划分所获得的信息增益记为<script type="math/tex">Gain(D, a) = Ent(D) - \sum_{v = 1}^V\frac{|D^v|}{|D|}Ent(D^v)</script>。<br>一般来说，信息增益越大，意味着用属性$a$来进行划分所获得的纯度提升越大，我们在每次对属性进行选择的时候，都用信息增益进行选择，即选择能获得最大增益的属性作为当前决策树结点进行划分。$ID3$算法就是采用信息增益作为选择标准。</p><h2 id="增益率"><a href="#增益率" class="headerlink" title="增益率"></a>增益率</h2><p>根据上面的式子我们可以发现，信息增益偏向于选择属性取值数较多的集合。一般情况来说，取值情况较多，每个部分纯度就越大，总体的纯度就越大。为了减少这种偏向带来的影响，我们不直接使用信息增益，而使用增益率。我们定义增益率为<script type="math/tex">Gain_ratio(D, a) = \frac{Gain(D, a)}{IV(a)}</script>，其中<script type="math/tex">IV(a) = -\sum_{v = 1}^V\frac{|D^v|}{D}log_2\frac{|D^v|}{D}</script><br>我们发现增益率会偏向于取值数较少的属性。因此，$C4.5$算法采用了启发式的方法，先选择信息增益高于平均水平的属性，再从中选择增益率最高的。</p><h2 id="基尼指数"><a href="#基尼指数" class="headerlink" title="基尼指数"></a>基尼指数</h2><p>$CART$决策树采用基尼指数来选择划分属性。定义<script type="math/tex">Gini(D) = \sum_{k = 1}^{|\gamma|}\sum_{k' \neq k}p_kp_{k'} = 1 - \sum_{k = 1}^{|\gamma|}p_k^2</script>。属性$a$的基尼指数定义为:<script type="math/tex">Gini_index(D, a) = \sum_{v = 1}^V\frac{|D^v|}{D}Gini(D^v)</script><br>划分的时候，我们选择基尼指数最小的属性作为当前决策树结点进行划分。</p><h1 id="剪枝处理"><a href="#剪枝处理" class="headerlink" title="剪枝处理"></a>剪枝处理</h1><p>当决策树分支过多的时候，就会出现过拟合的情况，泛化能力会很差，这时候我们要对决策树进行剪枝。</p><h2 id="预剪枝"><a href="#预剪枝" class="headerlink" title="预剪枝"></a>预剪枝</h2><p>如果在某个结点我们不再进行划分，我们会选择出此时这个结点属性集中出现最多的结果，并将它作为这个结点的结果。预剪枝指的是在当前结点进行划分的时候，我们先将取它原本应该取的划分属性，然后对比它划分前后的准确率，如果不划分的准确率更高，我们就不进行划分。预剪枝的本质就是基于贪心，但有可能给决策树带来欠拟合的风险。</p><h2 id="后剪枝"><a href="#后剪枝" class="headerlink" title="后剪枝"></a>后剪枝</h2><p>后剪枝指的是我们先完整生成一棵决策树，自底向上考察每一个结点，如果将其子树替换为某个叶节点，并且能提高准确率，我们就进行替换剪枝。<br>后剪枝一般来说欠拟合风险小，泛化性能优于预剪枝，但其训练开销大。</p><h1 id="连续与缺失值"><a href="#连续与缺失值" class="headerlink" title="连续与缺失值"></a>连续与缺失值</h1><h2 id="连续值处理"><a href="#连续值处理" class="headerlink" title="连续值处理"></a>连续值处理</h2><p>如果我们遇到了连续属性，我们仍使用决策树，我们要先对连续值进行一定处理。<br>假设样本集$D$和连续属性$a$，假设$a$在$D$上出现了$n$个不同的取值，我们将这些值从小到大进行排序，记为$a^1, a^2, \dots, a^n$。对此，我们可以写出$n - 1$个划分点<script type="math/tex">T_a = {\frac{a^i + a^{i + 1}}{2} | 1 \leq i \leq n - 1}</script>。然后我们就可以像离散属性点一样来考察这些划分点。</p><h2 id="缺失值处理"><a href="#缺失值处理" class="headerlink" title="缺失值处理"></a>缺失值处理</h2><p>假如样本的某些属性值丢失，如果放弃有缺失值的样本，会造成信息的浪费。因为，我们采取以下办法来训练带缺失值的样本：<br>给定训练集$D$和属性$a$，设$\widetilde{D}$为$D$中在属性$a$上没有缺失值的样本子集。假设我们给每个样本赋予一个权重$w_x$，并定义：</p><ul><li>$\rho = \frac{\sum_{x \in \widetilde{D}}w_x}{\sum_{x \in D} w_x}$</li><li>$\widetilde{p_k} = \frac{\sum_{x \in \widetilde{D_k}}w_x}{\sum_{x \in \widetilde{D}}w_x}(1 \leq k \leq |\gamma|)$</li><li>$\widetilde{r_v} = \frac{\sum_{x \in \widetilde{D}^v}w_x}{\sum_{x \in \widetilde{D}}w_x}(1 \leq v \leq V)$<br>简单来说，$\rho$表示无缺失值样本所占比例，$\widetilde{p_k}$表示无缺失值样本中第$k$类所占的比例，$\widetilde{r_v}$表示无缺失值样本中在属性$a$上取值$a^v$的样本所占的比例。<br>根据定义，可以推广信息增益计算式为：<script type="math/tex">Gain(D, a) = \rho * Gain(\widetilde{D}, a)</script><br>当样本$x$在属性$a$上划分值缺失时，则将$x$划入所有子结点中，再将其样本权值调整为$\widetilde{r_v} *w_x$。就是让同一个样本根据已知的分布情况，以不同的概率划入到不同的子结点中去。</li></ul><p>来一个鸢尾花的测试<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_iris</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> tree</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"></span><br><span class="line">iris = load_iris()</span><br><span class="line">x = iris[<span class="string">'data'</span>]</span><br><span class="line">y = iris[<span class="string">'target'</span>]</span><br><span class="line"></span><br><span class="line">train_x, test_x, train_y, test_y = train_test_split(x, y, test_size=<span class="number">0.25</span>, random_state=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">train_x = train_x.reshape(train_x.shape[<span class="number">0</span>], <span class="number">-1</span>)</span><br><span class="line">test_x = test_x.reshape(test_x.shape[<span class="number">0</span>], <span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">clf = tree.DecisionTreeClassifier()</span><br><span class="line">clf = clf.fit(train_x, train_y)</span><br><span class="line"></span><br><span class="line">cnt = <span class="number">0</span></span><br><span class="line">sum = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(test_x.shape[<span class="number">0</span>]):</span><br><span class="line">    t = []</span><br><span class="line">    t.append(test_x[i])</span><br><span class="line">    predict_y = clf.predict(t)</span><br><span class="line">    sum += <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span>(predict_y == test_y[i]): cnt += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">print(cnt, sum)</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;决策树简介&quot;&gt;&lt;a href=&quot;#决策树简介&quot; class=&quot;headerlink&quot; title=&quot;决策树简介&quot;&gt;&lt;/a&gt;决策树简介&lt;/h1&gt;&lt;p&gt;决策树(Decision Tree)是在已知各种情况发生概率的基础上，通过构成决策树来求取净现值的期望值大于等于零的
      
    
    </summary>
    
      <category term="机器学习" scheme="http://yoursite.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>贝叶斯分类器</title>
    <link href="http://yoursite.com/2020/07/01/%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%88%86%E7%B1%BB%E5%99%A8/"/>
    <id>http://yoursite.com/2020/07/01/贝叶斯分类器/</id>
    <published>2020-07-01T06:50:36.000Z</published>
    <updated>2020-07-11T08:05:37.480Z</updated>
    
    <content type="html"><![CDATA[<h1 id="先验概率和后验概率"><a href="#先验概率和后验概率" class="headerlink" title="先验概率和后验概率"></a>先验概率和后验概率</h1><p>之前一直搞不清楚这两个概念，这里来区分一下。<br>先验概率是指根据以往经验和分析得到的概率，如全概率公式，它往往作为”由因求果”问题中的”因”出现。<br>后验概率是指依据得到”结果”信息所计算出的最有可能是那种事件发生，如贝叶斯公式中的，是”执果寻因”问题中的”因”。</p><p>举个例子，女朋友每个月都会生气，假设什么都没发生，她今天生气的概率为$p_1$，这就是一种先验概率。<br>当你跟她打电话，发现她说话非常不耐烦，你觉得她今天大概率会生气，假设此时她生气的概率$p_2$，这就是一种后验概率。<br>懂了吧，后验概率其实就是一种条件概率，即是在你观测到某些信息后再发生这个事情的概率有多少。</p><h1 id="贝叶斯定理"><a href="#贝叶斯定理" class="headerlink" title="贝叶斯定理"></a>贝叶斯定理</h1><p>贝叶斯定理说的就是条件概率的事情，定义很简单:$P(A | B) = \frac{P(AB)<br>}{P(B)}$<br>我们可以这样写：$P(B | A) = \frac{P(AB)}{P(A)}$<br>那么可以得到：$P(A | B) = \frac{P(A)P(B | A)}{P(B)}$<br>假设事件$A$是女朋友今天生气了，事件$B$是女朋友打电话不耐烦，那么这个概率可以转换成求女朋友生气的概率、女朋友不耐烦的概率以及女朋友在生气情况下打电话不耐烦的概率。因为很多时候往往都是正面的条件概率不好求，但反面的会比较好求，即可以通过贝叶斯定理进行转换。</p><p>假设$x = (x_1, x_2, \dots, x_n)$表示包含有$D$维属性的数据对象。训练集有$k$个类别，分别为$y = (y_1, y_2, \dots, y_k)$。假设有待分类对象$x$，我们需要找<script type="math/tex">\argmax_{y_i \in y}(P(y_i | x))</script><br>根据上面的推导，我们可以转换为<script type="math/tex">P(y_i | x) = \frac{P(x | y_i)P(y_i)}{P(x)}</script>，由于$P(x)$是常数，实际上只需要最大化$P(x | y_i)P(y_i)$</p><h1 id="朴素贝叶斯分类器"><a href="#朴素贝叶斯分类器" class="headerlink" title="朴素贝叶斯分类器"></a>朴素贝叶斯分类器</h1><p>朴素贝叶斯分类器假设$x$的各个属性之间独立，那么上面就可以改写为：<script type="math/tex">P(y_i)\prod_{j = 1}^nP(x_j | y_i)</script><br>关于<script type="math/tex">P(x_j | y_i)</script>的计算方法，假设$y_i$有$m$个，其中带有$x_j$属性的有$n$个，当样本足够多时，我们就可以用频率值代替概率值，即：$P(x_j | y_i) = \frac{n}{m}$。<br>然而这个方法有个缺陷，属性一旦多了，有可能样本不能覆盖所有属性。假设一个属性样本中没出现过，那么概率直接就为0了。对此，我们对其进行拉普拉斯修正：<script type="math/tex">P(x_j | y_i) = \frac{n + 1}{m + N_j}</script>，其中$N_j$表示第$j$个属性一共可能的取值数。<br>如果属性取值是连续函数，可考虑采用概率密度函数。</p><h1 id="半朴素贝叶斯分类器"><a href="#半朴素贝叶斯分类器" class="headerlink" title="半朴素贝叶斯分类器"></a>半朴素贝叶斯分类器</h1><p>事实上，所有属性相互独立这个条件是很难满足的，这样就产生了半朴素贝叶斯分类器。独依赖估计是半朴素贝叶斯分类器常采用的一种策略，即每个属性最多依赖于一个其他属性。</p><h2 id="SPODE"><a href="#SPODE" class="headerlink" title="SPODE"></a>SPODE</h2><p>$SPODE$方法假设所有属性都依赖于同一个属性，这个属性称为超父属性。这个可以通过交叉验证等模型选择方法来确定。</p><h2 id="TAN"><a href="#TAN" class="headerlink" title="TAN"></a>TAN</h2><p>$SPODE$有他的局限性，即不一定所有属性都会有一个强相关的依赖属性，这时候就产生了$TAN$，$TAN$是基于最大带权生成树算法。<br>定义两个属性之间的条件互信息<script type="math/tex">I(x_i, x_j | y) = \sum_{x_i, x_j; y_k \in y}P(x_i, x_j | y_k)log\frac{P(x_i, x_j | y_k)}{P(x_i | y_k)P(x_j | y_k)}</script><br>然后可以以属性为点，构成完成图，任意两点<script type="math/tex">w(i, j) = I(x_i, x_j | y)</script>，对于做最大生成树（取负然后变为最小生成树），最后给边定向即可。</p><h2 id="AODE"><a href="#AODE" class="headerlink" title="AODE"></a>AODE</h2><p>$AODE$尝试将每个属性作为超父属性，然后将那些有足够训练数据支撑的$SPODE$集成起来作为最终结果。<script type="math/tex">\sum_{i = 1, |D_{x_i} \geq m'|}^dP(c, x_i) \prod_{j = 1}^dP(x_j | c, x_i)</script></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;先验概率和后验概率&quot;&gt;&lt;a href=&quot;#先验概率和后验概率&quot; class=&quot;headerlink&quot; title=&quot;先验概率和后验概率&quot;&gt;&lt;/a&gt;先验概率和后验概率&lt;/h1&gt;&lt;p&gt;之前一直搞不清楚这两个概念，这里来区分一下。&lt;br&gt;先验概率是指根据以往经验和分析得
      
    
    </summary>
    
      <category term="机器学习" scheme="http://yoursite.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>无监督学习</title>
    <link href="http://yoursite.com/2020/06/28/%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0/"/>
    <id>http://yoursite.com/2020/06/28/无监督学习/</id>
    <published>2020-06-28T10:04:08.000Z</published>
    <updated>2020-07-11T08:05:39.737Z</updated>
    
    <content type="html"><![CDATA[<p>我又在无监督学习（不学习）了</p><h1 id="无监督学习简介"><a href="#无监督学习简介" class="headerlink" title="无监督学习简介"></a>无监督学习简介</h1><p>前面区分过无监督学习和有监督学习，无监督学习没有输出标签，即没有$y$，无监督学习需要根据数据找出隐藏的数据结构，比如分类。</p><h1 id="K均值"><a href="#K均值" class="headerlink" title="K均值"></a>K均值</h1><h2 id="K-Means"><a href="#K-Means" class="headerlink" title="K-Means"></a>K-Means</h2><p>给你一堆空间里的点，让你把他们分成k类，使得所有类的最小化平方误差和最小E，也就是所谓的聚类，假设簇划分为$(C_1,C_2,\dots C_k)$，有<script type="math/tex">E = \sum_{i = 1}^k\sum_{x \in C_i}||x - \mu_{i}||_2^2</script>。其中有$\mu_i = \frac{1}{|C_i|}\sum_{x \in C_i}x$。<br>直接求解最小值是一个$NP$问题，所以K均值算法采用启发式迭代的方法，其具体步骤非常简单，首先有k个初始的聚类中心，迭代有如下几步：</p><ul><li>遍历每一个点</li><li>找到离这个点最近的聚类中心，把这个点标记属于这个聚类</li><li>对于每一个新标记出的聚类，计算其新的几何中心</li></ul><p>根据以上步骤迭代至收敛为止。</p><p>k均值算法算法对初始化非常敏感，如果只是随机选择，可能会落入局部最优解，并且收敛会很慢，为此对于初始化，有新的方法提出。</p><h2 id="K-Means-1"><a href="#K-Means-1" class="headerlink" title="K-Means++"></a>K-Means++</h2><p>假设要分为k类，我们需要初始化k个聚类中心，按照如下步骤：</p><ul><li>从输入的数据点集合中随机选择一个点作为第一个聚类中心$\mu_1$</li><li>对于数据集中的每一个点$x_i$，计算它与已选择的聚类中心中最近聚类中心的距离$D(x_i) = argmin||x_i - \mu_r||_2^2 r = 1, 2, \dots k_{selected}$</li><li>选择一个新的数据点作为新的聚类中心，选择的原则是：$D(x)$较大的点，被选取作为聚类中心的概率较大</li><li>重复步骤2-3直到选择出k个聚类质心</li><li>利用这k个质心来作为初始化质心去运行标准的K-Means算法</li></ul><h2 id="elkan-K-Means"><a href="#elkan-K-Means" class="headerlink" title="elkan K-Means"></a>elkan K-Means</h2><p>在普通k均值算法中，我们要计算样本点到所有质心的距离，这个复杂度跟向量维度有关，考虑通过三角形定理进行优化：三角形两边之和大于第三边，两边之差小于第三边。<br>知道两个质心$\mu_{j1}, \mu_{j2}$，如果我们预处理了两个质心间的距离$D(j_1, j_2)$，计算时发现$2D(x, j_1) \leq D(j_1, j_2)$，我们立即就可以知道$D(x, j_1) \leq D(x, j_2)$。此时我们就不需要再计算$D(x, j_2)$</p><h2 id="K-Means与KNN"><a href="#K-Means与KNN" class="headerlink" title="K-Means与KNN"></a>K-Means与KNN</h2><p>$K-Means$是无监督学习的聚类算法，没有样本输出；而$KNN$是监督学习的分类算法，有对应的类别输出。$KNN$基本不需要训练，对测试集里面的点，只需要找到在训练集中最近的k个点，用这最近的k个点的类别来决定测试点的类别。而$K-Means$则有明显的训练过程，找到k个类别的最佳质心，从而决定样本的簇类别。</p><h1 id="主成分分析-PCA"><a href="#主成分分析-PCA" class="headerlink" title="主成分分析(PCA)"></a>主成分分析(PCA)</h1><p>这玩意我怎么总觉得自己又看懂了，又没看懂呢。。。</p><p>简单来说，$PCA$是一种降维方法，因为可能某些数据本身就具备相关性，同时存在就会冗余，我们要在降维的同时将信息的损失尽量降低。</p><p>要掌握$PCA$，我们需要补充一些基础知识。</p><h2 id="向量的表示及基变换"><a href="#向量的表示及基变换" class="headerlink" title="向量的表示及基变换"></a>向量的表示及基变换</h2><h3 id="内积与投影"><a href="#内积与投影" class="headerlink" title="内积与投影"></a>内积与投影</h3><p>假设有两个向量$a, b$，他们的内积为$a^Tb$。考虑向量只有二维，通过几何意义我们可以发现内积的绝对值的几何意义是投影的长度，这个几何意义可以推广到高维去。</p><h3 id="基底"><a href="#基底" class="headerlink" title="基底"></a>基底</h3><p>我们平时表示某个向量例如$(2, 3)$，表示其在$x$正半轴上延申2个单位，在$y$正半轴上延申3个单位，其实我们是省略了基底，我们默认的基底都是$(1, 0), (0, 1)$，向量$(2, 3)$应该表示为$(1, 0)^T(2) + (0, 1)^T(3)$</p><h3 id="基变换的矩阵表示"><a href="#基变换的矩阵表示" class="headerlink" title="基变换的矩阵表示"></a>基变换的矩阵表示</h3><p>考虑从一组基换到另一组，这个过程我们可以用矩乘来表示，下面给一个例子：<br><img src="/mlimg/basechange.png" alt=""><br>维度不一样的话，只需要将变换矩阵的维度一起更改就可以了。</p><h2 id="方差"><a href="#方差" class="headerlink" title="方差"></a>方差</h2><p>那么降维后，我们希望数据越分散越好，因为越发散越能体现数据之间的不同，我们用方差来衡量数据的分散性。</p><h2 id="协方差"><a href="#协方差" class="headerlink" title="协方差"></a>协方差</h2><p>在希望方差尽量大的前提下，我们希望选择的维度越不相关越好。因为如果相关，那么我们可以继续对他降维，直到各个维度都不相关或者相关性很弱。我们用协方差来衡量相关性质，协方差公式如下：$Cov(a, b) = \frac{1}{m}\sum_{i = 1}^m(a_i - \overline{a})(b_i - \overline{b})$。假设我们对数据进行过归一化，均值为0，上面就可以简化为：$Cov(a, b) = \frac{1}{m}\sum_{i = 1}^ma_ib_i$。我们发现这个就等于$\frac{1}{m}XX^T(X是由样本组成的矩阵)$</p><p>至此，我们得到了降维问题的优化目标：<strong>将一组$N$维向量降为$K$维（$0 \leq K \leq N$），其目标是选择$K$个单位（模为1）正交基，使得原始数据变换到这组基上后，各字段两两间协方差为0，而字段的方差则尽可能大（在正交的约束下，取最大的$K$个方差，即取绝对值最大的$K$个特征值）。</strong></p><p>设原始数据矩阵X对应的协方差矩阵为$C$，而$P$是一组基按行组成的矩阵，设$Y = PX$，则$Y$为$X$对$P$做基变换后的数据。设$Y$的协方差矩阵为$D$，我们推导一下$D$与$C$的关系：</p><script type="math/tex; mode=display">D = \frac{1}{m}YY^T = \frac{1}{m}(PX)(PX)^T = \frac{1}{m}PXX^TP^T = PCP^T</script><p>现在我们要寻找一个矩阵$P$，满足$PCP^T$是一个对角矩阵，并且对角元素按从大到小依次排列，那么$P$的前$K$行就是要寻找的基，用$P$的前$K$行组成的矩阵乘以$X$就使得$X$从$N$维降到了$K$维并满足上述优化条件。由于协方差矩阵$C$是一个是对称矩阵，其必然有：</p><ul><li>实对称矩阵不同特征值对应的特征向量必然正交</li><li>设特征向量$λ$重数为$r$，则必然存在$r$个线性无关的特征向量对应于$λ$，因此可以将这$r$个特征向量单位正交化。<br>根据相似对角化，我们一定可以找到一个矩阵$\Lambda = PCP^T$，其中$\Lambda$是对角矩阵，$PP^T = I$。其对角元素为各特征向量对应的特征值（可能有重复）。</li></ul><p>这就是$PCA$的证明，关于里面特征值分解的内容。。看看以后补还是鸽掉吧。</p><h2 id="数据重现"><a href="#数据重现" class="headerlink" title="数据重现"></a>数据重现</h2><p>当我们想重现回高维数据时，不可能得到准确值，因为我们降维后，是用的投影值来代替原来的数据，实际上真实点到垂足点上还有段距离，这部分信息我们是丢失了的，是不可逆的，所以最终只能得到预估值。<br>我们知道$Y = PX$，又有$PP^T = I$，可以得到$X_{approx} = P^TY$，注意矩阵的维度即可。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我又在无监督学习（不学习）了&lt;/p&gt;
&lt;h1 id=&quot;无监督学习简介&quot;&gt;&lt;a href=&quot;#无监督学习简介&quot; class=&quot;headerlink&quot; title=&quot;无监督学习简介&quot;&gt;&lt;/a&gt;无监督学习简介&lt;/h1&gt;&lt;p&gt;前面区分过无监督学习和有监督学习，无监督学习没有输出标签
      
    
    </summary>
    
      <category term="机器学习" scheme="http://yoursite.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>支持向量机</title>
    <link href="http://yoursite.com/2020/06/27/%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/"/>
    <id>http://yoursite.com/2020/06/27/支持向量机/</id>
    <published>2020-06-27T03:47:19.000Z</published>
    <updated>2020-07-11T08:05:34.425Z</updated>
    
    <content type="html"><![CDATA[<h1 id="支持向量机简介"><a href="#支持向量机简介" class="headerlink" title="支持向量机简介"></a>支持向量机简介</h1><p>支持向量机（support vector machines, SVM）是一种二分类模型，它的基本模型是定义在特征空间上的间隔最大的线性分类器，间隔最大使它有别于感知机；SVM还包括核技巧，这使它成为实质上的非线性分类器。SVM的的学习策略就是间隔最大化，可形式化为一个求解凸二次规划的问题，也等价于正则化的合页损失函数的最小化问题。SVM的的学习算法就是求解凸二次规划的最优化算法。</p><h1 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h1><p>支持向量机(SVM)基本想法是找到能够正确划分平面数据集且间隔(Margin)最大的分隔超平面。这里间隔指的两个异类点之间的最近距离。这个距离可以用来衡量抗干扰性，距离越大抗干扰性越强。<br>假设超平面是$w^Tx + b = 0$，任意一个点$x$到超平面的距离为：$\frac{|w^Tx + b|}{||w||}$。<br>我们令正类的$y_i = 1$，负类的$y_i = -1$，假设超平面上所有向量都被分类正确，那么有:</p><script type="math/tex; mode=display">f(x)=\left\{\begin{aligned}&w^Tx_i + b \geq 1, &y_i = +1\\&w^Tx_i + b \leq 1, &y_i = -1\\\end{aligned}\right.</script><p>那么其中最近的两个异类点之间的距离$\gamma$便是取等的时候，即为$\gamma = \frac{2}{||w||}$<br>想要找到最大的$\gamma$，问题转换成了如下：</p><script type="math/tex; mode=display">\begin{aligned}&\max_{w, b}\frac{2}{||w||} \\&s.t. \ y_i(w^Tx_i + b) \geq 1\end{aligned}</script><h1 id="拉格朗日乘子法与KKT条件"><a href="#拉格朗日乘子法与KKT条件" class="headerlink" title="拉格朗日乘子法与KKT条件"></a>拉格朗日乘子法与KKT条件</h1><p>我们知道对于带约束的求极值问题，我们可以通过拉格朗日乘子法将约束去掉。高等数学里一般讲的都是等式约束，如果含有不等式约束我们就需要使用$KKT$条件。<br>我们写出$KKT$条件的数学表达式：</p><script type="math/tex; mode=display">\begin{aligned}&L(x, \lambda_j, \mu_k) = f(x) + \sum_{j = 1}^m\lambda_jg_j(x) + \sum_{k = 1}^p\mu_kh_k(x) \\&\nabla_xL =0 \\&g_j(x) = 0 \ j = 1, \cdots, m, \\&h_k(x) \leq 0 \\&\mu_k \geq 0\end{aligned}</script><p>其实用一句很简单的话来说，最值要嘛在各边界点处取到，要嘛在极值点处取到，这就是$KKT$条件。</p><h1 id="核函数"><a href="#核函数" class="headerlink" title="核函数"></a>核函数</h1><p>上述讲的都是线性可分的$SVM$，但很多时候平面无法线性可分，这时候我们可以把它扔到高维空间去，让它在高维空间上线性可分。<br><img src="/mlimg/transtohighdim.png" alt=""><br>那么我们需要找到一个$\phi(\cdot)$，能把原来的$x$转换到高维空间上。<br>考虑到中间有一步需要求$\phi(x_i)^T\phi(x_j)$，如果转换到高维空间上计算复杂度会很大，这时候就出现了核函数$\kappa(x_i, x_j) = \phi(x_i)^T\phi(x_j)$，使得我们不需要知道$\phi(\cdot)$的具体形式，也可以求出$\kappa(x_i, x_j) = \phi(x_i)^T\phi(x_j)$的值。<br><strong>核函数只是用来计算映射到高维空间之后的内积的一种简便方法。</strong></p><h1 id="逻辑回归和SVM选用建议"><a href="#逻辑回归和SVM选用建议" class="headerlink" title="逻辑回归和SVM选用建议"></a>逻辑回归和SVM选用建议</h1><p>设特征数为$n$，样本数为$m$，给出如下选择建议：</p><ul><li>$n$很大：逻辑回归或者不带核函数的$SVM$</li><li>$n$很小，$m$适中:带高斯核函数的$SVM$</li><li>$n$很小，$m$很大：逻辑回归或者不带核函数的$SVM$</li></ul><h1 id="软间隔"><a href="#软间隔" class="headerlink" title="软间隔"></a>软间隔</h1><p>前面讨论中，我们要求所有样本都分类正确，但实际上，如果要让所有样本都正确，得出的超平面稳定性可能会很差，现在考虑允许一部分样本不满足约束$y_i(w^Tx_i + b) \geq 1$，原来的最优化问题变为了：</p><script type="math/tex; mode=display">\begin{aligned}&\min_{w, b}\frac{1}{2}||w||^2 + C\sum_{i = 1}^ml_{0/1}(y_i(w^Tx_i + b) - 1)\end{aligned}</script><p>其中$C$被称为正则化系数，$l_{0/1}$如下：</p><script type="math/tex; mode=display">l_{0/1} = \left\{\begin{aligned}1, z < 0\\0, z \geq 0\end{aligned}\right.</script><p>实际上$l_{0/1}$非凸非连续，数学性质不好，我们常用如下三种函数来替代：</p><ul><li>$hinge$损失:$l_{hinge}(z) = max(0, 1 - z)$</li><li>指数损失：$l_{exp}(z) = e^{-z}$</li><li>对率损失：$l_{log}(z) = log(1 + e^{-z})$</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;支持向量机简介&quot;&gt;&lt;a href=&quot;#支持向量机简介&quot; class=&quot;headerlink&quot; title=&quot;支持向量机简介&quot;&gt;&lt;/a&gt;支持向量机简介&lt;/h1&gt;&lt;p&gt;支持向量机（support vector machines, SVM）是一种二分类模型，它的基本模型
      
    
    </summary>
    
      <category term="机器学习" scheme="http://yoursite.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>系统的设计与评估</title>
    <link href="http://yoursite.com/2020/06/21/%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E8%AF%84%E4%BC%B0/"/>
    <id>http://yoursite.com/2020/06/21/系统的设计与评估/</id>
    <published>2020-06-21T03:11:22.000Z</published>
    <updated>2020-07-11T08:05:22.087Z</updated>
    
    <content type="html"><![CDATA[<h1 id="模型的改善措施"><a href="#模型的改善措施" class="headerlink" title="模型的改善措施"></a>模型的改善措施</h1><p>当你觉得模型的效果不如意的时候，可以有如下的一些改善措施：</p><ul><li>获取更多的数据</li><li>减少一部分特征</li><li>获取更多的特征</li><li>尝试更高阶的多项式</li><li>尝试增大正则项的系数</li><li>尝试减少正则项的系数</li></ul><p>我们需要了解模型不好的原因在哪里，根本不好的原因来采取正确的改善措施。</p><h1 id="模型评估"><a href="#模型评估" class="headerlink" title="模型评估"></a>模型评估</h1><p>前面我们也提过过拟合的问题，即在训练集上模型表现得很好，但是在测试集上的表现很差，泛用性差、不稳定，易干扰。为了较科学的评估一个模型，我们需要把数据集分为两部分，训练集 + 测试集，一般这个比例为7：3，注意需要把数据集的顺序给打乱。</p><p>对于测试误差，如果是回归问题，形式与$cost$ $function$是一样的，即：$\frac{1}{2m}\sum_{i = 1}^m(h_{\theta}(x^{(i)}) - y^{(i)})^2$。如果是分类问题，可以用其分类问题对应的$cost$ $function$来衡量，或者用另一种评判方法：0/1分类，即每次找出可能性最大的预测结果，然后与对应结果相比，0表示相同，1表示不同，最后对所有样本求和再除以样本总量，就跟正确率其实是一个东西。</p><h1 id="模型选择和训练、验证、测试集"><a href="#模型选择和训练、验证、测试集" class="headerlink" title="模型选择和训练、验证、测试集"></a>模型选择和训练、验证、测试集</h1><p>当我们要进行不同模型之间的比较时，我们需要分出一部分数据用来调整超参数，这个部分我们称为测试集。测试集是模型训练过程中单独留出的样本集，它可以用于调整模型的超参数和用于对模型的能力进行初步评估。我们用验证集的误差来作为模型选择的标准。<br>对比见下：<br><img src="/mlimg/vsandts.png" alt=""></p><h1 id="偏差与方差"><a href="#偏差与方差" class="headerlink" title="偏差与方差"></a>偏差与方差</h1><h2 id="偏差与方差-1"><a href="#偏差与方差-1" class="headerlink" title="偏差与方差"></a>偏差与方差</h2><p><img src="/mlimg/biasandvariance.png" alt=""><br>上面的图其实能说明问题了。<br>偏差：样本与真实值之间的差距<br>方差：样本与期望值之间的差距<br>误差 = 偏差 + 方差（西瓜书上有推导）</p><p>如果模型欠拟合时，即高偏差，这时候就需要复杂化模型。当模型出现过拟合时，即高方差，这时候就需要简化模型。</p><h2 id="正则化的偏差与方差"><a href="#正则化的偏差与方差" class="headerlink" title="正则化的偏差与方差"></a>正则化的偏差与方差</h2><p>考虑正则化的系树$\lambda$，增大$\lambda$，相当于增大惩罚，即在简化模型，即在增大偏差，减小方差。减小$\lambda$，相当于减小惩罚，即在复杂模型，即在减小偏差，增大方差。</p><h1 id="查准率、召回率"><a href="#查准率、召回率" class="headerlink" title="查准率、召回率"></a>查准率、召回率</h1><p><img src="/mlimg/sickandhealthy.png" alt=""></p><ul><li>查准率 $P = \frac{TP}{TP + FP}$</li><li>召回率 $R = \frac{TP}{TP + FN}$</li></ul><p>这两个指标主要针对数据比例倾斜的情况，比如癌症，一个预测恒输出0的函数预测正确率会非常高，这时候就需要这两个指标来进行衡量。</p><p>这两个指标往往是负相关的关系，即FP和FN是负相关的关系。拿癌症举例子，你要预测为癌症的人的准确率高，就必然会将一部分本来是癌症的预测为不是癌症，反过来也是一样的道理。</p><p>我们定义$F = 2 \frac{PR}{P + R}$，我们最后用F值来评估模型的有效性。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;模型的改善措施&quot;&gt;&lt;a href=&quot;#模型的改善措施&quot; class=&quot;headerlink&quot; title=&quot;模型的改善措施&quot;&gt;&lt;/a&gt;模型的改善措施&lt;/h1&gt;&lt;p&gt;当你觉得模型的效果不如意的时候，可以有如下的一些改善措施：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;获取更多的数据
      
    
    </summary>
    
      <category term="机器学习" scheme="http://yoursite.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>神经网络</title>
    <link href="http://yoursite.com/2020/06/15/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
    <id>http://yoursite.com/2020/06/15/神经网络/</id>
    <published>2020-06-15T03:55:10.000Z</published>
    <updated>2020-07-11T08:05:14.339Z</updated>
    
    <content type="html"><![CDATA[<h1 id="神经网络简介"><a href="#神经网络简介" class="headerlink" title="神经网络简介"></a>神经网络简介</h1><h2 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h2><p>前面我们学习了线性模型，但现实中很多模型都是非线性的，我们又很难知道它对应的非线性模型的形式是什么，所以我们引入神经网络来解决非线性模型。<br>神经网络的模型图如下：<br><img src="/mlimg/neuralnetwork.png" alt=""><br>第一层我们称为输入层，最后一层我们成为输出层，其余所有层都称为中间层。</p><h2 id="非线性实例"><a href="#非线性实例" class="headerlink" title="非线性实例"></a>非线性实例</h2><p>为什么神经网络能够求出非线性模型呢，我们拿一个例子来看。<br>假设我们要求$x_1  AND  x_2$<br>这玩意我们可以用一个线性模型来拟合，如图：<br><img src="/mlimg/andopt.png" alt=""><br>如果是$NOT  x$:<br><img src="/mlimg/notopt.png" alt=""><br>那如果是$x_1  xnor  x_2$呢，这显然是一个非线性模型。<br>我们可以把它拆成$(NOT  x_1)  AND  (NOT  x_2)$<br>发现可以用一个中间层来保存两个$NOT$的结果，再组合$AND$的结果。<br>这也就是为什么神经网络能用来表达非线性模型。</p><h2 id="多元分类"><a href="#多元分类" class="headerlink" title="多元分类"></a>多元分类</h2><p>当任务是一个多元分类问题时，我们常对标准结果向量化：即每一个标准结果都是一个$n$ x $1$向量，并且只有其对应的那个特征元素为1，其他所有元素为0。<br>例如三元分类，标准向量如下：<br>$\left[<br>\begin{matrix}<br>1 \\<br>0 \\<br>0<br>\end{matrix}<br>\right]<br>$ $\left[<br>\begin{matrix}<br>0 \\<br>1 \\<br>0<br>\end{matrix}<br>\right]<br>$ $\left[<br>\begin{matrix}<br>0 \\<br>0 \\<br>1<br>\end{matrix}<br>\right]<br>$</p><h1 id="反向传播"><a href="#反向传播" class="headerlink" title="反向传播"></a>反向传播</h1><p>感觉反向传播的推导挺麻烦的，慢慢写吧。。</p><p>当每次正向传播得到预测值后，我们要根据预测值和真实值的误差，反向更新各个点的参数，从而让他们朝着使$loss$ $function$减小的方向更新。<br>我们用$a^{(i)}$表示第$i$层经过激活函数后输出的值<br>我们用$z^{(i)}$表示第$i$层经过激活函数前输出的值<br>我们用$\delta^{(i)}$表示第$i$层的误差，输出层的$\delta = a - y$<br>令代价函数为：$J(\theta) = -ylogh(x) - (1 - y)(1 - h(x))$<br>假设我们已知第$x + 1$层误差为$\delta^{x + 1}$，现在我们要求第$x$层的误差：<br>已知$\delta^{(x)} = \frac{\partial J(\theta)}{\partial z^{(x)}}$<br>$\delta^{(x)} = \frac{\partial J}{\partial a^{x + 1}}\frac{\partial a^{(x + 1)}}{\partial z^{(x + 1)}}\frac{\partial z^{(x + 1)}}{\partial a^{(x)}}\frac{\partial a^{(x)}}{\partial z^{(x)}}$<br>$ = (\frac{-y}{a^{(x + 1)}} + \frac{1 - y}{1 - a^{(x + 1)}})\frac{\partial g(z^{(x + 1)})}{\partial z^{(x + 1)}}\theta^{(x)}\frac{\partial g(z^{(x)})}{\partial z^{(x)}}$<br>$ = \delta^{(x + 1)}\theta^{(x)}a^{(x)}(1 - a^{(x)})$<br>考虑维度问题：<br>$ = (\theta^{(x)})^T\delta^{(x + 1)}g’(z^{(x)})$<br>可能从$\frac{\partial g(z^{(x)})}{\partial z^{(x)}} = a^{(x)}(1 - a^{(x)})$这一步不是特别好理解，需要对函数求导，拆成两部分相乘，然后发现两边都可以用$a$替换回来，就变成后面的形式了。</p><p>考虑参数更新<br>$dw = \frac{\partial J(\theta)}{\partial w} = \frac{\partial J(\theta)}{\partial \alpha}\frac{\partial \alpha}{\partial z}\frac{\partial z}{\partial w} = (a - y) x$<br>考虑维度问题：<br>$= x^{T}(a - y)$</p><p>自己写了个最简单的神经网络，吐了，以后还是调库吧，效果也不是很好，可能有地方写错了。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> h5py</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">path = <span class="string">'C:/Users/Nemo Sherry/Desktop'</span></span><br><span class="line">train_dataset = h5py.File(path + <span class="string">'/train_catvnoncat.h5'</span>, <span class="string">"r"</span>)</span><br><span class="line">test_dataset = h5py.File(path + <span class="string">'/test_catvnoncat.h5'</span>, <span class="string">"r"</span>)</span><br><span class="line">test_x = np.array(test_dataset[<span class="string">'test_set_x'</span>])</span><br><span class="line">test_y = np.array(test_dataset[<span class="string">'test_set_y'</span>])</span><br><span class="line">train_x = np.array(train_dataset[<span class="string">'train_set_x'</span>])</span><br><span class="line">m = train_x.shape[<span class="number">0</span>]</span><br><span class="line">train_y = np.array(train_dataset[<span class="string">'train_set_y'</span>])</span><br><span class="line">train_x = train_x.reshape(train_x.shape[<span class="number">0</span>], <span class="number">-1</span>)</span><br><span class="line">test_x = test_x.reshape(test_x.shape[<span class="number">0</span>], <span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(train_x.shape[<span class="number">0</span>]):</span><br><span class="line">    np.append(train_x[i], <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(test_x.shape[<span class="number">0</span>]):</span><br><span class="line">    np.append(test_x[i], <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">train_x = train_x.T</span><br><span class="line">test_x = test_x.T</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">train_x = train_x / <span class="number">1</span></span><br><span class="line">test_x = test_x / <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(train_x.shape[<span class="number">0</span>]):</span><br><span class="line">    train_x[i] = (train_x[i] - np.sum(train_x[i]) / train_x.shape[<span class="number">1</span>]) / <span class="number">255</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(test_x.shape[<span class="number">0</span>]):</span><br><span class="line">    test_x[i] = (test_x[i] - np.sum(test_x[i]) / test_x.shape[<span class="number">1</span>]) / <span class="number">255</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sigmoid</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1.</span> / (<span class="number">1</span> + np.exp(-x))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sum = <span class="number">0</span></span><br><span class="line">cnt = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">read = <span class="keyword">True</span></span><br><span class="line">w = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> read:</span><br><span class="line">    sys.stdin = open(<span class="string">'weight.txt'</span>,<span class="string">'r'</span>)</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        x = sys.stdin.readline()</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> x : <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>: x = float(x)</span><br><span class="line">        w.append(x)</span><br><span class="line">    w = np.array(w)</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>: w = np.zeros(train_x.shape[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">file = open(<span class="string">'weight.txt'</span>,<span class="string">'w'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">predict</span><span class="params">(w, x, y)</span>:</span></span><br><span class="line">    z = np.dot(w, x)</span><br><span class="line">    a = sigmoid(z)</span><br><span class="line">    a.reshape(a.shape[<span class="number">0</span>], <span class="number">1</span>)</span><br><span class="line">    cost = (<span class="number">-1.</span> / m) * np.sum(y * np.log(a) + (<span class="number">1</span> - y) * np.log(<span class="number">1</span> - a))</span><br><span class="line">    print(cost)</span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">lr = <span class="number">0.1</span></span><br><span class="line">la = <span class="number">5</span></span><br><span class="line"></span><br><span class="line">is_train = <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">propagate</span><span class="params">(w, x, y)</span>:</span></span><br><span class="line">    a = sigmoid(np.dot(w, x))</span><br><span class="line">    dw = <span class="number">1</span> / m * np.dot(x, (a - y).T)</span><br><span class="line">    w = w - lr * dw</span><br><span class="line">    <span class="keyword">return</span> w</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> is_train:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1000</span>):</span><br><span class="line">        w = propagate(w, train_x, train_y)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cnt = <span class="number">0</span></span><br><span class="line">sum = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">t = sigmoid(np.dot(w, train_x))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(t.shape[<span class="number">0</span>]):</span><br><span class="line">    sum += <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> (t[i] &gt;= <span class="number">0.5</span>) == (train_y[i]): cnt += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">print(cnt, sum)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cnt = <span class="number">0</span></span><br><span class="line">sum = <span class="number">0</span></span><br><span class="line">t = sigmoid(np.dot(w, test_x))</span><br><span class="line"></span><br><span class="line">predict(w, test_x, test_y)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(t.shape[<span class="number">0</span>]):</span><br><span class="line">    sum += <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> (t[i] &gt;= <span class="number">0.5</span>) == (test_y[i]): cnt += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">print(cnt, sum)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(w.shape[<span class="number">0</span>]):</span><br><span class="line">    file.write(str(w[i]))</span><br><span class="line">    file.write(<span class="string">'\n'</span>)</span><br><span class="line">file.close()</span><br></pre></td></tr></table></figure></p><p>中间还被一个坑坑了很久，读入进来的numpy的dtype是uint16类型的，我想每一行归一化，一开始直接对每一行操作，然后元素就全变成0了。猜测应该是在对第一行操作的时候，会先把这个numpy的dtype类型转成float的，然后就莫名丢失了内容。所以numpy要转类型要对整个矩阵一起转，不能只转某一行。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;神经网络简介&quot;&gt;&lt;a href=&quot;#神经网络简介&quot; class=&quot;headerlink&quot; title=&quot;神经网络简介&quot;&gt;&lt;/a&gt;神经网络简介&lt;/h1&gt;&lt;h2 id=&quot;模型&quot;&gt;&lt;a href=&quot;#模型&quot; class=&quot;headerlink&quot; title=&quot;模型&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="机器学习" scheme="http://yoursite.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>正则化</title>
    <link href="http://yoursite.com/2020/06/14/%E6%AD%A3%E5%88%99%E5%8C%96/"/>
    <id>http://yoursite.com/2020/06/14/正则化/</id>
    <published>2020-06-14T02:55:40.000Z</published>
    <updated>2020-07-11T08:05:18.956Z</updated>
    
    <content type="html"><![CDATA[<h1 id="拟合"><a href="#拟合" class="headerlink" title="拟合"></a>拟合</h1><p>如果一个模型拟合的不好，一般是如下两种：</p><ul><li>欠拟合</li><li>过拟合<br><img src="/mlimg/fit.png" alt=""><br>第一张图就是欠拟合，很显然不管什么样的直线模型都不能反映出房价后面逐渐平稳的趋势。<br>第二张图拟合效果不错，能反映出整个房价的变化趋势。<br>第三张图就是过拟合，我们知道用拉格朗日插值可以根据$n + 1$个点求出一个唯一确定$n$次多项式，但很显然各个项系数可能会非常大，稳定性也会很差。过拟合实际上就是逐渐靠近这个插值的多项式，使得它能在这些训练集的数据上跑的很好，但是测试集效果就会很差（抗干扰能力不强，容易受噪声影响）。</li></ul><p><img src="/mlimg/overfit.png" alt=""><br>如上图也是过拟合，边界的情况不够平滑，事实上我们希望的是下面这样的模型:<br><img src="/mlimg/goodfit.png" alt=""><br>虽然会在边界有一些误判，这也是很正常的，因为有噪声干扰等的原因，但我们希望边界平滑，从而有更好的泛用性。</p><p>为了解决如上的过拟合问题，我们引入了正则项。</p><h1 id="范数"><a href="#范数" class="headerlink" title="范数"></a>范数</h1><p>在介绍正则项前，我们先来看范数的相关内容。</p><h2 id="L-P范数"><a href="#L-P范数" class="headerlink" title="L-P范数"></a>L-P范数</h2><p>$||x||_p = \sqrt[p]{\sum_{i = 1}^nx_i^p}$</p><p>这是范数的通用定义，实际上在机器学习中，$L0, L1, L2$范数用的比较多，其它的使用都非常的少</p><h2 id="L0范数"><a href="#L0范数" class="headerlink" title="L0范数"></a>L0范数</h2><p>$L0$范围根据上面的定义其实不太准确，$L0$范数实际上求的是非零元素的个数。这貌似非常适合用来筛选特征，但实际上$L_0$范围不好找到一个好的数学表达形式（开0次方等行为比较诡异），所以$L_0$的最优化问题一般会被下放到$L_1, L_2$范数下进行最优化</p><h2 id="L1范数"><a href="#L1范数" class="headerlink" title="L1范数"></a>L1范数</h2><p>$L1$范数根据定义可以看出来是进行绝对值求和，下面我们对带有$L1$范数的梯度下降进行一下探究。</p><p>$\theta_j = \theta_j - \alpha(\frac{1}{m}\sum_{i = 1}^m\frac{\partial J(\theta)}{\theta_j} + \frac{\lambda}{m} * sgn(\theta_j))$<br>我们发现，与原来相比，当$\theta$大于0时，他会减去一个数，当$\theta$小于0时，他会加上一个数，当$\theta$等于0时，他不会改变。所以$L1$范围会让参数尽量的等于0，从而起到了参数稀疏化的作用，从而能够用来进行特征筛选。</p><h2 id="L2范数"><a href="#L2范数" class="headerlink" title="L2范数"></a>L2范数</h2><p>$L2$范数根据定义看出就是距离欧几里得距离求和，下面我们对带有$L2$范数的梯度下降进行一下探究。<br>$\theta_j = \theta_j - \alpha(\frac{1}{m}\sum_{i = 1}^m\frac{\partial J(\theta)}{\theta_j} + \frac{\lambda}{m} \theta_j) = (1 - \alpha \lambda)\theta - \frac{1}{m}\sum_{i = 1}^m\frac{\partial J(\theta)}{\theta_j}$<br>我们发现$L_2$范数每次更新时，相当于把自己乘上一个小于1的数再减去梯度，这过程就会使得参数越来越靠近0，但不会等于0，所以$L2$范数限制了参数会出现很大的情况，从而防止过拟合的情况发生。</p><h1 id="正则项"><a href="#正则项" class="headerlink" title="正则项"></a>正则项</h1><p>在原来的$loss$ $function$后面加上某些范数，这些加上的项就是正则项了。<br>对于梯度下降的正则项推导前面都做得差不多了，下面来看一看正规方程的：<br>$J(\theta) = \frac{1}{2m}(\theta X - T)^T(\theta X - T) + \frac{1}{2m}\lambda\theta^T\theta$<br>求导:<br>$\frac{\partial J(\theta)}{\partial \theta} = \frac{1}{2m}  (2X^TX\theta - 2X^TY + \lambda\theta^T\theta) = 0$<br>得到：<br>$\theta = (X^TX + \lambda E)^{-1}X^TY$<br>前面讨论无正则项时，$X^TX$可能会有不可逆的情况，通过加正则项可以解决这种不可逆的情况。</p><p>注意：</p><ul><li>实际使用中为了方便，可能会在正则项前面配一个常数，方便求导的时候可以直接约掉。</li><li>一般正则项我们不包含常数项，原因是常数项大不会扭曲边界，且很多时候确实需要大的常数项</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;拟合&quot;&gt;&lt;a href=&quot;#拟合&quot; class=&quot;headerlink&quot; title=&quot;拟合&quot;&gt;&lt;/a&gt;拟合&lt;/h1&gt;&lt;p&gt;如果一个模型拟合的不好，一般是如下两种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;欠拟合&lt;/li&gt;
&lt;li&gt;过拟合&lt;br&gt;&lt;img src=&quot;/mlimg
      
    
    </summary>
    
      <category term="机器学习" scheme="http://yoursite.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>Logistic回归</title>
    <link href="http://yoursite.com/2020/06/11/Logistic%E5%9B%9E%E5%BD%92/"/>
    <id>http://yoursite.com/2020/06/11/Logistic回归/</id>
    <published>2020-06-11T11:52:11.000Z</published>
    <updated>2020-07-11T08:05:11.813Z</updated>
    
    <content type="html"><![CDATA[<h1 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h1><p>之前学习了线性回归问题，$Logistic$回归虽然还带了回归的字眼，但实际上是一个分类问题。</p><p>分类问题和回归问题前面也做了区分，简单来说分类问题输出的是一个离散的值，相当于输出一个标签。</p><p>我们先讨论二分类的问题，假设分类标签为0、1。如果我们用线性回归的方法去拟合，会出现大于1或者小于0的情况，对于这部分情况我们难以给它分类。所以这才引出了$Logistic$回归</p><h1 id="假设陈述"><a href="#假设陈述" class="headerlink" title="假设陈述"></a>假设陈述</h1><p>我们引入$sigmoid$函数:<br><img src="/mlimg/sigmoid.png" alt=""><br>由图可知，如果用$sigmoid$函数，就可以把原来在值域的值转换到区间[0, 1]中，并且具体的数值可以用来近似表示分类为1(正例)的概率。<br>最后就有$h_{\theta}(X) = \frac{1}{1 + e^{-\theta^TX}}$</p><h1 id="决策边界"><a href="#决策边界" class="headerlink" title="决策边界"></a>决策边界</h1><p>决策边界是用来进行类别划分的边界函数，可以是线性函数也可以是非线性函数。<br><img src="/mlimg/decisionboundary.png" alt=""><br>在$Logistic$回归中，我们有如下预测：</p><ul><li>当$h_{\theta}(X) \geq 0.5$，即$\theta^TX \geq 0$，此时$y = 1$</li><li>当$h_{\theta}(X) &lt; 0.5$，即$\theta^TX &lt; 0$，此时$y = 0$<br>故边界由下述等式来确定：<br>$\theta^TX = 0$</li></ul><h1 id="最大似然估计"><a href="#最大似然估计" class="headerlink" title="最大似然估计"></a>最大似然估计</h1><p>最大似然估计是指在已知一组观测值和模型假设的情况下，求出能使得结果与观测值相同时最大可能性的模型参数。用人话来讲，就是我知道一组观测结果，知道模型的函数，但有些参数没确定，我需要确定这些参数，使得发生与观测情况相同事件的概率最大。</p><p>从另一个角度来说，对于函数$p(x | \theta)$，$x$表示一个具体的数据，$\theta$表示该模型的参数。</p><p>如果$\theta$已知，相当于就是概率函数，代入$x$就能求得$x$样本下时间发生的概率</p><p>如果$x$已知，相当于就是似然函数，它描述了对于不同的模型参数，出现$x$这个样本的概率</p><p>下面有个简单的例子，假设箱子里有一堆球，分别为黑白两色，假设某个人抽了100次，出现了60次白球，40次黑球，我们想知道白球占比是多少？<br>虽然是一个非常简单的问题，但是背后原理就是最大似然估计。<br>这个下面的模型就很简单，概率函数(出现白球)设为$p(x) = p$<br>它的最大似然估计为$p^{60}(1 - p)^{40}$<br>求导算出最大点的$p = 0.6$<br>这就是一个简单的最大似然估计的例子。</p><h1 id="代价函数"><a href="#代价函数" class="headerlink" title="代价函数"></a>代价函数</h1><p>我们先写出最终分类的概率函数：<br>$p(y | x;\theta) = (h_{\theta}(x))^y(1 - h_{\theta}(x))^{1 - y}$<br>对于一组m个的样本$(x_i, y_i)$，我们写出它的似然函数：<br>$L(\theta) = \prod_{i = 1}^m(h_{\theta}(x_i))^{y_i}(1 - h_{\theta}(x_i))^{1 - y_i}$<br>我们对其取对数似然：<br>$l(\theta) = logL(\theta) = \sum_{i = 1}^m(y_ilogh_{\theta}(x_i) + (1 - y_i)log(1 - h_{\theta}(x_i)))$<br>似然函数越大，表示拟合的越好；损失函数越小，同样表示拟合的越好，所以我们可以把似然函数取个反作为损失函数。<br>$J(\theta) = -l(\theta)$<br>这样我们就可以运用前面的梯度下降法来更新了<br>$\theta = \theta - \alpha\frac{1}{m}\frac{\partial J(\theta)}{\partial \theta}$<br>求导过程不写了，直接写最后结果：<br>$\theta_j = \theta_j - \alpha\sum_{i = 1}^m(h_{\theta}(x^{i}) - y^{(i)})x_j^{(i)}$</p><h1 id="多分类问题"><a href="#多分类问题" class="headerlink" title="多分类问题"></a>多分类问题</h1><p>感觉这上面多分类讲的有点简单啊，又查了查资料 + 看了下西瓜书，补充一些内容</p><p>我们已经知道了二分类问题，多分类问题就可以直接套用二分类的做法，只是需要多一个到二分类问题的转换。而这个转换的形式就有几种。</p><h2 id="一对一拆分-OvO"><a href="#一对一拆分-OvO" class="headerlink" title="一对一拆分(OvO)"></a>一对一拆分(OvO)</h2><p>一对一拆分就是最暴力的，对于$n$个分类，我们两两组合，构造$\frac{n(n - 1)}{2}$个二分类器，对于每一个分类器，我们把这两类的数据拿进去训练。对于一个样本，我们用每一个分类器都进行一次预测，最后取票数最高的作为最终预测值。</p><p>特点：分类器数目较多，需要的空间较大，每个分类器只使用两类数据。</p><h2 id="一对多拆分-OvR"><a href="#一对多拆分-OvR" class="headerlink" title="一对多拆分(OvR)"></a>一对多拆分(OvR)</h2><p>一对多拆分就是每次只选一个分类作为1(正例)，剩下的都作为反例，得到$n$个分类器。对于每个分类器都用所有数据去训练。对于一个样本，若有一个分类器为正类，则为该类别，否则取置信度最高的分类器识别的类别。</p><p>特点：分类器较少，每个分类器都需要训练全部数据。</p><h2 id="多对多拆分-MvM"><a href="#多对多拆分-MvM" class="headerlink" title="多对多拆分(MvM)"></a>多对多拆分(MvM)</h2><p>多对多拆分共有$m$个分类器，每个分类器将其中若干个类作为正类，剩下的作为反类，并采取纠错输出码(ECOC)<br>ECOC工作过程主要分为以下两步：<br>1.对N个类做M次划分，每次划分将一部分作为正类，一部分划分反类，从而形成一个二分类训练集。一共产生M个训练集，训练出M个分类器。<br>2.M个分类器分别对测试样本进行预测，这些预测标记组成一个编码。将这个预测编码与每个类各自的编码进行比较，返回其中距离最小的类别作为最终结果。<br><img src="/mlimg/ECOC.png" alt=""><br>如图所示，我们把样本拿到所有分类器中预测，得到一个ECOC码，我们根据码距找最近的，这里有两种码距，简单介绍一下：</p><ul><li>海明距离：简单来说就是有多少个不一样的距离就是多少</li><li>欧氏距离：类比空间里求欧氏距离的公式就可以求出</li></ul><p>特点：对同一个学习任务来说，ECOC编码越长，纠错能力越强。然而编码越长所需要的训练的分类器越多，计算存储开销都会增大；另一方面对于有限类别码长超过一定范围就没有意义了。对于同等长度的编码，理论上来说，任务两个类别之间的编码距离越远，则纠错能力越强。</p><p>最后附上内置数据集里的一个预测，跑的OvR，效果还挺不错的<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_iris <span class="comment">#导入IRIS数据集</span></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">iris = load_iris()</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line">x = iris[<span class="string">'data'</span>]</span><br><span class="line">x = x.tolist()</span><br><span class="line">y = iris[<span class="string">'target'</span>]</span><br><span class="line"></span><br><span class="line">w1 = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>)]</span><br><span class="line">w2 = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>)]</span><br><span class="line">w3 = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>)]</span><br><span class="line"><span class="comment">#print(w)</span></span><br><span class="line"></span><br><span class="line">lr = <span class="number">0.01</span></span><br><span class="line">m = len(x) // <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(x)):</span><br><span class="line">    x[i].append(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(w, x)</span>:</span></span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(w)):</span><br><span class="line">        res += w[i] * x[i]</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> / (<span class="number">1</span> + math.exp(-res))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> t <span class="keyword">in</span> range(<span class="number">1000000</span>):</span><br><span class="line">    i = random.randint(<span class="number">0</span>, <span class="number">20</span>) + random.randint(<span class="number">0</span>, <span class="number">2</span>) * <span class="number">50</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(len(w1)):</span><br><span class="line">        w1[j] = w1[j] - <span class="number">1</span> / m * lr * (f(w1, x[i]) - (<span class="number">1</span> <span class="keyword">if</span> y[i] == <span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span>)) * x[i][j]</span><br><span class="line">        w2[j] = w2[j] - <span class="number">1</span> / m * lr * (f(w2, x[i]) - (<span class="number">1</span> <span class="keyword">if</span> y[i] == <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span>)) * x[i][j]</span><br><span class="line">        w3[j] = w3[j] - <span class="number">1</span> / m * lr * (f(w3, x[i]) - (<span class="number">1</span> <span class="keyword">if</span> y[i] == <span class="number">2</span> <span class="keyword">else</span> <span class="number">0</span>)) * x[i][j]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">all = <span class="number">0</span></span><br><span class="line">correct = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">px = []</span><br><span class="line">py = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">150</span>):</span><br><span class="line">    all += <span class="number">1</span></span><br><span class="line">    p = [f(w1, x[i]), f(w2, x[i]), f(w3, x[i])]</span><br><span class="line">    flag = <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> max(p) == p[y[i]]:</span><br><span class="line">        correct += <span class="number">1</span></span><br><span class="line">        py.append(y[i])</span><br><span class="line">    <span class="keyword">else</span>: py.append(p.index(max(p)))</span><br><span class="line">    px.append(i)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(correct, all, correct / all)</span><br><span class="line"></span><br><span class="line">plt.plot(px, py, <span class="string">'.'</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;分类&quot;&gt;&lt;a href=&quot;#分类&quot; class=&quot;headerlink&quot; title=&quot;分类&quot;&gt;&lt;/a&gt;分类&lt;/h1&gt;&lt;p&gt;之前学习了线性回归问题，$Logistic$回归虽然还带了回归的字眼，但实际上是一个分类问题。&lt;/p&gt;
&lt;p&gt;分类问题和回归问题前面也做了区
      
    
    </summary>
    
      <category term="机器学习" scheme="http://yoursite.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>多变量线性回归</title>
    <link href="http://yoursite.com/2020/06/09/%E5%A4%9A%E5%8F%98%E9%87%8F%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/"/>
    <id>http://yoursite.com/2020/06/09/多变量线性回归/</id>
    <published>2020-06-09T07:30:43.000Z</published>
    <updated>2020-07-11T08:05:07.846Z</updated>
    
    <content type="html"><![CDATA[<h1 id="多功能"><a href="#多功能" class="headerlink" title="多功能"></a>多功能</h1><h2 id="一些定义"><a href="#一些定义" class="headerlink" title="一些定义"></a>一些定义</h2><ul><li>$x_i^{(j)}$:第$i$个样本的第$j$个特征</li></ul><h2 id="多变量形式"><a href="#多变量形式" class="headerlink" title="多变量形式"></a>多变量形式</h2><p>$h_{\theta}(x) = \theta_0 + \theta_1x_1 + \theta_2x_2 + \dots + \theta_nx_n$, 这里的$x_i$就代表第$i$个特征</p><h2 id="矩阵定义"><a href="#矩阵定义" class="headerlink" title="矩阵定义"></a>矩阵定义</h2><p>我们这里用矩阵来定义，后面我们将发现，运算过程可以变为矩阵的乘法。</p><ul><li><p>$\theta =<br>\left[<br>\begin{matrix}<br> \theta_0\\<br> \theta_1\\<br> \theta_2\\<br> .\\<br> .\\<br> \theta_n<br>\end{matrix}<br>\right]<br>$</p></li><li><p>$x =<br>\left[<br>\begin{matrix}<br> 1\\<br> x_1\\<br> x_2\\<br> .\\<br> .\\<br> x_n<br>\end{matrix}<br>\right]<br>$</p></li></ul><p>我们发现上面的$h_{\theta}(x)$可以写成$h_{\theta}(x) = \theta^Tx$</p><h1 id="多元梯度下降法"><a href="#多元梯度下降法" class="headerlink" title="多元梯度下降法"></a>多元梯度下降法</h1><p>其实就是把线性的拿来做了一个拓展，形式都完全一样</p><ul><li>$J(\theta_0, \theta_1, \theta_2\cdots, \theta_n) = \frac{1}{2m}\sum_{i = 1}^m(\theta_{i0} + \theta_1x_{i1} + \theta_2x_{i2} + \cdots + \theta_nx_{in} - y_i) ^ 2$</li></ul><p>那么我们有如下的更新方法：<br>$\theta_z = \theta_z - \alpha\frac{1}{m}\sum_{i = 1}^m(h_{\theta}(x^{(i)}) - y^{(i)})x_z{(i)}$，其中$x_0 = 1$</p><h1 id="特征放缩"><a href="#特征放缩" class="headerlink" title="特征放缩"></a>特征放缩</h1><p>在$h_{\theta}(x) = \theta_0 + \theta_1x_1 + \theta_2x_2 + \dots + \theta_nx_n$中，假设各个$x_i$的取值范围大小相差很大，在更新上会出现不稳定的问题。原因就是参数值大的出现的波动会更大，举个例子，假设各个参数$\theta_i$都增加0.01，那么取值范围较大的$x_i$特征就会使整个函数的波动更大，在等高线图上表现出来就是$x_i$越大$\theta_i$会显得越加扁平，会造成其他维度的更新较为缓慢。<strong>这样即造成迭代过程中很多轮次实际上是为了消除特征尺度上的不一致，</strong>故而增加了迭代的轮次，收敛速度变慢。<br><img src="\mlimg\equalheight1.png" alt=""></p><p>如果各个维度取值范围接近，那么在等高线图上看起来就会显得很均匀，比如二维平面上就是一个圆，三维平面上就是一个球。<br><img src="\mlimg\equalheight2.png" alt=""></p><p>明显从图中发现，越均匀就会减少很多”绕路”的更新，更直接的接近最小值。</p><p>特征放缩的方法有很多，最常用的是如下：<br>$x’ = \frac{x - \mu}{s}$，其中$s = max - min$，又称为标准差。<br>还有其他很多不同的方法，这里不赘述。</p><h1 id="多项式回归"><a href="#多项式回归" class="headerlink" title="多项式回归"></a>多项式回归</h1><p>多项式回归很简单，只需要把上述的多变量形式里面的$x_i$换成对应的幂次就行了。这个过程中要特别注意特征放缩的问题，因为多项式拟合里出现了幂次，很容易就使得某个原来$x$的取值范围变得很大。</p><h1 id="正规方程"><a href="#正规方程" class="headerlink" title="正规方程"></a>正规方程</h1><p>求解正规方程是不是就是最小二乘法的过程啊。。。</p><p>假设方程一共$n + 1$个特征，我们把每个训练的样本看作一个向量：<br>$x_i =<br>\left[<br>  \begin{matrix}<br>  x_i^{(0)}\\<br>  x_i^{(1)}\\<br>  x_i^{(2)}\\<br>  .\\<br>  .\\<br>  .\\<br>  x_i^{(n)}<br>  \end{matrix}<br>\right]<br>$ </p><p>我们就可以构造$X、y$矩阵:<br>$X =<br>\left[<br>  \begin{matrix}<br>  x_1\\<br>  x_2\\<br>  x_3\\<br>  .\\<br>  .\\<br>  .\\<br>  x_n<br>  \end{matrix}<br>\right]<br>$</p><p>$y =<br>\left[<br>  \begin{matrix}<br>  y_1\\<br>  y_2\\<br>  y_3\\<br>  .\\<br>  .\\<br>  .\\<br>  y_n<br>  \end{matrix}<br>\right]<br>$<br>最优化参数$\theta$矩阵就满足如下式子：<br>$\theta = (X^TX)^{-1}X^Ty$<br>这式子就跟最小二乘推导出的东西一毛一样嘛（应该说的就是一个东西）</p><p>关于梯度下降法和正规方程法的对比如下：<br><img src="/mlimg/comparegdandne.png" alt=""></p><h1 id="正规方程不可逆"><a href="#正规方程不可逆" class="headerlink" title="正规方程不可逆"></a>正规方程不可逆</h1><p>从上面式子看到，如果想要能求出正确结果，需要满足$X^TX$是可逆的，事实上可能会存在一些情况导致其不可逆，原因可能如下：</p><ul><li>特征太多，样本太少</li><li>特征之间不是独立关系</li></ul><p>第一点说的就是矩阵的秩太小，达不到满秩，自然就不可逆。<br>第二点说的是各个向量不是线性无关的，所以本质上秩在经过行列变换后会变小，达不到满秩。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;多功能&quot;&gt;&lt;a href=&quot;#多功能&quot; class=&quot;headerlink&quot; title=&quot;多功能&quot;&gt;&lt;/a&gt;多功能&lt;/h1&gt;&lt;h2 id=&quot;一些定义&quot;&gt;&lt;a href=&quot;#一些定义&quot; class=&quot;headerlink&quot; title=&quot;一些定义&quot;&gt;&lt;/a&gt;一些定
      
    
    </summary>
    
      <category term="机器学习" scheme="http://yoursite.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>单变量线性回归</title>
    <link href="http://yoursite.com/2020/06/08/%E5%8D%95%E5%8F%98%E9%87%8F%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/"/>
    <id>http://yoursite.com/2020/06/08/单变量线性回归/</id>
    <published>2020-06-08T02:31:51.000Z</published>
    <updated>2020-07-11T08:04:51.162Z</updated>
    
    <content type="html"><![CDATA[<h1 id="模型描述"><a href="#模型描述" class="headerlink" title="模型描述"></a>模型描述</h1><p>$y = \theta_0  +  \theta_1x$</p><h1 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h1><ul><li>$(x^{(i)}, y^{(i)})$表示训练集中第i对样本</li><li>$J(\theta_1, \theta_2  )$ $=$ $\frac{1}{2m}\sum_{i = 1}^m(h(x^{(i)})  - y^{(i)})^2$</li></ul><h1 id="梯度下降法"><a href="#梯度下降法" class="headerlink" title="梯度下降法"></a>梯度下降法</h1><ul><li>$\theta_i$ = $\theta_i$ - $\alpha \frac{\partial J(\theta_1, \theta_2)}{\theta_i}$，其中$\alpha$代表学习率</li></ul><p>其实根据高等数学知识可知，求偏导可以相当于把整个函数看作一元函数，我们已知一元导数表示在该点$x$增大，$y$增大的趋势。如果$x$增大$y$也增大，那么我们希望$x$减小，否则希望$x$增大，所以可以发现上面梯度下降的减号是很有道理的。<br>对于每一个变量我们都按上述操作进行更新，最后函数$J$就能往最小值逼近。</p><ul><li>梯度下降虽然是每次更新是让各个参数向着函数值减少值方向在变化，但并不一定是让各个参数一直在向最优的结果变化，举个例子：<br>$y = \theta_0  +  \theta_1x$<br>假设对于某个时刻，$\theta_1$很小，$\theta_0$很大，此时$loss$ $function$也很大，求导后发现$\theta_1$会继续减小，但实际上最优的情况比当前$\theta_1$要大。<br>但这并不影响什么，实际上只要迭代次数足够多，最后一定会绕回到非常靠近最优解的位置。</li></ul><p>附上一个小的test，拟合一条直线，数据随缘取的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">x = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">y = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>]</span><br><span class="line"></span><br><span class="line">w = [<span class="number">1000000</span>, <span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">lr = <span class="number">0.001</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1000000</span>):</span><br><span class="line">    k_sum = <span class="number">0</span></span><br><span class="line">    b_sum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(min(len(x), len(y))):</span><br><span class="line">        k_sum += (w[<span class="number">1</span>] * x[j] + w[<span class="number">0</span>] - y[j]) * x[j]</span><br><span class="line">        b_sum += (w[<span class="number">1</span>] * x[j] + w[<span class="number">0</span>] - y[j])</span><br><span class="line"></span><br><span class="line">    k_sum /= <span class="number">10</span></span><br><span class="line">    b_sum /= <span class="number">10</span></span><br><span class="line">    w[<span class="number">0</span>] = w[<span class="number">0</span>] - lr * b_sum</span><br><span class="line">    w[<span class="number">1</span>] = w[<span class="number">1</span>] - lr * k_sum</span><br><span class="line"></span><br><span class="line">print(w[<span class="number">0</span>], w[<span class="number">1</span>])</span><br></pre></td></tr></table></figure><p>最后得到k，b如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">k = <span class="number">1.9999999999994449</span></span><br><span class="line">b = <span class="number">1.0000000000011102</span></span><br></pre></td></tr></table></figure></p><p>发现非常接近准确值$y = 2x + 1$</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;模型描述&quot;&gt;&lt;a href=&quot;#模型描述&quot; class=&quot;headerlink&quot; title=&quot;模型描述&quot;&gt;&lt;/a&gt;模型描述&lt;/h1&gt;&lt;p&gt;$y = \theta_0  +  \theta_1x$&lt;/p&gt;
&lt;h1 id=&quot;损失函数&quot;&gt;&lt;a href=&quot;#损失函数&quot;
      
    
    </summary>
    
      <category term="机器学习" scheme="http://yoursite.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>初始机器学习</title>
    <link href="http://yoursite.com/2020/06/06/%E5%88%9D%E5%A7%8B%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    <id>http://yoursite.com/2020/06/06/初始机器学习/</id>
    <published>2020-06-06T01:54:32.000Z</published>
    <updated>2020-07-11T08:05:04.565Z</updated>
    
    <content type="html"><![CDATA[<h1 id="监督学习"><a href="#监督学习" class="headerlink" title="监督学习"></a>监督学习</h1><p>这一章好像没啥内容，主要是区分几个概念。</p><h2 id="监督学习-1"><a href="#监督学习-1" class="headerlink" title="监督学习"></a>监督学习</h2><p>利用一组已知类别的样本调整分类器的参数，使其达到所要求性能的过程</p><h2 id="分类问题与回归问题"><a href="#分类问题与回归问题" class="headerlink" title="分类问题与回归问题"></a>分类问题与回归问题</h2><p>由字面意思可得，分类问题解决的是把目标归属到某个类别当中，而回归问题解决的是通过一系列相关因素预测目标的一个值。</p><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><ul><li>分类问题的目标值是离散的，回归是连续的</li><li>二者$loss$ $function$函数性质不同，回归问题$loss$函数输出空间是度量空间，即可以”定量”，而分类问题$loss$函数输出空间不是度量空间，即只有正确和错误之分，只能”定性”</li></ul><h1 id="无监督学习"><a href="#无监督学习" class="headerlink" title="无监督学习"></a>无监督学习</h1><h2 id="无监督学习-1"><a href="#无监督学习-1" class="headerlink" title="无监督学习"></a>无监督学习</h2><p>根据类别未知(没有被标记)的训练样本解决模式识别中的各种问题</p><h2 id="无监督学习与有监督学习区别"><a href="#无监督学习与有监督学习区别" class="headerlink" title="无监督学习与有监督学习区别"></a>无监督学习与有监督学习区别</h2><ul><li>有监督学习有$y$，而无监督学习无$y$<br>上述说法只是表面现象，但感觉没有直击本质。搜集资料时看到一位网友的总结：标签$y$其实是一种施加于对$x$进行压缩过程中的约束。这就是有监督学习。换句话说，机器学习本质上是一种数据的压缩，有监督学习给了这种压缩一个约束，而无监督学习是让机器自己对数据进行重建，如下图：<br><img src="/mlimg/compare_superandunsuper.png" alt=""></li></ul><p>让我们来举两个例子：</p><ul><li>根据患者各方面情况判断是否得了某种病 有监督学习</li><li>根据新闻内容，内容相近的归为一个专题 无监督学习</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;监督学习&quot;&gt;&lt;a href=&quot;#监督学习&quot; class=&quot;headerlink&quot; title=&quot;监督学习&quot;&gt;&lt;/a&gt;监督学习&lt;/h1&gt;&lt;p&gt;这一章好像没啥内容，主要是区分几个概念。&lt;/p&gt;
&lt;h2 id=&quot;监督学习-1&quot;&gt;&lt;a href=&quot;#监督学习-1&quot; cla
      
    
    </summary>
    
      <category term="机器学习" scheme="http://yoursite.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>多项式，永远滴神</title>
    <link href="http://yoursite.com/2020/04/27/%E5%A4%9A%E9%A1%B9%E5%BC%8F%EF%BC%8C%E6%B0%B8%E8%BF%9C%E6%BB%B4%E7%A5%9E/"/>
    <id>http://yoursite.com/2020/04/27/多项式，永远滴神/</id>
    <published>2020-04-27T13:15:48.000Z</published>
    <updated>2020-10-02T07:15:11.087Z</updated>
    
    <content type="html"><![CDATA[<h1 id="FFT"><a href="#FFT" class="headerlink" title="FFT"></a>FFT</h1><p>先咕</p><h1 id="NTT"><a href="#NTT" class="headerlink" title="NTT"></a>NTT</h1><p>先咕</p><h1 id="FWT"><a href="#FWT" class="headerlink" title="FWT"></a>FWT</h1><p>FWT是解决形如<script type="math/tex">C_k = \sum_{i \ op \ j}A_i * B_j</script>，其中op可以是$\&amp;  | \bigoplus$等操作，普通方法肯定是$O(n^2)$的，考虑$FFT$是做了一种变化，然后变化后进行点乘，再逆变化回去，就可以把复杂度优化到$O(nlogn)$，$FWT$能不能采取类似的思路呢？答案是肯定的。<br>我们需要构造$FWT(A)$，使得$FWT(A  op  B) = FWT(A) * FWT(B)$<br>仔细观察，发现这个东西满足交换律：$FWT(A | B) = FWT(B | A)$<br>再观察，发现这玩意还满足结合律：$FWT((A + B) | C) = FWT(A | C) + FWT(B | C)$<br>我们对于一个多项式$A$，定义$A_0，A_1$，分别表示前一半和后一半多项式（二进制最高位为0和为1）。</p><h2 id="or"><a href="#or" class="headerlink" title="or"></a>or</h2><p>$FWT(A) = (FWT(A_0), FWT(A_0 + A_1))$<br>你问括号里的加法是什么意思？就是可以把他们看成一个维度相同的向量，对应位置相加。<br>你问括号里一个逗号什么意思，就是两个多项式拼起来。前面是前一半的结果，后面是后一半的结果。</p><p>考虑正确性，因为是或运算，FWT其实求的就是子集的前缀和（所有子集的和），首先前一半系数必然最高位都为0，所以只能是由$A_0$里面来产生的贡献。考虑后面，因为最高位必须为1，所以一部分贡献来自最高位为1的，同时考虑某个位置去掉最高位的1，会对应$A_0$中的某个位置，这部分贡献也会被包含，所以最终贡献就是$A_0 + A_1$<br>然后我们就可以递归去做求的$or的FWT$了（事实上实现的时候我们采用循环）</p><p>考虑怎么反变换回来，其实很简单$IFWT(A) = (IFWT(A_0)，IFWT(A_1 - A_0))$</p><h2 id="and"><a href="#and" class="headerlink" title="and"></a>and</h2><p>and刚好是跟or反过来的，or的$FWT$表示的是某个集合所有的子集的和，而and的$FWT$是表示的某个集合所有包含它的集合的和，相当于可以描述为后缀和？那么它的$FWT$我们考虑表示$FWT(A) = FWT(FWT(A_0 + A_1), FWT(A_1))$。</p><p>考虑正确性证明，首先后一半的贡献必须全来自$A_1$，前一半$A_0$会产生贡献，$A_0$每一项加上最高位对应$A_1$中的每一项也会产生贡献，所以就是$A_0 + A_1$</p><p>对应反变换也很好写$IFWT(A) = (IFWT(A_0 + A_1)，IFWT(A_1))$</p><h2 id="xor"><a href="#xor" class="headerlink" title="xor"></a>xor</h2><p>异或的构造是最难的，也是唯一没法从$FMT$角度解释的一个，可以说是真正的$FWT$。<br>这里给出构造$FWT(A) = (FWT(A_0 + A_1), FWT(A_0 - A_1))$</p><p>给出正确性证明：<br>$= FWT((A_0 \bigoplus B_0) + FWT(A_1 \bigoplus B_1), FWT(A_0 \bigoplus B_1) + FWT(A_1 \bigoplus B_0))$</p><script type="math/tex; mode=display">= (FWT(A_0 \bigoplus B_0 + A_1 \bigoplus B_1 + A_1 \bigoplus B_0 + A_0 \bigoplus B_1),</script><script type="math/tex; mode=display">FWT(A_0 \bigoplus B_0 + A_1 \bigoplus B_1 - A_1 \bigoplus B_0 - A_0 \bigoplus B_1))</script><script type="math/tex; mode=display">= ((FWT(A_0) + FWT(A_1)) * (FWT(B_0) + FWT(B_1)),</script><script type="math/tex; mode=display">(FWT(A_0) - FWT(A_1)) * (FWT(B_0) - FWT(B_1)))</script><script type="math/tex; mode=display">= (FWT(A_0 + A_1) * FWT(B_0 + B_1),</script><script type="math/tex; mode=display">FWT(A_0 - A_1) * FWT(B_0 - B_1))</script><script type="math/tex; mode=display">= (FWT(A_0 + A_1), FWT(A_0 - A_1)) * (FWT(B_0 + B_1),</script><script type="math/tex; mode=display">FWT(B_0 - B_1)) = FWT(A) * FWT(B)</script><h1 id="分治fft"><a href="#分治fft" class="headerlink" title="分治fft"></a>分治fft</h1><p>求<script type="math/tex">f_i = \sum_{j = 1}^if_{i - j}g_j</script>时，可以考虑分治fft</p><p>用cdq，考虑区间<script type="math/tex">[l, r]</script>里的<script type="math/tex">[l, mid]</script>对<script type="math/tex">[mid + 1, r]</script>这段区间的贡献，这可以用fft卷后直接累加到后面去。注意此时g的长度取区间长度，然后取结果中有用的项出来即可。<br>步骤如下：</p><ul><li>cdq(l, mid)</li><li>将[l, mid]与g卷积，将结果累加到[mid + 1, r]上(注意g的长度以及下标问题)</li><li>cdq(mid + 1, r)</li></ul><p>也可以用多项式求逆解决：<br>我们令<script type="math/tex">F(x) = \sum_{i = 0}^nf_ix^i, G(x) = \sum_{i = 0}^ng_ix^i,  G(0) = 0</script><br>发现有<script type="math/tex">F(x)G(x) + F(0) = F(x)(只看次数小于等于n的项)</script><br>有<script type="math/tex">F(x) = \frac{F(0)}{1 - G(x)}</script>(注意这里1就是常数1（0次项系数），不是多项式每一个位置的系数都是1)<br>直接上多项式求逆即可。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;FFT&quot;&gt;&lt;a href=&quot;#FFT&quot; class=&quot;headerlink&quot; title=&quot;FFT&quot;&gt;&lt;/a&gt;FFT&lt;/h1&gt;&lt;p&gt;先咕&lt;/p&gt;
&lt;h1 id=&quot;NTT&quot;&gt;&lt;a href=&quot;#NTT&quot; class=&quot;headerlink&quot; title=&quot;NTT&quot;&gt;
      
    
    </summary>
    
      <category term="多项式" scheme="http://yoursite.com/categories/%E5%A4%9A%E9%A1%B9%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>论一类x次方计数问题的求解</title>
    <link href="http://yoursite.com/2020/04/09/%E8%AE%BA%E4%B8%80%E7%B1%BBx%E6%AC%A1%E6%96%B9%E8%AE%A1%E6%95%B0%E9%97%AE%E9%A2%98%E7%9A%84%E6%B1%82%E8%A7%A3/"/>
    <id>http://yoursite.com/2020/04/09/论一类x次方计数问题的求解/</id>
    <published>2020-04-09T03:56:46.000Z</published>
    <updated>2020-07-11T08:04:58.680Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文主要探究总结一类问题：统计某种情况下某个东西出现次数的x次方的问题的求解。</p><h1 id="一次方"><a href="#一次方" class="headerlink" title="一次方"></a>一次方</h1><p>我们先看一看一次方的情况我们一般怎么思考问题：</p><h2 id="CCPC-Wannafly-Winter-Camp-Day8-Div2-穗乃果的考试"><a href="#CCPC-Wannafly-Winter-Camp-Day8-Div2-穗乃果的考试" class="headerlink" title="CCPC-Wannafly Winter Camp Day8 Div2 穗乃果的考试"></a><a href="https://www.cometoj.com/contest/31/problem/G?problem_id=440" target="_blank" rel="noopener">CCPC-Wannafly Winter Camp Day8 Div2 穗乃果的考试</a></h2><p><strong>询问一个01矩形中，所有子矩形包含1的个数的总和。</strong><br>枚举子矩形需要一个左上角和一个右下角，发现复杂度非常高，故而不能直接枚举矩形。<br>考虑答案 = $\sum_{子矩形x}\sum a_{ij}$<br>我们变换求和顺序:$\sum_{原矩形中每一个元素a_{ij}且a_{ij} == 1}\sum_{子矩形x}[x包含a_{ij}]$<br>应该不难证明二者是等价的，我们发现枚举$a_{ij}$ 我们是可以接受的，且算有多少子矩形包含$a_{ij}$是非常容易的一件事情，那么问题就做完了。</p><p>一次好像非常显然，但是这只是给你开心开心的。</p><a id="more"></a><h1 id="2次方"><a href="#2次方" class="headerlink" title="2次方"></a>2次方</h1><p>还是先引入一个题目：</p><h2 id="CCPC-Wannafly-Winter-Camp-Day8-Div1-穗乃果的考试"><a href="#CCPC-Wannafly-Winter-Camp-Day8-Div1-穗乃果的考试" class="headerlink" title="CCPC-Wannafly Winter Camp Day8 Div1 穗乃果的考试"></a><a href="https://www.cometoj.com/contest/30/problem/G?problem_id=430" target="_blank" rel="noopener">CCPC-Wannafly Winter Camp Day8 Div1 穗乃果的考试</a></h2><p><strong>我家果果是真的喜欢组合数学啊，还都是这么难的</strong><br>发现跟上一题的变化就是1次变为了2次，但是一下子就难了不少呢。<br>我们还是冷静分析一波：<br>答案 = $\sum_{子矩形x}\sum^2_{a_{ij}}a_{ij}$<br>展开看一看：$\sum_{子矩形x}(a_n + a_{n + 1} + … + a_{m})(a_n + a_{n + 1} + … + a_{m})$<br>PS：$(a_n + a_{n + 1} + …. + a_{m})$指的是$子矩形x$中所有的元素。<br>还是变换求和顺序，我们看之前一次的时候，我们是从所有$a_{ij} == 1$中选一个出来，看有多少子矩形包含$a_{ij}$，本质是从后面每一个可能对答案产生贡献的项拿出来，看有多少情况包含它。<br>我们看二次的后面的项：$(a_n + a_{n + 1} + … + a_{m})(a_n + a_{n + 1} + … + a_{m})$，把乘法展开，相当于枚举每一个不为0的项，然后看有多少子矩形包含这两项。<br>那么答案 = $\sum_{(x = a_{ij}) == 1}\sum_{(y = a_{ij}) == 1} 包含x和y两个点的子矩形的数目$<br>然后枚举一个点，另一个点分为四个方向，前缀和维护一下就做完了。</p><div><div class="fold_hider"><div class="close hider_title">代码</div></div><div class="fold"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> db;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vi;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;ll&gt; vl;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;pii&gt; vp;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">const</span> ll INF = <span class="number">1e18</span>;</span><br><span class="line"><span class="keyword">const</span> db eps = <span class="number">1e-10</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> eb emplace_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ep emplace</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mem(a) memset(a, 0, sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> copy(a, b) memcpy(a, b, sizeof(b))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PA cout &lt;&lt; <span class="meta-string">"pass\n"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lowbit(x) (x &amp; -x)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(x) x.begin(), x.end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TM cout &lt;&lt; db(clock()) / CLOCKS_PER_SEC &lt;&lt; <span class="meta-string">'\n'</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">mt19937 <span class="title">mrand</span><span class="params">(chrono::high_resolution_clock::now().time_since_epoch().count())</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;<span class="title">inline</span> <span class="title">void</span> <span class="title">upmin</span>(<span class="title">T</span> &amp;<span class="title">x</span>, <span class="title">T</span> <span class="title">y</span>) &#123;</span>x = x &gt; y ? y : x;&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;<span class="title">inline</span> <span class="title">void</span> <span class="title">upmax</span>(<span class="title">T</span> &amp;<span class="title">x</span>, <span class="title">T</span> <span class="title">y</span>) &#123;</span>x = x &lt; y ? y : x;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2020</span>;</span><br><span class="line"><span class="keyword">char</span> s[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    x += y;</span><br><span class="line">    <span class="keyword">if</span>(x &gt;= mod) x -= mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sub</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    x -= y;</span><br><span class="line">    <span class="keyword">if</span>(x &lt; <span class="number">0</span>) x += mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> s3[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> s4[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> c1[maxn][maxn], c2[maxn][maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s[i] + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i][j] == <span class="string">'1'</span>)&#123;</span><br><span class="line">                add(s3[i][j], <span class="number">1l</span>l * i * j % mod);</span><br><span class="line">                add(s4[i][j], <span class="number">1l</span>l * i * (m - j + <span class="number">1</span>) % mod);</span><br><span class="line">                add(c1[i][j], <span class="number">1</span>);</span><br><span class="line">                add(c2[i][j], <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            add(s3[i][j], s3[i - <span class="number">1</span>][j]);</span><br><span class="line">            add(s3[i][j], s3[i][j - <span class="number">1</span>]);</span><br><span class="line">            sub(s3[i][j], s3[i - <span class="number">1</span>][j - <span class="number">1</span>]);</span><br><span class="line">            add(c1[i][j], c1[i - <span class="number">1</span>][j]);</span><br><span class="line">            add(c1[i][j], c1[i][j - <span class="number">1</span>]);</span><br><span class="line">            sub(c1[i][j], c1[i - <span class="number">1</span>][j - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = m; j; j--)&#123;</span><br><span class="line">            add(s4[i][j], s4[i - <span class="number">1</span>][j]);</span><br><span class="line">            add(s4[i][j], s4[i][j + <span class="number">1</span>]);</span><br><span class="line">            sub(s4[i][j], s4[i - <span class="number">1</span>][j + <span class="number">1</span>]);</span><br><span class="line">            add(c2[i][j], c2[i - <span class="number">1</span>][j]);</span><br><span class="line">            add(c2[i][j], c2[i][j + <span class="number">1</span>]);</span><br><span class="line">            sub(c2[i][j], c2[i - <span class="number">1</span>][j + <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i][j] == <span class="string">'0'</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> a = n - i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> b = m - j + <span class="number">1</span>;</span><br><span class="line">            add(res, <span class="number">1l</span>l * a * b % mod * s3[i - <span class="number">1</span>][j - <span class="number">1</span>] % mod);</span><br><span class="line">            b = j;</span><br><span class="line">            add(res, <span class="number">1l</span>l * a * b % mod * s4[i - <span class="number">1</span>][j + <span class="number">1</span>] % mod);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    add(res, res);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> pre = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i][j] == <span class="string">'0'</span>) <span class="keyword">continue</span>;</span><br><span class="line">            add(tmp, <span class="number">1l</span>l * (m - j + <span class="number">1</span>) * pre % mod);</span><br><span class="line">            add(pre, j);</span><br><span class="line">        &#125;</span><br><span class="line">        tmp = <span class="number">2l</span>l * tmp * i % mod * (n - i + <span class="number">1</span>) % mod;</span><br><span class="line">        add(res, tmp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)&#123;</span><br><span class="line">        <span class="keyword">int</span> pre = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i][j] == <span class="string">'0'</span>) <span class="keyword">continue</span>;</span><br><span class="line">            add(tmp, <span class="number">1l</span>l * (n - i + <span class="number">1</span>) * pre % mod);</span><br><span class="line">            add(pre, i);</span><br><span class="line">        &#125;</span><br><span class="line">        tmp = <span class="number">2l</span>l * tmp * j % mod * (m - j + <span class="number">1</span>) % mod;</span><br><span class="line">        add(res, tmp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i][j] == <span class="string">'1'</span>) add(res, <span class="number">1l</span>l * (n - i + <span class="number">1</span>) * i % mod * (m - j + <span class="number">1</span>) % mod * j % mod);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><h1 id="x次方"><a href="#x次方" class="headerlink" title="x次方"></a>x次方</h1><p>根据上面的做法我们可以看出，对于求某种情况下某个东西x次方的贡献，我们把符合条件的点提出来变成一个序列，然后复制x次，问题就变成了这x个序列每个选1个，然后求同时包含这x个的情况一共有多少种。</p><p>再来看一个稍微硬核一点的题</p><h2 id="Asia-Beijing-Regional-2014-F-Fluorescent"><a href="#Asia-Beijing-Regional-2014-F-Fluorescent" class="headerlink" title="Asia-Beijing Regional 2014 - F(Fluorescent)"></a><a href="http://opentrains.snarknews.info/~ejudge/team.cgi?SID=0ff216405c1f68d0&amp;action=2" target="_blank" rel="noopener">Asia-Beijing Regional 2014 - F(Fluorescent)</a></h2><p><strong>给定n栈灯，m个开关（n &lt;= 50, m &lt;= 50），每个开关连接一系列灯，并且能把这一系列灯的状态同时翻转，问所有情况下亮着灯数目三次方的期望是多少</strong></p><p>考虑答案 = $\sum_{情况x}(a_1 + a_2 + … + a_n)^3$<br>考虑变换求和顺序：对$(a_1 + a_2 + … + a_n)^3$中的每一组不为0的项，求有多少方案使得这三个位置最后都是亮着的。</p><p>这样我们就可以枚举三个位置，然后用状压dp求解了，最后求和就行了。</p><div><div class="fold_hider"><div class="close hider_title">代码</div></div><div class="fold"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> db;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vi;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;ll&gt; vl;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;pii&gt; vp;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">const</span> ll INF = <span class="number">1e18</span>;</span><br><span class="line"><span class="keyword">const</span> db eps = <span class="number">1e-10</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> eb emplace_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ep emplace</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mem(a) memset(a, 0, sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> copy(a, b) memcpy(a, b, sizeof(b))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PA cout &lt;&lt; <span class="meta-string">"pass\n"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lowbit(x) (x &amp; -x)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(x) x.begin(), x.end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TM cout &lt;&lt; db(clock()) / CLOCKS_PER_SEC &lt;&lt; <span class="meta-string">'\n'</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">mt19937 <span class="title">mrand</span><span class="params">(chrono::high_resolution_clock::now().time_since_epoch().count())</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;<span class="title">inline</span> <span class="title">void</span> <span class="title">upmin</span>(<span class="title">T</span> &amp;<span class="title">x</span>, <span class="title">T</span> <span class="title">y</span>) &#123;</span>x = x &gt; y ? y : x;&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;<span class="title">inline</span> <span class="title">void</span> <span class="title">upmax</span>(<span class="title">T</span> &amp;<span class="title">x</span>, <span class="title">T</span> <span class="title">y</span>) &#123;</span>x = x &lt; y ? y : x;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T;</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">55</span>][<span class="number">8</span>];</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">bool</span> vis[<span class="number">55</span>][<span class="number">55</span>];</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    x += y;</span><br><span class="line">    <span class="keyword">if</span>(x &gt;= mod) x -= mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>), <span class="built_in">cin</span>.tie(<span class="number">0</span>), <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; fixed &lt;&lt; setprecision(<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> kase = <span class="number">1</span>; kase &lt;= T; kase++)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">        mem(vis);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> len;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; len;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= len; j++)&#123;</span><br><span class="line">                <span class="keyword">int</span> x;</span><br><span class="line">                <span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">                vis[i][x] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; k++)&#123;</span><br><span class="line">                    mem(dp);</span><br><span class="line">                    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> p = <span class="number">1</span>; p &lt;= m; p++)&#123;</span><br><span class="line">                        <span class="keyword">int</span> t1 = <span class="number">0</span>, t2 = <span class="number">0</span>, t3 = <span class="number">0</span>;</span><br><span class="line">                        <span class="keyword">if</span>(vis[p][i]) t1 = <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">if</span>(vis[p][j]) t2 = <span class="number">2</span>;</span><br><span class="line">                        <span class="keyword">if</span>(vis[p][k]) t3 = <span class="number">4</span>;</span><br><span class="line">                        <span class="keyword">for</span>(<span class="keyword">int</span> mask = <span class="number">0</span>; mask &lt; <span class="number">8</span>; mask++)&#123;</span><br><span class="line">                            add(dp[p][mask ^ t1 ^ t2 ^ t3], dp[p - <span class="number">1</span>][mask]);</span><br><span class="line">                            add(dp[p][mask], dp[p - <span class="number">1</span>][mask]);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    add(res, dp[m][<span class="number">7</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Case #"</span> &lt;&lt; kase &lt;&lt; <span class="string">": "</span> &lt;&lt; res &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><p>再来个最难的</p><h2 id="2018-2019-ACM-ICPC-Asia-Xuzhou-Regional-Contest-D-Rikka-with-Subsequences"><a href="#2018-2019-ACM-ICPC-Asia-Xuzhou-Regional-Contest-D-Rikka-with-Subsequences" class="headerlink" title="2018-2019 ACM-ICPC, Asia Xuzhou Regional Contest - D(Rikka with Subsequences)"></a><a href="https://codeforces.com/gym/102012/problem/D" target="_blank" rel="noopener">2018-2019 ACM-ICPC, Asia Xuzhou Regional Contest - D(Rikka with Subsequences)</a></h2><p><strong>给定一种”好子序列”的定义，求所有本质相同好子序列个数三次方的和</strong></p><p>直接考虑问题转换，既然是求本质相同的好子序列出现次数三次方的和，我们可以等价于求把原序列复制三份，在三份上各取一个子序列，且子序列相同的情况数。</p><p>考虑$dp[i][j][k]$为第一个好子序列最后为$i$结尾，第二个好子序列最后以$j$结尾，第三个好子序列最后以$k$结尾。考虑转移，对于某一个$dp[i][j][k]$，我们找前面有多少$dp[i’][j’][k’]$ $(i’ &lt; i, j’ &lt; j, k’ &lt; k)$，但由于还有好子序列的限制，所以我们要找到所有$a[i’] = a[i]$的点，剩下的就是找$j’$, $k’$，这相当于是个二位前缀和（因为只用限制一个点，剩下$a[j]$，$a[k]$，$a[j’]$，$a[k’]$必然相等。）也就是对于每个$i$，我们对所有满足$a[j] = a[i]$的$j$，$k$求一次前缀和，然后加速转移，同时在这里统计方案即可。</p><div><div class="fold_hider"><div class="close hider_title">代码</div></div><div class="fold"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> db;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vi;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;ll&gt; vl;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;pii&gt; vp;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">const</span> ll INF = <span class="number">1e18</span>;</span><br><span class="line"><span class="keyword">const</span> db eps = <span class="number">1e-10</span>;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> eb emplace_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ep emplace</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mem(a) memset(a, 0, sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> copy(a, b) memcpy(a, b, sizeof(b))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PA cout &lt;&lt; <span class="meta-string">"pass\n"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lowbit(x) (x &amp; -x)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(x) x.begin(), x.end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TM cout &lt;&lt; db(clock()) / CLOCKS_PER_SEC &lt;&lt; <span class="meta-string">'\n'</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function">mt19937 <span class="title">mrand</span><span class="params">(chrono::high_resolution_clock::now().time_since_epoch().count())</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;<span class="title">inline</span> <span class="title">void</span> <span class="title">upmin</span>(<span class="title">T</span> &amp;<span class="title">x</span>, <span class="title">T</span> <span class="title">y</span>) &#123;</span>x = x &gt; y ? y : x;&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;<span class="title">inline</span> <span class="title">void</span> <span class="title">upmax</span>(<span class="title">T</span> &amp;<span class="title">x</span>, <span class="title">T</span> <span class="title">y</span>) &#123;</span>x = x &lt; y ? y : x;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> n, T;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">220</span>;</span><br><span class="line"><span class="keyword">int</span> dp[maxn][maxn], sum[maxn][maxn];</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    x += y;</span><br><span class="line">    <span class="keyword">if</span>(x &gt;= mod) x -= mod;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sub</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    x -= y;</span><br><span class="line">    <span class="keyword">if</span>(x &lt; <span class="number">0</span>) x += mod;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">char</span> s[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> a[maxn];</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= n; j++)&#123;</span><br><span class="line">                dp[i][j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s[i] + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; k++)&#123;</span><br><span class="line">                    sum[j][k] = s[a[j]][a[i]] == <span class="string">'1'</span> ? dp[j][k] : <span class="number">0</span>;</span><br><span class="line">                    add(sum[j][k], sum[j - <span class="number">1</span>][k]);</span><br><span class="line">                    add(sum[j][k], sum[j][k - <span class="number">1</span>]);</span><br><span class="line">                    sub(sum[j][k], sum[j - <span class="number">1</span>][k - <span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; k++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(a[i] == a[j] &amp;&amp; a[j] == a[k])&#123;</span><br><span class="line">                        <span class="keyword">int</span> tmp = <span class="number">1</span>;</span><br><span class="line">                        add(tmp, sum[j - <span class="number">1</span>][k - <span class="number">1</span>]);</span><br><span class="line">                        add(res, tmp);</span><br><span class="line">                        add(dp[j][k], tmp);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>对于统计中$x$次方求和的问题，转换为把原来的东西复制$x$次，每个里面选一种方案，求原来有多少方案能使这$x$个方案同时满足。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;本文主要探究总结一类问题：统计某种情况下某个东西出现次数的x次方的问题的求解。&lt;/p&gt;
&lt;h1 id=&quot;一次方&quot;&gt;&lt;a href=&quot;#一次方&quot; class=&quot;headerlink&quot; title=&quot;一次方&quot;&gt;&lt;/a&gt;一次方&lt;/h1&gt;&lt;p&gt;我们先看一看一次方的情况我们一般怎么思考问题：&lt;/p&gt;
&lt;h2 id=&quot;CCPC-Wannafly-Winter-Camp-Day8-Div2-穗乃果的考试&quot;&gt;&lt;a href=&quot;#CCPC-Wannafly-Winter-Camp-Day8-Div2-穗乃果的考试&quot; class=&quot;headerlink&quot; title=&quot;CCPC-Wannafly Winter Camp Day8 Div2 穗乃果的考试&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://www.cometoj.com/contest/31/problem/G?problem_id=440&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;CCPC-Wannafly Winter Camp Day8 Div2 穗乃果的考试&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;询问一个01矩形中，所有子矩形包含1的个数的总和。&lt;/strong&gt;&lt;br&gt;枚举子矩形需要一个左上角和一个右下角，发现复杂度非常高，故而不能直接枚举矩形。&lt;br&gt;考虑答案 = $\sum_{子矩形x}\sum a_{ij}$&lt;br&gt;我们变换求和顺序:$\sum_{原矩形中每一个元素a_{ij}且a_{ij} == 1}\sum_{子矩形x}[x包含a_{ij}]$&lt;br&gt;应该不难证明二者是等价的，我们发现枚举$a_{ij}$ 我们是可以接受的，且算有多少子矩形包含$a_{ij}$是非常容易的一件事情，那么问题就做完了。&lt;/p&gt;
&lt;p&gt;一次好像非常显然，但是这只是给你开心开心的。&lt;/p&gt;
    
    </summary>
    
      <category term="组合数学" scheme="http://yoursite.com/categories/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"/>
    
    
  </entry>
  
  <entry>
    <title>CNN学习笔记</title>
    <link href="http://yoursite.com/2020/04/05/CNN%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2020/04/05/CNN学习笔记/</id>
    <published>2020-04-05T03:41:51.000Z</published>
    <updated>2020-07-11T08:12:38.222Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CNN整体结构"><a href="#CNN整体结构" class="headerlink" title="CNN整体结构"></a>CNN整体结构</h1><p>之前学习了全连接层，我们先再看看全连接层的结构：<br><img src="/mlimg/AffineStruct.png" alt=""><br>简单总结一下，我们发现就是由一堆 <strong>输入 -&gt; Affine层 -&gt; 激活函数</strong> 组成的。<br>再来康康CNN的结构：<br><img src="/mlimg/CNNStruct.png" alt=""><br>我们发现前面的Affine层换成了Conv（卷积）层，并且多加入了一个Pooling（池化）层。当然最后还是保留了部分Affine层。</p><h1 id="卷积层"><a href="#卷积层" class="headerlink" title="卷积层"></a>卷积层</h1><h2 id="为什么要引入卷积层"><a href="#为什么要引入卷积层" class="headerlink" title="为什么要引入卷积层"></a>为什么要引入卷积层</h2><p>考虑引入卷积层，必然是以前的全连接层存在某些问题。首先，全连接层的运算量大，因为每两个点都必须有一个权值，所以边数是点数平方级别的。其次，CNN主要针对的是图像问题，在图像中，两个相距较远的像素可以认为是基本无关的，但全连接层中仍会考虑它们，相当于有很多无用的计算量。<br>基于此，我们考虑用卷积层替换全连接层，卷积层就可以改良上述缺点。</p><h2 id="卷积运算"><a href="#卷积运算" class="headerlink" title="卷积运算"></a>卷积运算</h2><p>因为之前学过图想处理，感觉卷积运算理解起来就非常容易。<br><img src="/mlimg/Conv.png" alt=""><br>直接看图吧，相当于就是拿一个窗口在图上滑动，然后对于每一个位置，直接做点积运算，得到的结果放到最终结果的对应位置（如果有偏置的话还要加上偏置的值）。</p><p>当然这只是一维情况，事实上只要不是黑白图片，一般都是三通道的，也就是三维的，那么卷积运算就是三个通道结果相加：<br><img src="/mlimg/3DConv.png" alt=""><br><img src="/mlimg/3DConv2.png" alt=""></p><h2 id="卷积层实现"><a href="#卷积层实现" class="headerlink" title="卷积层实现"></a>卷积层实现</h2><p>这个就比较偏编程技巧了，一般的想法是几层for循环就可以解决，然而这样效率比较慢。我们一般而言是先把数据向量化，也就是展开，也可以称作是降维：<br><img src="/mlimg/ConvProcess.png" alt=""><br>展开对应关系如下图所示：<br><img src="/mlimg/ConvProcess1.png" alt=""><br>同样我们也可以把滤波器的展开，最后发现，我们的卷积运算就可以转换为矩阵乘法了，最后再把结果还原为原来的形状：<br><img src="/mlimg/ConvProcess2.png" alt=""></p><h1 id="池化层"><a href="#池化层" class="headerlink" title="池化层"></a>池化层</h1><h2 id="为什么要引入卷积层-1"><a href="#为什么要引入卷积层-1" class="headerlink" title="为什么要引入卷积层"></a>为什么要引入卷积层</h2><p>池化是缩小高、长方向上的空间的运算。池化层可以增强对微小变化的鲁棒性。</p><h2 id="池化运算"><a href="#池化运算" class="headerlink" title="池化运算"></a>池化运算</h2><p><img src="/mlimg/Pooling.png" alt=""><br>其实跟卷积运算挺类似的，看图就能直接明白了。<br>池化也有很多种，比如Max池化，Average池化等，一般来说Max池化用的比较多。</p><h2 id="池化层实现"><a href="#池化层实现" class="headerlink" title="池化层实现"></a>池化层实现</h2><p>池化层实现思想差不多，先把原来数据展开，进行运算，然后再还原回去：<br><img src="/mlimg/PoolingProcess.png" alt=""><br>具体来说就是把每个滤波器能在的位置展开成一行，然后就可以变成对每一行进行操作，最后挨着还原回去就行了。<br><img src="/mlimg/PoolingProcess.png" alt=""></p><p>接下来去研究下pytorch去了。。。研究完再补。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;CNN整体结构&quot;&gt;&lt;a href=&quot;#CNN整体结构&quot; class=&quot;headerlink&quot; title=&quot;CNN整体结构&quot;&gt;&lt;/a&gt;CNN整体结构&lt;/h1&gt;&lt;p&gt;之前学习了全连接层，我们先再看看全连接层的结构：&lt;br&gt;&lt;img src=&quot;/mlimg/Affin
      
    
    </summary>
    
      <category term="机器学习" scheme="http://yoursite.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
</feed>

<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>小雅米，来来往往这么多人，有多少是圆梦后才衣锦还乡的呢？</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2021-05-14T02:34:46.379Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>kimoyami</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Hall定理</title>
    <link href="http://yoursite.com/2021/04/12/Hall%E5%AE%9A%E7%90%86/"/>
    <id>http://yoursite.com/2021/04/12/Hall定理/</id>
    <published>2021-04-12T12:48:10.000Z</published>
    <updated>2021-05-14T02:34:46.379Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Hall定理内容"><a href="#Hall定理内容" class="headerlink" title="Hall定理内容"></a>Hall定理内容</h1><ul><li>假设二分图两部分点集分别为<script type="math/tex">X, Y</script>(|X| &lt; |Y|)，二分图存在完美匹配(匹配数为|X|)的充要条件是：对于<script type="math/tex">X</script>中任意大小为<script type="math/tex">k</script>的集合<script type="math/tex">W</script>，<script type="math/tex">Y</script>中与其相邻的点集记为<script type="math/tex">N(W)</script>，有<script type="math/tex">|W| \leq N(W)</script></li><li>二分图的最大匹配数等于<script type="math/tex">|X| - \underset{W \in X}{min} ({|N(W)| - |W|})</script></li></ul><p><script type="math/tex">Hall</script>定理因为作用于任意子集取<script type="math/tex">min</script>，但题目往往具有某些特殊性质，使得取<script type="math/tex">min</script>的集合<script type="math/tex">W</script>或者<script type="math/tex">N(W)</script>是一段连续的区间，然后利用线段树或者其它方法配合解决问题</p><a id="more"></a><h1 id="Hall定理-前后缀"><a href="#Hall定理-前后缀" class="headerlink" title="Hall定理 + 前后缀"></a>Hall定理 + 前后缀</h1><h2 id="cf-338E-Optimize"><a href="#cf-338E-Optimize" class="headerlink" title="cf 338E Optimize!"></a><a href="https://codeforces.com/contest/338/problem/E" target="_blank" rel="noopener">cf 338E Optimize!</a></h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给定长度为<script type="math/tex">n, m</script>的<script type="math/tex">A, B</script>数组，给定<script type="math/tex">h</script>，问<script type="math/tex">A</script>中有多少个长度为<script type="math/tex">m</script>的子区间能与<script type="math/tex">B</script>进行完美匹配(匹配条件是<script type="math/tex">A_i + B_j \geq h</script>)</p><h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><p>因为与<script type="math/tex">B</script>的顺序无关，不妨给<script type="math/tex">B</script>数组先排个序。能发现对于某个<script type="math/tex">A_i</script>，覆盖的一定是排序后的<script type="math/tex">B</script>的一段后缀。那么我们有如下推论：</p><ul><li>假设<script type="math/tex">B</script>为<script type="math/tex">X</script>集合，<script type="math/tex">A</script>为<script type="math/tex">Y</script>集合，取得<script type="math/tex">Hall</script>定理中<script type="math/tex">\underset{W \in X}{min} ({|N(W)| - |W|})</script>的<script type="math/tex">W</script>一定是数组<script type="math/tex">B</script>的一段前缀区间。</li><li>证明：对于任意的<script type="math/tex">j < i, B_j < B_i</script>，有<script type="math/tex">N(B_j) \in N_(B_i)</script>，所以一个子集与<script type="math/tex">A</script>中相邻的元素只与子集中最大元素有关，如果子集中小于最大值的部分有没取的，我们取了后不会改变<script type="math/tex">|N(W)|</script>，所以我们可以贪心取满前缀。</li></ul><p>有了如上推论，我们发现我们只需要维护<script type="math/tex">m</script>个前缀区间的<script type="math/tex">|N(W)| - |W|</script>的值即可，只要保证最小值<script type="math/tex">\geq</script> 0即可有完美匹配。</p><div><div class="fold_hider"><div class="close hider_title">代码</div></div><div class="fold"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">3e5</span> + <span class="number">233</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">Segment_Tree</span> &#123;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ls o &lt;&lt; 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rs o &lt;&lt; 1 | 1</span></span><br><span class="line">    T sum[maxn &lt;&lt; <span class="number">2</span>], tag[maxn &lt;&lt; <span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> mx[maxn &lt;&lt; <span class="number">2</span>], mn[maxn &lt;&lt; <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">up</span><span class="params">(<span class="keyword">int</span> o)</span> </span>&#123;</span><br><span class="line">        sum[o] = sum[ls] + sum[rs];</span><br><span class="line">        mn[o] = min(mn[ls], mn[rs]);</span><br><span class="line">        mx[o] = max(mx[ls], mx[rs]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">down</span><span class="params">(<span class="keyword">int</span> o, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tag[o]) &#123;</span><br><span class="line">            tag[ls] += tag[o];</span><br><span class="line">            tag[rs] += tag[o];</span><br><span class="line">            sum[ls] += tag[o] * (m - (m &gt;&gt; <span class="number">1</span>));</span><br><span class="line">            sum[rs] += tag[o] * (m &gt;&gt; <span class="number">1</span>);</span><br><span class="line">            mx[ls] += tag[o];</span><br><span class="line">            mx[rs] += tag[o];</span><br><span class="line">            mn[ls] += tag[o];</span><br><span class="line">            mn[rs] += tag[o];</span><br><span class="line">            tag[o] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> o, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        tag[o] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(l == r) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        build(ls, l, mid);</span><br><span class="line">        build(rs, mid + <span class="number">1</span>, r);</span><br><span class="line">        up(o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">upd</span><span class="params">(<span class="keyword">int</span> o, <span class="keyword">int</span> tl, <span class="keyword">int</span> tr, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tr &lt; l || r &lt; tl)<span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (l &lt;= tl &amp;&amp; tr &lt;= r) &#123;</span><br><span class="line">            tag[o] += v;</span><br><span class="line">            sum[o] += (tr - tl + <span class="number">1</span>) * v;</span><br><span class="line">            mx[o] += v;</span><br><span class="line">            mn[o] += v;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        down(o, tr - tl + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> mid = (tl + tr) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        upd(ls, tl, mid, l, r, v);</span><br><span class="line">        upd(rs, mid + <span class="number">1</span>, tr, l, r, v);</span><br><span class="line">        up(o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function">T <span class="title">qsum</span><span class="params">(<span class="keyword">int</span> o, <span class="keyword">int</span> tl, <span class="keyword">int</span> tr, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tr &lt; l || r &lt; tl)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (l &lt;= tl &amp;&amp; tr &lt;= r)<span class="keyword">return</span> sum[o];</span><br><span class="line">        down(o, tr - tl + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> mid = (tl + tr) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> qsum(ls, tl, mid, l, r) + qsum(rs, mid + <span class="number">1</span>, tr, l, r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">qmax</span><span class="params">(<span class="keyword">int</span> o, <span class="keyword">int</span> tl, <span class="keyword">int</span> tr, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tr &lt; l || r &lt; tl)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (l &lt;= tl &amp;&amp; tr &lt;= r)<span class="keyword">return</span> mx[o];</span><br><span class="line">        down(o, tr - tl + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> mid = (tl + tr) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> max(qmax(ls, tl, mid, l, r), qmax(rs, mid + <span class="number">1</span>, tr, l, r));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">qmin</span><span class="params">(<span class="keyword">int</span> o, <span class="keyword">int</span> tl, <span class="keyword">int</span> tr, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tr &lt; l || r &lt; tl)<span class="keyword">return</span> inf;</span><br><span class="line">        <span class="keyword">if</span> (l &lt;= tl &amp;&amp; tr &lt;= r)<span class="keyword">return</span> mn[o];</span><br><span class="line">        down(o, tr - tl + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> mid = (tl + tr) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> min(qmin(ls, tl, mid, l, r), qmin(rs, mid + <span class="number">1</span>, tr, l, r));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> ls</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> rs</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Segment_Tree&lt;<span class="keyword">int</span>&gt; tr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[maxn], b[maxn], n, m, h;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>), <span class="built_in">cin</span>.tie(<span class="number">0</span>), <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; h;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i += <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; b[i];</span><br><span class="line">        tr.upd(<span class="number">1</span>, <span class="number">1</span>, m, i, i, -i);</span><br><span class="line">    &#125;</span><br><span class="line">    sort(b + <span class="number">1</span>, b + m + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i += <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i += <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> p = lower_bound(b + <span class="number">1</span>, b + m + <span class="number">1</span>, h - a[i]) - b;</span><br><span class="line">        <span class="keyword">if</span>(p &gt;= <span class="number">1</span> &amp;&amp; p &lt;= m) tr.upd(<span class="number">1</span>, <span class="number">1</span>, m, p, m, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = m + <span class="number">1</span>; i &lt;= n + <span class="number">1</span>; i += <span class="number">1</span>)&#123;</span><br><span class="line">        res += tr.qmin(<span class="number">1</span>, <span class="number">1</span>, m, <span class="number">1</span>, m) &gt;= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(i == n + <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">int</span> p = lower_bound(b + <span class="number">1</span>, b + m + <span class="number">1</span>, h - a[i - m]) - b;</span><br><span class="line">        <span class="keyword">if</span>(p &gt;= <span class="number">1</span> &amp;&amp; p &lt;= m) tr.upd(<span class="number">1</span>, <span class="number">1</span>, m, p, m, <span class="number">-1</span>);</span><br><span class="line">        p = lower_bound(b + <span class="number">1</span>, b + m + <span class="number">1</span>, h - a[i]) - b;</span><br><span class="line">        <span class="keyword">if</span>(p &gt;= <span class="number">1</span> &amp;&amp; p &lt;= m) tr.upd(<span class="number">1</span>, <span class="number">1</span>, m, p, m, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><h2 id="cf-1373-G-Pawns"><a href="#cf-1373-G-Pawns" class="headerlink" title="cf 1373 G Pawns"></a><a href="https://codeforces.com/contest/1373/problem/G" target="_blank" rel="noopener">cf 1373 G Pawns</a></h2><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>给<script type="math/tex">n</script>行<script type="math/tex">n</script>列的棋盘，每次给某个位置增加或删除一个棋子，每个棋子只能往<script type="math/tex">(x, y + 1), (x - 1, y + 1), (x + 1, y + 1)</script>移动，第<script type="math/tex">k</script>列是特殊列，要求把所有棋子都移动到第<script type="math/tex">k</script>列并且每个位置最多放一个棋子，问最少需要增加多少行。</p><h3 id="解法-1"><a href="#解法-1" class="headerlink" title="解法"></a>解法</h3><p>一个棋子能到的行的范围是<script type="math/tex">[y + abs(x - k), \infty]</script>，发现能覆盖的是一段后缀。但因为这题我们要求的是棋子匹配完，所以我们选择棋子的集合为二分图的<script type="math/tex">X</script>部分。我们发现一个子集<script type="math/tex">W \in X</script>能到达的集合<script type="math/tex">N(W)</script>只与子集中具有最小<script type="math/tex">t</script>的元素有关，所以维护的区间一定是<script type="math/tex">X</script>的一段后缀。设最后答案为<script type="math/tex">res</script>，对于任意一个后缀区间<script type="math/tex">i</script>需要满足<script type="math/tex">res - i + 1 \geq cnt_i</script>，即<script type="math/tex">res \geq cnt_i + i - 1</script>，于是动态维护最大的<script type="math/tex">t</script>，取<script type="math/tex">[1, t]</script>中<script type="math/tex">cnt_i + i - 1</script>最大值<script type="math/tex">- n</script>即使最少需要添加的行数。<br><div><div class="fold_hider"><div class="close hider_title">代码</div></div><div class="fold"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">5e5</span> + <span class="number">233</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">Segment_Tree</span> &#123;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ls o &lt;&lt; 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rs o &lt;&lt; 1 | 1</span></span><br><span class="line">    T sum[maxn &lt;&lt; <span class="number">2</span>], tag[maxn &lt;&lt; <span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> mx[maxn &lt;&lt; <span class="number">2</span>], mn[maxn &lt;&lt; <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">up</span><span class="params">(<span class="keyword">int</span> o)</span> </span>&#123;</span><br><span class="line">        sum[o] = sum[ls] + sum[rs];</span><br><span class="line">        mn[o] = min(mn[ls], mn[rs]);</span><br><span class="line">        mx[o] = max(mx[ls], mx[rs]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">down</span><span class="params">(<span class="keyword">int</span> o, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tag[o]) &#123;</span><br><span class="line">            tag[ls] += tag[o];</span><br><span class="line">            tag[rs] += tag[o];</span><br><span class="line">            sum[ls] += tag[o] * (m - (m &gt;&gt; <span class="number">1</span>));</span><br><span class="line">            sum[rs] += tag[o] * (m &gt;&gt; <span class="number">1</span>);</span><br><span class="line">            mx[ls] += tag[o];</span><br><span class="line">            mx[rs] += tag[o];</span><br><span class="line">            mn[ls] += tag[o];</span><br><span class="line">            mn[rs] += tag[o];</span><br><span class="line">            tag[o] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> o, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        tag[o] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(l == r) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        build(ls, l, mid);</span><br><span class="line">        build(rs, mid + <span class="number">1</span>, r);</span><br><span class="line">        up(o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">upd</span><span class="params">(<span class="keyword">int</span> o, <span class="keyword">int</span> tl, <span class="keyword">int</span> tr, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tr &lt; l || r &lt; tl)<span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (l &lt;= tl &amp;&amp; tr &lt;= r) &#123;</span><br><span class="line">            tag[o] += v;</span><br><span class="line">            sum[o] += (tr - tl + <span class="number">1</span>) * v;</span><br><span class="line">            mx[o] += v;</span><br><span class="line">            mn[o] += v;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        down(o, tr - tl + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> mid = (tl + tr) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        upd(ls, tl, mid, l, r, v);</span><br><span class="line">        upd(rs, mid + <span class="number">1</span>, tr, l, r, v);</span><br><span class="line">        up(o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function">T <span class="title">qsum</span><span class="params">(<span class="keyword">int</span> o, <span class="keyword">int</span> tl, <span class="keyword">int</span> tr, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tr &lt; l || r &lt; tl)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (l &lt;= tl &amp;&amp; tr &lt;= r)<span class="keyword">return</span> sum[o];</span><br><span class="line">        down(o, tr - tl + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> mid = (tl + tr) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> qsum(ls, tl, mid, l, r) + qsum(rs, mid + <span class="number">1</span>, tr, l, r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">qmax</span><span class="params">(<span class="keyword">int</span> o, <span class="keyword">int</span> tl, <span class="keyword">int</span> tr, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tr &lt; l || r &lt; tl)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (l &lt;= tl &amp;&amp; tr &lt;= r)<span class="keyword">return</span> mx[o];</span><br><span class="line">        down(o, tr - tl + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> mid = (tl + tr) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> max(qmax(ls, tl, mid, l, r), qmax(rs, mid + <span class="number">1</span>, tr, l, r));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">qmin</span><span class="params">(<span class="keyword">int</span> o, <span class="keyword">int</span> tl, <span class="keyword">int</span> tr, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tr &lt; l || r &lt; tl)<span class="keyword">return</span> inf;</span><br><span class="line">        <span class="keyword">if</span> (l &lt;= tl &amp;&amp; tr &lt;= r)<span class="keyword">return</span> mn[o];</span><br><span class="line">        down(o, tr - tl + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> mid = (tl + tr) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> min(qmin(ls, tl, mid, l, r), qmin(rs, mid + <span class="number">1</span>, tr, l, r));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> ls</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> rs</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Segment_Tree&lt;<span class="keyword">int</span>&gt; tr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, k;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>), <span class="built_in">cin</span>.tie(<span class="number">0</span>), <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= maxn; i += <span class="number">1</span>)&#123;</span><br><span class="line">        tr.upd(<span class="number">1</span>, <span class="number">1</span>, maxn, i, i, i - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">multiset</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">    <span class="built_in">set</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; chess;</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="keyword">int</span> x, y;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        <span class="keyword">int</span> t = y + <span class="built_in">abs</span>(x - k);</span><br><span class="line">        <span class="keyword">if</span>(chess.find(make_pair(x, y)) != chess.end())&#123;</span><br><span class="line">            chess.erase(make_pair(x, y));</span><br><span class="line">            s.erase(s.find(t));</span><br><span class="line">            tr.upd(<span class="number">1</span>, <span class="number">1</span>, maxn, <span class="number">1</span>, t, <span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            chess.insert(make_pair(x, y));</span><br><span class="line">            s.insert(t);</span><br><span class="line">            tr.upd(<span class="number">1</span>, <span class="number">1</span>, maxn, <span class="number">1</span>, t, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(s.empty())&#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="number">0</span> &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> pos = *(--s.end());</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; max(<span class="number">0</span>, tr.qmax(<span class="number">1</span>, <span class="number">1</span>, maxn, <span class="number">1</span>, pos) - n) &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></p><h2 id="ACM-ICPC-2017-Asia-Xi-An"><a href="#ACM-ICPC-2017-Asia-Xi-An" class="headerlink" title="ACM-ICPC 2017 Asia Xi An"></a><a href="https://nanti.jisuanke.com/t/A1617" target="_blank" rel="noopener">ACM-ICPC 2017 Asia Xi An</a></h2><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><p>给定长度为<script type="math/tex">n, m</script>的<script type="math/tex">A, B</script>数组，给定<script type="math/tex">k</script>，每次询问一个<script type="math/tex">[L, R]</script>，问<script type="math/tex">B</script>中<script type="math/tex">[L, R]</script>子区间能否与<script type="math/tex">A</script>进行完美匹配(匹配条件是<script type="math/tex">A_i + B_j \geq k</script>)</p><h3 id="解法-2"><a href="#解法-2" class="headerlink" title="解法"></a>解法</h3><p>与第一题如出一辙，只需要用双指针预处理出每个<script type="math/tex">l</script>对应的最小的可行的<script type="math/tex">r</script>即可。</p><div><div class="fold_hider"><div class="close hider_title">代码</div></div><div class="fold"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">5e5</span> + <span class="number">233</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">Segment_Tree</span> &#123;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ls o &lt;&lt; 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rs o &lt;&lt; 1 | 1</span></span><br><span class="line">    T sum[maxn &lt;&lt; <span class="number">2</span>], tag[maxn &lt;&lt; <span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> mx[maxn &lt;&lt; <span class="number">2</span>], mn[maxn &lt;&lt; <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">up</span><span class="params">(<span class="keyword">int</span> o)</span> </span>&#123;</span><br><span class="line">        sum[o] = sum[ls] + sum[rs];</span><br><span class="line">        mn[o] = min(mn[ls], mn[rs]);</span><br><span class="line">        mx[o] = max(mx[ls], mx[rs]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">down</span><span class="params">(<span class="keyword">int</span> o, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tag[o]) &#123;</span><br><span class="line">            tag[ls] += tag[o];</span><br><span class="line">            tag[rs] += tag[o];</span><br><span class="line">            sum[ls] += tag[o] * (m - (m &gt;&gt; <span class="number">1</span>));</span><br><span class="line">            sum[rs] += tag[o] * (m &gt;&gt; <span class="number">1</span>);</span><br><span class="line">            mx[ls] += tag[o];</span><br><span class="line">            mx[rs] += tag[o];</span><br><span class="line">            mn[ls] += tag[o];</span><br><span class="line">            mn[rs] += tag[o];</span><br><span class="line">            tag[o] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> o, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        tag[o] = sum[o] = mx[o] = mn[o] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(l == r) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        build(ls, l, mid);</span><br><span class="line">        build(rs, mid + <span class="number">1</span>, r);</span><br><span class="line">        up(o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">upd</span><span class="params">(<span class="keyword">int</span> o, <span class="keyword">int</span> tl, <span class="keyword">int</span> tr, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tr &lt; l || r &lt; tl)<span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (l &lt;= tl &amp;&amp; tr &lt;= r) &#123;</span><br><span class="line">            tag[o] += v;</span><br><span class="line">            sum[o] += (tr - tl + <span class="number">1</span>) * v;</span><br><span class="line">            mx[o] += v;</span><br><span class="line">            mn[o] += v;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        down(o, tr - tl + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> mid = (tl + tr) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        upd(ls, tl, mid, l, r, v);</span><br><span class="line">        upd(rs, mid + <span class="number">1</span>, tr, l, r, v);</span><br><span class="line">        up(o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function">T <span class="title">qsum</span><span class="params">(<span class="keyword">int</span> o, <span class="keyword">int</span> tl, <span class="keyword">int</span> tr, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tr &lt; l || r &lt; tl)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (l &lt;= tl &amp;&amp; tr &lt;= r)<span class="keyword">return</span> sum[o];</span><br><span class="line">        down(o, tr - tl + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> mid = (tl + tr) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> qsum(ls, tl, mid, l, r) + qsum(rs, mid + <span class="number">1</span>, tr, l, r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">qmax</span><span class="params">(<span class="keyword">int</span> o, <span class="keyword">int</span> tl, <span class="keyword">int</span> tr, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tr &lt; l || r &lt; tl)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (l &lt;= tl &amp;&amp; tr &lt;= r)<span class="keyword">return</span> mx[o];</span><br><span class="line">        down(o, tr - tl + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> mid = (tl + tr) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> max(qmax(ls, tl, mid, l, r), qmax(rs, mid + <span class="number">1</span>, tr, l, r));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">qmin</span><span class="params">(<span class="keyword">int</span> o, <span class="keyword">int</span> tl, <span class="keyword">int</span> tr, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tr &lt; l || r &lt; tl)<span class="keyword">return</span> inf;</span><br><span class="line">        <span class="keyword">if</span> (l &lt;= tl &amp;&amp; tr &lt;= r)<span class="keyword">return</span> mn[o];</span><br><span class="line">        down(o, tr - tl + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> mid = (tl + tr) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> min(qmin(ls, tl, mid, l, r), qmin(rs, mid + <span class="number">1</span>, tr, l, r));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> ls</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> rs</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Segment_Tree&lt;<span class="keyword">int</span>&gt; tr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, k, q, T;</span><br><span class="line"><span class="keyword">int</span> a[maxn], b[maxn];</span><br><span class="line"><span class="keyword">int</span> res[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>), <span class="built_in">cin</span>.tie(<span class="number">0</span>), <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line">        tr.build(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i += <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">            tr.upd(<span class="number">1</span>, <span class="number">1</span>, n, i, i, -i);</span><br><span class="line">        &#125;</span><br><span class="line">        sort(a + <span class="number">1</span>, a + n + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i += <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; b[i];</span><br><span class="line">            b[i] = lower_bound(a + <span class="number">1</span>, a + n + <span class="number">1</span>, k - b[i]) - a;</span><br><span class="line">            <span class="comment">//cout &lt;&lt; b[i] &lt;&lt; " \n"[i == m];</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> r = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> l = <span class="number">1</span>; l &lt;= m; l += <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(r + <span class="number">1</span> &lt;= m &amp;&amp; tr.qmin(<span class="number">1</span>, <span class="number">1</span>, n, <span class="number">1</span>, n) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                r += <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(b[r] &gt;= <span class="number">1</span> &amp;&amp; b[r] &lt;= n) tr.upd(<span class="number">1</span>, <span class="number">1</span>, n, b[r], n, <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(tr.qmin(<span class="number">1</span>, <span class="number">1</span>, n, <span class="number">1</span>, n) &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">                res[l] = r;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> res[l] = m + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(b[l] &gt;= <span class="number">1</span> &amp;&amp; b[l] &lt;= n) tr.upd(<span class="number">1</span>, <span class="number">1</span>, n, b[l], n, <span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; q;</span><br><span class="line">        <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">            <span class="keyword">int</span> l, r;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; l &gt;&gt; r;</span><br><span class="line">            <span class="keyword">if</span>(r &gt;= res[l]) <span class="built_in">cout</span> &lt;&lt; <span class="string">"1"</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">"0"</span>;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Hall定理内容&quot;&gt;&lt;a href=&quot;#Hall定理内容&quot; class=&quot;headerlink&quot; title=&quot;Hall定理内容&quot;&gt;&lt;/a&gt;Hall定理内容&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;假设二分图两部分点集分别为&lt;script type=&quot;math/tex&quot;&gt;X, Y&lt;/script&gt;(|X| &amp;lt; |Y|)，二分图存在完美匹配(匹配数为|X|)的充要条件是：对于&lt;script type=&quot;math/tex&quot;&gt;X&lt;/script&gt;中任意大小为&lt;script type=&quot;math/tex&quot;&gt;k&lt;/script&gt;的集合&lt;script type=&quot;math/tex&quot;&gt;W&lt;/script&gt;，&lt;script type=&quot;math/tex&quot;&gt;Y&lt;/script&gt;中与其相邻的点集记为&lt;script type=&quot;math/tex&quot;&gt;N(W)&lt;/script&gt;，有&lt;script type=&quot;math/tex&quot;&gt;|W| \leq N(W)&lt;/script&gt;&lt;/li&gt;
&lt;li&gt;二分图的最大匹配数等于&lt;script type=&quot;math/tex&quot;&gt;|X| - \underset{W \in X}{min} ({|N(W)| - |W|})&lt;/script&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;script type=&quot;math/tex&quot;&gt;Hall&lt;/script&gt;定理因为作用于任意子集取&lt;script type=&quot;math/tex&quot;&gt;min&lt;/script&gt;，但题目往往具有某些特殊性质，使得取&lt;script type=&quot;math/tex&quot;&gt;min&lt;/script&gt;的集合&lt;script type=&quot;math/tex&quot;&gt;W&lt;/script&gt;或者&lt;script type=&quot;math/tex&quot;&gt;N(W)&lt;/script&gt;是一段连续的区间，然后利用线段树或者其它方法配合解决问题&lt;/p&gt;
    
    </summary>
    
      <category term="Hall定理" scheme="http://yoursite.com/categories/Hall%E5%AE%9A%E7%90%86/"/>
    
    
  </entry>
  
  <entry>
    <title>莫队总结</title>
    <link href="http://yoursite.com/2020/12/07/%E8%8E%AB%E9%98%9F%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2020/12/07/莫队总结/</id>
    <published>2020-12-07T14:59:26.000Z</published>
    <updated>2021-01-31T09:55:08.952Z</updated>
    
    <content type="html"><![CDATA[<p>写一篇总结，以后一劳永逸了。<br><a id="more"></a></p><h1 id="莫队"><a href="#莫队" class="headerlink" title="莫队"></a>莫队</h1><p>普通莫队只有一个说的点，<strong>一定要注意先删后加对答案是否有影响</strong>，没影响的情况下指针移动顺序是可以任意的，如果有影响的情况必须讨论移动顺序，具体来说左右指针都在左边就必须先移动右指针，左右指针都在右边就必须先移动左指针，不过一般不会存在这个问题，反正做的时候注意一下就好了。</p><p><string>&gt;以前傻逼了，先把所有add操作做了再做del操作就不会有这个问题了&lt;/strong&gt;</string></p><h1 id="带修改的莫队"><a href="#带修改的莫队" class="headerlink" title="带修改的莫队"></a>带修改的莫队</h1><p>新增一维时间<script type="math/tex">T</script>，然后用三个指针移动，块大小设为<script type="math/tex">n^{\frac{2}{3}}</script>时复杂度最优，为<script type="math/tex">n^{\frac{5}{3}}</script><br>移动时间指针时，首先判断修改点是否在<script type="math/tex">[l, r]</script>范围内，在的话得重新统计贡献。然后直接<script type="math/tex">swap</script>要修改的值和原来的值，因为以后回去还要改回去，所以直接<script type="math/tex">swap</script>一下就好了。<br>给个例题，不多bb，遇到直接抄<br><a href="https://www.luogu.com.cn/problem/P1903" target="_blank" rel="noopener">P1903 [国家集训队]数颜色 / 维护队列</a><br><div><div class="fold_hider"><div class="close hider_title">代码</div></div><div class="fold"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e6</span> + <span class="number">233</span>;</span><br><span class="line"><span class="keyword">int</span> cnt[maxn], a[maxn];</span><br><span class="line"><span class="keyword">int</span> bel[maxn];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r, t, id;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> node &amp;p) <span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bel[l] ^ bel[p.l] ? bel[l] &lt; bel[p.l] : (bel[r] ^ bel[p.r] ? bel[r] &lt; bel[p.r] : (t &lt; p.t));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;q[maxn];</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line">pii c[maxn];</span><br><span class="line"><span class="keyword">int</span> block;</span><br><span class="line"><span class="keyword">int</span> ans;</span><br><span class="line"><span class="keyword">int</span> res[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    ans += !cnt[a[x]]++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    ans -= !--cnt[a[x]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>), <span class="built_in">cin</span>.tie(<span class="number">0</span>), <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; fixed &lt;&lt; setprecision(<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    block = <span class="built_in">pow</span>(n, <span class="number">2.0</span> / <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">        bel[i] = i / block + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> qcnt = <span class="number">0</span>, rcnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="built_in">string</span> s;</span><br><span class="line">        <span class="keyword">int</span> x, y;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; s &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        <span class="keyword">if</span>(s[<span class="number">0</span>] == <span class="string">'Q'</span>)&#123;</span><br><span class="line">            q[++qcnt] = node&#123;x, y, rcnt, qcnt&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            c[++rcnt] = pii(x, y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(q + <span class="number">1</span>, q + qcnt + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">1</span>, r = <span class="number">0</span>, t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(t &lt; q[i].t)&#123;</span><br><span class="line">            ++t;</span><br><span class="line">            <span class="keyword">if</span>(c[t].first &gt;= l &amp;&amp; c[t].first &lt;= r)&#123;</span><br><span class="line">                del(c[t].first);</span><br><span class="line">            &#125;</span><br><span class="line">            swap(a[c[t].first], c[t].second);</span><br><span class="line">            <span class="keyword">if</span>(c[t].first &gt;= l &amp;&amp; c[t].first &lt;= r)&#123;</span><br><span class="line">                add(c[t].first);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(t &gt; q[i].t)&#123;</span><br><span class="line">            <span class="keyword">if</span>(c[t].first &gt;= l &amp;&amp; c[t].first &lt;= r)&#123;</span><br><span class="line">                del(c[t].first);</span><br><span class="line">            &#125;</span><br><span class="line">            swap(a[c[t].first], c[t].second);</span><br><span class="line">            <span class="keyword">if</span>(c[t].first &gt;= l &amp;&amp; c[t].first &lt;= r)&#123;</span><br><span class="line">                add(c[t].first);</span><br><span class="line">            &#125;</span><br><span class="line">            --t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(l &gt; q[i].l) add(--l);</span><br><span class="line">        <span class="keyword">while</span>(r &lt; q[i].r) add(++r);</span><br><span class="line">        <span class="keyword">while</span>(l &lt; q[i].l) del(l++);</span><br><span class="line">        <span class="keyword">while</span>(r &gt; q[i].r) del(r--);</span><br><span class="line">       </span><br><span class="line">        res[q[i].id] = ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= qcnt; ++i) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; res[i] &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></p><h1 id="树上莫队"><a href="#树上莫队" class="headerlink" title="树上莫队"></a>树上莫队</h1><p>树上莫队利用了欧拉序，欧拉序有很多种，这里用的是进去加一次出来加一次那种，然后对于两点路径<script type="math/tex">(u, v)(in[u] < in[y])</script>可以做如下讨论：</p><ul><li><script type="math/tex">lca(u, v) = u</script>，则统计<script type="math/tex">in[u] \rightarrow in[v]</script>之间的路径</li><li><script type="math/tex">lca(u, v) != u</script>，则统计<script type="math/tex">out[u] \rightarrow in[v]</script>之间的路径，但<script type="math/tex">lca</script>不包含在内，<script type="math/tex">lca</script>需要单独计算。<br>至于为什么画个图就知道了，非<script type="math/tex">(u, v)</script>路径上的点要嘛不访问，要嘛访问两次，两次就可以抵消掉。</li></ul><p>几个比较容易错的点</p><ul><li>欧拉序对应的是树上的点，而不是点的值，因为点的值可能是重复出现的。</li><li>遇到一个点不再是对应的add或者del操作，而是如果访问过则是del，没访问过则是add<br>一定要注意这两个细节问题！</li></ul><p><a href="https://www.luogu.com.cn/problem/SP10707" target="_blank" rel="noopener">SP10707 COT2 - Count on a tree II</a><br><div><div class="fold_hider"><div class="close hider_title">代码</div></div><div class="fold"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">4e5</span> + <span class="number">233</span>;</span><br><span class="line"><span class="keyword">int</span> cnt[maxn], a[maxn];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; G[maxn];</span><br><span class="line"><span class="keyword">int</span> dfs_clock, bel[maxn];</span><br><span class="line"><span class="keyword">int</span> in[maxn], out[maxn], f[maxn][<span class="number">20</span>];</span><br><span class="line"><span class="keyword">int</span> d[maxn];</span><br><span class="line"><span class="keyword">int</span> b[maxn];</span><br><span class="line"><span class="keyword">int</span> vis[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">    f[u][<span class="number">0</span>] = fa;</span><br><span class="line">    d[u] = d[fa] + <span class="number">1</span>;</span><br><span class="line">    in[u] = ++dfs_clock;</span><br><span class="line">    b[dfs_clock] = u; <span class="comment">//注意这里一定是记录点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">20</span>; i++) f[u][i] = f[f[u][i - <span class="number">1</span>]][i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> v : G[u])&#123;</span><br><span class="line">        <span class="keyword">if</span>(v == fa) <span class="keyword">continue</span>;</span><br><span class="line">        dfs(v, u);</span><br><span class="line">    &#125;</span><br><span class="line">    out[u] = ++dfs_clock;</span><br><span class="line">    b[dfs_clock] = u;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lca</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(d[x] &lt; d[y]) swap(x, y);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">19</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(d[f[x][i]] &gt;= d[y]) x = f[x][i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(x == y) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">19</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(f[x][i] != f[y][i]) x = f[x][i], y = f[y][i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f[x][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r, lca, id;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> node &amp;t) <span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bel[l] ^ bel[t.l] ? bel[l] &lt; bel[t.l] : (bel[l] &amp; <span class="number">1</span> ? r &lt; t.r : r &gt; t.r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;q[maxn];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ans;</span><br><span class="line"><span class="keyword">int</span> res[maxn];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    ans += !cnt[a[x]]++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    ans -= !--cnt[a[x]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">upd</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(vis[x]) del(x);</span><br><span class="line">    <span class="keyword">else</span> add(x);</span><br><span class="line">    vis[x] ^= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>), <span class="built_in">cin</span>.tie(<span class="number">0</span>), <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; fixed &lt;&lt; setprecision(<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pos;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">        pos.emplace_back(a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    sort(pos.begin(), pos.end());</span><br><span class="line">    pos.erase(unique(pos.begin(), pos.end()), pos.end());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        a[i] = lower_bound(pos.begin(), pos.end(), a[i]) - pos.begin() + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> u, v;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v;</span><br><span class="line">        G[u].emplace_back(v);</span><br><span class="line">        G[v].emplace_back(u);</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> block = <span class="built_in">sqrt</span>(dfs_clock);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= dfs_clock; ++i) &#123;</span><br><span class="line">        bel[i] = i / block + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> u, v;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v;</span><br><span class="line">        <span class="keyword">if</span>(in[u] &gt; in[v]) swap(u, v);</span><br><span class="line">        <span class="keyword">int</span> lc = lca(u, v);</span><br><span class="line">        <span class="keyword">if</span>(lc == u) &#123;</span><br><span class="line">            q[i].l = in[u];</span><br><span class="line">            q[i].r = in[v];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            q[i].l = out[u];</span><br><span class="line">            q[i].r = in[v];</span><br><span class="line">            q[i].lca = lc;</span><br><span class="line">        &#125;</span><br><span class="line">        q[i].id = i;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(q + <span class="number">1</span>, q + m + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">1</span>, r = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; q[i].l) upd(b[l++]);</span><br><span class="line">        <span class="keyword">while</span>(l &gt; q[i].l) upd(b[--l]);</span><br><span class="line">        <span class="keyword">while</span>(r &lt; q[i].r) upd(b[++r]);</span><br><span class="line">        <span class="keyword">while</span>(r &gt; q[i].r) upd(b[r--]);</span><br><span class="line">        res[q[i].id] = ans + (q[i].lca ? !cnt[a[q[i].lca]] : <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; res[i] &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></p><h1 id="回滚莫队"><a href="#回滚莫队" class="headerlink" title="回滚莫队"></a>回滚莫队</h1><p>当遇到一些只方便单向进行的操作，如取<script type="math/tex">max, mex</script>，这些操作都不好撤销，我们可以考虑采用回滚莫队。<br>回滚莫队对于左端点在一个块内的询问按右端点排序后一起处理。假设操作时增加操作，如果询问左右点在一个块内，我们直接暴力。否则我们每次把左指针固定在当前块的右端点，然后单调移动右指针。对于左边多出来的部分我们直接暴力求答案，并用一个临时变量记录答案，可知道单次复杂度不超过块大小。操作完后我们直接回滚直接的更新操作即可，这样还是保证了<script type="math/tex">n\sqrt(n)</script>的复杂度。</p><p>如果是删除，那么每次到一个新的块，右端点直接设在最右边，左端点设在块的左端点，然后右端点单调删，左端点暴力删，删完求答案回滚即可。</p><p>给个例题：</p><p><a href="https://atcoder.jp/contests/joisc2014/tasks/joisc2014_c" target="_blank" rel="noopener">历史研究</a><br><div><div class="fold_hider"><div class="close hider_title">代码</div></div><div class="fold"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e5</span> + <span class="number">233</span>;</span><br><span class="line"><span class="keyword">int</span> bel[maxn];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r, id;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> node &amp;t) <span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bel[l] ^ bel[t.l] ? bel[l] &lt; bel[t.l] : r &lt; t.r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;q[maxn];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[maxn], b[maxn];</span><br><span class="line"><span class="keyword">int</span> cnt[maxn], tmp[maxn];</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll res[maxn];</span><br><span class="line"><span class="keyword">int</span> pl[maxn], pr[maxn];</span><br><span class="line">ll ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    cnt[b[x]]++;</span><br><span class="line">    ans = max(ans, <span class="number">1l</span>l * cnt[b[x]] * a[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>), <span class="built_in">cin</span>.tie(<span class="number">0</span>), <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; fixed &lt;&lt; setprecision(<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">        vec.emplace_back(a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    sort(vec.begin(), vec.end());</span><br><span class="line">    vec.erase(unique(vec.begin(), vec.end()), vec.end());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        b[i] = lower_bound(vec.begin(), vec.end(), a[i]) - vec.begin() + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> block = <span class="built_in">sqrt</span>(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        bel[i] = i / block + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n; i; i--) pl[bel[i]] = i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) pr[bel[i]] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; q[i].l &gt;&gt; q[i].r;</span><br><span class="line">        q[i].id = i;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(q + <span class="number">1</span>, q + m + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">1</span>, r = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> cur_block = <span class="number">0</span>;</span><br><span class="line">    ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">        <span class="comment">//块相同直接暴力</span></span><br><span class="line">        <span class="keyword">if</span>(bel[q[i].l] == bel[q[i].r])&#123;</span><br><span class="line">            ll t = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = q[i].l; j &lt;= q[i].r; j++)&#123;</span><br><span class="line">                tmp[b[j]]++;</span><br><span class="line">                t = max(t, <span class="number">1l</span>l * tmp[b[j]] * a[j]);</span><br><span class="line">            &#125;</span><br><span class="line">            res[q[i].id] = t;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = q[i].l; j &lt;= q[i].r; j++)&#123;</span><br><span class="line">                tmp[b[j]]--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//来到一个新块，重设左右指针，清空答案。</span></span><br><span class="line">        <span class="keyword">if</span>(bel[q[i].l] != cur_block)&#123;</span><br><span class="line">            ans = <span class="number">0</span>;</span><br><span class="line">            l = pr[bel[q[i].l]] + <span class="number">1</span>;</span><br><span class="line">            r = l - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= vec.size(); j++) cnt[j] = <span class="number">0</span>;</span><br><span class="line">            cur_block = bel[q[i].l];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//单调更新右端点</span></span><br><span class="line">        <span class="keyword">while</span>(r &lt; q[i].r) add(++r);</span><br><span class="line">        ll now = ans;</span><br><span class="line">        <span class="comment">//左端点暴力求答案</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = l - <span class="number">1</span>; j &gt;= q[i].l; j--)&#123;</span><br><span class="line">            cnt[b[j]]++;</span><br><span class="line">            now = max(now, <span class="number">1l</span>l * cnt[b[j]] * a[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//回滚</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = l - <span class="number">1</span>; j &gt;= q[i].l; j--)&#123;</span><br><span class="line">            cnt[b[j]]--;</span><br><span class="line">        &#125;</span><br><span class="line">        res[q[i].id] = now;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; res[i] &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;写一篇总结，以后一劳永逸了。&lt;br&gt;
    
    </summary>
    
      <category term="莫队" scheme="http://yoursite.com/categories/%E8%8E%AB%E9%98%9F/"/>
    
    
  </entry>
  
  <entry>
    <title>决策单调进阶</title>
    <link href="http://yoursite.com/2020/11/25/%E5%86%B3%E7%AD%96%E5%8D%95%E8%B0%83%E8%BF%9B%E9%98%B6/"/>
    <id>http://yoursite.com/2020/11/25/决策单调进阶/</id>
    <published>2020-11-25T11:43:10.000Z</published>
    <updated>2020-12-04T10:45:33.420Z</updated>
    
    <content type="html"><![CDATA[<h1 id="斜率优化"><a href="#斜率优化" class="headerlink" title="斜率优化"></a>斜率优化</h1><p>最简单的用单调队列的就不说了，说几个难的</p><a id="more"></a><ul><li>斜率不单调：斜率不单调的时候，我们就得在维护的凸壳上二分，找到最优的策略</li><li>x不单调：x不单调意味着加入的时候不是按顺序加的，一般用平衡树/cdq维护</li></ul><h2 id="x不单调"><a href="#x不单调" class="headerlink" title="x不单调"></a>x不单调</h2><p>考虑平衡树维护，按照一下策略进行更新：</p><ul><li>平衡树上找到该点的前驱和后继</li><li>判断这个点和前驱、后继构成的图形是不是凸的（叉积判断），如果不是就退出</li><li>否则从前驱开始，一直找前两个点，判断这三个点是否是凸的，如果不是则删掉前驱，一直到是凸的为止（或者为空）</li><li>后继同理</li><li>插入该点</li></ul><p>一般来说写起来会比较麻烦一点，如果用set后续二分的时候只能对x进行二分，从而找到对应点的斜率。</p><p>如果用<script type="math/tex">cdq</script>会好写很多，但是有些题目会有所限制用cdq就不是那么方便。<br>一般<script type="math/tex">cdq</script>按照如下策略：</p><ul><li>处理左区间</li><li>左区间按x排序，右区间按斜率排序</li><li>左区间用单调队列构建凸包，右区间单调询问答案更新</li><li>处理右区间</li></ul><p><a href="https://codeforces.com/contest/932/problem/F" target="_blank" rel="noopener">cf-932F</a><br>考虑列出<script type="math/tex">dp</script>方程：<script type="math/tex">dp[u] = dp[v] + a_ub_v(v在u子树内)</script><br>发现是一个类似凸包的玩意，并且可以通过启发式合并进行合并。<br>但是发现横坐标和斜率都不单调，得用平衡树进行维护。</p><div><div class="fold_hider"><div class="close hider_title">代码</div></div><div class="fold"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> __int128 i128;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> db;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vi;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;ll&gt; vl;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;pii&gt; vp;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">const</span> ll INF = <span class="number">1e18</span>;</span><br><span class="line"><span class="keyword">const</span> db eps = <span class="number">1e-10</span>;</span><br><span class="line"><span class="keyword">const</span> db pi = <span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> eb emplace_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ep emplace</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mem(a) memset(a, 0, sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> copy(a, b) memcpy(a, b, sizeof(b))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PA cout &lt;&lt; <span class="meta-string">"pass\n"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lowbit(x) (x &amp; -x)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(x) x.begin(), x.end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TM cout &lt;&lt; db(clock()) / CLOCKS_PER_SEC &lt;&lt; <span class="meta-string">'\n'</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function">mt19937 <span class="title">mrand</span><span class="params">(chrono::high_resolution_clock::now().time_since_epoch().count())</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;<span class="title">inline</span> <span class="title">void</span> <span class="title">upmin</span>(<span class="title">T</span> &amp;<span class="title">x</span>, <span class="title">T</span> <span class="title">y</span>) &#123;</span>x = x &gt; y ? y : x;&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;<span class="title">inline</span> <span class="title">void</span> <span class="title">upmax</span>(<span class="title">T</span> &amp;<span class="title">x</span>, <span class="title">T</span> <span class="title">y</span>) &#123;</span>x = x &lt; y ? y : x;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Convex</span>&#123;</span></span><br><span class="line">    ll x, y;</span><br><span class="line">    Convex(ll xx = <span class="number">0</span>, ll yy = <span class="number">0</span>)&#123;</span><br><span class="line">        x = xx;</span><br><span class="line">        y = yy;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> Convex &amp;r) <span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x &lt; r.x || (x == r.x) &amp;&amp; y &lt; r.y;</span><br><span class="line">    &#125;</span><br><span class="line">    Convex <span class="keyword">operator</span> +(<span class="keyword">const</span> Convex &amp;r) <span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Convex(x + r.x, y + r.y);</span><br><span class="line">    &#125;</span><br><span class="line">    Convex <span class="keyword">operator</span> -(<span class="keyword">const</span> Convex &amp;r) <span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Convex(x - r.x, y - r.y);</span><br><span class="line">    &#125;</span><br><span class="line">    i128 <span class="keyword">operator</span> ^(<span class="keyword">const</span> Convex &amp;r) <span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i128(x) * r.y - i128(y) * r.x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check_convex</span><span class="params">(Convex a, Convex b, Convex c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((a - b) ^ (c - b)) &lt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>), <span class="built_in">cin</span>.tie(<span class="number">0</span>), <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; fixed &lt;&lt; setprecision(<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    vi a(n + 1), b(n + 1), G[n + 1];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; b[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> u, v;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v;</span><br><span class="line">        G[u].emplace_back(v);</span><br><span class="line">        G[v].emplace_back(u);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">set</span>&lt;Convex&gt; s[n + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">vector</span>&lt;ll&gt; dp(n + <span class="number">1</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">auto</span> insert = [&amp;](<span class="built_in">set</span>&lt;Convex&gt; &amp;a, Convex b) &#123;</span><br><span class="line">        <span class="keyword">if</span>(a.find(b) != a.end()) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(a.size() &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            a.insert(b);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        a.insert(b);</span><br><span class="line">        <span class="keyword">auto</span> now = a.lower_bound(b);</span><br><span class="line">        <span class="keyword">auto</span> cp = prev(now);</span><br><span class="line">        <span class="keyword">auto</span> cn = next(now);</span><br><span class="line">        <span class="keyword">if</span>(now != a.begin() &amp;&amp; cn != a.end())&#123;</span><br><span class="line">            <span class="keyword">if</span>(!check_convex(*cp, *now, *cn)) &#123;</span><br><span class="line">                a.erase(now);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        a.erase(now);</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">auto</span> p = a.lower_bound(b);</span><br><span class="line">            <span class="keyword">if</span>(p == a.end()) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">auto</span> nx = next(p);</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">if</span>(nx == a.end()) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span>(!check_convex(b, *p, *nx)) a.erase(p);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">auto</span> p = a.lower_bound(b);</span><br><span class="line">            <span class="keyword">if</span>(p == a.begin()) <span class="keyword">break</span>;</span><br><span class="line">            p = prev(p);</span><br><span class="line">            <span class="keyword">if</span>(p == a.begin()) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">auto</span> pre = prev(p);</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">if</span> (!check_convex(*pre, *p, b)) a.erase(p);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        a.insert(b);</span><br><span class="line">    &#125;;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">auto</span> cal = [&amp;](<span class="built_in">set</span>&lt;Convex&gt; &amp;a, ll x)&#123;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">auto</span> p = a.begin();</span><br><span class="line">        <span class="keyword">auto</span> q = next(p);</span><br><span class="line">        Convex v = *q - *p;</span><br><span class="line">        <span class="keyword">if</span>(v.y &gt;= v.x * x) <span class="keyword">return</span> *p;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">-1e6</span>, r = <span class="number">1e6</span>, ans = <span class="number">-1e6</span>;</span><br><span class="line">        <span class="keyword">while</span>(r &gt;= l)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">auto</span> t = a.lower_bound(Convex(mid, -INF));</span><br><span class="line">            <span class="keyword">if</span>(t == a.end())&#123;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(t == a.begin())&#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">                ans = mid;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">auto</span> pt = prev(t);</span><br><span class="line">            Convex v = *t - *pt;</span><br><span class="line">            <span class="keyword">if</span>(v.y &lt;= v.x * x) l = mid + <span class="number">1</span>, ans = mid;</span><br><span class="line">            <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *a.lower_bound(Convex(ans, -INF));</span><br><span class="line">    &#125;;</span><br><span class="line"> </span><br><span class="line">    function&lt;<span class="keyword">void</span>(<span class="keyword">int</span>, <span class="keyword">int</span>) &gt; dfs = [&amp;](<span class="keyword">int</span> u, <span class="keyword">int</span> f)&#123;</span><br><span class="line">        dp[u] = INF;</span><br><span class="line">        <span class="keyword">if</span>(G[u].size() == <span class="number">1</span> &amp;&amp; u != <span class="number">1</span>) dp[u] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : G[u])&#123;</span><br><span class="line">            <span class="keyword">if</span>(v == f) <span class="keyword">continue</span>;</span><br><span class="line">            dfs(v, u);</span><br><span class="line">            <span class="keyword">if</span>(s[u].size() &gt; s[v].size())&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">auto</span> it : s[v]) insert(s[u], it);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">auto</span> it : s[u]) insert(s[v], it);</span><br><span class="line">                swap(s[u], s[v]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span>(s[u].size() &lt;= <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> it : s[u]) &#123;</span><br><span class="line">                dp[u] = min(dp[u], it.y + it.x * a[u]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">auto</span> it = cal(s[u], -a[u]);</span><br><span class="line">            dp[u] = it.y + it.x * a[u];</span><br><span class="line">        &#125;</span><br><span class="line">        insert(s[u], Convex(b[u], dp[u]));</span><br><span class="line">    &#125;;</span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; dp[i] &lt;&lt; <span class="string">" \n"</span>[i == n];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><p>回头补一个pbds的写法，看看会不会好写一些。<br>但这个题用<script type="math/tex">cdq</script>就没那么好做，因为转换成序列的话，一个点询问的不再是前缀，而是一段区间，就比较麻烦。</p><p><a href="https://www.luogu.com.cn/problem/P5785" target="_blank" rel="noopener">P5785 [SDOI2012]任务安排</a><br>来看这个题，就是序列上的斜率优化，斜率不单调，就可以用cdq写，就会非常好写。<br><div><div class="fold_hider"><div class="close hider_title">代码</div></div><div class="fold"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> __int128 i128;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> db;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vi;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;ll&gt; vl;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;pii&gt; vp;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">const</span> ll INF = <span class="number">1e18</span>;</span><br><span class="line"><span class="keyword">const</span> db eps = <span class="number">1e-10</span>;</span><br><span class="line"><span class="keyword">const</span> db pi = <span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> eb emplace_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ep emplace</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mem(a) memset(a, 0, sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> copy(a, b) memcpy(a, b, sizeof(b))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PA cout &lt;&lt; <span class="meta-string">"pass\n"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lowbit(x) (x &amp; -x)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(x) x.begin(), x.end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TM cout &lt;&lt; db(clock()) / CLOCKS_PER_SEC &lt;&lt; <span class="meta-string">'\n'</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">mt19937 <span class="title">mrand</span><span class="params">(chrono::high_resolution_clock::now().time_since_epoch().count())</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;<span class="title">inline</span> <span class="title">void</span> <span class="title">upmin</span>(<span class="title">T</span> &amp;<span class="title">x</span>, <span class="title">T</span> <span class="title">y</span>) &#123;</span>x = x &gt; y ? y : x;&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;<span class="title">inline</span> <span class="title">void</span> <span class="title">upmax</span>(<span class="title">T</span> &amp;<span class="title">x</span>, <span class="title">T</span> <span class="title">y</span>) &#123;</span>x = x &lt; y ? y : x;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, s;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>), <span class="built_in">cin</span>.tie(<span class="number">0</span>), <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; fixed &lt;&lt; setprecision(<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; s;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ord(n + <span class="number">1</span>), q(n + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">vector</span>&lt;ll&gt; dp(n + <span class="number">1</span>), c(n + <span class="number">1</span>), sum(n + <span class="number">1</span>), t(n + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; t[i] &gt;&gt; c[i];</span><br><span class="line">        sum[i] = sum[i - <span class="number">1</span>] + t[i];</span><br><span class="line">        c[i] += c[i - <span class="number">1</span>];</span><br><span class="line">        dp[i] = INF;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> cal = [&amp;](<span class="keyword">int</span> i, <span class="keyword">int</span> j)&#123;</span><br><span class="line">        dp[i] = min(dp[i], dp[j] + sum[i] * (c[i] - c[j]) + s * (c[n] - c[j]));</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> up = [&amp;](<span class="keyword">int</span> i, <span class="keyword">int</span> j)&#123;</span><br><span class="line">        <span class="keyword">return</span> (dp[i] - s * c[i]) - (dp[j] - s * c[j]);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> down = [&amp;](<span class="keyword">int</span> i, <span class="keyword">int</span> j)&#123;</span><br><span class="line">        <span class="keyword">return</span> c[i] - c[j];</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    function&lt;<span class="keyword">void</span>(<span class="keyword">int</span>, <span class="keyword">int</span>) &gt; cdq = [&amp;](<span class="keyword">int</span> l, <span class="keyword">int</span> r)&#123;</span><br><span class="line">        <span class="keyword">if</span>(l == r) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        cdq(l, mid);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = l; i &lt;= r; i++) ord[i] = i;</span><br><span class="line">        sort(ord.begin() + l, ord.begin() + mid + <span class="number">1</span>, [&amp;](<span class="keyword">int</span> x, <span class="keyword">int</span> y)&#123;</span><br><span class="line">            <span class="keyword">return</span> c[x] &lt; c[y];</span><br><span class="line">        &#125;);</span><br><span class="line">        sort(ord.begin() + mid + <span class="number">1</span>, ord.begin() + r + <span class="number">1</span>, [&amp;](<span class="keyword">int</span> x, <span class="keyword">int</span> y)&#123;</span><br><span class="line">            <span class="keyword">return</span> sum[x] &lt; sum[y];</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> head = <span class="number">1</span>, tail = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> cmp = [&amp;](ll x1, ll y1, ll x2, ll y2)&#123;</span><br><span class="line">            <span class="comment">//return 1.0 * x1 / y1 &lt;= 1.0 * x2 / y2;</span></span><br><span class="line">            <span class="keyword">if</span>(y1 &lt;= <span class="number">0</span> &amp;&amp; y2 &lt;= <span class="number">0</span>) <span class="keyword">return</span> i128(x1) * y2 &lt;= i128(x2) * y1;</span><br><span class="line">            <span class="keyword">if</span>(y1 &gt;= <span class="number">0</span> &amp;&amp; y2 &gt;= <span class="number">0</span>) <span class="keyword">return</span> i128(x1) * y2 &lt;= i128(x2) * y1;</span><br><span class="line">            <span class="keyword">return</span> i128(x1) * y2 &gt;= i128(x2) * y1;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = l; i &lt;= mid; i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(head &lt; tail &amp;&amp; cmp(up(ord[i], q[tail]), down(ord[i], q[tail]), up(q[tail], q[tail - <span class="number">1</span>]), down(q[tail], q[tail - <span class="number">1</span>])</span><br><span class="line">            )) tail--;</span><br><span class="line">            q[++tail] = ord[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = mid + <span class="number">1</span>; i &lt;= r; i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(head &lt; tail &amp;&amp; cmp(up(q[head + <span class="number">1</span>], q[head]), down(q[head + <span class="number">1</span>], q[head]), sum[ord[i]], <span class="number">1</span>)) head++;</span><br><span class="line">            cal(ord[i], q[head]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cdq(mid + <span class="number">1</span>, r);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    cdq(<span class="number">0</span>, n);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; dp[n] &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></p><h1 id="李超树"><a href="#李超树" class="headerlink" title="李超树"></a>李超树</h1><p>给定一个平面直角坐标系，支持动态插入一条线段，询问从某一个位置/某一段区间从上往下或者从下往上看能看到的第一条线段。</p><p>李超树的核心思想是每个区间维护一个优势线段，具体来说，在某个区间中点能取得最大/最小值的线段为核心线段，我们查询的时候只需要沿着路径在线段树上一路查所有区间优势线段，取最优的答案即可。</p><p>对于修改，我们先把线段的值域分割到线段树的区间上，每次访问一个完整的包含在线段值域中的区间时：</p><ul><li>若当前区间还没有记录最优势线段，则记录最优势线段并返回。</li><li>若当前区间的最优势线段被插入的线段完全覆盖，则把最优势线段修改为被插入线段并返回。</li><li>若当前区间的最优势线段把被插入线断完全覆盖，则直接返回。</li><li>若当前区间最优势线段与被插入线段有交，则先判断哪条线段在当前区间更优，并把更劣的线段下传到交点所在子区间。（交点两边的部分被这两条线段分别控制，而我们已经让在中点更优的那条线段作为区间最优势线段，因此更劣的那条线段只有可能在交点所在子区间超过当前区间的最优势线段）</li></ul><p>每次操作均摊复杂度是<script type="math/tex">O(log^2n)</script><br>模板:<br><div><div class="fold_hider"><div class="close hider_title">代码</div></div><div class="fold"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">233</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">注意事项：</span></span><br><span class="line"><span class="comment">1、插入直线的时候一定记得把直线的flag设为1！！！</span></span><br><span class="line"><span class="comment">2、注意最大最小值，斜率初始化时候的上下限</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">Intervel</span>&#123;</span></span><br><span class="line">    T k, b;</span><br><span class="line">    <span class="keyword">int</span> flag;</span><br><span class="line">    Intervel(T kk = <span class="number">0</span>, T bb = <span class="number">0</span>, T ff = <span class="number">0</span>)&#123;</span><br><span class="line">        k = kk;</span><br><span class="line">        b = bb;</span><br><span class="line">        flag = ff;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">T <span class="title">cal</span><span class="params">(T x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> k * x + b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">LiChao_Segment</span>&#123;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ls o &lt;&lt; 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rs o &lt;&lt; 1 | 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> upd_mx() mx[o] = max(mx[o], max(seg_mx[o].cal(tl), seg_mx[o].cal(tr)))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> upd_mn() mn[o] = min(mn[o], min(seg_mn[o].cal(tl), seg_mn[o].cal(tr)))</span></span><br><span class="line"></span><br><span class="line">    Intervel&lt;T&gt; seg_mx[maxn &lt;&lt; <span class="number">2</span>], seg_mn[maxn &lt;&lt; <span class="number">2</span>];</span><br><span class="line">    T mx[maxn &lt;&lt; <span class="number">2</span>], mn[maxn &lt;&lt; <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">up</span><span class="params">(<span class="keyword">int</span> o)</span></span>&#123;</span><br><span class="line">        mx[o] = max(mx[o], max(mx[ls], mx[rs]));</span><br><span class="line">        mn[o] = min(mn[o], min(mn[ls], mn[rs]));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> o, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="comment">//视情况初始化</span></span><br><span class="line">        seg_mx[o] = seg_mn[o] = Intervel&lt;T&gt;();</span><br><span class="line">        mx[o] = <span class="number">0</span>, mn[o] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(l == r) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        build(ls, l, mid);</span><br><span class="line">        build(rs, mid + <span class="number">1</span>, r);</span><br><span class="line">        up(o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">updmax</span><span class="params">(<span class="keyword">int</span> o, <span class="keyword">int</span> tl, <span class="keyword">int</span> tr, <span class="keyword">int</span> l, <span class="keyword">int</span> r, Intervel&lt;T&gt; v)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l &gt; tr || tl &gt; r) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = tl + tr &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(l &lt;= tl &amp;&amp; tr &lt;= r)&#123;</span><br><span class="line">            <span class="comment">// 没有其他线段，直接覆盖</span></span><br><span class="line">            <span class="keyword">if</span>(!seg_mx[o].flag) &#123;</span><br><span class="line">                seg_mx[o] = v;</span><br><span class="line">                seg_mx[o].flag = <span class="number">1</span>;</span><br><span class="line">                upd_mx();</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 全区间最优，直接覆盖</span></span><br><span class="line">            <span class="keyword">if</span>(v.cal(tl) &gt;= seg_mx[o].cal(tl) &amp;&amp; v.cal(tr) &gt;= seg_mx[o].cal(tr))&#123;</span><br><span class="line">                seg_mx[o] = v;</span><br><span class="line">                upd_mx();</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/* 有相交，讨论劣势线段往哪边走更新，注意如果k，b是double的话比较的时候需要加eps</span></span><br><span class="line"><span class="comment">                中点谁更高谁就是优势线段，通过比较左端点高度判断往哪边走</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">             <span class="keyword">if</span>(v.cal(tl) &gt;= seg_mx[o].cal(tl) || v.cal(tr) &gt;= seg_mx[o].cal(tr))&#123;</span><br><span class="line">                <span class="keyword">if</span>(v.cal(mid) &gt; seg_mx[o].cal(mid)) swap(seg_mx[o], v);</span><br><span class="line">                upd_mx();</span><br><span class="line">                <span class="keyword">if</span>(v.cal(tl) &gt; seg_mx[o].cal(tl)) updmax(ls, tl, mid, l, r, v);</span><br><span class="line">                <span class="keyword">else</span> updmax(rs, mid + <span class="number">1</span>, tr, l, r, v);</span><br><span class="line">                up(o);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        updmax(ls, tl, mid, l, r, v);</span><br><span class="line">        updmax(rs, mid + <span class="number">1</span>, tr, l, r, v);</span><br><span class="line">        up(o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//注意检查第一句的-INF是否满足题目条件</span></span><br><span class="line">    <span class="function">T <span class="title">qmax</span><span class="params">(<span class="keyword">int</span> o, <span class="keyword">int</span> tl, <span class="keyword">int</span> tr, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l &gt; tr || tl &gt; r) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(l &lt;= tl &amp;&amp; tr &lt;= r) <span class="keyword">return</span> mx[o];</span><br><span class="line">        <span class="keyword">int</span> mid = tl + tr &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        T res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(seg_mx[o].flag) res = max(res, max(seg_mx[o].cal(max(tl, l)), seg_mx[o].cal(min(tr, r))));</span><br><span class="line">        res = max(res, qmax(ls, tl, mid, l, r));</span><br><span class="line">        res = max(res, qmax(rs, mid + <span class="number">1</span>, tr, l, r));</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">updmin</span><span class="params">(<span class="keyword">int</span> o, <span class="keyword">int</span> tl, <span class="keyword">int</span> tr, <span class="keyword">int</span> l, <span class="keyword">int</span> r, Intervel&lt;T&gt; v)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l &gt; tr || tl &gt; r) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = tl + tr &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(l &lt;= tl &amp;&amp; tr &lt;= r)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!seg_mn[o].flag) &#123;</span><br><span class="line">                seg_mn[o] = v;</span><br><span class="line">                seg_mn[o].flag = <span class="number">1</span>;</span><br><span class="line">                upd_mn();</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(v.cal(tl) &lt;= seg_mn[o].cal(tl) &amp;&amp; v.cal(tr) &lt;= seg_mn[o].cal(tr))&#123;</span><br><span class="line">                seg_mn[o] = v;</span><br><span class="line">                upd_mn();</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(v.cal(tl) &lt;= seg_mn[o].cal(tl) || v.cal(tr) &lt;= seg_mn[o].cal(tr))&#123;</span><br><span class="line">                <span class="keyword">if</span>(v.cal(mid) &lt; seg_mn[o].cal(mid)) swap(seg_mn[o], v);</span><br><span class="line">                upd_mn();</span><br><span class="line">                <span class="keyword">if</span>(v.cal(tl) &lt; seg_mn[o].cal(tl)) updmin(ls, tl, mid, l, r, v);</span><br><span class="line">                <span class="keyword">else</span> updmin(rs, mid + <span class="number">1</span>, tr, l, r, v);</span><br><span class="line">                up(o);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        updmin(ls, tl, mid, l, r, v);</span><br><span class="line">        updmin(rs, mid + <span class="number">1</span>, tr, l, r, v);</span><br><span class="line">        up(o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//注意检查第一句的INF是否满足题目条件</span></span><br><span class="line">    <span class="function">T <span class="title">qmin</span><span class="params">(<span class="keyword">int</span> o, <span class="keyword">int</span> tl, <span class="keyword">int</span> tr, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l &gt; tr || tl &gt; r) <span class="keyword">return</span> <span class="number">1e18</span>;</span><br><span class="line">        <span class="keyword">if</span>(l &lt;= tl &amp;&amp; tr &lt;= r) <span class="keyword">return</span> mn[o];</span><br><span class="line">        <span class="keyword">int</span> mid = tl + tr &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        T res = <span class="number">1e18</span>;</span><br><span class="line">        <span class="keyword">if</span>(seg_mn[o].flag) res = min(res, min(seg_mn[o].cal(max(tl, l)), seg_mn[o].cal(min(tr, r))));</span><br><span class="line">        res = min(res, qmin(ls, tl, mid, l, r));</span><br><span class="line">        res = min(res, qmin(rs, mid + <span class="number">1</span>, tr, l, r));</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> ls</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> rs</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">LiChao_Segment&lt;<span class="keyword">double</span>&gt; tr;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">char</span> s[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    tr.build(<span class="number">1</span>, <span class="number">1</span>, <span class="number">100005</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">double</span> x, y;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s %lf"</span>, s + <span class="number">1</span>, &amp;x);</span><br><span class="line">        <span class="keyword">if</span>(s[<span class="number">1</span>] == <span class="string">'P'</span>)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%lf"</span>, &amp;y);</span><br><span class="line">            x = x - y;</span><br><span class="line">            tr.updmin(<span class="number">1</span>, <span class="number">1</span>, <span class="number">100005</span>, <span class="number">1</span>, <span class="number">100005</span>, Intervel&lt;<span class="keyword">double</span>&gt;(-y, -x, <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> p = x;</span><br><span class="line">            <span class="keyword">double</span> res = -tr.qmin(<span class="number">1</span>, <span class="number">1</span>, <span class="number">100005</span>, p, p);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, (<span class="keyword">long</span> <span class="keyword">long</span>)(<span class="built_in">floor</span>(res) / <span class="number">100</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></p><p>李超树很容易应用在斜率优化上，原来我们是维护一个凸包，事实上如果直接把转移式子看成一条条线段的话，我们直接可以把这些决策点插入李超树，转移的时候就是求最大/最小值。李超树还很容易用到树上的斜率优化上，只需要改为线段树合并即可。</p><p><a href="https://codeforces.com/contest/932/problem/F" target="_blank" rel="noopener">cf-932F</a><br>根据上面写的dp方程，我们直接把<script type="math/tex">b[u]</script>当成斜率，<script type="math/tex">dp[u]</script>当成截距，然后插入李超树，转移直接求树上最小值，在写一个线段树合并即可。<br><div><div class="fold_hider"><div class="close hider_title">代码</div></div><div class="fold"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> db;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vi;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;ll&gt; vl;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;pii&gt; vp;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">const</span> ll INF = <span class="number">1e18</span>;</span><br><span class="line"><span class="keyword">const</span> db eps = <span class="number">1e-10</span>;</span><br><span class="line"><span class="keyword">const</span> db pi = <span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> eb emplace_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ep emplace</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mem(a) memset(a, 0, sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> copy(a, b) memcpy(a, b, sizeof(b))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PA cout &lt;&lt; <span class="meta-string">"pass\n"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lowbit(x) (x &amp; -x)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(x) x.begin(), x.end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TM cout &lt;&lt; db(clock()) / CLOCKS_PER_SEC &lt;&lt; <span class="meta-string">'\n'</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">mt19937 <span class="title">mrand</span><span class="params">(chrono::high_resolution_clock::now().time_since_epoch().count())</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;<span class="title">inline</span> <span class="title">void</span> <span class="title">upmin</span>(<span class="title">T</span> &amp;<span class="title">x</span>, <span class="title">T</span> <span class="title">y</span>) &#123;</span>x = x &gt; y ? y : x;&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;<span class="title">inline</span> <span class="title">void</span> <span class="title">upmax</span>(<span class="title">T</span> &amp;<span class="title">x</span>, <span class="title">T</span> <span class="title">y</span>) &#123;</span>x = x &lt; y ? y : x;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">233</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">Intervel</span>&#123;</span></span><br><span class="line">    T k, b;</span><br><span class="line">    <span class="keyword">int</span> flag;</span><br><span class="line">    Intervel(T kk = <span class="number">0</span>, T bb = <span class="number">0</span>, T ff = <span class="number">0</span>)&#123;</span><br><span class="line">        k = kk;</span><br><span class="line">        b = bb;</span><br><span class="line">        flag = ff;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">T <span class="title">cal</span><span class="params">(T x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> k * x + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">LiChao_Segment</span> &#123;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> upd_mn() mn[o] = min(mn[o], min(seg_mn[o].cal(tl), seg_mn[o].cal(tr)))</span></span><br><span class="line">    Intervel&lt;T&gt; seg_mn[maxn &lt;&lt; <span class="number">5</span>];</span><br><span class="line">    T mn[maxn &lt;&lt; <span class="number">5</span>];</span><br><span class="line">    <span class="keyword">int</span> ls[maxn &lt;&lt; <span class="number">5</span>], rs[maxn &lt;&lt; <span class="number">5</span>];</span><br><span class="line">    <span class="keyword">int</span> idx;</span><br><span class="line">    <span class="keyword">int</span> root[maxn &lt;&lt; <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">up</span><span class="params">(<span class="keyword">int</span> o)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(ls[o]) mn[o] = min(mn[o], mn[ls[o]]);</span><br><span class="line">        <span class="keyword">if</span>(rs[o]) mn[o] = min(mn[o], mn[rs[o]]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">newnode</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ++idx;</span><br><span class="line">        seg_mn[idx] = Intervel&lt;T&gt;();</span><br><span class="line">        mn[idx] = INF;</span><br><span class="line">        <span class="keyword">return</span> idx;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">upd</span><span class="params">(<span class="keyword">int</span> &amp;o, <span class="keyword">int</span> tl, <span class="keyword">int</span> tr, <span class="keyword">int</span> l, <span class="keyword">int</span> r, Intervel&lt;T&gt; v)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!o) o = newnode();</span><br><span class="line">        <span class="keyword">if</span>(l &gt; tr || tl &gt; r) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = tl + tr &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(l &lt;= tl &amp;&amp; tr &lt;= r)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!seg_mn[o].flag) &#123;</span><br><span class="line">                seg_mn[o] = v;</span><br><span class="line">                upd_mn();</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(v.cal(tl) &lt;= seg_mn[o].cal(tl) &amp;&amp; v.cal(tr) &lt;= seg_mn[o].cal(tr))&#123;</span><br><span class="line">                seg_mn[o] = v;</span><br><span class="line">                upd_mn();</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(v.cal(tl) &lt;= seg_mn[o].cal(tl) || v.cal(tr) &lt;= seg_mn[o].cal(tr))&#123;</span><br><span class="line">                <span class="keyword">if</span>(v.cal(mid) &lt; seg_mn[o].cal(mid)) swap(seg_mn[o], v);</span><br><span class="line">                upd_mn();</span><br><span class="line">                <span class="keyword">if</span>(v.cal(tl) &lt; seg_mn[o].cal(tl)) upd(ls[o], tl, mid, l, r, v);</span><br><span class="line">                <span class="keyword">else</span> upd(rs[o], mid + <span class="number">1</span>, tr, l, r, v);</span><br><span class="line">                up(o);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        upd(ls[o], tl, mid, l, r, v);</span><br><span class="line">        upd(rs[o], mid + <span class="number">1</span>, tr, l, r, v);</span><br><span class="line">        up(o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">T <span class="title">qmin</span><span class="params">(<span class="keyword">int</span> o, <span class="keyword">int</span> tl, <span class="keyword">int</span> tr, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!o || l &gt; tr || tl &gt; r) <span class="keyword">return</span> INF;</span><br><span class="line">        <span class="keyword">if</span>(l &lt;= tl &amp;&amp; tr &lt;= r) <span class="keyword">return</span> mn[o];</span><br><span class="line">        <span class="keyword">int</span> mid = tl + tr &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        T res = INF;</span><br><span class="line">        <span class="keyword">if</span>(seg_mn[o].flag) res = min(res, min(seg_mn[o].cal(max(tl, l)), seg_mn[o].cal(min(tr, r))));</span><br><span class="line">        res = min(res, qmin(ls[o], tl, mid, l, r));</span><br><span class="line">        res = min(res, qmin(rs[o], mid + <span class="number">1</span>, tr, l, r));</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!u || !v) <span class="keyword">return</span> u + v;</span><br><span class="line">        upd(u, l, r, <span class="number">-1e5</span> - <span class="number">5</span>, <span class="number">1e5</span> + <span class="number">5</span>, seg_mn[v]);</span><br><span class="line">        <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        ls[u] = merge(ls[u], ls[v], l, mid);</span><br><span class="line">        rs[u] = merge(rs[u], rs[v], mid + <span class="number">1</span>, r);</span><br><span class="line">        up(u);</span><br><span class="line">        <span class="keyword">return</span> u;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">LiChao_Segment&lt;ll&gt; tr;</span><br><span class="line"><span class="keyword">int</span> a[maxn], b[maxn];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; G[maxn];</span><br><span class="line">ll dp[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> f)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> v : G[u])&#123;</span><br><span class="line">        <span class="keyword">if</span>(v == f) <span class="keyword">continue</span>;</span><br><span class="line">        dfs(v, u);</span><br><span class="line">        tr.root[u] = tr.merge(tr.root[u], tr.root[v], <span class="number">-1e5</span> - <span class="number">5</span>, <span class="number">1e5</span> + <span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(G[u].size() == <span class="number">1</span> &amp;&amp; u != <span class="number">1</span>) dp[u] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> dp[u] = tr.qmin(tr.root[u], <span class="number">-1e5</span> - <span class="number">5</span>, <span class="number">1e5</span> + <span class="number">5</span>, a[u], a[u]);</span><br><span class="line">    tr.upd(tr.root[u], <span class="number">-1e5</span> - <span class="number">5</span>, <span class="number">1e5</span> + <span class="number">5</span>, <span class="number">-1e5</span> - <span class="number">5</span>, <span class="number">1e5</span> + <span class="number">5</span>, Intervel&lt;ll&gt;(b[u], dp[u], <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>), <span class="built_in">cin</span>.tie(<span class="number">0</span>), <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; fixed &lt;&lt; setprecision(<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; b[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> u, v;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v;</span><br><span class="line">        G[u].emplace_back(v);</span><br><span class="line">        G[v].emplace_back(u);</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; dp[i] &lt;&lt; <span class="string">" \n"</span>[i == n];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></p><p><a href="https://codeforces.com/contest/1175/problem/G" target="_blank" rel="noopener">cf-1175G</a><br>考虑分治，每次枚举中点mid，考虑前面对后面转移的贡献，如果最大值在左边，我们发现可以用李超树维护转移，比较好写。<br>难一点的是最大值在右边，发现可以用维护一个翻转过来的凸包，但由于斜率不是单调递增询问，所以我们只能在凸包上二分，然后转移即可。</p><p>总之就是非常难写<br><div><div class="fold_hider"><div class="close hider_title">代码</div></div><div class="fold"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> db;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vi;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;ll&gt; vl;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;pii&gt; vp;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">const</span> ll INF = <span class="number">1e18</span>;</span><br><span class="line"><span class="keyword">const</span> db eps = <span class="number">1e-10</span>;</span><br><span class="line"><span class="keyword">const</span> db pi = <span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> eb emplace_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ep emplace</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mem(a) memset(a, 0, sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> copy(a, b) memcpy(a, b, sizeof(b))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PA cout &lt;&lt; <span class="meta-string">"pass\n"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lowbit(x) (x &amp; -x)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(x) x.begin(), x.end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TM cout &lt;&lt; db(clock()) / CLOCKS_PER_SEC &lt;&lt; <span class="meta-string">'\n'</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">mt19937 <span class="title">mrand</span><span class="params">(chrono::high_resolution_clock::now().time_since_epoch().count())</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;<span class="title">inline</span> <span class="title">void</span> <span class="title">upmin</span>(<span class="title">T</span> &amp;<span class="title">x</span>, <span class="title">T</span> <span class="title">y</span>) &#123;</span>x = x &gt; y ? y : x;&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;<span class="title">inline</span> <span class="title">void</span> <span class="title">upmax</span>(<span class="title">T</span> &amp;<span class="title">x</span>, <span class="title">T</span> <span class="title">y</span>) &#123;</span>x = x &lt; y ? y : x;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e4</span> + <span class="number">233</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">Intervel</span>&#123;</span></span><br><span class="line">    T k, b;</span><br><span class="line">    <span class="keyword">int</span> flag;</span><br><span class="line">    Intervel(T kk = <span class="number">0</span>, T bb = <span class="number">0</span>, T ff = <span class="number">0</span>)&#123;</span><br><span class="line">        k = kk;</span><br><span class="line">        b = bb;</span><br><span class="line">        flag = ff;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">T <span class="title">cal</span><span class="params">(T x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> k * x + b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">LiChao_Segment</span> &#123;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ls o &lt;&lt; 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rs o &lt;&lt; 1 | 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> upd_mx() mx[o] = max(mx[o], max(seg_mx[o].cal(tl), seg_mx[o].cal(tr)))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> upd_mn() mn[o] = min(mn[o], min(seg_mn[o].cal(tl), seg_mn[o].cal(tr)))</span></span><br><span class="line"></span><br><span class="line">    Intervel&lt;T&gt; seg_mn[maxn &lt;&lt; <span class="number">2</span>];</span><br><span class="line">    T mn[maxn &lt;&lt; <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">up</span><span class="params">(<span class="keyword">int</span> o)</span> </span>&#123;</span><br><span class="line">        mn[o] = min(mn[o], min(mn[ls], mn[rs]));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> o, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">        mn[o] = INF;</span><br><span class="line">        seg_mn[o] = Intervel&lt;ll&gt;();</span><br><span class="line">        <span class="keyword">if</span>(l == r) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        build(ls, l, mid);</span><br><span class="line">        build(rs, mid + <span class="number">1</span>, r);</span><br><span class="line">        up(o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">(<span class="keyword">int</span> o, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">        mn[o] = INF;</span><br><span class="line">        seg_mn[o] = Intervel&lt;ll&gt;();</span><br><span class="line">        <span class="keyword">if</span>(l == r)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(seg_mn[ls].flag) clear(ls, l, mid);</span><br><span class="line">        <span class="keyword">if</span>(seg_mn[rs].flag) clear(rs, mid + <span class="number">1</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">updmin</span><span class="params">(<span class="keyword">int</span> o, <span class="keyword">int</span> tl, <span class="keyword">int</span> tr, <span class="keyword">int</span> l, <span class="keyword">int</span> r, Intervel&lt;T&gt; v)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l &gt; tr || tl &gt; r) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = tl + tr &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(l &lt;= tl &amp;&amp; tr &lt;= r)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!seg_mn[o].flag) &#123;</span><br><span class="line">                seg_mn[o] = v;</span><br><span class="line">                upd_mn();</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(v.cal(tl) &lt;= seg_mn[o].cal(tl) &amp;&amp; v.cal(tr) &lt;= seg_mn[o].cal(tr))&#123;</span><br><span class="line">                seg_mn[o] = v;</span><br><span class="line">                upd_mn();</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(v.cal(tl) &lt;= seg_mn[o].cal(tl) || v.cal(tr) &lt;= seg_mn[o].cal(tr))&#123;</span><br><span class="line">                <span class="keyword">if</span>(v.cal(mid) &lt; seg_mn[o].cal(mid)) swap(seg_mn[o], v);</span><br><span class="line">                upd_mn();</span><br><span class="line">                <span class="keyword">if</span>(v.cal(tl) &lt; seg_mn[o].cal(tl)) updmin(ls, tl, mid, l, r, v);</span><br><span class="line">                <span class="keyword">else</span> updmin(rs, mid + <span class="number">1</span>, tr, l, r, v);</span><br><span class="line">                up(o);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        updmin(ls, tl, mid, l, r, v);</span><br><span class="line">        updmin(rs, mid + <span class="number">1</span>, tr, l, r, v);</span><br><span class="line">        up(o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">T <span class="title">qmin</span><span class="params">(<span class="keyword">int</span> o, <span class="keyword">int</span> tl, <span class="keyword">int</span> tr, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l &gt; tr || tl &gt; r) <span class="keyword">return</span> <span class="number">1e18</span>;</span><br><span class="line">        <span class="keyword">if</span>(l &lt;= tl &amp;&amp; tr &lt;= r) <span class="keyword">return</span> mn[o];</span><br><span class="line">        <span class="keyword">int</span> mid = tl + tr &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        T res = <span class="number">1e18</span>;</span><br><span class="line">        <span class="keyword">if</span>(seg_mn[o].flag) res = min(res, min(seg_mn[o].cal(max(tl, l)), seg_mn[o].cal(min(tr, r))));</span><br><span class="line">        res = min(res, qmin(ls, tl, mid, l, r));</span><br><span class="line">        res = min(res, qmin(rs, mid + <span class="number">1</span>, tr, l, r));</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">ll dp[maxn][<span class="number">110</span>];</span><br><span class="line"><span class="keyword">int</span> a[maxn];</span><br><span class="line">LiChao_Segment&lt;ll&gt; tr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> pre[maxn], suf[maxn];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> q[maxn], head, tail;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l == r)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    solve(l, mid, k);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> mx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = mid; i &gt;= l; i--)&#123;</span><br><span class="line">        mx = max(mx, a[i]);</span><br><span class="line">        suf[i] = mx;</span><br><span class="line">    &#125;</span><br><span class="line">    mx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = mid + <span class="number">1</span>; i &lt;= r; i++)&#123;</span><br><span class="line">        mx = max(mx, a[i]);</span><br><span class="line">        pre[i] = mx;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// max_val in left</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> pl = l;</span><br><span class="line">    suf[mid + <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = r; i &gt; mid; i--)&#123;</span><br><span class="line">        <span class="keyword">while</span>(pl &lt;= mid &amp;&amp; suf[pl + <span class="number">1</span>] &gt;= pre[i])&#123;</span><br><span class="line">            tr.updmin(<span class="number">1</span>, <span class="number">0</span>, <span class="number">2e4</span>, <span class="number">0</span>, <span class="number">2e4</span>, Intervel&lt;ll&gt;(suf[pl + <span class="number">1</span>], dp[pl][k - <span class="number">1</span>] - <span class="number">1l</span>l * pl * suf[pl + <span class="number">1</span>], <span class="number">1</span>));</span><br><span class="line">            pl++;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[i][k] = min(dp[i][k], tr.qmin(<span class="number">1</span>, <span class="number">0</span>, <span class="number">2e4</span>, i, i));</span><br><span class="line">    &#125;</span><br><span class="line">    tr.clear(<span class="number">1</span>, <span class="number">0</span>, <span class="number">2e4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// max_val in right</span></span><br><span class="line"></span><br><span class="line">    head = <span class="number">1</span>, tail = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">auto</span> up = [&amp;](<span class="keyword">int</span> j, <span class="keyword">int</span> i)&#123;</span><br><span class="line">        <span class="keyword">return</span> dp[i][k - <span class="number">1</span>] - dp[j][k - <span class="number">1</span>];</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> down = [&amp;](<span class="keyword">int</span> j, <span class="keyword">int</span> i)&#123;</span><br><span class="line">        <span class="keyword">return</span> (mid - i) - (mid - j);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    pl = mid;</span><br><span class="line">    head = tail = <span class="number">1</span>;</span><br><span class="line">    q[head] = mid;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = mid + <span class="number">1</span>; i &lt;= r; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (pl &gt; l &amp;&amp; suf[pl] &lt;= pre[i]) &#123;</span><br><span class="line">            pl--;</span><br><span class="line">            <span class="keyword">while</span> (head &lt; tail &amp;&amp;</span><br><span class="line">                   up(q[tail - <span class="number">1</span>], q[tail]) * down(q[tail], pl) &gt;= down(q[tail - <span class="number">1</span>], q[tail]) * up(q[tail], pl))</span><br><span class="line">                tail--;</span><br><span class="line">            q[++tail] = pl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (head &gt; tail) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">int</span> lb = head + <span class="number">1</span>, ub = tail, ans = head;</span><br><span class="line">        <span class="keyword">while</span> (ub &gt;= lb) &#123;</span><br><span class="line">            <span class="keyword">int</span> m = ub + lb &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (up(q[m - <span class="number">1</span>], q[m]) &lt;= -down(q[m - <span class="number">1</span>], q[m]) * pre[i]) lb = m + <span class="number">1</span>, ans = m;</span><br><span class="line">            <span class="keyword">else</span> ub = m - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//cout &lt;&lt; head &lt;&lt; ' ' &lt;&lt; tail &lt;&lt; ' ' &lt;&lt; ans &lt;&lt; ' ' &lt;&lt; k &lt;&lt; ' ' &lt;&lt; i &lt;&lt; ' ' &lt;&lt; q[ans] &lt;&lt; '\n';</span></span><br><span class="line">        dp[i][k] = min(dp[i][k], dp[q[ans]][k - <span class="number">1</span>] + <span class="number">1l</span>l * (i - q[ans]) * pre[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    solve(mid + <span class="number">1</span>, r, k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> k;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>), <span class="built_in">cin</span>.tie(<span class="number">0</span>), <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; fixed &lt;&lt; setprecision(<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= k; ++j) &#123;</span><br><span class="line">            dp[i][j] = inf;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; ++i) &#123;</span><br><span class="line">        tr.build(<span class="number">1</span>, <span class="number">0</span>, <span class="number">2e4</span>);</span><br><span class="line">        solve(<span class="number">0</span>, n, i);</span><br><span class="line">        <span class="comment">/*for(int j = 0; j &lt;= n; j++)&#123;</span></span><br><span class="line"><span class="comment">            cout &lt;&lt; dp[j][i] &lt;&lt; ' ';</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        cout &lt;&lt; '\n';*/</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; dp[n][k] &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;斜率优化&quot;&gt;&lt;a href=&quot;#斜率优化&quot; class=&quot;headerlink&quot; title=&quot;斜率优化&quot;&gt;&lt;/a&gt;斜率优化&lt;/h1&gt;&lt;p&gt;最简单的用单调队列的就不说了，说几个难的&lt;/p&gt;
    
    </summary>
    
      <category term="决策单调性" scheme="http://yoursite.com/categories/%E5%86%B3%E7%AD%96%E5%8D%95%E8%B0%83%E6%80%A7/"/>
    
    
  </entry>
  
  <entry>
    <title>斯特林数</title>
    <link href="http://yoursite.com/2020/11/05/%E6%96%AF%E7%89%B9%E6%9E%97%E6%95%B0/"/>
    <id>http://yoursite.com/2020/11/05/斯特林数/</id>
    <published>2020-11-05T11:18:39.000Z</published>
    <updated>2021-01-14T03:10:47.940Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第一类斯特林数"><a href="#第一类斯特林数" class="headerlink" title="第一类斯特林数"></a>第一类斯特林数</h1><p>第一类斯特林数<script type="math/tex">S_1(n, m)</script>表示<script type="math/tex">n</script>个元素分成<script type="math/tex">m</script>个环的方案数。<br>递推式：<script type="math/tex">S_1(n, m) = S_1(n - 1, m - 1) + (n - 1) * S_1(n - 1, m)</script><br>即考虑最后一个数是单独成环还是放在某一个已成环的位置。</p><h2 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h2><ul><li><script type="math/tex; mode=display">n! = \sum_{i = 0}^nS_1(n, i)</script></li><li><script type="math/tex; mode=display">x^{\underline{n}} = S_1(n, i)(-1)^{n - i}x^i</script></li><li><script type="math/tex; mode=display">x^{\overline{n}} = S_1(n, i)x^i</script></li></ul><script type="math/tex; mode=display">\sum_{i = 0}^nS_1(n, i)x^i = \prod_{i = 0}^{n - 1}(x + i)</script><p>这个也很好解释，一共要转移<script type="math/tex">n</script>次，每次要嘛选第一个式子，系数为1，<script type="math/tex">x</script>幂次增加1，要嘛选第二个式子，<script type="math/tex">x</script>幂次不变，系数为<script type="math/tex">i - 1</script>，所以容易得出生成函数。<br>这生成函数直接分治<script type="math/tex">fft</script>，可以求出第一类斯特林数。</p><a id="more"></a><p><a href="https://codeforces.com/problemset/problem/960/G" target="_blank" rel="noopener">cf-960G Bandit Blues</a><br>令<script type="math/tex">dp[i][j]表示前i个最大的数，有j个前面没有比它更大的数的排列方案数</script>，考虑加入一个新的最小的数，可以得到转移<script type="math/tex">dp[i][j] = dp[i - 1][j - 1] + (i - 1) * dp[i - 1][j]</script>，这玩意就是第一类斯特林数，直接分治<script type="math/tex">fft</script>求解。<br>然后考虑会被最大的数<script type="math/tex">n</script>分成两部分，考虑先选<script type="math/tex">a + b - 1</script>个前面没有比它更大的数出来，然后选其中<script type="math/tex">b - 1</script>个翻转到后面去，所以最后答案就是<script type="math/tex">S_1(n - 1, a + b - 2) * C_{a + b - 2}^{a - 1}</script></p><h1 id="第二类斯特林数"><a href="#第二类斯特林数" class="headerlink" title="第二类斯特林数"></a>第二类斯特林数</h1><p>第二类斯特林数是把<script type="math/tex">n</script>个元素放入<script type="math/tex">m</script>个盒子中，每个盒子非空的方案数。<script type="math/tex">S_2(n, m) = S_2(n - 1, m - 1) + m * S_2(n - 1, m)</script><br>第二类斯特林数有容斥做法：<script type="math/tex">S_2(n, m) = \frac{1}{m!}\sum_{i = 0}^m(-1)^{m - i}C_m^ii^n</script></p><p>即求出最多放在<script type="math/tex">i</script>个盒子的方案数，再容斥即可。<br>把组合数拆开发现是一个卷积的形式，直接<script type="math/tex">fft</script>求解即可。</p><h2 id="性质-1"><a href="#性质-1" class="headerlink" title="性质"></a>性质</h2><ul><li><script type="math/tex; mode=display">m^n = \sum_{i = 0}^mS(n, i) * i ! * C_m^i</script>非常有用一个性质，当n是一个不变的数时，展开后然后交换前后求和顺序，可以构造出卷积的形式。</li></ul><p><a href="https://codeforces.com/contest/1278/problem/F" target="_blank" rel="noopener">cf1278F-cards</a><br>一次排列中有一个小丑的概率$p = \frac{1}{m}$<br>很显然可以推出式子<script type="math/tex">ans = \sum_{i = 0}^nC_n^ip^i(1 - p)^{n - i}i^k</script></p><p>展开$i^k$：<script type="math/tex">ans = \sum_{i = 0}^n C_n^i p^i (1 - p)^{n - i} \sum_{j = 0}^i S(k, j) * j! * C_i^j</script></p><p>把第二维的上限改成$n$，因为后面的都是0，交换求和顺序：<script type="math/tex">ans = \sum_{j = 0}^nS(k, j)*j!*\sum_{i = 0}^nC_n^ip^i(1 - p)^{n - i}*C_i^j</script></p><p>组合数魔改：<script type="math/tex">ans = \sum_{j = 0}^nS(k, j)*j!*\sum_{i = 0}^nC_n^jp^i(1 - p)^{n - i}*C_{n - j}^{i - j}</script></p><p>更改第二维上下限：<script type="math/tex">ans = \sum_{j = 0}^nC_n^j * S(k, j)*j!*\sum_{i = j}^np^i(1 - p)^{n - i}*C_{n - j}^{i - j}</script></p><p>再改：<script type="math/tex">ans = \sum_{j = 0}^nC_n^j * S(k, j)*j!*\sum_{i = 0}^{n - j}p^{i - j}(1 - p)^{n - j - i}*C_{n - j}^{i}</script></p><p>发现后面可以二项式合并了，答案就为1，那么<script type="math/tex">ans = \sum_{j = 0}^{min(n, k)}C_n^j * S(k, j)*j!</script></p><p>预处理第二类斯特林数，展开成下降幂的形式就可以搞了。<br><div><div class="fold_hider"><div class="close hider_title">代码</div></div><div class="fold"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vi;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    x += y;</span><br><span class="line">    <span class="keyword">if</span>(x &gt;= mod) x -= mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">sub</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    x -= y;</span><br><span class="line">    <span class="keyword">if</span>(x &lt; <span class="number">0</span>) x += mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">mul</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1l</span>l * x * y % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">inv</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">    a %= mod;</span><br><span class="line">    <span class="keyword">if</span> (a &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        a += mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> b = mod, u = <span class="number">0</span>, v = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (a) &#123;</span><br><span class="line">        <span class="keyword">int</span> t = b / a;</span><br><span class="line">        b -= t * a;</span><br><span class="line">        swap(a, b);</span><br><span class="line">        u -= t * v;</span><br><span class="line">        swap(u, v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (u &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        u += mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> u;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">pow_mod</span><span class="params">(<span class="keyword">int</span> q, <span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(w)&#123;</span><br><span class="line">        <span class="keyword">if</span>(w &amp; <span class="number">1</span>) ret = mul(ret, q);</span><br><span class="line">        q = mul(q, q);</span><br><span class="line">        w &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Polynomial&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; rev = &#123;<span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">getlen</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(len &lt;= x) len &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dft</span><span class="params">(vi &amp;a, <span class="keyword">int</span> on)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>, len = a.size();</span><br><span class="line">        <span class="keyword">while</span>((<span class="number">1</span> &lt;&lt; cnt) &lt; len) ++cnt;</span><br><span class="line">        rev.resize(len);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">            rev[i] = (rev[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; (cnt - <span class="number">1</span>));</span><br><span class="line">            <span class="keyword">if</span> (i &lt; rev[i])swap(a[i], a[rev[i]]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> h = <span class="number">1</span>; h &lt; len; h &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> wn = pow_mod(<span class="number">3</span>, (mod - <span class="number">1</span>) / (h &lt;&lt; <span class="number">1</span>));</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len; j += (h &lt;&lt; <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="keyword">int</span> w = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = j; k &lt; j + h; k++) &#123;</span><br><span class="line">                    <span class="keyword">int</span> u = a[k] % mod;</span><br><span class="line">                    <span class="keyword">int</span> t = <span class="number">1l</span>l * w * a[k + h] % mod;</span><br><span class="line">                    a[k] = (u + t) % mod;</span><br><span class="line">                    a[k + h] = (u + mod - t) % mod;</span><br><span class="line">                    w = <span class="number">1l</span>l * w * wn % mod;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (on == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len / <span class="number">2</span>; i++)</span><br><span class="line">                swap(a[i], a[len - i]);</span><br><span class="line">            <span class="keyword">int</span> inv = pow_mod(len, mod - <span class="number">2</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">                a[i] = (ll)a[i] * inv % mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vi <span class="title">mul</span><span class="params">(vi a, vi b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = a.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> m = b.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> len = getlen(n + m);</span><br><span class="line">        <span class="function">vi <span class="title">c</span><span class="params">(len)</span></span>;</span><br><span class="line">        a.resize(len);</span><br><span class="line">        b.resize(len);</span><br><span class="line">        dft(a, <span class="number">1</span>), dft(b, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">            c[i] =  (ll)a[i] * b[i] % mod;</span><br><span class="line">        &#125;</span><br><span class="line">        dft(c, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">vi&amp; <span class="keyword">operator</span> *= (vi &amp;a, <span class="keyword">const</span> vi &amp;b) &#123;</span><br><span class="line">    <span class="keyword">if</span> (min(a.size(), b.size()) &lt; <span class="number">128</span>) &#123;</span><br><span class="line">        vi c = a;</span><br><span class="line">        a.assign(a.size() + b.size() - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; c.size(); ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; b.size(); ++j) &#123;</span><br><span class="line">                add(a[i + j], mul(c[i], b[j]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        a = Polynomial::mul(a, b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vi <span class="keyword">operator</span> * (<span class="keyword">const</span> vi &amp;a, <span class="keyword">const</span> vi &amp;b) &#123;</span><br><span class="line">    vi c = a;</span><br><span class="line">    <span class="keyword">return</span> c *= b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, k;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>), <span class="built_in">cin</span>.tie(<span class="number">0</span>), <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a(k + <span class="number">1</span>, <span class="number">0</span>), b(k + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; fac(k + <span class="number">1</span>), inv(k + <span class="number">1</span>), down(k + <span class="number">1</span>);</span><br><span class="line">    fac[<span class="number">0</span>] = inv[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    down[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; ++i)&#123;</span><br><span class="line">        fac[i] = <span class="number">1l</span>l * fac[i - <span class="number">1</span>] * i % mod;</span><br><span class="line">        inv[i] = pow_mod(fac[i], mod - <span class="number">2</span>);</span><br><span class="line">        down[i] = <span class="number">1l</span>l * down[i - <span class="number">1</span>] * (n - i + <span class="number">1</span>) % mod;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= k; i++)&#123;</span><br><span class="line">        a[i] = <span class="number">1l</span>l * pow_mod(i, k) * inv[i] % mod;</span><br><span class="line">        b[i] = <span class="number">1l</span>l * pow_mod(mod - <span class="number">1</span>, i) * inv[i] % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">auto</span> c = a * b;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> prob = pow_mod(m, mod - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= min(n, k); i++)&#123;</span><br><span class="line">        res = (res + <span class="number">1l</span>l * down[i] * pow_mod(prob, i) % mod * c[i]) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><br>不知道这玩意有啥用，先写着吧，碰到再更。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;第一类斯特林数&quot;&gt;&lt;a href=&quot;#第一类斯特林数&quot; class=&quot;headerlink&quot; title=&quot;第一类斯特林数&quot;&gt;&lt;/a&gt;第一类斯特林数&lt;/h1&gt;&lt;p&gt;第一类斯特林数&lt;script type=&quot;math/tex&quot;&gt;S_1(n, m)&lt;/script&gt;表示&lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt;个元素分成&lt;script type=&quot;math/tex&quot;&gt;m&lt;/script&gt;个环的方案数。&lt;br&gt;递推式：&lt;script type=&quot;math/tex&quot;&gt;S_1(n, m) = S_1(n - 1, m - 1) + (n - 1) * S_1(n - 1, m)&lt;/script&gt;&lt;br&gt;即考虑最后一个数是单独成环还是放在某一个已成环的位置。&lt;/p&gt;
&lt;h2 id=&quot;性质&quot;&gt;&lt;a href=&quot;#性质&quot; class=&quot;headerlink&quot; title=&quot;性质&quot;&gt;&lt;/a&gt;性质&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;script type=&quot;math/tex; mode=display&quot;&gt;n! = \sum_{i = 0}^nS_1(n, i)&lt;/script&gt;&lt;/li&gt;
&lt;li&gt;&lt;script type=&quot;math/tex; mode=display&quot;&gt;x^{\underline{n}} = S_1(n, i)(-1)^{n - i}x^i&lt;/script&gt;&lt;/li&gt;
&lt;li&gt;&lt;script type=&quot;math/tex; mode=display&quot;&gt;x^{\overline{n}} = S_1(n, i)x^i&lt;/script&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;script type=&quot;math/tex; mode=display&quot;&gt;\sum_{i = 0}^nS_1(n, i)x^i = \prod_{i = 0}^{n - 1}(x + i)&lt;/script&gt;&lt;p&gt;这个也很好解释，一共要转移&lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt;次，每次要嘛选第一个式子，系数为1，&lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt;幂次增加1，要嘛选第二个式子，&lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt;幂次不变，系数为&lt;script type=&quot;math/tex&quot;&gt;i - 1&lt;/script&gt;，所以容易得出生成函数。&lt;br&gt;这生成函数直接分治&lt;script type=&quot;math/tex&quot;&gt;fft&lt;/script&gt;，可以求出第一类斯特林数。&lt;/p&gt;
    
    </summary>
    
      <category term="组合数学" scheme="http://yoursite.com/categories/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"/>
    
    
  </entry>
  
  <entry>
    <title>整数划分与五边形定理</title>
    <link href="http://yoursite.com/2020/11/04/%E6%95%B4%E6%95%B0%E5%88%92%E5%88%86%E4%B8%8E%E4%BA%94%E8%BE%B9%E5%BD%A2%E5%AE%9A%E7%90%86/"/>
    <id>http://yoursite.com/2020/11/04/整数划分与五边形定理/</id>
    <published>2020-11-04T03:20:47.000Z</published>
    <updated>2020-11-04T07:48:21.155Z</updated>
    
    <content type="html"><![CDATA[<p>去年沈阳栽的跟头，白送一个题没有拿到，结果现在才补。</p><h1 id="整数划分"><a href="#整数划分" class="headerlink" title="整数划分"></a>整数划分</h1><p>整数划分有很多变种，一般来说通过二维dp以及控制dp的转移策略都可以在<script type="math/tex">n^2</script>的复杂度完成。下面讨论一部分：</p><a id="more"></a><h2 id="划分成k个整数"><a href="#划分成k个整数" class="headerlink" title="划分成k个整数"></a>划分成k个整数</h2><p>设<script type="math/tex">f_{i, j}</script>为把<script type="math/tex">i</script>划分成<script type="math/tex">j</script>个数的方案，得:<script type="math/tex">f_{i, j} = f_{i - j, j} + f_{i - 1, j - 1}</script>，即整体加1或者新划分1</p><h2 id="划分成k个不重复的整数"><a href="#划分成k个不重复的整数" class="headerlink" title="划分成k个不重复的整数"></a>划分成k个不重复的整数</h2><p>设<script type="math/tex">f_{i, j}</script>为把<script type="math/tex">i</script>划分成<script type="math/tex">j</script>个数的方案，得<script type="math/tex">f_{i, j} = f_{i - j, j} + f_{i - j, j - 1}</script>，即整体加1或者整体加1后再新划分1</p><h2 id="划分成不大于m的正整数"><a href="#划分成不大于m的正整数" class="headerlink" title="划分成不大于m的正整数"></a>划分成不大于m的正整数</h2><p>设<script type="math/tex">f_{i, j}</script>为把<script type="math/tex">i</script>划分成最大数不超过<script type="math/tex">j</script>的划分数，得：<script type="math/tex">f_{i, j} = f_{i - j, j} + f_{i, j - 1}</script></p><h2 id="划分成不小于m的正整数"><a href="#划分成不小于m的正整数" class="headerlink" title="划分成不小于m的正整数"></a>划分成不小于m的正整数</h2><p>设<script type="math/tex">f_{i, j}</script>为把<script type="math/tex">i</script>划分成最小数不小于<script type="math/tex">j</script>的划分数，得：<script type="math/tex">f_{i, j} = f_{i - j, j} + f_{i, j + 1}</script></p><h2 id="划分成不大于m的不重复正整数个数"><a href="#划分成不大于m的不重复正整数个数" class="headerlink" title="划分成不大于m的不重复正整数个数"></a>划分成不大于m的不重复正整数个数</h2><p>设<script type="math/tex">f_{i, j}</script>为把<script type="math/tex">i</script>划分成最大数不超过<script type="math/tex">j</script>的划分数，得：<script type="math/tex">f_{i, j} = f_{i - j, j - 1} + f_{i, j - 1}</script></p><h2 id="划分成不小于m的不重复正整数个数"><a href="#划分成不小于m的不重复正整数个数" class="headerlink" title="划分成不小于m的不重复正整数个数"></a>划分成不小于m的不重复正整数个数</h2><p>设<script type="math/tex">f_{i, j}</script>为把<script type="math/tex">i</script>划分成最小数不小于<script type="math/tex">j</script>的划分数，得：<script type="math/tex">f_{i, j} = f_{i - j, j + 1} + f_{i, j + 1}</script></p><h2 id="划分成不大于m的不重复k个正整数"><a href="#划分成不大于m的不重复k个正整数" class="headerlink" title="划分成不大于m的不重复k个正整数"></a>划分成不大于m的不重复k个正整数</h2><p>设<script type="math/tex">f_{i, j}</script>为把<script type="math/tex">i</script>划分成<script type="math/tex">j</script>个数的方案，得<script type="math/tex">f_{i, j} = f_{i - j, j} + f_{i - j, j - 1} - f_{i - (m + 1), j - 1}</script>，整体加 1 和整体加1后再新划分1。当<script type="math/tex">i</script>大于<script type="math/tex">m</script>的时候减去最后一项，因为每次转移最多有一个大于<script type="math/tex">m</script>的数，直接扣掉贡献即可。</p><h2 id="划分成若干个奇数"><a href="#划分成若干个奇数" class="headerlink" title="划分成若干个奇数"></a>划分成若干个奇数</h2><p>设<script type="math/tex">f_{i, j}</script>为把<script type="math/tex">i</script>划分成最大数不超过<script type="math/tex">j</script>的划分数，得：</p><script type="math/tex; mode=display">f_{i, j} = f_{i - j, j - 1} + f_{i, j} \ \ \  (j \% 2 == 1)\\f_{i, j} = f_{i - j, j - 1}  \ \ \ \ \ (j \% 2 == 0)</script><h2 id="划分成k个奇数"><a href="#划分成k个奇数" class="headerlink" title="划分成k个奇数"></a>划分成k个奇数</h2><p>设<script type="math/tex">f_{i, j}</script>为把<script type="math/tex">i</script>划分成<script type="math/tex">j</script>个奇数的方案，<script type="math/tex">g_{i, j}</script>为把<script type="math/tex">i</script>划分成<script type="math/tex">j</script>个偶数的方案，得：</p><script type="math/tex; mode=display">f_{i, j} = g_{i - j, j} + f_{i - 1, j - 1}</script><script type="math/tex; mode=display">g_{i, j} = f_{i - j, j}</script><p>以上都是<script type="math/tex">n^2dp</script><br>但对于某些没限制或者弱限制的，我们可以在更好的复杂度内完成。</p><h2 id="划分成若干整数"><a href="#划分成若干整数" class="headerlink" title="划分成若干整数"></a>划分成若干整数</h2><p>考虑分块背包，<script type="math/tex">S = \sqrt(n)</script>，分为<script type="math/tex">[1, S - 1]和[S, n]</script>两部分，<br>前面直接完全背包<br>后面考虑选的数不会超过<script type="math/tex">\sqrt(n)</script>个，令<script type="math/tex">f_{i, j}</script>表示<script type="math/tex">i</script>划分成j个整数，因为这里最小整数是<script type="math/tex">S</script>，得：<script type="math/tex">f_{i, j} = f_{i - j, j} + f_{i - S, j - 1}</script><br>复杂度<script type="math/tex">O(n\sqrt(n))</script></p><h1 id="五边形数"><a href="#五边形数" class="headerlink" title="五边形数"></a>五边形数</h1><p>五边形数满足一个递推式：<script type="math/tex">f_i = f_{i - 1} + 3n - 2</script><br>可以直接得到公式:<script type="math/tex">f_i = \frac{n(3n - 1)}{2}</script><br>前几个五边形数：<script type="math/tex">1, 5, 12, 22, 35, 51, 70, 92, 117, 145, 176, 210...</script></p><h1 id="广义五边形数"><a href="#广义五边形数" class="headerlink" title="广义五边形数"></a>广义五边形数</h1><p>上述是在<script type="math/tex">n</script>取正数的时候，广义五边形数允许<script type="math/tex">n</script>取负数，值取绝对值，最后得到序列：<script type="math/tex">0, 1, 2, 5, 7, 12, 15, 22, 26, 35, 40, 51, 57, 70...</script></p><h1 id="欧拉函数"><a href="#欧拉函数" class="headerlink" title="欧拉函数"></a>欧拉函数</h1><p>欧拉函数<script type="math/tex">\phi(x) = \prod_{i = 1}^{+ \infty}(1 - x^i)</script><br>这很好理解，每一个<script type="math/tex">i</script>对应的式子代表选数<script type="math/tex">i</script>的生成函数，乘起来就是最后的划分方案数。</p><p>最后的方案数<script type="math/tex">G(x) = \prod_{i = 1}^{+ \infty}\frac{1}{1 - x^i}</script><br>于是有<script type="math/tex">G(x)\phi(x) = 1</script>。</p><p>得：<script type="math/tex">\phi(x) = \prod_{i = 1}^{+ \infty}(1 - x^i) = \sum_{-\infty}^{+\infty}(-1)^kx^{\frac{k(3k-1)}{2}} = 1 + \sum_{1}^{+\infty}(-1)^i(x^{\frac{k(3k-1)}{2}} + x^{\frac{k(3k+1)}{2}})</script></p><p>展开得<script type="math/tex">\phi(x) = (1 - x - x^2 + x^5 + x^7 - x^{12} - x^{15}....)</script></p><p>有<script type="math/tex">(1 + p_1x + p_2x^2 + p_3x^3 + ... + p_nx^n)(1 - x - x^2 + x^5 + x^7 - x^{12} - x^{15}...) = 1</script></p><p>对比<script type="math/tex">x^n</script>的系数，我们得到<script type="math/tex">p_n - p_{n - 1} - p_{n - 2} + p_{n - 5} + p_{n - 7} + ... = 0</script>，就可以得到<script type="math/tex">p_n</script>的递推式。</p><p>由五边形数的递推数我们看出大小数量级是<script type="math/tex">n^2</script>的，所以<script type="math/tex">n</script>以内五边形数个数的数量级在<script type="math/tex">\sqrt(n)</script>个，转移复杂度<script type="math/tex">O(n\sqrt(n))</script></p><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=4651" target="_blank" rel="noopener">HDU-4651 Partition</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> db;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vi;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;ll&gt; vl;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;pii&gt; vp;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">const</span> ll INF = <span class="number">1e18</span>;</span><br><span class="line"><span class="keyword">const</span> db eps = <span class="number">1e-10</span>;</span><br><span class="line"><span class="keyword">const</span> db pi = <span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> eb emplace_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ep emplace</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mem(a) memset(a, 0, sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> copy(a, b) memcpy(a, b, sizeof(b))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PA cout &lt;&lt; <span class="meta-string">"pass\n"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lowbit(x) (x &amp; -x)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(x) x.begin(), x.end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TM cout &lt;&lt; db(clock()) / CLOCKS_PER_SEC &lt;&lt; <span class="meta-string">'\n'</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">mt19937 <span class="title">mrand</span><span class="params">(chrono::high_resolution_clock::now().time_since_epoch().count())</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;<span class="title">inline</span> <span class="title">void</span> <span class="title">upmin</span>(<span class="title">T</span> &amp;<span class="title">x</span>, <span class="title">T</span> <span class="title">y</span>) &#123;</span>x = x &gt; y ? y : x;&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;<span class="title">inline</span> <span class="title">void</span> <span class="title">upmax</span>(<span class="title">T</span> &amp;<span class="title">x</span>, <span class="title">T</span> <span class="title">y</span>) &#123;</span>x = x &lt; y ? y : x;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e5</span> + <span class="number">233</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    x += y;</span><br><span class="line">    <span class="keyword">if</span>(x &gt;= mod) x -= mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sub</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    x -= y;</span><br><span class="line">    <span class="keyword">if</span>(x &lt; <span class="number">0</span>) x += mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; f;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(maxn);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i * (<span class="number">3</span> * i + <span class="number">1</span>) / <span class="number">2</span> &lt; maxn; i++)&#123;</span><br><span class="line">        f.eb(i * (<span class="number">3</span> * i - <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">        f.eb(i * (<span class="number">3</span> * i + <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; maxn; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; f.size() &amp;&amp; f[j] &lt;= i; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>((j / <span class="number">2</span>) &amp; <span class="number">1</span>) sub(sum, dp[i - f[j]]);</span><br><span class="line">            <span class="keyword">else</span> add(sum, dp[i - f[j]]);</span><br><span class="line">        &#125;</span><br><span class="line">        dp[i] = sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T, n;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>), <span class="built_in">cin</span>.tie(<span class="number">0</span>), <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; fixed &lt;&lt; setprecision(<span class="number">10</span>);</span><br><span class="line">    init();</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; dp[n] &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="每个数选择次数小于k次"><a href="#每个数选择次数小于k次" class="headerlink" title="每个数选择次数小于k次"></a>每个数选择次数小于k次</h1><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=4658" target="_blank" rel="noopener">HDU-4658 Integer Partition</a><br>考虑<script type="math/tex">G'(x) = \prod_{i = 1}^{\infty}\frac{1 - x^{ik}}{1 - x^i} = \frac{\phi(x^k)}{\phi(x)} = \phi(x^k)G(x)</script><br>展开后得<script type="math/tex">(1 - x^{k} - x^{2k} + x^{5k} + x^{7k}....)(1 + p_1x + p_2x^2 + p_3x^3 + ... + p_nx^n)</script><br>其中<script type="math/tex">x^n</script>的系数就是答案，答案为<script type="math/tex">p_n - p_{n - k} - p_{n - 2k} + p_{n + 5k} + p_{n + 7k} + ...</script></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> db;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vi;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;ll&gt; vl;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;pii&gt; vp;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">const</span> ll INF = <span class="number">1e18</span>;</span><br><span class="line"><span class="keyword">const</span> db eps = <span class="number">1e-10</span>;</span><br><span class="line"><span class="keyword">const</span> db pi = <span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> eb emplace_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ep emplace</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mem(a) memset(a, 0, sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> copy(a, b) memcpy(a, b, sizeof(b))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PA cout &lt;&lt; <span class="meta-string">"pass\n"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lowbit(x) (x &amp; -x)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(x) x.begin(), x.end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TM cout &lt;&lt; db(clock()) / CLOCKS_PER_SEC &lt;&lt; <span class="meta-string">'\n'</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">mt19937 <span class="title">mrand</span><span class="params">(chrono::high_resolution_clock::now().time_since_epoch().count())</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;<span class="title">inline</span> <span class="title">void</span> <span class="title">upmin</span>(<span class="title">T</span> &amp;<span class="title">x</span>, <span class="title">T</span> <span class="title">y</span>) &#123;</span>x = x &gt; y ? y : x;&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;<span class="title">inline</span> <span class="title">void</span> <span class="title">upmax</span>(<span class="title">T</span> &amp;<span class="title">x</span>, <span class="title">T</span> <span class="title">y</span>) &#123;</span>x = x &lt; y ? y : x;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e5</span> + <span class="number">233</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    x += y;</span><br><span class="line">    <span class="keyword">if</span>(x &gt;= mod) x -= mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sub</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    x -= y;</span><br><span class="line">    <span class="keyword">if</span>(x &lt; <span class="number">0</span>) x += mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; f;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(maxn);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i * (<span class="number">3</span> * i + <span class="number">1</span>) / <span class="number">2</span> &lt; maxn; i++)&#123;</span><br><span class="line">        f.eb(i * (<span class="number">3</span> * i - <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">        f.eb(i * (<span class="number">3</span> * i + <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; maxn; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; f.size() &amp;&amp; f[j] &lt;= i; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>((j / <span class="number">2</span>) &amp; <span class="number">1</span>) sub(sum, dp[i - f[j]]);</span><br><span class="line">            <span class="keyword">else</span> add(sum, dp[i - f[j]]);</span><br><span class="line">        &#125;</span><br><span class="line">        dp[i] = sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = dp[n];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; f.size() &amp;&amp; f[i] * k &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>((i / <span class="number">2</span>) &amp; <span class="number">1</span>) add(res, dp[n - k * f[i]]);</span><br><span class="line">        <span class="keyword">else</span> sub(res, dp[n - k * f[i]]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T, n, k;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>), <span class="built_in">cin</span>.tie(<span class="number">0</span>), <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; fixed &lt;&lt; setprecision(<span class="number">10</span>);</span><br><span class="line">    init();</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; solve(n, k) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有一种多项式的做法，但跑的巨慢无比，比根号还慢很多，就不学了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;去年沈阳栽的跟头，白送一个题没有拿到，结果现在才补。&lt;/p&gt;
&lt;h1 id=&quot;整数划分&quot;&gt;&lt;a href=&quot;#整数划分&quot; class=&quot;headerlink&quot; title=&quot;整数划分&quot;&gt;&lt;/a&gt;整数划分&lt;/h1&gt;&lt;p&gt;整数划分有很多变种，一般来说通过二维dp以及控制dp的转移策略都可以在&lt;script type=&quot;math/tex&quot;&gt;n^2&lt;/script&gt;的复杂度完成。下面讨论一部分：&lt;/p&gt;
    
    </summary>
    
      <category term="组合数学" scheme="http://yoursite.com/categories/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"/>
    
    
  </entry>
  
  <entry>
    <title>同余大杂烩</title>
    <link href="http://yoursite.com/2020/10/29/%E5%90%8C%E4%BD%99%E5%A4%A7%E6%9D%82%E7%83%A9/"/>
    <id>http://yoursite.com/2020/10/29/同余大杂烩/</id>
    <published>2020-10-29T12:07:38.000Z</published>
    <updated>2020-10-30T03:35:13.747Z</updated>
    
    <content type="html"><![CDATA[<h1 id="exgcd"><a href="#exgcd" class="headerlink" title="exgcd"></a>exgcd</h1><p>拓展欧几里得<script type="math/tex">exgcd</script>用来求方程<script type="math/tex">ax + by = gcd(a, b)</script>的一组特解，考虑运用辗转相除，假设我们得到了<script type="math/tex">a_1x_1 + b_1y_1 = gcd(a, b)</script>的解<script type="math/tex">x_1, y_1</script>，<script type="math/tex">(a_1 = b, b_1 = a - \lfloor\frac{a}{b}\rfloor * b)</script>，可以得到<script type="math/tex">y = x_1 - \lfloor\frac{a}{b}\rfloor * y_1</script>，<script type="math/tex">x = y_1</script>，所以我们可以直接交换<script type="math/tex">x, y</script>，再减去<script type="math/tex">\lfloor\frac{a}{b}\rfloor * y_1</script>即可，代码如下：<br><a id="more"></a><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ll <span class="title">exgcd</span><span class="params">(ll a, ll b, ll &amp;x, ll &amp;y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!b) &#123;</span><br><span class="line">        x = <span class="number">1</span>, y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    ll g = exgcd(b, a % b, y, x);</span><br><span class="line">    y -= x * (a / b);</span><br><span class="line">    <span class="keyword">return</span> g;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果给方程<script type="math/tex">ax + by = c</script>判断是否有解，只用判断是否有<script type="math/tex">gcd(a, b) | c</script>，求解出来后直接把<script type="math/tex">x, y</script>乘上<script type="math/tex">c / gcd(a, b)</script>即可。</p><h2 id="最小自然数解"><a href="#最小自然数解" class="headerlink" title="最小自然数解"></a>最小自然数解</h2><p>可能有些情况需要我们保证<script type="math/tex">x</script>或者<script type="math/tex">y</script>是正整数，我们先考虑通解形式。<br>我们知道每次变化都是以<script type="math/tex">gcd(a, b)</script>为最小单位，感知我们可以发现，每次改变一个单位的<script type="math/tex">x</script>，会增加<script type="math/tex">\frac{a}{gcd(a, b)}</script>个<script type="math/tex">gcd</script>，改变一个单位的<script type="math/tex">y</script>，会增加<script type="math/tex">\frac{b}{gcd(a, b)}</script>个<script type="math/tex">gcd</script>，为了保证二者能够相互约掉，最小的改变的一步应该为<script type="math/tex">\frac{ab}{gcd(a, b)}</script>，那么通解形式为：</p><script type="math/tex; mode=display">x = a(x_0 + \frac{b}{gcd(a, b)}), y = b(y_0 + \frac{a}{gcd(a, b)})</script><p>换句话说，对于<script type="math/tex">x</script>的解空间，它们在模<script type="math/tex">\frac{b}{gcd(a, b)}</script>下是一个等价类，对于<script type="math/tex">y</script>的解空间，它们在模<script type="math/tex">\frac{a}{gcd(a, b)}</script>下是一个等价类。</p><p>于是我们可以求最小自然数解，如<script type="math/tex">x</script>，直接拿特解对<script type="math/tex">\frac{b}{gcd(a, b)}</script>求模意义下的最小自然数等价类，算出对应的<script type="math/tex">y</script>即可得到答案</p><h2 id="求逆元"><a href="#求逆元" class="headerlink" title="求逆元"></a>求逆元</h2><p>求逆元我们习惯用费马小定理，但当<script type="math/tex">p</script>不是质数但是与<script type="math/tex">a</script>互质的时候，这时候存在逆元，却不能用费马小定理求逆元了，于是我们考虑用<script type="math/tex">exgcd</script>求逆元。<br>方程<script type="math/tex">a_x \equiv (1 \ mod \ p)</script>等价于存在一个<script type="math/tex">b使得ax - bp = 1</script>，于是只需要用<script type="math/tex">exgcd</script>求方程的解就行了，注意求出来后<script type="math/tex">x</script>可能是负数，需要对<script type="math/tex">p</script>取模求模意义下的最小自然数等价类。</p><h1 id="中国剩余定理"><a href="#中国剩余定理" class="headerlink" title="中国剩余定理"></a>中国剩余定理</h1><h2 id="中国剩余定理-1"><a href="#中国剩余定理-1" class="headerlink" title="中国剩余定理"></a>中国剩余定理</h2><p>中国剩余定理用来求解同余方程组</p><script type="math/tex; mode=display">\begin{cases}x \equiv a_1(mod \ m_1)\\x \equiv a_2(mod \ m_2)\\x \equiv a_3(mod \ m_3)\\... \\x \equiv a_n(mod \ m_n)\\\end{cases}</script><p>其中<script type="math/tex">m_1, m_2, m_3, \cdots, m_n</script>是两两互质的数<br>一般是求<script type="math/tex">x</script>的最小正整数解</p><h3 id="定理"><a href="#定理" class="headerlink" title="定理"></a>定理</h3><p>令<script type="math/tex">M = \prod_{i = 1}^n m_i</script>, <script type="math/tex">\frac{M}{m_i}t_i \equiv 1</script><br>有一个特解为<script type="math/tex">x = \sum_{i = 1}^na_i\frac{M}{m_i}t_i</script><br>最小非负整数解为<script type="math/tex">(x \% M + M) % M</script><br>证明非常容易，代入原来的<script type="math/tex">n</script>个条件发现都满足。</p><p>中国剩余定理常用来辅助解决一些题目，一些题目对合数取模不好做的时候，可以对其所有质因子次方项取模求答案，最后再用<script type="math/tex">crt</script>合并答案。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ll <span class="title">crt</span><span class="params">(<span class="built_in">vector</span>&lt;ll&gt; &amp;m, <span class="built_in">vector</span>&lt;ll&gt; &amp;a)</span></span>&#123;</span><br><span class="line">    ll M = <span class="number">1</span>, res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m.size(); i++) M *= m[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m.size(); i++)&#123;</span><br><span class="line">        ll w = M / m[i];</span><br><span class="line">        ll t = Ex_gcd::inv(w, m[i]);</span><br><span class="line">        <span class="comment">//res = (res + t * w * a[i]) % M;</span></span><br><span class="line">        res = (res + mul(mul(t, w, M), a[i], M)) % M; <span class="comment">//防止爆long long</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (res % M + M) % M;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="拓展中国剩余定理"><a href="#拓展中国剩余定理" class="headerlink" title="拓展中国剩余定理"></a>拓展中国剩余定理</h2><p>当所有<script type="math/tex">m_i</script>之间不满足两两互质的情况，这时候就要用到拓展中国剩余定理。</p><h3 id="定理-1"><a href="#定理-1" class="headerlink" title="定理"></a>定理</h3><p>假设我们求出前<script type="math/tex">k - 1</script>个方程的解为<script type="math/tex">x</script>，且<script type="math/tex">M = lcm(\prod_{i = 1}^{k - 1}m_i)</script>，则前<script type="math/tex">k - 1</script>个方程的通解为<script type="math/tex">x + iM</script>。<br>考虑加入第<script type="math/tex">k</script>个方程，需要求一个<script type="math/tex">t</script>满足<script type="math/tex">x + tM \equiv (a_k \ mod \ m_k)</script>，转换一下即求<script type="math/tex">bm_k + tM \equiv(a_k - x \ mod \ m_k)</script>，这玩意可以用<script type="math/tex">exgcd</script>求解，当<script type="math/tex">gcd(m_k, M) | a_k - x</script>满足时才有解。求出对应的<script type="math/tex">t</script>后，我们需要将其扩大<script type="math/tex">\frac{a_k - x}{gcd(m_k, M)}</script>倍，且根据上面我们知道它的最小周期为<script type="math/tex">\frac{M}{gcd(M, m_i)}</script>，直接对其取模即可（注意过程中可能爆，所以用龟速乘）。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ll <span class="title">mul</span><span class="params">(ll q, ll w, ll mod)</span></span>&#123;</span><br><span class="line">    ll ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(w)&#123;</span><br><span class="line">        <span class="keyword">if</span>(w &amp; <span class="number">1</span>) ret = (ret + q) % mod;</span><br><span class="line">        q = (q + q) % mod;</span><br><span class="line">        w &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">excrt</span><span class="params">(<span class="built_in">vector</span>&lt;ll&gt; &amp;m, <span class="built_in">vector</span>&lt;ll&gt; &amp;a)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    ll M = m[<span class="number">0</span>], res = a[<span class="number">0</span>], x, y;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m.size(); i++)&#123;</span><br><span class="line">        ll c = (a[i] - res % m[i] + m[i]) % m[i];</span><br><span class="line">        ll g = Ex_gcd::exgcd(M, m[i], x, y);</span><br><span class="line">        <span class="keyword">if</span>(c % g) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        ll bg = m[i] / g;</span><br><span class="line">        x = mul(x, c / g, bg);</span><br><span class="line">        res += x * M;</span><br><span class="line">        M *= bg;</span><br><span class="line">        res = (res % M + M) % M;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (res % M + M) % M;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="卢卡斯定理"><a href="#卢卡斯定理" class="headerlink" title="卢卡斯定理"></a>卢卡斯定理</h1><p>对于一般的组合数满足<script type="math/tex">n, m << p</script>的<script type="math/tex">C_n^m \ mod \ p</script>，我们预处理阶乘，然后用阶乘及逆元去做。但是当<script type="math/tex">n, m > p</script>的时候，预处理阶乘就不行了，这时候阶乘永远求出来结果是0，但是可能真实答案不是0。<br>卢卡斯定理用来计算这一类问题。</p><h2 id="卢卡斯定理-1"><a href="#卢卡斯定理-1" class="headerlink" title="卢卡斯定理"></a>卢卡斯定理</h2><p>当<script type="math/tex">p</script>是质数的时候，有如下性质：</p><script type="math/tex; mode=display">C_n^m \ mod \ p = C_{n \% p}^{m \% p}C_{n / p}^{m / p}</script><p>证明略过。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ll <span class="title">C</span><span class="params">(ll n, ll m, ll p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt; <span class="number">0</span> || n &lt; m || m &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> fac[n] * inv[m] % p * inv[n - m] % p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">lucas</span><span class="params">(ll n, ll m, ll p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!m) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> C(n % p, m % p, p) * lucas(n / p, m / p, p) % p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="拓展卢卡斯定理"><a href="#拓展卢卡斯定理" class="headerlink" title="拓展卢卡斯定理"></a>拓展卢卡斯定理</h2><p>当<script type="math/tex">p</script>不是质数，上面的性质就不成立了，我们只能来冷静分析一波。<br>这时候就要用上<script type="math/tex">crt</script>的套路了，考虑把<script type="math/tex">p</script>分解成一部分因子相乘，每个因子都只包含一种质数，这样各个因子之间就是互质的，我们对这些因子求答案，再用<script type="math/tex">crt</script>合并。</p><h3 id="求解-C-n-m-mod-p-i-k"><a href="#求解-C-n-m-mod-p-i-k" class="headerlink" title="求解$C_n^m  mod  p_i^k$"></a>求解$C_n^m  mod  p_i^k$</h3><p>这玩意也不能直接套用卢卡斯定理，我们考虑将<script type="math/tex">C_n^m</script>里面所有<script type="math/tex">p_i</script>的因子提出来，算剩下部分的贡献，即变为<script type="math/tex">\frac{\frac{n!}{p_i^a}}{\frac{m!}{p_i^b}\frac{(n - m)!}{p_i^c}}p_i^{a - b - c}</script></p><p>问题变成了求<script type="math/tex">\frac{n!}{p_i^a} \ mod \ p_i^k \ mod \ p_i^k</script></p><h3 id="求解-frac-n-p-i-a-mod-p-i-k"><a href="#求解-frac-n-p-i-a-mod-p-i-k" class="headerlink" title="求解$\frac{n!}{p_i^a}  mod  p_i^k$"></a>求解$\frac{n!}{p_i^a}  mod  p_i^k$</h3><p>我们把<script type="math/tex">n!</script>贡献分为三部分：</p><ul><li><script type="math/tex">p_i</script>的次方</li><li><script type="math/tex">\lfloor\frac{n}{p_i}\rfloor</script>!</li><li>非<script type="math/tex">p_i</script>倍数部分的余数</li></ul><p>举个例子<script type="math/tex">n = 22, p = 3</script></p><script type="math/tex; mode=display">22! = 3^7 * (7!) * (1 * 2 * 4 * 5 * 7 * 8 * 10 * 11 * 13 * 14 * 16 * 17 * 19 * 20 * 22)</script><p>第一部分就是<script type="math/tex">3^7</script>，因为我们在外面会去掉所有<script type="math/tex">p_i</script>，所以没有贡献。<br>第二部分是<script type="math/tex">7!</script>，直接递归下去做。<br>第三部分分为两个part，一个是完整的模<script type="math/tex">p_i</script>周期内，所有完整周期内非<script type="math/tex">p_i</script>倍数的乘积的余数都是一样的，直接算一个周期然后快速幂即可，最后可能还剩一部分非完整的，剩下的部分直接暴力算即可。<br><strong>tips</strong>:预处理阶乘会快很多</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> Lucas&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;ll&gt; fac;</span><br><span class="line"></span><br><span class="line">    <span class="function">ll <span class="title">pow_mod</span><span class="params">(ll q, ll w, ll mod)</span></span>&#123;</span><br><span class="line">        ll ret = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(w)&#123;</span><br><span class="line">            <span class="keyword">if</span>(w &amp; <span class="number">1</span>) ret = ret * q % mod;</span><br><span class="line">            q = q * q % mod;</span><br><span class="line">            w &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ll <span class="title">solve_fac</span><span class="params">(ll n, ll p, ll pk)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!n) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> pow_mod(fac[pk], n / pk, pk) * fac[n % pk] % pk * solve_fac(n / p, p, pk) % pk;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ll <span class="title">cal</span><span class="params">(ll n, ll m, ll p)</span></span>&#123;</span><br><span class="line">        ll cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(ll i = n; i; i /= p) cnt += i / p;</span><br><span class="line">        <span class="keyword">for</span>(ll i = m; i; i /= p) cnt -= i / p;</span><br><span class="line">        <span class="keyword">for</span>(ll i = n - m; i; i /= p) cnt -= i / p;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ll <span class="title">C</span><span class="params">(ll n, ll m, ll p, ll pk)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt; m) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        fac.resize(pk + <span class="number">1</span>);</span><br><span class="line">        fac[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= pk; i++)&#123;</span><br><span class="line">            fac[i] = fac[i - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(i % p) fac[i] = fac[i] * i % pk;</span><br><span class="line">        &#125;</span><br><span class="line">        ll a = solve_fac(n, p, pk);</span><br><span class="line">        ll b = solve_fac(m, p, pk);</span><br><span class="line">        ll c = solve_fac(n - m, p, pk);</span><br><span class="line">        ll cnt = cal(n, m, p);</span><br><span class="line">        <span class="keyword">return</span> a * Ex_gcd::inv(b, pk) % pk * Ex_gcd::inv(c, pk) % pk * pow_mod(p, cnt, pk) % pk;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ll <span class="title">exlucas</span><span class="params">(ll n, ll m, ll mod)</span></span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;ll&gt; a, b;</span><br><span class="line">        <span class="keyword">for</span>(ll i = <span class="number">2</span>; i * i &lt;= mod &amp;&amp; mod &gt; <span class="number">1</span>; i++)&#123;</span><br><span class="line">            ll tmp = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(mod % i == <span class="number">0</span>) mod /= i, tmp *= i;</span><br><span class="line">            <span class="keyword">if</span>(tmp &gt; <span class="number">1</span>) b.push_back(C(n, m, i, tmp)), a.push_back(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(mod &gt; <span class="number">1</span>) b.push_back(C(n, m, mod, mod)), a.push_back(mod);</span><br><span class="line">        <span class="keyword">return</span> CRT::crt(a, b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;exgcd&quot;&gt;&lt;a href=&quot;#exgcd&quot; class=&quot;headerlink&quot; title=&quot;exgcd&quot;&gt;&lt;/a&gt;exgcd&lt;/h1&gt;&lt;p&gt;拓展欧几里得&lt;script type=&quot;math/tex&quot;&gt;exgcd&lt;/script&gt;用来求方程&lt;script type=&quot;math/tex&quot;&gt;ax + by = gcd(a, b)&lt;/script&gt;的一组特解，考虑运用辗转相除，假设我们得到了&lt;script type=&quot;math/tex&quot;&gt;a_1x_1 + b_1y_1 = gcd(a, b)&lt;/script&gt;的解&lt;script type=&quot;math/tex&quot;&gt;x_1, y_1&lt;/script&gt;，&lt;script type=&quot;math/tex&quot;&gt;(a_1 = b, b_1 = a - \lfloor\frac{a}{b}\rfloor * b)&lt;/script&gt;，可以得到&lt;script type=&quot;math/tex&quot;&gt;y = x_1 - \lfloor\frac{a}{b}\rfloor * y_1&lt;/script&gt;，&lt;script type=&quot;math/tex&quot;&gt;x = y_1&lt;/script&gt;，所以我们可以直接交换&lt;script type=&quot;math/tex&quot;&gt;x, y&lt;/script&gt;，再减去&lt;script type=&quot;math/tex&quot;&gt;\lfloor\frac{a}{b}\rfloor * y_1&lt;/script&gt;即可，代码如下：&lt;br&gt;
    
    </summary>
    
      <category term="数论" scheme="http://yoursite.com/categories/%E6%95%B0%E8%AE%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>Polya定理, Start Dash!</title>
    <link href="http://yoursite.com/2020/10/10/Polya%E5%AE%9A%E7%90%86-Start-Dash/"/>
    <id>http://yoursite.com/2020/10/10/Polya定理-Start-Dash/</id>
    <published>2020-10-10T08:09:58.000Z</published>
    <updated>2020-10-11T18:54:36.736Z</updated>
    
    <content type="html"><![CDATA[<p><strong>如果能为了某个人变强，对于悲伤我也心存感激~</strong></p><h1 id="Polya简介"><a href="#Polya简介" class="headerlink" title="Polya简介"></a>Polya简介</h1><p>Polya定理用来解决旋转，对称同构的计数问题，其定理形式简单，但变种问题十分多且有趣。</p><h2 id="前置"><a href="#前置" class="headerlink" title="前置"></a>前置</h2><ul><li>置换</li><li>数论<br>本文不打算讲前置内容以及定理的证明</li></ul><h2 id="定理内容"><a href="#定理内容" class="headerlink" title="定理内容"></a>定理内容</h2><script type="math/tex; mode=display">M = \frac{1}{G}\sum_{i = 1}^gf(c_i)</script><p>其中<script type="math/tex">c_i</script>表示第i种置换中循环节的个数。</p><p>用简单的话来说，<script type="math/tex">Polya</script>就是找到所有的置换，然后对每一种置换找到循环节个数，同一个循环节看成一个不动点（如染色问题中循环节内的所有点必须是同一种颜色），算出该置换下的方案数，对所有置换的方案数求和后平均。</p><p>那么问题很明显可以划分为两个步骤：</p><ul><li>找到置换</li><li>算出置换下的方案数</li></ul><p>难题可能是在这两个步骤的某一步中比较不好处理，但所有的<script type="math/tex">Polya</script>题目无外乎都要这么考虑</p><a id="more"></a><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="http://poj.org/problem?id=2154" target="_blank" rel="noopener">poj-2154</a><br>将正n边形的n个顶点用n种颜色染色，问有多少种方案？<br>考虑置换，可能是旋转，有n种情况(旋转1,2,3<script type="math/tex">\cdots</script>n个点)。本题说了不考虑翻转，所以就没有翻转对应的置换。<br>考虑旋转长度为i，此时循环节的个数就为<script type="math/tex">gcd(n, i)</script>，那么问题变成了求<script type="math/tex">\sum_{i = 1}^nn^{gcd(n, i) - 1}</script>。由于n很大，直接枚举就起飞了，考虑数论优化。</p><script type="math/tex; mode=display">\sum_{i = 1}^nn^{gcd(n, i)} = \sum_{d | n}n^d\sum_{i = 1}^{\frac{n}{d}}[gcd(i, \frac{n}{d}) == 1]</script><p>我们发现<script type="math/tex">\sum_{i = 1}^{\frac{n}{d}}[gcd(i, \frac{n}{d}) == 1] = \phi(\frac{n}{d})</script><br>于是有<script type="math/tex">\sum_{i = 1}^nn^{gcd(i, n)} = \sum_{d | n}n^d\phi(\frac{n}{d})</script><br>枚举因子，直接暴力算<script type="math/tex">phi</script>函数即可优化到<script type="math/tex">O(\sqrt(n))</script></p><div><div class="fold_hider"><div class="close hider_title">代码</div></div><div class="fold"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> db;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vi;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;ll&gt; vl;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;pii&gt; vp;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">const</span> ll INF = <span class="number">1e18</span>;</span><br><span class="line"><span class="keyword">const</span> db eps = <span class="number">1e-10</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> eb emplace_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ep emplace</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mem(a) memset(a, 0, sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> copy(a, b) memcpy(a, b, sizeof(b))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PA cout &lt;&lt; <span class="meta-string">"pass\n"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lowbit(x) (x &amp; -x)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(x) x.begin(), x.end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TM cout &lt;&lt; db(clock()) / CLOCKS_PER_SEC &lt;&lt; <span class="meta-string">'\n'</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;<span class="title">inline</span> <span class="title">void</span> <span class="title">upmin</span>(<span class="title">T</span> &amp;<span class="title">x</span>, <span class="title">T</span> <span class="title">y</span>) &#123;</span>x = x &gt; y ? y : x;&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;<span class="title">inline</span> <span class="title">void</span> <span class="title">upmax</span>(<span class="title">T</span> &amp;<span class="title">x</span>, <span class="title">T</span> <span class="title">y</span>) &#123;</span>x = x &lt; y ? y : x;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">euler</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = n, a = n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i * i &lt;= a; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a % i == <span class="number">0</span>) &#123;</span><br><span class="line">            res = res / i * (i - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">while</span> (a % i == <span class="number">0</span>) a /= i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (a &gt; <span class="number">1</span>) res = res / a * (a - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T, n, p;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pow_mod</span><span class="params">(<span class="keyword">int</span> q, <span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">1</span>;</span><br><span class="line">    q %= p;</span><br><span class="line">    <span class="keyword">while</span>(w)&#123;</span><br><span class="line">        <span class="keyword">if</span>(w &amp; <span class="number">1</span>) ret = ret * q % p;</span><br><span class="line">        q = q * q % p;</span><br><span class="line">        w &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>), <span class="built_in">cin</span>.tie(<span class="number">0</span>), <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; p;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i * i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(n % i == <span class="number">0</span>)&#123;</span><br><span class="line">                res = (res + euler(n / i) % p * pow_mod(n, i - <span class="number">1</span>)) % p;</span><br><span class="line">                <span class="keyword">if</span>(n / i != i)&#123;</span><br><span class="line">                    res = (res + euler(i) % p * pow_mod(n, n / i - <span class="number">1</span>)) % p;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><p><a href="https://ac.nowcoder.com/acm/problem/54301" target="_blank" rel="noopener">远山的占卜</a><br>把对角的提出来算好方案数，然后就变成跟上一个题一模一样的题了，数据范围有些不一样，所以预处理好<script type="math/tex">phi</script>函数即可。<br><div><div class="fold_hider"><div class="close hider_title">代码</div></div><div class="fold"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> db;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vi;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;ll&gt; vl;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;pii&gt; vp;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">const</span> ll INF = <span class="number">1e18</span>;</span><br><span class="line"><span class="keyword">const</span> db eps = <span class="number">1e-10</span>;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> eb emplace_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ep emplace</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mem(a) memset(a, 0, sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> copy(a, b) memcpy(a, b, sizeof(b))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PA cout &lt;&lt; <span class="meta-string">"pass\n"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lowbit(x) (x &amp; -x)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(x) x.begin(), x.end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TM cout &lt;&lt; db(clock()) / CLOCKS_PER_SEC &lt;&lt; <span class="meta-string">'\n'</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> T, n, k;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">19260817</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = mod;</span><br><span class="line"><span class="keyword">int</span> phi[maxn];</span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line">vi prime;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    phi[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; maxn; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!vis[i]) prime.eb(i), phi[i] = i - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; prime.size() &amp;&amp; i * prime[j] &lt; maxn; ++j) &#123;</span><br><span class="line">            vis[i * prime[j]] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(i % prime[j] == <span class="number">0</span>) &#123;</span><br><span class="line">                phi[i * prime[j]] = phi[i] * prime[j];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            phi[i * prime[j]] = phi[i] * phi[prime[j]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">ll <span class="title">pow_mod</span><span class="params">(ll q, ll w)</span></span>&#123;</span><br><span class="line">    ll ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(w)&#123;</span><br><span class="line">        <span class="keyword">if</span>(w &amp; <span class="number">1</span>) ret = <span class="number">1l</span>l * ret * q % mod;</span><br><span class="line">        q = <span class="number">1l</span>l * q * q % mod;</span><br><span class="line">        w &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>), <span class="built_in">cin</span>.tie(<span class="number">0</span>), <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    init();</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k;</span><br><span class="line">        ll res = <span class="number">0</span>, base = <span class="number">1l</span>l * k * (k + <span class="number">1</span>) / <span class="number">2</span> % mod;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i * i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(n % i) <span class="keyword">continue</span>;</span><br><span class="line">            res = (res + <span class="number">1l</span>l * phi[n / i] * pow_mod(base, i)) % mod;</span><br><span class="line">            <span class="keyword">if</span>(i * i == n) <span class="keyword">continue</span>;</span><br><span class="line">            res = (res + <span class="number">1l</span>l * phi[i] * pow_mod(base, n / i)) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; res * pow_mod(n, mod - 2) % mod &lt;&lt; '\n';</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></p><p><a href="http://poj.org/problem?id=2888" target="_blank" rel="noopener">poj-2888</a><br>还是项链问题，但是有些被颜色不能相邻，求方案数。</p><p>还是依次枚举置换，找到置换的循环节个数，问题就变成了求长度为x的带限制的项链问题的方案数。<br>考虑dp，当前点选了什么颜色，可以通过dp构建一个矩阵来转移，通过矩阵快速幂即可算出方案数，最后求和就行了。</p><div><div class="fold_hider"><div class="close hider_title">代码</div></div><div class="fold"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> db;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vi;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;ll&gt; vl;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;pii&gt; vp;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">const</span> ll INF = <span class="number">1e18</span>;</span><br><span class="line"><span class="keyword">const</span> db eps = <span class="number">1e-10</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> eb emplace_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ep emplace</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mem(a) memset(a, 0, sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> copy(a, b) memcpy(a, b, sizeof(b))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PA cout &lt;&lt; <span class="meta-string">"pass\n"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lowbit(x) (x &amp; -x)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(x) x.begin(), x.end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TM cout &lt;&lt; db(clock()) / CLOCKS_PER_SEC &lt;&lt; <span class="meta-string">'\n'</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;<span class="title">inline</span> <span class="title">void</span> <span class="title">upmin</span>(<span class="title">T</span> &amp;<span class="title">x</span>, <span class="title">T</span> <span class="title">y</span>) &#123;</span>x = x &gt; y ? y : x;&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;<span class="title">inline</span> <span class="title">void</span> <span class="title">upmax</span>(<span class="title">T</span> &amp;<span class="title">x</span>, <span class="title">T</span> <span class="title">y</span>) &#123;</span>x = x &lt; y ? y : x;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T, n, m, k;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">matrix</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> mp[<span class="number">10</span>][<span class="number">10</span>];</span><br><span class="line">    matrix()&#123;</span><br><span class="line">        mem(mp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) mp[i][i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;base;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">9973</span>;</span><br><span class="line"></span><br><span class="line">matrix <span class="keyword">operator</span> * (<span class="keyword">const</span> matrix a, <span class="keyword">const</span> matrix b)&#123;</span><br><span class="line">    matrix c;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> t = <span class="number">0</span>; t &lt; m; t++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; ++j) &#123;</span><br><span class="line">                c.mp[i][j] = (c.mp[i][j] + a.mp[i][t] * b.mp[t][j]) % mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">matrix <span class="title">pow_mod</span><span class="params">(matrix q, <span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">    matrix ret;</span><br><span class="line">    ret.init();</span><br><span class="line">    <span class="keyword">while</span>(w)&#123;</span><br><span class="line">        <span class="keyword">if</span>(w &amp; <span class="number">1</span>) ret = ret * q;</span><br><span class="line">        q = q * q;</span><br><span class="line">        w &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pow_mod</span><span class="params">(<span class="keyword">int</span> q, <span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">1</span>;</span><br><span class="line">    q %= mod;</span><br><span class="line">    <span class="keyword">while</span>(w)&#123;</span><br><span class="line">        <span class="keyword">if</span>(w &amp; <span class="number">1</span>) ret = ret * q % mod;</span><br><span class="line">        q = q * q % mod;</span><br><span class="line">        w &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">euler</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = n, a = n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i * i &lt;= a; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a % i == <span class="number">0</span>) &#123;</span><br><span class="line">            res = res / i * (i - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">while</span> (a % i == <span class="number">0</span>) a /= i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (a &gt; <span class="number">1</span>) res = res / a * (a - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    matrix c = pow_mod(base, x);</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) res = (res + c.mp[i][i]) % mod;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>), <span class="built_in">cin</span>.tie(<span class="number">0</span>), <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++)&#123;</span><br><span class="line">                base.mp[i][j] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> x, y;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y;</span><br><span class="line">            x--, y--;</span><br><span class="line">            base.mp[x][y] = base.mp[y][x] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i * i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(n % i == <span class="number">0</span>)&#123;</span><br><span class="line">                res = (res + euler(n / i) % mod * solve(i)) % mod;</span><br><span class="line">                <span class="keyword">if</span>(n / i != i)&#123;</span><br><span class="line">                    res = (res + euler(i) % mod * solve(n / i)) % mod;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; res * pow_mod(n, mod - 2) % mod &lt;&lt; '\n';</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><p><a href="https://codeforces.com/gym/259514/problem/J" target="_blank" rel="noopener">2019 ICPC Asia Nanchang Onsite-J Summon</a><br>然后你就发现这个题就是上个题的加强版，限制从相邻变成了连续四个，其它的思路基本完全一样。只是注意复杂度，如果用快速幂复杂度为<script type="math/tex">O(64 * 64 * 64 * \sqrt(100000) * log)</script>会T，得想办法把log去掉，于是我们预处理分块，对于某一个幂次只需要<script type="math/tex">O(64^3)</script>即可计算得出，记得枚举因子或者记忆化求解即可。</p><div><div class="fold_hider"><div class="close hider_title">代码</div></div><div class="fold"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> db;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vi;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;ll&gt; vl;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;pii&gt; vp;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">const</span> ll INF = <span class="number">1e18</span>;</span><br><span class="line"><span class="keyword">const</span> db eps = <span class="number">1e-10</span>;</span><br><span class="line"><span class="keyword">const</span> db pi = <span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> eb emplace_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ep emplace</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mem(a) memset(a, 0, sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> copy(a, b) memcpy(a, b, sizeof(b))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PA cout &lt;&lt; <span class="meta-string">"pass\n"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lowbit(x) (x &amp; -x)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(x) x.begin(), x.end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TM cout &lt;&lt; db(clock()) / CLOCKS_PER_SEC &lt;&lt; <span class="meta-string">'\n'</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">mt19937 <span class="title">mrand</span><span class="params">(chrono::high_resolution_clock::now().time_since_epoch().count())</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;<span class="title">inline</span> <span class="title">void</span> <span class="title">upmin</span>(<span class="title">T</span> &amp;<span class="title">x</span>, <span class="title">T</span> <span class="title">y</span>) &#123;</span>x = x &gt; y ? y : x;&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;<span class="title">inline</span> <span class="title">void</span> <span class="title">upmax</span>(<span class="title">T</span> &amp;<span class="title">x</span>, <span class="title">T</span> <span class="title">y</span>) &#123;</span>x = x &lt; y ? y : x;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">400</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">matrix</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> mp[<span class="number">70</span>][<span class="number">70</span>];</span><br><span class="line"></span><br><span class="line">    matrix()&#123;</span><br><span class="line">        mem(mp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">64</span>; i++) mp[i][i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;a[maxn + <span class="number">10</span>], b[maxn + <span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">matrix <span class="keyword">operator</span> * (<span class="keyword">const</span> matrix a, <span class="keyword">const</span> matrix b)&#123;</span><br><span class="line">    matrix c;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">64</span>; k++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">64</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">64</span>; j++)&#123;</span><br><span class="line">                c.mp[i][j] = (c.mp[i][j] + <span class="number">1l</span>l * a.mp[i][k] * b.mp[k][j]) % mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ban[<span class="number">4</span>][<span class="number">4</span>][<span class="number">4</span>][<span class="number">4</span>];</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> res[<span class="number">100005</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> i * <span class="number">4</span> * <span class="number">4</span> + j * <span class="number">4</span> + k;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(res[x] != <span class="number">-1</span>) <span class="keyword">return</span> res[x];</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    matrix c = b[x / maxn] * a[x % maxn];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">64</span>; i++) ans = (ans + c.mp[i][i]) % mod;</span><br><span class="line">    res[x] = ans;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pow_mod</span><span class="params">(<span class="keyword">int</span> q, <span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(w)&#123;</span><br><span class="line">        <span class="keyword">if</span>(w &amp; <span class="number">1</span>) ret = <span class="number">1l</span>l * ret * q % mod;</span><br><span class="line">        q = <span class="number">1l</span>l * q * q % mod;</span><br><span class="line">        w &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>), <span class="built_in">cin</span>.tie(<span class="number">0</span>), <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; fixed &lt;&lt; setprecision(<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> q, w, e, r;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; q &gt;&gt; w &gt;&gt; e &gt;&gt; r;</span><br><span class="line">        ban[q][w][e][r] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; k++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> p = <span class="number">0</span>; p &lt; <span class="number">4</span>; p++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(!ban[i][j][k][p])a[<span class="number">1</span>].mp[get(i, j, k)][get(j, k, p)] = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(res, <span class="number">-1</span>, <span class="keyword">sizeof</span>(res));</span><br><span class="line">    a[<span class="number">0</span>].init();</span><br><span class="line">    b[<span class="number">0</span>].init();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= maxn; i++)&#123;</span><br><span class="line">        a[i] = a[i - <span class="number">1</span>] * a[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    b[<span class="number">1</span>] = a[maxn];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= maxn; i++)&#123;</span><br><span class="line">        b[i] = b[i - <span class="number">1</span>] * b[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        ans = (ans + solve(__gcd(n, i))) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; 1ll * ans * pow_mod(n, mod - 2) % mod &lt;&lt; '\n';</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=2481" target="_blank" rel="noopener">hdu-2481</a><br>还是旋转，考虑旋转后变成了求解<script type="math/tex">f(x)</script>的子问题，</p><p>关于<script type="math/tex">f(n)</script>有递推公式<script type="math/tex">f(n) = 3f(n - 1) - f(n - 2) + 2</script>（怎么来的后面再研究）<br>根据这个公示可以构造矩阵快速幂，于是跟poj-2888基本一样了。</p><p>注意这里P不是质数，所以最后除以n的时候会比较难办，有一个办法是把P先乘上n，然后对这个P’取模，最后结果再除以n即可，这样就需要开__int128了。</p><div><div class="fold_hider"><div class="close hider_title">代码</div></div><div class="fold"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> __int128 i128;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> db;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vi;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;ll&gt; vl;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;pii&gt; vp;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">const</span> ll INF = <span class="number">1e18</span>;</span><br><span class="line"><span class="keyword">const</span> db eps = <span class="number">1e-10</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> eb emplace_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ep emplace</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mem(a) memset(a, 0, sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> copy(a, b) memcpy(a, b, sizeof(b))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PA cout &lt;&lt; <span class="meta-string">"pass\n"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lowbit(x) (x &amp; -x)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(x) x.begin(), x.end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TM cout &lt;&lt; db(clock()) / CLOCKS_PER_SEC &lt;&lt; <span class="meta-string">'\n'</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;<span class="title">inline</span> <span class="title">void</span> <span class="title">upmin</span>(<span class="title">T</span> &amp;<span class="title">x</span>, <span class="title">T</span> <span class="title">y</span>) &#123;</span>x = x &gt; y ? y : x;&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;<span class="title">inline</span> <span class="title">void</span> <span class="title">upmax</span>(<span class="title">T</span> &amp;<span class="title">x</span>, <span class="title">T</span> <span class="title">y</span>) &#123;</span>x = x &lt; y ? y : x;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">matrix</span>&#123;</span></span><br><span class="line">    ll mp[<span class="number">3</span>][<span class="number">3</span>];</span><br><span class="line">    matrix()&#123;</span><br><span class="line">        mem(mp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) mp[i][i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;base, s;</span><br><span class="line"></span><br><span class="line">ll mod;</span><br><span class="line"></span><br><span class="line">matrix <span class="keyword">operator</span> * (<span class="keyword">const</span> matrix a, <span class="keyword">const</span> matrix b)&#123;</span><br><span class="line">    matrix c;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> t = <span class="number">0</span>; t &lt; <span class="number">3</span>; t++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; ++j) &#123;</span><br><span class="line">                c.mp[i][j] = (c.mp[i][j] + i128(a.mp[i][t]) * b.mp[t][j]) % mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">matrix <span class="title">pow_mod</span><span class="params">(matrix q, ll w)</span></span>&#123;</span><br><span class="line">    matrix ret;</span><br><span class="line">    ret.init();</span><br><span class="line">    <span class="keyword">while</span>(w)&#123;</span><br><span class="line">        <span class="keyword">if</span>(w &amp; <span class="number">1</span>) ret = ret * q;</span><br><span class="line">        q = q * q;</span><br><span class="line">        w &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">euler</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = n, a = n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i * i &lt;= a; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a % i == <span class="number">0</span>) &#123;</span><br><span class="line">            res = res / i * (i - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">while</span> (a % i == <span class="number">0</span>) a /= i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (a &gt; <span class="number">1</span>) res = res / a * (a - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, p;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">solve</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">    matrix c = pow_mod(base, x - <span class="number">2</span>) * s;</span><br><span class="line">    <span class="keyword">return</span> c.mp[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>), <span class="built_in">cin</span>.tie(<span class="number">0</span>), <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    s.mp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">5</span>;</span><br><span class="line">    s.mp[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    s.mp[<span class="number">2</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; p)&#123;</span><br><span class="line">        mod = <span class="number">1l</span>l * n * p;</span><br><span class="line">        base.mp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">3</span>;</span><br><span class="line">        base.mp[<span class="number">0</span>][<span class="number">1</span>] = mod - <span class="number">1</span>;</span><br><span class="line">        base.mp[<span class="number">0</span>][<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">        base.mp[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        base.mp[<span class="number">2</span>][<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">        ll res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i * i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(n % i == <span class="number">0</span>)&#123;</span><br><span class="line">                res = (res + i128(euler(n / i)) * solve(i)) % mod;</span><br><span class="line">                <span class="keyword">if</span>(n / i != i)&#123;</span><br><span class="line">                    res = (res + i128(euler(i)) * solve(n / i)) % mod;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; res / n &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><p><a href="https://nanti.jisuanke.com/t/A1423" target="_blank" rel="noopener">ACM-ICPC 2017 Asia Qingdao-Floppy Cube</a><br>我们发现所有置换都可以由三种操作得到：沿正视图右选90°，向上翻转180°，沿俯视图右旋180°。<br>所以我们通过bfs找到所有置换，然后得到每个置换的循环节个数，即可算出最后的方案数。</p><div><div class="fold_hider"><div class="close hider_title">代码</div></div><div class="fold"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> __int128 i128;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> db;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vi;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;ll&gt; vl;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;pii&gt; vp;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">const</span> ll INF = <span class="number">1e18</span>;</span><br><span class="line"><span class="keyword">const</span> db eps = <span class="number">1e-10</span>;</span><br><span class="line"><span class="keyword">const</span> db pi = <span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> eb emplace_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ep emplace</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mem(a) memset(a, 0, sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> copy(a, b) memcpy(a, b, sizeof(b))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PA cout &lt;&lt; <span class="meta-string">"pass\n"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lowbit(x) (x &amp; -x)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(x) x.begin(), x.end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TM cout &lt;&lt; db(clock()) / CLOCKS_PER_SEC &lt;&lt; <span class="meta-string">'\n'</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">mt19937 <span class="title">mrand</span><span class="params">(chrono::high_resolution_clock::now().time_since_epoch().count())</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;<span class="title">inline</span> <span class="title">void</span> <span class="title">upmin</span>(<span class="title">T</span> &amp;<span class="title">x</span>, <span class="title">T</span> <span class="title">y</span>) &#123;</span>x = x &gt; y ? y : x;&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;<span class="title">inline</span> <span class="title">void</span> <span class="title">upmax</span>(<span class="title">T</span> &amp;<span class="title">x</span>, <span class="title">T</span> <span class="title">y</span>) &#123;</span>x = x &lt; y ? y : x;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">30</span>] = &#123;<span class="number">6</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">15</span>, <span class="number">12</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">13</span>, <span class="number">10</span>, <span class="number">17</span>, <span class="number">14</span>, <span class="number">11</span>, <span class="number">27</span>, <span class="number">28</span>, <span class="number">29</span>, <span class="number">18</span>, <span class="number">19</span>, <span class="number">20</span>, <span class="number">21</span>, <span class="number">22</span>, <span class="number">23</span>, <span class="number">24</span>, <span class="number">25</span>, <span class="number">26</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> b[<span class="number">30</span>] = &#123;<span class="number">15</span>, <span class="number">16</span>, <span class="number">17</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">26</span>, <span class="number">25</span>, <span class="number">24</span>, <span class="number">23</span>, <span class="number">22</span>, <span class="number">21</span>, <span class="number">20</span>, <span class="number">19</span>, <span class="number">18</span>, <span class="number">29</span>, <span class="number">28</span>, <span class="number">27</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> c[<span class="number">30</span>] = &#123;<span class="number">11</span>, <span class="number">10</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">16</span>, <span class="number">17</span>, <span class="number">20</span>, <span class="number">19</span>, <span class="number">18</span>, <span class="number">29</span>, <span class="number">22</span>, <span class="number">23</span>, <span class="number">24</span>, <span class="number">25</span>, <span class="number">26</span>, <span class="number">27</span>, <span class="number">28</span>, <span class="number">21</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">vi <span class="title">op1</span><span class="params">(vi x)</span></span>&#123;</span><br><span class="line">    <span class="function">vi <span class="title">r</span><span class="params">(<span class="number">30</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">30</span>; i++)&#123;</span><br><span class="line">        r[i] = x[a[i]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">vi <span class="title">op2</span><span class="params">(vi x)</span></span>&#123;</span><br><span class="line">    <span class="function">vi <span class="title">r</span><span class="params">(<span class="number">30</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">30</span>; i++)&#123;</span><br><span class="line">        r[i] = x[b[i]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">vi <span class="title">op3</span><span class="params">(vi x)</span></span>&#123;</span><br><span class="line">    <span class="function">vi <span class="title">r</span><span class="params">(<span class="number">30</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">30</span>; i++)&#123;</span><br><span class="line">        r[i] = x[c[i]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span>&lt;vi, <span class="keyword">int</span>&gt; vis;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, vi &amp;x, vi &amp;ok)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ok[u]) <span class="keyword">return</span>;</span><br><span class="line">    ok[u] = <span class="number">1</span>;</span><br><span class="line">    dfs(x[u], x, ok);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getcircle</span><span class="params">(vi x)</span></span>&#123;</span><br><span class="line">    <span class="function">vi <span class="title">ok</span><span class="params">(<span class="number">30</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">30</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ok[i]) <span class="keyword">continue</span>;</span><br><span class="line">        dfs(i, x, ok);</span><br><span class="line">        cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vi now;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">vi <span class="title">s</span><span class="params">(<span class="number">30</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">30</span>; i++) s[i] = i;</span><br><span class="line">    <span class="built_in">queue</span>&lt;vi&gt; q;</span><br><span class="line">    q.push(s);</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        vi t = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">if</span>(vis[t]) <span class="keyword">continue</span>;</span><br><span class="line">        vis[t] = <span class="number">1</span>;</span><br><span class="line">        vi r = op1(t);</span><br><span class="line">        <span class="keyword">if</span>(vis.find(r) == vis.end()) q.push(r);</span><br><span class="line">        r = op2(t);</span><br><span class="line">        <span class="keyword">if</span>(vis.find(r) == vis.end()) q.push(r);</span><br><span class="line">        r = op3(t);</span><br><span class="line">        <span class="keyword">if</span>(vis.find(r) == vis.end()) q.push(r);</span><br><span class="line">        now.eb(getcircle(t));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T, n, p;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">pow_mod</span><span class="params">(ll q, ll w, ll mod)</span></span>&#123;</span><br><span class="line">    ll ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(w)&#123;</span><br><span class="line">        <span class="keyword">if</span>(w &amp; <span class="number">1</span>) ret = i128(ret) * q % mod;</span><br><span class="line">        q = i128(q) * q % mod;</span><br><span class="line">        w &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll bin[<span class="number">40</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>), <span class="built_in">cin</span>.tie(<span class="number">0</span>), <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; fixed &lt;&lt; setprecision(<span class="number">10</span>);</span><br><span class="line">    bfs();</span><br><span class="line">    bin[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; p;</span><br><span class="line">        ll mod = <span class="number">1l</span>l * p * now.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">40</span>; i++) bin[i] = i128(bin[i - <span class="number">1</span>]) * n % mod;</span><br><span class="line">        ll res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it : now)&#123;</span><br><span class="line">            res = (res + bin[it]) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">        res /= now.size();</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><p><a href="https://vjudge.net/problem/SGU-282" target="_blank" rel="noopener">sgu-282</a><br>这个题就非常牛了，但想通也不难。<br>考虑不能直接枚举置换了，因为有n！种，但我们注意到是完全图，意味着很多置换有共同特征，所以我们直接考虑枚举循环节的划分，然后算把数填进去的方案数。<br>假设现在划分成了<script type="math/tex">L_1, L_2, \cdots, L_k(L_1 + L_2 + \cdots + L_k = n)</script>，把数放进去的方案数就是<script type="math/tex">\frac{n!}{L_1!L_2!\cdots L_k!}</script><br>每个循环节内的排列方案数是<script type="math/tex">(L_{i} - 1)!</script><br>但是如果有些循环节的长度相同，假设长度为x的有<script type="math/tex">d_x</script>个，方案数还得除以<script type="math/tex">d_x!</script><br>所以最后置换的方案数是<script type="math/tex">\frac{n!}{L_1L_2\cdots  L_nd_1!d_2!\cdots d_x!}</script></p><p>算完置换的方案数，还得算循环节的个数。我们现在枚举的是点循环节，因为是对边操作（对边染色），考虑要映射为边循环节。<br>如果两个点在一个点循环节内，可以容易看出一共有<script type="math/tex">\frac{L}{2}</script>个边循环节（边的跨点长度有这么多种）。<br>如果两个点在不同的点循环节内，可以发现每一个边循环节内包含<script type="math/tex">lcm(L_1, L_2)</script>条边，一共有<script type="math/tex">L_1 * L_2</script>条边，所以边循环节个数为<script type="math/tex">gcd(L_1, L-2)</script><br>求出边循环节个数后直接算染色方案即可。<br>复杂度<script type="math/tex">O(n的划分数 * n^2)</script></p><div><div class="fold_hider"><div class="close hider_title">代码</div></div><div class="fold"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> db;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vi;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;ll&gt; vl;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;pii&gt; vp;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">const</span> ll INF = <span class="number">1e18</span>;</span><br><span class="line"><span class="keyword">const</span> db eps = <span class="number">1e-10</span>;</span><br><span class="line"><span class="keyword">const</span> db pi = <span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> eb emplace_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ep emplace</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mem(a) memset(a, 0, sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> copy(a, b) memcpy(a, b, sizeof(b))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PA cout &lt;&lt; <span class="meta-string">"pass\n"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lowbit(x) (x &amp; -x)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(x) x.begin(), x.end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TM cout &lt;&lt; db(clock()) / CLOCKS_PER_SEC &lt;&lt; <span class="meta-string">'\n'</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">mt19937 <span class="title">mrand</span><span class="params">(chrono::high_resolution_clock::now().time_since_epoch().count())</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;<span class="title">inline</span> <span class="title">void</span> <span class="title">upmin</span>(<span class="title">T</span> &amp;<span class="title">x</span>, <span class="title">T</span> <span class="title">y</span>) &#123;</span>x = x &gt; y ? y : x;&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;<span class="title">inline</span> <span class="title">void</span> <span class="title">upmax</span>(<span class="title">T</span> &amp;<span class="title">x</span>, <span class="title">T</span> <span class="title">y</span>) &#123;</span>x = x &lt; y ? y : x;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, p;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">55</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fac[maxn], inv[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pow_mod</span><span class="params">(<span class="keyword">int</span> q, <span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(w)&#123;</span><br><span class="line">        <span class="keyword">if</span>(w &amp; <span class="number">1</span>) ret = <span class="number">1l</span>l * ret * q % p;</span><br><span class="line">        q = <span class="number">1l</span>l * q * q % p;</span><br><span class="line">        w &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> res;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> sum, vi &amp;t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(sum == n) &#123;</span><br><span class="line">        <span class="keyword">int</span> ret = fac[n];</span><br><span class="line">        <span class="keyword">int</span> now = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t.size(); i++) &#123;</span><br><span class="line">            ret = <span class="number">1l</span>l * ret * inv[t[i]] % p;</span><br><span class="line">            ret = <span class="number">1l</span>l * ret * fac[t[i] - <span class="number">1</span>] % p;</span><br><span class="line">            now += t[i] / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; t.size(); j++)&#123;</span><br><span class="line">                now += __gcd(t[i], t[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; t.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(t[i] == t[i - <span class="number">1</span>]) cnt++;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                ret = <span class="number">1l</span>l * ret * inv[cnt] % p;</span><br><span class="line">                cnt = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ret = <span class="number">1l</span>l * ret * inv[cnt] % p;</span><br><span class="line">        res = (res + <span class="number">1l</span>l * ret * pow_mod(m, now)) % p;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(sum + x &gt; n) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = x; i + sum &lt;= n; i++)&#123;</span><br><span class="line">        t.eb(i);</span><br><span class="line">        dfs(i, sum + i, t);</span><br><span class="line">        t.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>), <span class="built_in">cin</span>.tie(<span class="number">0</span>), <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; fixed &lt;&lt; setprecision(<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; p;</span><br><span class="line">    fac[<span class="number">0</span>] = inv[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        fac[i] = <span class="number">1l</span>l * fac[i - <span class="number">1</span>] * i % p;</span><br><span class="line">        inv[i] = pow_mod(fac[i], p - <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    vi t;</span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">0</span>, t);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="number">1l</span>l * res * inv[n] % p &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><p>总之关于Polya题目，可能会套上dp或者数论优化以及快速幂优化，是暴力算<script type="math/tex">\phi</script>还是预处理，分块快速幂还是直接求解都根据题目数据范围来决定。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;如果能为了某个人变强，对于悲伤我也心存感激~&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&quot;Polya简介&quot;&gt;&lt;a href=&quot;#Polya简介&quot; class=&quot;headerlink&quot; title=&quot;Polya简介&quot;&gt;&lt;/a&gt;Polya简介&lt;/h1&gt;&lt;p&gt;Polya定理用来解决旋转，对称同构的计数问题，其定理形式简单，但变种问题十分多且有趣。&lt;/p&gt;
&lt;h2 id=&quot;前置&quot;&gt;&lt;a href=&quot;#前置&quot; class=&quot;headerlink&quot; title=&quot;前置&quot;&gt;&lt;/a&gt;前置&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;置换&lt;/li&gt;
&lt;li&gt;数论&lt;br&gt;本文不打算讲前置内容以及定理的证明&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;定理内容&quot;&gt;&lt;a href=&quot;#定理内容&quot; class=&quot;headerlink&quot; title=&quot;定理内容&quot;&gt;&lt;/a&gt;定理内容&lt;/h2&gt;&lt;script type=&quot;math/tex; mode=display&quot;&gt;M = \frac{1}{G}\sum_{i = 1}^gf(c_i)&lt;/script&gt;&lt;p&gt;其中&lt;script type=&quot;math/tex&quot;&gt;c_i&lt;/script&gt;表示第i种置换中循环节的个数。&lt;/p&gt;
&lt;p&gt;用简单的话来说，&lt;script type=&quot;math/tex&quot;&gt;Polya&lt;/script&gt;就是找到所有的置换，然后对每一种置换找到循环节个数，同一个循环节看成一个不动点（如染色问题中循环节内的所有点必须是同一种颜色），算出该置换下的方案数，对所有置换的方案数求和后平均。&lt;/p&gt;
&lt;p&gt;那么问题很明显可以划分为两个步骤：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;找到置换&lt;/li&gt;
&lt;li&gt;算出置换下的方案数&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;难题可能是在这两个步骤的某一步中比较不好处理，但所有的&lt;script type=&quot;math/tex&quot;&gt;Polya&lt;/script&gt;题目无外乎都要这么考虑&lt;/p&gt;
    
    </summary>
    
      <category term="Polya" scheme="http://yoursite.com/categories/Polya/"/>
    
    
  </entry>
  
  <entry>
    <title>回文树及其应用</title>
    <link href="http://yoursite.com/2020/09/17/%E5%9B%9E%E6%96%87%E6%A0%91%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/"/>
    <id>http://yoursite.com/2020/09/17/回文树及其应用/</id>
    <published>2020-09-17T01:40:11.000Z</published>
    <updated>2021-05-12T15:38:43.704Z</updated>
    
    <content type="html"><![CDATA[<h1 id="回文树"><a href="#回文树" class="headerlink" title="回文树"></a>回文树</h1><p>回文树实际上跟后缀自动机非常类似，用来解决回文串的问题，一般能解决如下问题及其变形：</p><ul><li>求串S前缀0 ~ i内本质不同回文串的个数</li><li>求串S内每一个本质不同回文串出现的次数</li><li>求串S内回文串的个数</li><li>求以下标i结尾的回文串的个数</li></ul><p>我们先介绍一下回文树需要维护的变量：</p><ul><li>$len[i]: $表示编号为i的节点表示的回文串的长度</li><li>$ch[u][i]: $表示编号为i的节点表示的回文串在两边添加字符c以后变成的回文串的编号</li><li>$f[i]: $表示节点i失配以后跳转不等于自身的节点i表示的回文串的最长后缀回文串</li><li>$cnt[i]: $表示节点i表示的本质不同的串的个数（建树时求出的不是完全的，最后count()函数跑一遍以后才是正确的，这跟后缀自动机是一样的）</li><li>$num[i]:$表示以节点i表示的最长回文串的最右端点为回文串结尾的回文串个数 </li><li>$diff[i]: $表示该节点与父节点表示的回文串的长度差</li><li>$top[i]: $表示所在等差数列的首项位置</li><li>$last: $指向新添加一个字母后所形成的最长回文串表示的节点</li><li>$S[i]: $表示第i次添加的字符</li><li>$p: $表示添加的节点个数(0是偶回文树的根，1是奇回文树的根)</li><li>$n: $表示添加的字符个数</li></ul><p><img src="/images/15.png" alt=""><br><img src="/images/16.png" alt=""><br><img src="/images/17.png" alt=""><br>构造过程这里不解释，自行参考其它资料（其实是觉得不重要）</p><h2 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h2><ul><li><p>回文树跟后缀自动机不一样的地方，后缀自动机跳<script type="math/tex">fail</script>的复杂度均摊是<script type="math/tex">O(\sqrt(n))</script>的，但回文树均摊可能是<script type="math/tex">O(n)</script>的，比如全是一个字符的串，所以在回文树上一般不能直接跳<script type="math/tex">fail</script>来解决问题。</p></li><li><p>回文树其实分为两棵树，0是偶回文树的根，1是奇回文树的根，所以如果要树上计数别忘了0，1都需要开始dfs</p></li></ul><h1 id="回文树与border定理"><a href="#回文树与border定理" class="headerlink" title="回文树与border定理"></a>回文树与border定理</h1><p>border定理告诉我们，一个串的border可以由log个等差数列组成。<br>如果在回文串上，回文串的border还是回文串，所以回文树的任意一条<script type="math/tex">fail</script>链所表示的回文串的长度组成的序列也可以写成log段等差数列。<br>这有什么用呢，假设我们现在需要通过回文树来转移dp，一般dp形式如下:</p><script type="math/tex; mode=display">dp[i] <- dp[j - 1] (s(j, i)是回文串)</script><p>这时候如果在回文树上找到所有符合的$j$的复杂度是$O(n)$的，我们只好探究一下等差数列的性质。<br>假设回文树上有三个回文串长为:<script type="math/tex">b_1, b_2, b_3(b_1 > b_2 > b_3)</script>，它们的公差为$d$，当前dp位置为$i$<br><img src="/images/14.png" alt=""><br>可以发现$b_1$画虚线前面部分和$b_2$相等，$b_2$画虚线前面部分和$b_3$相等，即<script type="math/tex">S(i - b_1, i - d) = S(i - b_2, i)</script>，<script type="math/tex">S(i - b_2, i - d) = S(i - b_3)</script>。可以发现这两个值在<script type="math/tex">i - d</script>结尾的时候已经维护过了，所以我们只需要维护<script type="math/tex">S(i - b_3, i - d)</script>就行了，也就是在一个等差数列里，相当于整个维护的值循环后移了一位，你只需要补上最前面的那个最新的值就行了。<br>因为我们考虑用一个$g(t)$来维护$[t, top[t])$上等差数列上的信息，如序列为1, 2, 3, 4, 6, 7, 10，对于公差为2的等差子数列，我们维护的是$[6, t]$的信息（4的信息会在它向前的等差数列中被维护）。发现划分后每个等差子数列只差最前面位置的信息需要添加（公差为2的当中需要添加6，也就是$top[t] + diff[t]$）。我们在每个等差数列的末尾来维护这一段等差数列的前缀状态（和，max，min之类的），然后往上跳到上一段等差数列，继续加上新的一个状态即可，边维护的过程中可以边统计答案。</p><a id="more"></a><p>最出名的莫过这个题了<br><a href="https://codeforces.com/problemset/problem/932/G" target="_blank" rel="noopener">ICM Technex 2018 and Codeforces Round #463 (Div. 1 + Div. 2, combined)</a></p><p>dp方程如下：</p><script type="math/tex; mode=display">dp[i] = dp[i] + dp[j - 1](S(i, j)是回文串并且i, j - 1都是偶数)</script><div><div class="fold_hider"><div class="close hider_title">代码</div></div><div class="fold"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxnode = <span class="number">1e6</span> + <span class="number">100</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> sigma_size = <span class="number">26</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> ch[maxnode][sigma_size];</span><br><span class="line"><span class="keyword">int</span> f[maxnode];</span><br><span class="line"><span class="keyword">int</span> cnt[maxnode];   </span><br><span class="line"><span class="keyword">int</span> num[maxnode];  </span><br><span class="line"><span class="keyword">int</span> len[maxnode];  </span><br><span class="line"><span class="keyword">int</span> s[maxnode];     </span><br><span class="line"><span class="keyword">int</span> diff[maxnode];   </span><br><span class="line"><span class="keyword">int</span> top[maxnode];    </span><br><span class="line"><span class="keyword">int</span> last;       </span><br><span class="line"><span class="keyword">int</span> sz;</span><br><span class="line"><span class="keyword">int</span> p;      </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">newnode</span><span class="params">(<span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sigma_size; i++)ch[p][i] = <span class="number">0</span>;</span><br><span class="line">    cnt[p] = <span class="number">0</span>;</span><br><span class="line">    num[p] = <span class="number">0</span>;</span><br><span class="line">    len[p] = w;</span><br><span class="line">    <span class="keyword">return</span> p++;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    p = <span class="number">0</span>;</span><br><span class="line">    newnode(<span class="number">0</span>);</span><br><span class="line">    newnode(<span class="number">-1</span>);</span><br><span class="line">    last = <span class="number">0</span>;</span><br><span class="line">    sz = <span class="number">0</span>;</span><br><span class="line">    s[sz] = <span class="number">-1</span>;</span><br><span class="line">    f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getfail</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (s[sz - len[x] - <span class="number">1</span>] != s[sz])x = f[x];</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    s[++sz] = c;</span><br><span class="line">    <span class="keyword">int</span> cur = getfail(last);</span><br><span class="line">    <span class="keyword">if</span> (!ch[cur][c]) &#123;</span><br><span class="line">        <span class="keyword">int</span> now = newnode(len[cur] + <span class="number">2</span>);</span><br><span class="line">        f[now] = ch[getfail(f[cur])][c];</span><br><span class="line">        ch[cur][c] = now;</span><br><span class="line">        diff[now] = len[now] - len[f[now]];</span><br><span class="line">        top[now] = diff[now] == diff[f[now]] ? top[f[now]] : f[now];</span><br><span class="line">        num[now] = num[f[now]] + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    last = ch[cur][c];</span><br><span class="line">    cnt[last]++;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">count</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = p<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        cnt[f[i]] += cnt[i];</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">char</span> str[maxnode];</span><br><span class="line"><span class="keyword">char</span> tmp[maxnode];</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> dp[maxnode];</span><br><span class="line"><span class="keyword">int</span> g[maxnode];</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, str + <span class="number">1</span>);</span><br><span class="line">    n = <span class="built_in">strlen</span>(str + <span class="number">1</span>);</span><br><span class="line">    init();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n / <span class="number">2</span>; i++)&#123;</span><br><span class="line">        tmp[<span class="number">2</span> * i - <span class="number">1</span>] = str[i];</span><br><span class="line">        tmp[<span class="number">2</span> * i] = str[n - i + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        add(tmp[i] - <span class="string">'a'</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> t = last; t &gt; <span class="number">1</span>; t = top[t])&#123;</span><br><span class="line">            g[t] = dp[i - len[top[t]] - diff[t]];</span><br><span class="line">            <span class="keyword">if</span>(diff[t] == diff[f[t]])&#123;</span><br><span class="line">                g[t] = (g[t] + g[f[t]]) % mod;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i % <span class="number">2</span> == <span class="number">0</span>) dp[i] = (dp[i] + g[t]) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, dp[n]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><h1 id="可撤销回文树"><a href="#可撤销回文树" class="headerlink" title="可撤销回文树"></a>可撤销回文树</h1><p>考虑我们需要动态加入、删除一个点，此时如果还用原来的暴力跳$fail$就会被卡掉，因为原来的复杂度分析是均摊的，但是单次跳$fail$是可能被卡到$O(n)$的。<br>此时可以用$border$定理进行优化，我们发现回文树上一段等差数列，如果第一项不匹配，那么这段等差数列对应的回文串都不会匹配（简单画图即可观察得出），于是我们只需要跳$log$段等差数列即可。这样删除直接把最后一个点移掉就好了，插入的复杂度是严格$log$的<br><div><div class="fold_hider"><div class="close hider_title">代码</div></div><div class="fold"><p>~~~c++<br>int getfail(int x){<br>    while(s[sz - len[x] - 1] != s[sz]){<br>        if(s[sz - len[f[x]] - 1] == s[sz]){<br>            return f[x];<br>        }<br>        else x = top[x];<br>    }<br>    return x;<br>}</p></div></div></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;回文树&quot;&gt;&lt;a href=&quot;#回文树&quot; class=&quot;headerlink&quot; title=&quot;回文树&quot;&gt;&lt;/a&gt;回文树&lt;/h1&gt;&lt;p&gt;回文树实际上跟后缀自动机非常类似，用来解决回文串的问题，一般能解决如下问题及其变形：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;求串S前缀0 ~ i内本质不同回文串的个数&lt;/li&gt;
&lt;li&gt;求串S内每一个本质不同回文串出现的次数&lt;/li&gt;
&lt;li&gt;求串S内回文串的个数&lt;/li&gt;
&lt;li&gt;求以下标i结尾的回文串的个数&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们先介绍一下回文树需要维护的变量：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$len[i]: $表示编号为i的节点表示的回文串的长度&lt;/li&gt;
&lt;li&gt;$ch[u][i]: $表示编号为i的节点表示的回文串在两边添加字符c以后变成的回文串的编号&lt;/li&gt;
&lt;li&gt;$f[i]: $表示节点i失配以后跳转不等于自身的节点i表示的回文串的最长后缀回文串&lt;/li&gt;
&lt;li&gt;$cnt[i]: $表示节点i表示的本质不同的串的个数（建树时求出的不是完全的，最后count()函数跑一遍以后才是正确的，这跟后缀自动机是一样的）&lt;/li&gt;
&lt;li&gt;$num[i]:$表示以节点i表示的最长回文串的最右端点为回文串结尾的回文串个数 &lt;/li&gt;
&lt;li&gt;$diff[i]: $表示该节点与父节点表示的回文串的长度差&lt;/li&gt;
&lt;li&gt;$top[i]: $表示所在等差数列的首项位置&lt;/li&gt;
&lt;li&gt;$last: $指向新添加一个字母后所形成的最长回文串表示的节点&lt;/li&gt;
&lt;li&gt;$S[i]: $表示第i次添加的字符&lt;/li&gt;
&lt;li&gt;$p: $表示添加的节点个数(0是偶回文树的根，1是奇回文树的根)&lt;/li&gt;
&lt;li&gt;$n: $表示添加的字符个数&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;/images/15.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;img src=&quot;/images/16.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;img src=&quot;/images/17.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;构造过程这里不解释，自行参考其它资料（其实是觉得不重要）&lt;/p&gt;
&lt;h2 id=&quot;性质&quot;&gt;&lt;a href=&quot;#性质&quot; class=&quot;headerlink&quot; title=&quot;性质&quot;&gt;&lt;/a&gt;性质&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;回文树跟后缀自动机不一样的地方，后缀自动机跳&lt;script type=&quot;math/tex&quot;&gt;fail&lt;/script&gt;的复杂度均摊是&lt;script type=&quot;math/tex&quot;&gt;O(\sqrt(n))&lt;/script&gt;的，但回文树均摊可能是&lt;script type=&quot;math/tex&quot;&gt;O(n)&lt;/script&gt;的，比如全是一个字符的串，所以在回文树上一般不能直接跳&lt;script type=&quot;math/tex&quot;&gt;fail&lt;/script&gt;来解决问题。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;回文树其实分为两棵树，0是偶回文树的根，1是奇回文树的根，所以如果要树上计数别忘了0，1都需要开始dfs&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;回文树与border定理&quot;&gt;&lt;a href=&quot;#回文树与border定理&quot; class=&quot;headerlink&quot; title=&quot;回文树与border定理&quot;&gt;&lt;/a&gt;回文树与border定理&lt;/h1&gt;&lt;p&gt;border定理告诉我们，一个串的border可以由log个等差数列组成。&lt;br&gt;如果在回文串上，回文串的border还是回文串，所以回文树的任意一条&lt;script type=&quot;math/tex&quot;&gt;fail&lt;/script&gt;链所表示的回文串的长度组成的序列也可以写成log段等差数列。&lt;br&gt;这有什么用呢，假设我们现在需要通过回文树来转移dp，一般dp形式如下:&lt;/p&gt;
&lt;script type=&quot;math/tex; mode=display&quot;&gt;dp[i] &lt;- dp[j - 1] (s(j, i)是回文串)&lt;/script&gt;&lt;p&gt;这时候如果在回文树上找到所有符合的$j$的复杂度是$O(n)$的，我们只好探究一下等差数列的性质。&lt;br&gt;假设回文树上有三个回文串长为:&lt;script type=&quot;math/tex&quot;&gt;b_1, b_2, b_3(b_1 &gt; b_2 &gt; b_3)&lt;/script&gt;，它们的公差为$d$，当前dp位置为$i$&lt;br&gt;&lt;img src=&quot;/images/14.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;可以发现$b_1$画虚线前面部分和$b_2$相等，$b_2$画虚线前面部分和$b_3$相等，即&lt;script type=&quot;math/tex&quot;&gt;S(i - b_1, i - d) = S(i - b_2, i)&lt;/script&gt;，&lt;script type=&quot;math/tex&quot;&gt;S(i - b_2, i - d) = S(i - b_3)&lt;/script&gt;。可以发现这两个值在&lt;script type=&quot;math/tex&quot;&gt;i - d&lt;/script&gt;结尾的时候已经维护过了，所以我们只需要维护&lt;script type=&quot;math/tex&quot;&gt;S(i - b_3, i - d)&lt;/script&gt;就行了，也就是在一个等差数列里，相当于整个维护的值循环后移了一位，你只需要补上最前面的那个最新的值就行了。&lt;br&gt;因为我们考虑用一个$g(t)$来维护$[t, top[t])$上等差数列上的信息，如序列为1, 2, 3, 4, 6, 7, 10，对于公差为2的等差子数列，我们维护的是$[6, t]$的信息（4的信息会在它向前的等差数列中被维护）。发现划分后每个等差子数列只差最前面位置的信息需要添加（公差为2的当中需要添加6，也就是$top[t] + diff[t]$）。我们在每个等差数列的末尾来维护这一段等差数列的前缀状态（和，max，min之类的），然后往上跳到上一段等差数列，继续加上新的一个状态即可，边维护的过程中可以边统计答案。&lt;/p&gt;
    
    </summary>
    
      <category term="回文自动机" scheme="http://yoursite.com/categories/%E5%9B%9E%E6%96%87%E8%87%AA%E5%8A%A8%E6%9C%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>论积性函数与线性筛</title>
    <link href="http://yoursite.com/2020/09/13/%E8%AE%BA%E7%A7%AF%E6%80%A7%E5%87%BD%E6%95%B0%E4%B8%8E%E7%BA%BF%E6%80%A7%E7%AD%9B/"/>
    <id>http://yoursite.com/2020/09/13/论积性函数与线性筛/</id>
    <published>2020-09-13T03:15:25.000Z</published>
    <updated>2020-09-13T03:58:22.391Z</updated>
    
    <content type="html"><![CDATA[<p>草，这离上一次更新也不知道有多少了，有生之年系列？</p><a id="more"></a><h1 id="线性筛"><a href="#线性筛" class="headerlink" title="线性筛"></a>线性筛</h1><p>线性筛保证了每个数只被它最小的素因子筛到一次，模板如下：<br><div><div class="fold_hider"><div class="close hider_title">代码</div></div><div class="fold"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; maxn; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(!vis[i])&#123;</span><br><span class="line">        prime.eb(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; prime.size() &amp;&amp; i * prime[j] &lt; maxn; j++)&#123;</span><br><span class="line">        vis[i * prime[j]] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(i % prime[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><br>关键在为什么$i \% prime[j] == 0$的就会break掉，考虑$i * prime[j + 1]$一定会被$prime[j]和另一个i$相乘的时候筛掉，所以我们在这里break掉保证每个数只被筛掉一次。</p><h1 id="积性函数"><a href="#积性函数" class="headerlink" title="积性函数"></a>积性函数</h1><p>积性函数分为如下两类：</p><ul><li>完全积性函数：$f(ab) = f(a) * f(b)$</li><li>普通积性函数: $f(ab) = f(a) * f(b), gcd(a, b) = 1$<br>一般我们要讨论的就是普通积性函数。</li></ul><h1 id="线性筛积性函数"><a href="#线性筛积性函数" class="headerlink" title="线性筛积性函数"></a>线性筛积性函数</h1><p>一般来说，积性函数都是可以用线性筛来求解的，一般需要考虑如下最重要的部分：</p><ul><li>$f(p^k)$是否好求解<br>假设上面求解复杂度为$x$，那么线性筛该积性函数的复杂度就为$O(n + \frac{nx}{logn})$</li></ul><p>先给出一些定义：</p><ul><li>$low(i):$表示i最小素因子的乘积<br>例如$low(36) = 2^2 = 4， low(27) = 3^3 = 27$</li></ul><p>按照如下流程进行线性筛积性函数:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; maxn; i++)&#123;</span><br><span class="line">       <span class="keyword">if</span>(!vis[i])&#123;</span><br><span class="line">           prime.eb(i);</span><br><span class="line">           low[i] = i</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; prime.size() &amp;&amp; i * prime[j] &lt; maxn; j++)&#123;</span><br><span class="line">           vis[i * prime[j]] = <span class="number">1</span>;</span><br><span class="line">           low[i * prime[j]] = low[i] * prime[j]</span><br><span class="line">           <span class="keyword">if</span>(i % prime[j] == <span class="number">0</span>) &#123;</span><br><span class="line">               <span class="keyword">if</span>(low[i] == i) f[i * prime[j]] = 求解</span><br><span class="line">               <span class="keyword">else</span>&#123;</span><br><span class="line">                   f[i * prime[j]] = f[i / low[i]] * f[low[i * prime[j]]];</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">else</span>&#123;</span><br><span class="line">               f[i * prime[j]] = f[i] * f[prime[j]];</span><br><span class="line">               low[i * prime[j]] = prime[j] </span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>主要解释一下<script type="math/tex">i \% prime[j] == 0</script>里面的部分，考虑如果<script type="math/tex">prime[j]不是i的唯一素因子</script>，那么<script type="math/tex">i * prime[j]</script>可以分解为只包含<script type="math/tex">prime[j]</script>和剩下部分的两个因子组成，并且一定互质，这样可以推出来<script type="math/tex">f[i * prime[j]]</script>的值。<br>但如果<script type="math/tex">prime[j]是i的唯一素因子</script>，这样做就会有问题了，也就是前面所说的$f(p^k)$的答案我们需要单独求解。</p><h1 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h1><p>来看一个练习题<br><a href="https://ac.nowcoder.com/acm/contest/7329/F" target="_blank" rel="noopener">解方程</a></p><script type="math/tex; mode=display">f(n) * g_p(n) = g_q(n)</script><p>由莫比乌斯反演我们知道<script type="math/tex">g_p(n)^{-1} = g_p(n)\mu(n)</script></p><script type="math/tex; mode=display">f(n) = g_q(n) * (g_p(n)\mu(n))</script><p>右边两个都是积性函数，积性函数的迪利克雷卷积也是积性函数。<br>那么我们只用想办法求$f(p^k)$就可以了<br>由莫比乌斯函数我们知道，只有两项是有贡献的，所以很好求，求解复杂度是$log(n)$的<br>所以线性筛的复杂度$O(n + \frac{nlogn}{logn}) = O(n)$<br><div><div class="fold_hider"><div class="close hider_title">代码</div></div><div class="fold"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> db;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vi;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;ll&gt; vl;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;pii&gt; vp;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">const</span> ll INF = <span class="number">1e18</span>;</span><br><span class="line"><span class="keyword">const</span> db eps = <span class="number">1e-10</span>;</span><br><span class="line"><span class="keyword">const</span> db pi = <span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> eb emplace_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ep emplace</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mem(a) memset(a, 0, sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> copy(a, b) memcpy(a, b, sizeof(b))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PA cout &lt;&lt; <span class="meta-string">"pass\n"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lowbit(x) (x &amp; -x)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(x) x.begin(), x.end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TM cout &lt;&lt; db(clock()) / CLOCKS_PER_SEC &lt;&lt; <span class="meta-string">'\n'</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">mt19937 <span class="title">mrand</span><span class="params">(chrono::high_resolution_clock::now().time_since_epoch().count())</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;<span class="title">inline</span> <span class="title">void</span> <span class="title">upmin</span>(<span class="title">T</span> &amp;<span class="title">x</span>, <span class="title">T</span> <span class="title">y</span>) &#123;</span>x = x &gt; y ? y : x;&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;<span class="title">inline</span> <span class="title">void</span> <span class="title">upmax</span>(<span class="title">T</span> &amp;<span class="title">x</span>, <span class="title">T</span> <span class="title">y</span>) &#123;</span>x = x &lt; y ? y : x;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pow_mod</span><span class="params">(<span class="keyword">int</span> q, <span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(w)&#123;</span><br><span class="line">        <span class="keyword">if</span>(w &amp; <span class="number">1</span>) ret = <span class="number">1l</span>l * ret * q % mod;</span><br><span class="line">        q = <span class="number">1l</span>l * q * q % mod;</span><br><span class="line">        w &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e7</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> f[maxn], low[maxn];</span><br><span class="line">vi prime;</span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"><span class="keyword">int</span> n, p, q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    f[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; maxn; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!vis[i])&#123;</span><br><span class="line">            prime.eb(i);</span><br><span class="line">            f[i] = (pow_mod(i, q) + mod - pow_mod(i, p)) % mod;</span><br><span class="line">            low[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; prime.size() &amp;&amp; i * prime[j] &lt; maxn; j++)&#123;</span><br><span class="line">            vis[i * prime[j]] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(i % prime[j] == <span class="number">0</span>)&#123;</span><br><span class="line">                low[i * prime[j]] = low[i] * prime[j];</span><br><span class="line">                <span class="keyword">if</span>(i == low[i]) &#123;</span><br><span class="line">                    f[i * prime[j]] = (pow_mod(i * prime[j], q) - <span class="number">1l</span>l * pow_mod(i, q) * pow_mod(prime[j], p) % mod + mod) % mod;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    f[i * prime[j]] = <span class="number">1l</span>l * f[i / low[i]] * f[low[i * prime[j]]] % mod;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                f[i * prime[j]] = <span class="number">1l</span>l * f[i] * f[prime[j]] % mod;</span><br><span class="line">                low[i * prime[j]] = prime[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        res ^= f[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>), <span class="built_in">cin</span>.tie(<span class="number">0</span>), <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; fixed &lt;&lt; setprecision(<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; p &gt;&gt; q;</span><br><span class="line">    init();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></p><p>什么时候迪利克雷卷积也要系统学一下，未完待续~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;草，这离上一次更新也不知道有多少了，有生之年系列？&lt;/p&gt;
    
    </summary>
    
      <category term="积性函数" scheme="http://yoursite.com/categories/%E7%A7%AF%E6%80%A7%E5%87%BD%E6%95%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>集成学习</title>
    <link href="http://yoursite.com/2020/07/11/%E9%9B%86%E6%88%90%E5%AD%A6%E4%B9%A0/"/>
    <id>http://yoursite.com/2020/07/11/集成学习/</id>
    <published>2020-07-11T07:07:56.000Z</published>
    <updated>2020-07-11T09:48:12.129Z</updated>
    
    <content type="html"><![CDATA[<h1 id="集成学习简介"><a href="#集成学习简介" class="headerlink" title="集成学习简介"></a>集成学习简介</h1><p>集成学习通过构建多个个体学习器，并让他们单独产生结果，最后将它们的结果合并起来，给出一个整体的最终结果。这就好像如果每个人单独做一套题，可能不管是谁，都会做错一部分题。但如果有很多人一起做，最后根据大家的结果和一个合并策略，选出一个结果，后者的正确率一般来说会高很多。<br>集成学习通过将多个学习器结合，常可获得比单一学习器显著优越的泛化性能，这对弱学习器(泛化性能略优于随机猜测的学习器)尤为明显。<br>首先我们希望各个学习器本身要有准确性，如果各个学习器本身的准确度不够，最后出来的结果一定不好。其次我们希望各个学习器之间要有差异，即学习器要多样性。如果大部分学习器学习方法和参数都差不多的话，相当于它们都会做出一样的预测，那么集成学习就没有意义了。但事实上，准确性和多样性很多时候是冲突的，如何产生”好而不同”的个体学习器，是集成学习的核心。<br>根据个体学习器的生成方式，集成学习方法大致可分为两大类，即个体学习器间存在强依赖关系、必须串行生成的序列化方法，以及个体学习器间不存在强依赖关系，可同时生成的并行化方法；前者代表是$Boosting$，后者代表是$Bagging$和随机森林。</p><h1 id="Boosting"><a href="#Boosting" class="headerlink" title="Boosting"></a>Boosting</h1><p>$Boosting$是一族可将弱学习器提升为强学习器的算法。先从初始训练集训练出一个基学习器，再根据基学习器的表现对训练样本分布进行调整，使得先前基学习器做错的样本在后面得到更多的关注。</p><h2 id="AdaBoost"><a href="#AdaBoost" class="headerlink" title="AdaBoost"></a>AdaBoost</h2><p>$AdaBoost$的算法流程如下：<br><img src="/mlimg/Adaboost.png" alt=""><br>$AdaBoost$的核心是两个权重：数据集权重$D$和分类器权重$a$。前者为了在生成每一个分类器时，决定每个数据对损失函数的影响，即我们需要把重心放在之前分错类的那些数据上。后者是对测试数据进行预测时，各个分类器对最终结果影响的比重。<br>初始每个训练样本都具有相同的权重，每一次我们生成一个新的分类器，并用带权的数据对它进行训练，算出训练后的误差率，然后根据错误率确定这个分类器在最后决策中占的权重，然后更新数据集权重$D$，然后继续生成下一个分类器。<br>那么就会有如下问题：<br><strong>$a_t$的表达式是怎么推到来的？</strong><br>$AdaBoost$采用指数损失函数$l_{exp}(H | D) = E_{x \sim D}[e^{-f(x)H(x)}]$<br>我们知道最后结果由各个分类器线性加权得到：<script type="math/tex">H(x) = \sum_{t = 1}^Ta_th_t(x)</script><br>所以如果我们要确定当前分类器的$a_t$，考虑对其求偏导：<script type="math/tex">\frac{\partial l_{exp}(a_th_t | D_t)}{\partial a_t} = -e^{-a_t}(1 - \epsilon_t) + e^{a_t}\epsilon_t</script><br>令其等于0即可得出<script type="math/tex">a_t = \frac{1}{2}ln(\frac{1 - \epsilon_t}{\epsilon_t})</script></p><p><strong>$Z_t$是干嘛的，怎么计算出来的？</strong><br>$Z_t$是归一化常数，为了保证所有$D_i$的和加起来为1，<script type="math/tex">Z_t = \sum_{i}D_t(i)e^{-a_ty_ih_t(x_i)} = \sum_{h_t(x_i) = y_i}D_t(i)e^{-a_i} + \sum_{h_t(x_i) \neq y_i}D_t(i)e^{a_i}</script>。<br>代入$a_t$，得<script type="math/tex">Z_t = 2\sqrt{\epsilon_t(1 - \epsilon_t)}</script></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;集成学习简介&quot;&gt;&lt;a href=&quot;#集成学习简介&quot; class=&quot;headerlink&quot; title=&quot;集成学习简介&quot;&gt;&lt;/a&gt;集成学习简介&lt;/h1&gt;&lt;p&gt;集成学习通过构建多个个体学习器，并让他们单独产生结果，最后将它们的结果合并起来，给出一个整体的最终结果。这就
      
    
    </summary>
    
      <category term="机器学习" scheme="http://yoursite.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>决策树</title>
    <link href="http://yoursite.com/2020/07/10/%E5%86%B3%E7%AD%96%E6%A0%91/"/>
    <id>http://yoursite.com/2020/07/10/决策树/</id>
    <published>2020-07-10T01:22:55.000Z</published>
    <updated>2020-07-11T08:05:42.550Z</updated>
    
    <content type="html"><![CDATA[<h1 id="决策树简介"><a href="#决策树简介" class="headerlink" title="决策树简介"></a>决策树简介</h1><p>决策树(Decision Tree)是在已知各种情况发生概率的基础上，通过构成决策树来求取净现值的期望值大于等于零的概率，评价项目风险，判断其可行性的决策分析方法，是直观运用概率分析的一种图解法。由于这种决策分支画成图形很像一棵树的枝干，故称决策树。</p><h1 id="划分选择"><a href="#划分选择" class="headerlink" title="划分选择"></a>划分选择</h1><h2 id="信息增益"><a href="#信息增益" class="headerlink" title="信息增益"></a>信息增益</h2><p>信息熵是度量样本集合纯度最常用的一种指标。假设当前样本集合$D$中第$k$类样本所占比例为$p_k(k = 1, 2, \dots, |\gamma|)$,则$D$的信息熵定义为：<script type="math/tex">Ent(D) = -\sum_{k = 1}^{|\gamma|}p_klog_2p_k</script>。信息熵的值越小，信息的纯度越高。<br>假设某个样本的属性$a$的$V$个可能取值${a^1, a^2, a^3, \dots, a^V}$，若使用$a$来对样本集合$D$进行划分，则会在这里产生$V$个分支结点。其中第$v$个结点包含了$D$中所有在属性$a$上取值为$a^v$的样本，记为$D^v$。我们利用属性$a$对样本集$D$进行划分所获得的信息增益记为<script type="math/tex">Gain(D, a) = Ent(D) - \sum_{v = 1}^V\frac{|D^v|}{|D|}Ent(D^v)</script>。<br>一般来说，信息增益越大，意味着用属性$a$来进行划分所获得的纯度提升越大，我们在每次对属性进行选择的时候，都用信息增益进行选择，即选择能获得最大增益的属性作为当前决策树结点进行划分。$ID3$算法就是采用信息增益作为选择标准。</p><h2 id="增益率"><a href="#增益率" class="headerlink" title="增益率"></a>增益率</h2><p>根据上面的式子我们可以发现，信息增益偏向于选择属性取值数较多的集合。一般情况来说，取值情况较多，每个部分纯度就越大，总体的纯度就越大。为了减少这种偏向带来的影响，我们不直接使用信息增益，而使用增益率。我们定义增益率为<script type="math/tex">Gain_ratio(D, a) = \frac{Gain(D, a)}{IV(a)}</script>，其中<script type="math/tex">IV(a) = -\sum_{v = 1}^V\frac{|D^v|}{D}log_2\frac{|D^v|}{D}</script><br>我们发现增益率会偏向于取值数较少的属性。因此，$C4.5$算法采用了启发式的方法，先选择信息增益高于平均水平的属性，再从中选择增益率最高的。</p><h2 id="基尼指数"><a href="#基尼指数" class="headerlink" title="基尼指数"></a>基尼指数</h2><p>$CART$决策树采用基尼指数来选择划分属性。定义<script type="math/tex">Gini(D) = \sum_{k = 1}^{|\gamma|}\sum_{k' \neq k}p_kp_{k'} = 1 - \sum_{k = 1}^{|\gamma|}p_k^2</script>。属性$a$的基尼指数定义为:<script type="math/tex">Gini_index(D, a) = \sum_{v = 1}^V\frac{|D^v|}{D}Gini(D^v)</script><br>划分的时候，我们选择基尼指数最小的属性作为当前决策树结点进行划分。</p><h1 id="剪枝处理"><a href="#剪枝处理" class="headerlink" title="剪枝处理"></a>剪枝处理</h1><p>当决策树分支过多的时候，就会出现过拟合的情况，泛化能力会很差，这时候我们要对决策树进行剪枝。</p><h2 id="预剪枝"><a href="#预剪枝" class="headerlink" title="预剪枝"></a>预剪枝</h2><p>如果在某个结点我们不再进行划分，我们会选择出此时这个结点属性集中出现最多的结果，并将它作为这个结点的结果。预剪枝指的是在当前结点进行划分的时候，我们先将取它原本应该取的划分属性，然后对比它划分前后的准确率，如果不划分的准确率更高，我们就不进行划分。预剪枝的本质就是基于贪心，但有可能给决策树带来欠拟合的风险。</p><h2 id="后剪枝"><a href="#后剪枝" class="headerlink" title="后剪枝"></a>后剪枝</h2><p>后剪枝指的是我们先完整生成一棵决策树，自底向上考察每一个结点，如果将其子树替换为某个叶节点，并且能提高准确率，我们就进行替换剪枝。<br>后剪枝一般来说欠拟合风险小，泛化性能优于预剪枝，但其训练开销大。</p><h1 id="连续与缺失值"><a href="#连续与缺失值" class="headerlink" title="连续与缺失值"></a>连续与缺失值</h1><h2 id="连续值处理"><a href="#连续值处理" class="headerlink" title="连续值处理"></a>连续值处理</h2><p>如果我们遇到了连续属性，我们仍使用决策树，我们要先对连续值进行一定处理。<br>假设样本集$D$和连续属性$a$，假设$a$在$D$上出现了$n$个不同的取值，我们将这些值从小到大进行排序，记为$a^1, a^2, \dots, a^n$。对此，我们可以写出$n - 1$个划分点<script type="math/tex">T_a = {\frac{a^i + a^{i + 1}}{2} | 1 \leq i \leq n - 1}</script>。然后我们就可以像离散属性点一样来考察这些划分点。</p><h2 id="缺失值处理"><a href="#缺失值处理" class="headerlink" title="缺失值处理"></a>缺失值处理</h2><p>假如样本的某些属性值丢失，如果放弃有缺失值的样本，会造成信息的浪费。因为，我们采取以下办法来训练带缺失值的样本：<br>给定训练集$D$和属性$a$，设$\widetilde{D}$为$D$中在属性$a$上没有缺失值的样本子集。假设我们给每个样本赋予一个权重$w_x$，并定义：</p><ul><li>$\rho = \frac{\sum_{x \in \widetilde{D}}w_x}{\sum_{x \in D} w_x}$</li><li>$\widetilde{p_k} = \frac{\sum_{x \in \widetilde{D_k}}w_x}{\sum_{x \in \widetilde{D}}w_x}(1 \leq k \leq |\gamma|)$</li><li>$\widetilde{r_v} = \frac{\sum_{x \in \widetilde{D}^v}w_x}{\sum_{x \in \widetilde{D}}w_x}(1 \leq v \leq V)$<br>简单来说，$\rho$表示无缺失值样本所占比例，$\widetilde{p_k}$表示无缺失值样本中第$k$类所占的比例，$\widetilde{r_v}$表示无缺失值样本中在属性$a$上取值$a^v$的样本所占的比例。<br>根据定义，可以推广信息增益计算式为：<script type="math/tex">Gain(D, a) = \rho * Gain(\widetilde{D}, a)</script><br>当样本$x$在属性$a$上划分值缺失时，则将$x$划入所有子结点中，再将其样本权值调整为$\widetilde{r_v} *w_x$。就是让同一个样本根据已知的分布情况，以不同的概率划入到不同的子结点中去。</li></ul><p>来一个鸢尾花的测试<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_iris</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> tree</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"></span><br><span class="line">iris = load_iris()</span><br><span class="line">x = iris[<span class="string">'data'</span>]</span><br><span class="line">y = iris[<span class="string">'target'</span>]</span><br><span class="line"></span><br><span class="line">train_x, test_x, train_y, test_y = train_test_split(x, y, test_size=<span class="number">0.25</span>, random_state=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">train_x = train_x.reshape(train_x.shape[<span class="number">0</span>], <span class="number">-1</span>)</span><br><span class="line">test_x = test_x.reshape(test_x.shape[<span class="number">0</span>], <span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">clf = tree.DecisionTreeClassifier()</span><br><span class="line">clf = clf.fit(train_x, train_y)</span><br><span class="line"></span><br><span class="line">cnt = <span class="number">0</span></span><br><span class="line">sum = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(test_x.shape[<span class="number">0</span>]):</span><br><span class="line">    t = []</span><br><span class="line">    t.append(test_x[i])</span><br><span class="line">    predict_y = clf.predict(t)</span><br><span class="line">    sum += <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span>(predict_y == test_y[i]): cnt += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">print(cnt, sum)</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;决策树简介&quot;&gt;&lt;a href=&quot;#决策树简介&quot; class=&quot;headerlink&quot; title=&quot;决策树简介&quot;&gt;&lt;/a&gt;决策树简介&lt;/h1&gt;&lt;p&gt;决策树(Decision Tree)是在已知各种情况发生概率的基础上，通过构成决策树来求取净现值的期望值大于等于零的
      
    
    </summary>
    
      <category term="机器学习" scheme="http://yoursite.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>贝叶斯分类器</title>
    <link href="http://yoursite.com/2020/07/01/%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%88%86%E7%B1%BB%E5%99%A8/"/>
    <id>http://yoursite.com/2020/07/01/贝叶斯分类器/</id>
    <published>2020-07-01T06:50:36.000Z</published>
    <updated>2020-07-11T08:05:37.480Z</updated>
    
    <content type="html"><![CDATA[<h1 id="先验概率和后验概率"><a href="#先验概率和后验概率" class="headerlink" title="先验概率和后验概率"></a>先验概率和后验概率</h1><p>之前一直搞不清楚这两个概念，这里来区分一下。<br>先验概率是指根据以往经验和分析得到的概率，如全概率公式，它往往作为”由因求果”问题中的”因”出现。<br>后验概率是指依据得到”结果”信息所计算出的最有可能是那种事件发生，如贝叶斯公式中的，是”执果寻因”问题中的”因”。</p><p>举个例子，女朋友每个月都会生气，假设什么都没发生，她今天生气的概率为$p_1$，这就是一种先验概率。<br>当你跟她打电话，发现她说话非常不耐烦，你觉得她今天大概率会生气，假设此时她生气的概率$p_2$，这就是一种后验概率。<br>懂了吧，后验概率其实就是一种条件概率，即是在你观测到某些信息后再发生这个事情的概率有多少。</p><h1 id="贝叶斯定理"><a href="#贝叶斯定理" class="headerlink" title="贝叶斯定理"></a>贝叶斯定理</h1><p>贝叶斯定理说的就是条件概率的事情，定义很简单:$P(A | B) = \frac{P(AB)<br>}{P(B)}$<br>我们可以这样写：$P(B | A) = \frac{P(AB)}{P(A)}$<br>那么可以得到：$P(A | B) = \frac{P(A)P(B | A)}{P(B)}$<br>假设事件$A$是女朋友今天生气了，事件$B$是女朋友打电话不耐烦，那么这个概率可以转换成求女朋友生气的概率、女朋友不耐烦的概率以及女朋友在生气情况下打电话不耐烦的概率。因为很多时候往往都是正面的条件概率不好求，但反面的会比较好求，即可以通过贝叶斯定理进行转换。</p><p>假设$x = (x_1, x_2, \dots, x_n)$表示包含有$D$维属性的数据对象。训练集有$k$个类别，分别为$y = (y_1, y_2, \dots, y_k)$。假设有待分类对象$x$，我们需要找<script type="math/tex">\argmax_{y_i \in y}(P(y_i | x))</script><br>根据上面的推导，我们可以转换为<script type="math/tex">P(y_i | x) = \frac{P(x | y_i)P(y_i)}{P(x)}</script>，由于$P(x)$是常数，实际上只需要最大化$P(x | y_i)P(y_i)$</p><h1 id="朴素贝叶斯分类器"><a href="#朴素贝叶斯分类器" class="headerlink" title="朴素贝叶斯分类器"></a>朴素贝叶斯分类器</h1><p>朴素贝叶斯分类器假设$x$的各个属性之间独立，那么上面就可以改写为：<script type="math/tex">P(y_i)\prod_{j = 1}^nP(x_j | y_i)</script><br>关于<script type="math/tex">P(x_j | y_i)</script>的计算方法，假设$y_i$有$m$个，其中带有$x_j$属性的有$n$个，当样本足够多时，我们就可以用频率值代替概率值，即：$P(x_j | y_i) = \frac{n}{m}$。<br>然而这个方法有个缺陷，属性一旦多了，有可能样本不能覆盖所有属性。假设一个属性样本中没出现过，那么概率直接就为0了。对此，我们对其进行拉普拉斯修正：<script type="math/tex">P(x_j | y_i) = \frac{n + 1}{m + N_j}</script>，其中$N_j$表示第$j$个属性一共可能的取值数。<br>如果属性取值是连续函数，可考虑采用概率密度函数。</p><h1 id="半朴素贝叶斯分类器"><a href="#半朴素贝叶斯分类器" class="headerlink" title="半朴素贝叶斯分类器"></a>半朴素贝叶斯分类器</h1><p>事实上，所有属性相互独立这个条件是很难满足的，这样就产生了半朴素贝叶斯分类器。独依赖估计是半朴素贝叶斯分类器常采用的一种策略，即每个属性最多依赖于一个其他属性。</p><h2 id="SPODE"><a href="#SPODE" class="headerlink" title="SPODE"></a>SPODE</h2><p>$SPODE$方法假设所有属性都依赖于同一个属性，这个属性称为超父属性。这个可以通过交叉验证等模型选择方法来确定。</p><h2 id="TAN"><a href="#TAN" class="headerlink" title="TAN"></a>TAN</h2><p>$SPODE$有他的局限性，即不一定所有属性都会有一个强相关的依赖属性，这时候就产生了$TAN$，$TAN$是基于最大带权生成树算法。<br>定义两个属性之间的条件互信息<script type="math/tex">I(x_i, x_j | y) = \sum_{x_i, x_j; y_k \in y}P(x_i, x_j | y_k)log\frac{P(x_i, x_j | y_k)}{P(x_i | y_k)P(x_j | y_k)}</script><br>然后可以以属性为点，构成完成图，任意两点<script type="math/tex">w(i, j) = I(x_i, x_j | y)</script>，对于做最大生成树（取负然后变为最小生成树），最后给边定向即可。</p><h2 id="AODE"><a href="#AODE" class="headerlink" title="AODE"></a>AODE</h2><p>$AODE$尝试将每个属性作为超父属性，然后将那些有足够训练数据支撑的$SPODE$集成起来作为最终结果。<script type="math/tex">\sum_{i = 1, |D_{x_i} \geq m'|}^dP(c, x_i) \prod_{j = 1}^dP(x_j | c, x_i)</script></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;先验概率和后验概率&quot;&gt;&lt;a href=&quot;#先验概率和后验概率&quot; class=&quot;headerlink&quot; title=&quot;先验概率和后验概率&quot;&gt;&lt;/a&gt;先验概率和后验概率&lt;/h1&gt;&lt;p&gt;之前一直搞不清楚这两个概念，这里来区分一下。&lt;br&gt;先验概率是指根据以往经验和分析得
      
    
    </summary>
    
      <category term="机器学习" scheme="http://yoursite.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>无监督学习</title>
    <link href="http://yoursite.com/2020/06/28/%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0/"/>
    <id>http://yoursite.com/2020/06/28/无监督学习/</id>
    <published>2020-06-28T10:04:08.000Z</published>
    <updated>2020-07-11T08:05:39.737Z</updated>
    
    <content type="html"><![CDATA[<p>我又在无监督学习（不学习）了</p><h1 id="无监督学习简介"><a href="#无监督学习简介" class="headerlink" title="无监督学习简介"></a>无监督学习简介</h1><p>前面区分过无监督学习和有监督学习，无监督学习没有输出标签，即没有$y$，无监督学习需要根据数据找出隐藏的数据结构，比如分类。</p><h1 id="K均值"><a href="#K均值" class="headerlink" title="K均值"></a>K均值</h1><h2 id="K-Means"><a href="#K-Means" class="headerlink" title="K-Means"></a>K-Means</h2><p>给你一堆空间里的点，让你把他们分成k类，使得所有类的最小化平方误差和最小E，也就是所谓的聚类，假设簇划分为$(C_1,C_2,\dots C_k)$，有<script type="math/tex">E = \sum_{i = 1}^k\sum_{x \in C_i}||x - \mu_{i}||_2^2</script>。其中有$\mu_i = \frac{1}{|C_i|}\sum_{x \in C_i}x$。<br>直接求解最小值是一个$NP$问题，所以K均值算法采用启发式迭代的方法，其具体步骤非常简单，首先有k个初始的聚类中心，迭代有如下几步：</p><ul><li>遍历每一个点</li><li>找到离这个点最近的聚类中心，把这个点标记属于这个聚类</li><li>对于每一个新标记出的聚类，计算其新的几何中心</li></ul><p>根据以上步骤迭代至收敛为止。</p><p>k均值算法算法对初始化非常敏感，如果只是随机选择，可能会落入局部最优解，并且收敛会很慢，为此对于初始化，有新的方法提出。</p><h2 id="K-Means-1"><a href="#K-Means-1" class="headerlink" title="K-Means++"></a>K-Means++</h2><p>假设要分为k类，我们需要初始化k个聚类中心，按照如下步骤：</p><ul><li>从输入的数据点集合中随机选择一个点作为第一个聚类中心$\mu_1$</li><li>对于数据集中的每一个点$x_i$，计算它与已选择的聚类中心中最近聚类中心的距离$D(x_i) = argmin||x_i - \mu_r||_2^2 r = 1, 2, \dots k_{selected}$</li><li>选择一个新的数据点作为新的聚类中心，选择的原则是：$D(x)$较大的点，被选取作为聚类中心的概率较大</li><li>重复步骤2-3直到选择出k个聚类质心</li><li>利用这k个质心来作为初始化质心去运行标准的K-Means算法</li></ul><h2 id="elkan-K-Means"><a href="#elkan-K-Means" class="headerlink" title="elkan K-Means"></a>elkan K-Means</h2><p>在普通k均值算法中，我们要计算样本点到所有质心的距离，这个复杂度跟向量维度有关，考虑通过三角形定理进行优化：三角形两边之和大于第三边，两边之差小于第三边。<br>知道两个质心$\mu_{j1}, \mu_{j2}$，如果我们预处理了两个质心间的距离$D(j_1, j_2)$，计算时发现$2D(x, j_1) \leq D(j_1, j_2)$，我们立即就可以知道$D(x, j_1) \leq D(x, j_2)$。此时我们就不需要再计算$D(x, j_2)$</p><h2 id="K-Means与KNN"><a href="#K-Means与KNN" class="headerlink" title="K-Means与KNN"></a>K-Means与KNN</h2><p>$K-Means$是无监督学习的聚类算法，没有样本输出；而$KNN$是监督学习的分类算法，有对应的类别输出。$KNN$基本不需要训练，对测试集里面的点，只需要找到在训练集中最近的k个点，用这最近的k个点的类别来决定测试点的类别。而$K-Means$则有明显的训练过程，找到k个类别的最佳质心，从而决定样本的簇类别。</p><h1 id="主成分分析-PCA"><a href="#主成分分析-PCA" class="headerlink" title="主成分分析(PCA)"></a>主成分分析(PCA)</h1><p>这玩意我怎么总觉得自己又看懂了，又没看懂呢。。。</p><p>简单来说，$PCA$是一种降维方法，因为可能某些数据本身就具备相关性，同时存在就会冗余，我们要在降维的同时将信息的损失尽量降低。</p><p>要掌握$PCA$，我们需要补充一些基础知识。</p><h2 id="向量的表示及基变换"><a href="#向量的表示及基变换" class="headerlink" title="向量的表示及基变换"></a>向量的表示及基变换</h2><h3 id="内积与投影"><a href="#内积与投影" class="headerlink" title="内积与投影"></a>内积与投影</h3><p>假设有两个向量$a, b$，他们的内积为$a^Tb$。考虑向量只有二维，通过几何意义我们可以发现内积的绝对值的几何意义是投影的长度，这个几何意义可以推广到高维去。</p><h3 id="基底"><a href="#基底" class="headerlink" title="基底"></a>基底</h3><p>我们平时表示某个向量例如$(2, 3)$，表示其在$x$正半轴上延申2个单位，在$y$正半轴上延申3个单位，其实我们是省略了基底，我们默认的基底都是$(1, 0), (0, 1)$，向量$(2, 3)$应该表示为$(1, 0)^T(2) + (0, 1)^T(3)$</p><h3 id="基变换的矩阵表示"><a href="#基变换的矩阵表示" class="headerlink" title="基变换的矩阵表示"></a>基变换的矩阵表示</h3><p>考虑从一组基换到另一组，这个过程我们可以用矩乘来表示，下面给一个例子：<br><img src="/mlimg/basechange.png" alt=""><br>维度不一样的话，只需要将变换矩阵的维度一起更改就可以了。</p><h2 id="方差"><a href="#方差" class="headerlink" title="方差"></a>方差</h2><p>那么降维后，我们希望数据越分散越好，因为越发散越能体现数据之间的不同，我们用方差来衡量数据的分散性。</p><h2 id="协方差"><a href="#协方差" class="headerlink" title="协方差"></a>协方差</h2><p>在希望方差尽量大的前提下，我们希望选择的维度越不相关越好。因为如果相关，那么我们可以继续对他降维，直到各个维度都不相关或者相关性很弱。我们用协方差来衡量相关性质，协方差公式如下：$Cov(a, b) = \frac{1}{m}\sum_{i = 1}^m(a_i - \overline{a})(b_i - \overline{b})$。假设我们对数据进行过归一化，均值为0，上面就可以简化为：$Cov(a, b) = \frac{1}{m}\sum_{i = 1}^ma_ib_i$。我们发现这个就等于$\frac{1}{m}XX^T(X是由样本组成的矩阵)$</p><p>至此，我们得到了降维问题的优化目标：<strong>将一组$N$维向量降为$K$维（$0 \leq K \leq N$），其目标是选择$K$个单位（模为1）正交基，使得原始数据变换到这组基上后，各字段两两间协方差为0，而字段的方差则尽可能大（在正交的约束下，取最大的$K$个方差，即取绝对值最大的$K$个特征值）。</strong></p><p>设原始数据矩阵X对应的协方差矩阵为$C$，而$P$是一组基按行组成的矩阵，设$Y = PX$，则$Y$为$X$对$P$做基变换后的数据。设$Y$的协方差矩阵为$D$，我们推导一下$D$与$C$的关系：</p><script type="math/tex; mode=display">D = \frac{1}{m}YY^T = \frac{1}{m}(PX)(PX)^T = \frac{1}{m}PXX^TP^T = PCP^T</script><p>现在我们要寻找一个矩阵$P$，满足$PCP^T$是一个对角矩阵，并且对角元素按从大到小依次排列，那么$P$的前$K$行就是要寻找的基，用$P$的前$K$行组成的矩阵乘以$X$就使得$X$从$N$维降到了$K$维并满足上述优化条件。由于协方差矩阵$C$是一个是对称矩阵，其必然有：</p><ul><li>实对称矩阵不同特征值对应的特征向量必然正交</li><li>设特征向量$λ$重数为$r$，则必然存在$r$个线性无关的特征向量对应于$λ$，因此可以将这$r$个特征向量单位正交化。<br>根据相似对角化，我们一定可以找到一个矩阵$\Lambda = PCP^T$，其中$\Lambda$是对角矩阵，$PP^T = I$。其对角元素为各特征向量对应的特征值（可能有重复）。</li></ul><p>这就是$PCA$的证明，关于里面特征值分解的内容。。看看以后补还是鸽掉吧。</p><h2 id="数据重现"><a href="#数据重现" class="headerlink" title="数据重现"></a>数据重现</h2><p>当我们想重现回高维数据时，不可能得到准确值，因为我们降维后，是用的投影值来代替原来的数据，实际上真实点到垂足点上还有段距离，这部分信息我们是丢失了的，是不可逆的，所以最终只能得到预估值。<br>我们知道$Y = PX$，又有$PP^T = I$，可以得到$X_{approx} = P^TY$，注意矩阵的维度即可。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我又在无监督学习（不学习）了&lt;/p&gt;
&lt;h1 id=&quot;无监督学习简介&quot;&gt;&lt;a href=&quot;#无监督学习简介&quot; class=&quot;headerlink&quot; title=&quot;无监督学习简介&quot;&gt;&lt;/a&gt;无监督学习简介&lt;/h1&gt;&lt;p&gt;前面区分过无监督学习和有监督学习，无监督学习没有输出标签
      
    
    </summary>
    
      <category term="机器学习" scheme="http://yoursite.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>支持向量机</title>
    <link href="http://yoursite.com/2020/06/27/%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/"/>
    <id>http://yoursite.com/2020/06/27/支持向量机/</id>
    <published>2020-06-27T03:47:19.000Z</published>
    <updated>2020-07-11T08:05:34.425Z</updated>
    
    <content type="html"><![CDATA[<h1 id="支持向量机简介"><a href="#支持向量机简介" class="headerlink" title="支持向量机简介"></a>支持向量机简介</h1><p>支持向量机（support vector machines, SVM）是一种二分类模型，它的基本模型是定义在特征空间上的间隔最大的线性分类器，间隔最大使它有别于感知机；SVM还包括核技巧，这使它成为实质上的非线性分类器。SVM的的学习策略就是间隔最大化，可形式化为一个求解凸二次规划的问题，也等价于正则化的合页损失函数的最小化问题。SVM的的学习算法就是求解凸二次规划的最优化算法。</p><h1 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h1><p>支持向量机(SVM)基本想法是找到能够正确划分平面数据集且间隔(Margin)最大的分隔超平面。这里间隔指的两个异类点之间的最近距离。这个距离可以用来衡量抗干扰性，距离越大抗干扰性越强。<br>假设超平面是$w^Tx + b = 0$，任意一个点$x$到超平面的距离为：$\frac{|w^Tx + b|}{||w||}$。<br>我们令正类的$y_i = 1$，负类的$y_i = -1$，假设超平面上所有向量都被分类正确，那么有:</p><script type="math/tex; mode=display">f(x)=\left\{\begin{aligned}&w^Tx_i + b \geq 1, &y_i = +1\\&w^Tx_i + b \leq 1, &y_i = -1\\\end{aligned}\right.</script><p>那么其中最近的两个异类点之间的距离$\gamma$便是取等的时候，即为$\gamma = \frac{2}{||w||}$<br>想要找到最大的$\gamma$，问题转换成了如下：</p><script type="math/tex; mode=display">\begin{aligned}&\max_{w, b}\frac{2}{||w||} \\&s.t. \ y_i(w^Tx_i + b) \geq 1\end{aligned}</script><h1 id="拉格朗日乘子法与KKT条件"><a href="#拉格朗日乘子法与KKT条件" class="headerlink" title="拉格朗日乘子法与KKT条件"></a>拉格朗日乘子法与KKT条件</h1><p>我们知道对于带约束的求极值问题，我们可以通过拉格朗日乘子法将约束去掉。高等数学里一般讲的都是等式约束，如果含有不等式约束我们就需要使用$KKT$条件。<br>我们写出$KKT$条件的数学表达式：</p><script type="math/tex; mode=display">\begin{aligned}&L(x, \lambda_j, \mu_k) = f(x) + \sum_{j = 1}^m\lambda_jg_j(x) + \sum_{k = 1}^p\mu_kh_k(x) \\&\nabla_xL =0 \\&g_j(x) = 0 \ j = 1, \cdots, m, \\&h_k(x) \leq 0 \\&\mu_k \geq 0\end{aligned}</script><p>其实用一句很简单的话来说，最值要嘛在各边界点处取到，要嘛在极值点处取到，这就是$KKT$条件。</p><h1 id="核函数"><a href="#核函数" class="headerlink" title="核函数"></a>核函数</h1><p>上述讲的都是线性可分的$SVM$，但很多时候平面无法线性可分，这时候我们可以把它扔到高维空间去，让它在高维空间上线性可分。<br><img src="/mlimg/transtohighdim.png" alt=""><br>那么我们需要找到一个$\phi(\cdot)$，能把原来的$x$转换到高维空间上。<br>考虑到中间有一步需要求$\phi(x_i)^T\phi(x_j)$，如果转换到高维空间上计算复杂度会很大，这时候就出现了核函数$\kappa(x_i, x_j) = \phi(x_i)^T\phi(x_j)$，使得我们不需要知道$\phi(\cdot)$的具体形式，也可以求出$\kappa(x_i, x_j) = \phi(x_i)^T\phi(x_j)$的值。<br><strong>核函数只是用来计算映射到高维空间之后的内积的一种简便方法。</strong></p><h1 id="逻辑回归和SVM选用建议"><a href="#逻辑回归和SVM选用建议" class="headerlink" title="逻辑回归和SVM选用建议"></a>逻辑回归和SVM选用建议</h1><p>设特征数为$n$，样本数为$m$，给出如下选择建议：</p><ul><li>$n$很大：逻辑回归或者不带核函数的$SVM$</li><li>$n$很小，$m$适中:带高斯核函数的$SVM$</li><li>$n$很小，$m$很大：逻辑回归或者不带核函数的$SVM$</li></ul><h1 id="软间隔"><a href="#软间隔" class="headerlink" title="软间隔"></a>软间隔</h1><p>前面讨论中，我们要求所有样本都分类正确，但实际上，如果要让所有样本都正确，得出的超平面稳定性可能会很差，现在考虑允许一部分样本不满足约束$y_i(w^Tx_i + b) \geq 1$，原来的最优化问题变为了：</p><script type="math/tex; mode=display">\begin{aligned}&\min_{w, b}\frac{1}{2}||w||^2 + C\sum_{i = 1}^ml_{0/1}(y_i(w^Tx_i + b) - 1)\end{aligned}</script><p>其中$C$被称为正则化系数，$l_{0/1}$如下：</p><script type="math/tex; mode=display">l_{0/1} = \left\{\begin{aligned}1, z < 0\\0, z \geq 0\end{aligned}\right.</script><p>实际上$l_{0/1}$非凸非连续，数学性质不好，我们常用如下三种函数来替代：</p><ul><li>$hinge$损失:$l_{hinge}(z) = max(0, 1 - z)$</li><li>指数损失：$l_{exp}(z) = e^{-z}$</li><li>对率损失：$l_{log}(z) = log(1 + e^{-z})$</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;支持向量机简介&quot;&gt;&lt;a href=&quot;#支持向量机简介&quot; class=&quot;headerlink&quot; title=&quot;支持向量机简介&quot;&gt;&lt;/a&gt;支持向量机简介&lt;/h1&gt;&lt;p&gt;支持向量机（support vector machines, SVM）是一种二分类模型，它的基本模型
      
    
    </summary>
    
      <category term="机器学习" scheme="http://yoursite.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>系统的设计与评估</title>
    <link href="http://yoursite.com/2020/06/21/%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E8%AF%84%E4%BC%B0/"/>
    <id>http://yoursite.com/2020/06/21/系统的设计与评估/</id>
    <published>2020-06-21T03:11:22.000Z</published>
    <updated>2020-07-11T08:05:22.087Z</updated>
    
    <content type="html"><![CDATA[<h1 id="模型的改善措施"><a href="#模型的改善措施" class="headerlink" title="模型的改善措施"></a>模型的改善措施</h1><p>当你觉得模型的效果不如意的时候，可以有如下的一些改善措施：</p><ul><li>获取更多的数据</li><li>减少一部分特征</li><li>获取更多的特征</li><li>尝试更高阶的多项式</li><li>尝试增大正则项的系数</li><li>尝试减少正则项的系数</li></ul><p>我们需要了解模型不好的原因在哪里，根本不好的原因来采取正确的改善措施。</p><h1 id="模型评估"><a href="#模型评估" class="headerlink" title="模型评估"></a>模型评估</h1><p>前面我们也提过过拟合的问题，即在训练集上模型表现得很好，但是在测试集上的表现很差，泛用性差、不稳定，易干扰。为了较科学的评估一个模型，我们需要把数据集分为两部分，训练集 + 测试集，一般这个比例为7：3，注意需要把数据集的顺序给打乱。</p><p>对于测试误差，如果是回归问题，形式与$cost$ $function$是一样的，即：$\frac{1}{2m}\sum_{i = 1}^m(h_{\theta}(x^{(i)}) - y^{(i)})^2$。如果是分类问题，可以用其分类问题对应的$cost$ $function$来衡量，或者用另一种评判方法：0/1分类，即每次找出可能性最大的预测结果，然后与对应结果相比，0表示相同，1表示不同，最后对所有样本求和再除以样本总量，就跟正确率其实是一个东西。</p><h1 id="模型选择和训练、验证、测试集"><a href="#模型选择和训练、验证、测试集" class="headerlink" title="模型选择和训练、验证、测试集"></a>模型选择和训练、验证、测试集</h1><p>当我们要进行不同模型之间的比较时，我们需要分出一部分数据用来调整超参数，这个部分我们称为测试集。测试集是模型训练过程中单独留出的样本集，它可以用于调整模型的超参数和用于对模型的能力进行初步评估。我们用验证集的误差来作为模型选择的标准。<br>对比见下：<br><img src="/mlimg/vsandts.png" alt=""></p><h1 id="偏差与方差"><a href="#偏差与方差" class="headerlink" title="偏差与方差"></a>偏差与方差</h1><h2 id="偏差与方差-1"><a href="#偏差与方差-1" class="headerlink" title="偏差与方差"></a>偏差与方差</h2><p><img src="/mlimg/biasandvariance.png" alt=""><br>上面的图其实能说明问题了。<br>偏差：样本与真实值之间的差距<br>方差：样本与期望值之间的差距<br>误差 = 偏差 + 方差（西瓜书上有推导）</p><p>如果模型欠拟合时，即高偏差，这时候就需要复杂化模型。当模型出现过拟合时，即高方差，这时候就需要简化模型。</p><h2 id="正则化的偏差与方差"><a href="#正则化的偏差与方差" class="headerlink" title="正则化的偏差与方差"></a>正则化的偏差与方差</h2><p>考虑正则化的系树$\lambda$，增大$\lambda$，相当于增大惩罚，即在简化模型，即在增大偏差，减小方差。减小$\lambda$，相当于减小惩罚，即在复杂模型，即在减小偏差，增大方差。</p><h1 id="查准率、召回率"><a href="#查准率、召回率" class="headerlink" title="查准率、召回率"></a>查准率、召回率</h1><p><img src="/mlimg/sickandhealthy.png" alt=""></p><ul><li>查准率 $P = \frac{TP}{TP + FP}$</li><li>召回率 $R = \frac{TP}{TP + FN}$</li></ul><p>这两个指标主要针对数据比例倾斜的情况，比如癌症，一个预测恒输出0的函数预测正确率会非常高，这时候就需要这两个指标来进行衡量。</p><p>这两个指标往往是负相关的关系，即FP和FN是负相关的关系。拿癌症举例子，你要预测为癌症的人的准确率高，就必然会将一部分本来是癌症的预测为不是癌症，反过来也是一样的道理。</p><p>我们定义$F = 2 \frac{PR}{P + R}$，我们最后用F值来评估模型的有效性。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;模型的改善措施&quot;&gt;&lt;a href=&quot;#模型的改善措施&quot; class=&quot;headerlink&quot; title=&quot;模型的改善措施&quot;&gt;&lt;/a&gt;模型的改善措施&lt;/h1&gt;&lt;p&gt;当你觉得模型的效果不如意的时候，可以有如下的一些改善措施：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;获取更多的数据
      
    
    </summary>
    
      <category term="机器学习" scheme="http://yoursite.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>神经网络</title>
    <link href="http://yoursite.com/2020/06/15/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
    <id>http://yoursite.com/2020/06/15/神经网络/</id>
    <published>2020-06-15T03:55:10.000Z</published>
    <updated>2020-07-11T08:05:14.339Z</updated>
    
    <content type="html"><![CDATA[<h1 id="神经网络简介"><a href="#神经网络简介" class="headerlink" title="神经网络简介"></a>神经网络简介</h1><h2 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h2><p>前面我们学习了线性模型，但现实中很多模型都是非线性的，我们又很难知道它对应的非线性模型的形式是什么，所以我们引入神经网络来解决非线性模型。<br>神经网络的模型图如下：<br><img src="/mlimg/neuralnetwork.png" alt=""><br>第一层我们称为输入层，最后一层我们成为输出层，其余所有层都称为中间层。</p><h2 id="非线性实例"><a href="#非线性实例" class="headerlink" title="非线性实例"></a>非线性实例</h2><p>为什么神经网络能够求出非线性模型呢，我们拿一个例子来看。<br>假设我们要求$x_1  AND  x_2$<br>这玩意我们可以用一个线性模型来拟合，如图：<br><img src="/mlimg/andopt.png" alt=""><br>如果是$NOT  x$:<br><img src="/mlimg/notopt.png" alt=""><br>那如果是$x_1  xnor  x_2$呢，这显然是一个非线性模型。<br>我们可以把它拆成$(NOT  x_1)  AND  (NOT  x_2)$<br>发现可以用一个中间层来保存两个$NOT$的结果，再组合$AND$的结果。<br>这也就是为什么神经网络能用来表达非线性模型。</p><h2 id="多元分类"><a href="#多元分类" class="headerlink" title="多元分类"></a>多元分类</h2><p>当任务是一个多元分类问题时，我们常对标准结果向量化：即每一个标准结果都是一个$n$ x $1$向量，并且只有其对应的那个特征元素为1，其他所有元素为0。<br>例如三元分类，标准向量如下：<br>$\left[<br>\begin{matrix}<br>1 \\<br>0 \\<br>0<br>\end{matrix}<br>\right]<br>$ $\left[<br>\begin{matrix}<br>0 \\<br>1 \\<br>0<br>\end{matrix}<br>\right]<br>$ $\left[<br>\begin{matrix}<br>0 \\<br>0 \\<br>1<br>\end{matrix}<br>\right]<br>$</p><h1 id="反向传播"><a href="#反向传播" class="headerlink" title="反向传播"></a>反向传播</h1><p>感觉反向传播的推导挺麻烦的，慢慢写吧。。</p><p>当每次正向传播得到预测值后，我们要根据预测值和真实值的误差，反向更新各个点的参数，从而让他们朝着使$loss$ $function$减小的方向更新。<br>我们用$a^{(i)}$表示第$i$层经过激活函数后输出的值<br>我们用$z^{(i)}$表示第$i$层经过激活函数前输出的值<br>我们用$\delta^{(i)}$表示第$i$层的误差，输出层的$\delta = a - y$<br>令代价函数为：$J(\theta) = -ylogh(x) - (1 - y)(1 - h(x))$<br>假设我们已知第$x + 1$层误差为$\delta^{x + 1}$，现在我们要求第$x$层的误差：<br>已知$\delta^{(x)} = \frac{\partial J(\theta)}{\partial z^{(x)}}$<br>$\delta^{(x)} = \frac{\partial J}{\partial a^{x + 1}}\frac{\partial a^{(x + 1)}}{\partial z^{(x + 1)}}\frac{\partial z^{(x + 1)}}{\partial a^{(x)}}\frac{\partial a^{(x)}}{\partial z^{(x)}}$<br>$ = (\frac{-y}{a^{(x + 1)}} + \frac{1 - y}{1 - a^{(x + 1)}})\frac{\partial g(z^{(x + 1)})}{\partial z^{(x + 1)}}\theta^{(x)}\frac{\partial g(z^{(x)})}{\partial z^{(x)}}$<br>$ = \delta^{(x + 1)}\theta^{(x)}a^{(x)}(1 - a^{(x)})$<br>考虑维度问题：<br>$ = (\theta^{(x)})^T\delta^{(x + 1)}g’(z^{(x)})$<br>可能从$\frac{\partial g(z^{(x)})}{\partial z^{(x)}} = a^{(x)}(1 - a^{(x)})$这一步不是特别好理解，需要对函数求导，拆成两部分相乘，然后发现两边都可以用$a$替换回来，就变成后面的形式了。</p><p>考虑参数更新<br>$dw = \frac{\partial J(\theta)}{\partial w} = \frac{\partial J(\theta)}{\partial \alpha}\frac{\partial \alpha}{\partial z}\frac{\partial z}{\partial w} = (a - y) x$<br>考虑维度问题：<br>$= x^{T}(a - y)$</p><p>自己写了个最简单的神经网络，吐了，以后还是调库吧，效果也不是很好，可能有地方写错了。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> h5py</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">path = <span class="string">'C:/Users/Nemo Sherry/Desktop'</span></span><br><span class="line">train_dataset = h5py.File(path + <span class="string">'/train_catvnoncat.h5'</span>, <span class="string">"r"</span>)</span><br><span class="line">test_dataset = h5py.File(path + <span class="string">'/test_catvnoncat.h5'</span>, <span class="string">"r"</span>)</span><br><span class="line">test_x = np.array(test_dataset[<span class="string">'test_set_x'</span>])</span><br><span class="line">test_y = np.array(test_dataset[<span class="string">'test_set_y'</span>])</span><br><span class="line">train_x = np.array(train_dataset[<span class="string">'train_set_x'</span>])</span><br><span class="line">m = train_x.shape[<span class="number">0</span>]</span><br><span class="line">train_y = np.array(train_dataset[<span class="string">'train_set_y'</span>])</span><br><span class="line">train_x = train_x.reshape(train_x.shape[<span class="number">0</span>], <span class="number">-1</span>)</span><br><span class="line">test_x = test_x.reshape(test_x.shape[<span class="number">0</span>], <span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(train_x.shape[<span class="number">0</span>]):</span><br><span class="line">    np.append(train_x[i], <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(test_x.shape[<span class="number">0</span>]):</span><br><span class="line">    np.append(test_x[i], <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">train_x = train_x.T</span><br><span class="line">test_x = test_x.T</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">train_x = train_x / <span class="number">1</span></span><br><span class="line">test_x = test_x / <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(train_x.shape[<span class="number">0</span>]):</span><br><span class="line">    train_x[i] = (train_x[i] - np.sum(train_x[i]) / train_x.shape[<span class="number">1</span>]) / <span class="number">255</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(test_x.shape[<span class="number">0</span>]):</span><br><span class="line">    test_x[i] = (test_x[i] - np.sum(test_x[i]) / test_x.shape[<span class="number">1</span>]) / <span class="number">255</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sigmoid</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1.</span> / (<span class="number">1</span> + np.exp(-x))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sum = <span class="number">0</span></span><br><span class="line">cnt = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">read = <span class="keyword">True</span></span><br><span class="line">w = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> read:</span><br><span class="line">    sys.stdin = open(<span class="string">'weight.txt'</span>,<span class="string">'r'</span>)</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        x = sys.stdin.readline()</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> x : <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>: x = float(x)</span><br><span class="line">        w.append(x)</span><br><span class="line">    w = np.array(w)</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>: w = np.zeros(train_x.shape[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">file = open(<span class="string">'weight.txt'</span>,<span class="string">'w'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">predict</span><span class="params">(w, x, y)</span>:</span></span><br><span class="line">    z = np.dot(w, x)</span><br><span class="line">    a = sigmoid(z)</span><br><span class="line">    a.reshape(a.shape[<span class="number">0</span>], <span class="number">1</span>)</span><br><span class="line">    cost = (<span class="number">-1.</span> / m) * np.sum(y * np.log(a) + (<span class="number">1</span> - y) * np.log(<span class="number">1</span> - a))</span><br><span class="line">    print(cost)</span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">lr = <span class="number">0.1</span></span><br><span class="line">la = <span class="number">5</span></span><br><span class="line"></span><br><span class="line">is_train = <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">propagate</span><span class="params">(w, x, y)</span>:</span></span><br><span class="line">    a = sigmoid(np.dot(w, x))</span><br><span class="line">    dw = <span class="number">1</span> / m * np.dot(x, (a - y).T)</span><br><span class="line">    w = w - lr * dw</span><br><span class="line">    <span class="keyword">return</span> w</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> is_train:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1000</span>):</span><br><span class="line">        w = propagate(w, train_x, train_y)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cnt = <span class="number">0</span></span><br><span class="line">sum = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">t = sigmoid(np.dot(w, train_x))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(t.shape[<span class="number">0</span>]):</span><br><span class="line">    sum += <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> (t[i] &gt;= <span class="number">0.5</span>) == (train_y[i]): cnt += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">print(cnt, sum)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cnt = <span class="number">0</span></span><br><span class="line">sum = <span class="number">0</span></span><br><span class="line">t = sigmoid(np.dot(w, test_x))</span><br><span class="line"></span><br><span class="line">predict(w, test_x, test_y)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(t.shape[<span class="number">0</span>]):</span><br><span class="line">    sum += <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> (t[i] &gt;= <span class="number">0.5</span>) == (test_y[i]): cnt += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">print(cnt, sum)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(w.shape[<span class="number">0</span>]):</span><br><span class="line">    file.write(str(w[i]))</span><br><span class="line">    file.write(<span class="string">'\n'</span>)</span><br><span class="line">file.close()</span><br></pre></td></tr></table></figure></p><p>中间还被一个坑坑了很久，读入进来的numpy的dtype是uint16类型的，我想每一行归一化，一开始直接对每一行操作，然后元素就全变成0了。猜测应该是在对第一行操作的时候，会先把这个numpy的dtype类型转成float的，然后就莫名丢失了内容。所以numpy要转类型要对整个矩阵一起转，不能只转某一行。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;神经网络简介&quot;&gt;&lt;a href=&quot;#神经网络简介&quot; class=&quot;headerlink&quot; title=&quot;神经网络简介&quot;&gt;&lt;/a&gt;神经网络简介&lt;/h1&gt;&lt;h2 id=&quot;模型&quot;&gt;&lt;a href=&quot;#模型&quot; class=&quot;headerlink&quot; title=&quot;模型&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="机器学习" scheme="http://yoursite.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>正则化</title>
    <link href="http://yoursite.com/2020/06/14/%E6%AD%A3%E5%88%99%E5%8C%96/"/>
    <id>http://yoursite.com/2020/06/14/正则化/</id>
    <published>2020-06-14T02:55:40.000Z</published>
    <updated>2020-07-11T08:05:18.956Z</updated>
    
    <content type="html"><![CDATA[<h1 id="拟合"><a href="#拟合" class="headerlink" title="拟合"></a>拟合</h1><p>如果一个模型拟合的不好，一般是如下两种：</p><ul><li>欠拟合</li><li>过拟合<br><img src="/mlimg/fit.png" alt=""><br>第一张图就是欠拟合，很显然不管什么样的直线模型都不能反映出房价后面逐渐平稳的趋势。<br>第二张图拟合效果不错，能反映出整个房价的变化趋势。<br>第三张图就是过拟合，我们知道用拉格朗日插值可以根据$n + 1$个点求出一个唯一确定$n$次多项式，但很显然各个项系数可能会非常大，稳定性也会很差。过拟合实际上就是逐渐靠近这个插值的多项式，使得它能在这些训练集的数据上跑的很好，但是测试集效果就会很差（抗干扰能力不强，容易受噪声影响）。</li></ul><p><img src="/mlimg/overfit.png" alt=""><br>如上图也是过拟合，边界的情况不够平滑，事实上我们希望的是下面这样的模型:<br><img src="/mlimg/goodfit.png" alt=""><br>虽然会在边界有一些误判，这也是很正常的，因为有噪声干扰等的原因，但我们希望边界平滑，从而有更好的泛用性。</p><p>为了解决如上的过拟合问题，我们引入了正则项。</p><h1 id="范数"><a href="#范数" class="headerlink" title="范数"></a>范数</h1><p>在介绍正则项前，我们先来看范数的相关内容。</p><h2 id="L-P范数"><a href="#L-P范数" class="headerlink" title="L-P范数"></a>L-P范数</h2><p>$||x||_p = \sqrt[p]{\sum_{i = 1}^nx_i^p}$</p><p>这是范数的通用定义，实际上在机器学习中，$L0, L1, L2$范数用的比较多，其它的使用都非常的少</p><h2 id="L0范数"><a href="#L0范数" class="headerlink" title="L0范数"></a>L0范数</h2><p>$L0$范围根据上面的定义其实不太准确，$L0$范数实际上求的是非零元素的个数。这貌似非常适合用来筛选特征，但实际上$L_0$范围不好找到一个好的数学表达形式（开0次方等行为比较诡异），所以$L_0$的最优化问题一般会被下放到$L_1, L_2$范数下进行最优化</p><h2 id="L1范数"><a href="#L1范数" class="headerlink" title="L1范数"></a>L1范数</h2><p>$L1$范数根据定义可以看出来是进行绝对值求和，下面我们对带有$L1$范数的梯度下降进行一下探究。</p><p>$\theta_j = \theta_j - \alpha(\frac{1}{m}\sum_{i = 1}^m\frac{\partial J(\theta)}{\theta_j} + \frac{\lambda}{m} * sgn(\theta_j))$<br>我们发现，与原来相比，当$\theta$大于0时，他会减去一个数，当$\theta$小于0时，他会加上一个数，当$\theta$等于0时，他不会改变。所以$L1$范围会让参数尽量的等于0，从而起到了参数稀疏化的作用，从而能够用来进行特征筛选。</p><h2 id="L2范数"><a href="#L2范数" class="headerlink" title="L2范数"></a>L2范数</h2><p>$L2$范数根据定义看出就是距离欧几里得距离求和，下面我们对带有$L2$范数的梯度下降进行一下探究。<br>$\theta_j = \theta_j - \alpha(\frac{1}{m}\sum_{i = 1}^m\frac{\partial J(\theta)}{\theta_j} + \frac{\lambda}{m} \theta_j) = (1 - \alpha \lambda)\theta - \frac{1}{m}\sum_{i = 1}^m\frac{\partial J(\theta)}{\theta_j}$<br>我们发现$L_2$范数每次更新时，相当于把自己乘上一个小于1的数再减去梯度，这过程就会使得参数越来越靠近0，但不会等于0，所以$L2$范数限制了参数会出现很大的情况，从而防止过拟合的情况发生。</p><h1 id="正则项"><a href="#正则项" class="headerlink" title="正则项"></a>正则项</h1><p>在原来的$loss$ $function$后面加上某些范数，这些加上的项就是正则项了。<br>对于梯度下降的正则项推导前面都做得差不多了，下面来看一看正规方程的：<br>$J(\theta) = \frac{1}{2m}(\theta X - T)^T(\theta X - T) + \frac{1}{2m}\lambda\theta^T\theta$<br>求导:<br>$\frac{\partial J(\theta)}{\partial \theta} = \frac{1}{2m}  (2X^TX\theta - 2X^TY + \lambda\theta^T\theta) = 0$<br>得到：<br>$\theta = (X^TX + \lambda E)^{-1}X^TY$<br>前面讨论无正则项时，$X^TX$可能会有不可逆的情况，通过加正则项可以解决这种不可逆的情况。</p><p>注意：</p><ul><li>实际使用中为了方便，可能会在正则项前面配一个常数，方便求导的时候可以直接约掉。</li><li>一般正则项我们不包含常数项，原因是常数项大不会扭曲边界，且很多时候确实需要大的常数项</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;拟合&quot;&gt;&lt;a href=&quot;#拟合&quot; class=&quot;headerlink&quot; title=&quot;拟合&quot;&gt;&lt;/a&gt;拟合&lt;/h1&gt;&lt;p&gt;如果一个模型拟合的不好，一般是如下两种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;欠拟合&lt;/li&gt;
&lt;li&gt;过拟合&lt;br&gt;&lt;img src=&quot;/mlimg
      
    
    </summary>
    
      <category term="机器学习" scheme="http://yoursite.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>Logistic回归</title>
    <link href="http://yoursite.com/2020/06/11/Logistic%E5%9B%9E%E5%BD%92/"/>
    <id>http://yoursite.com/2020/06/11/Logistic回归/</id>
    <published>2020-06-11T11:52:11.000Z</published>
    <updated>2020-07-11T08:05:11.813Z</updated>
    
    <content type="html"><![CDATA[<h1 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h1><p>之前学习了线性回归问题，$Logistic$回归虽然还带了回归的字眼，但实际上是一个分类问题。</p><p>分类问题和回归问题前面也做了区分，简单来说分类问题输出的是一个离散的值，相当于输出一个标签。</p><p>我们先讨论二分类的问题，假设分类标签为0、1。如果我们用线性回归的方法去拟合，会出现大于1或者小于0的情况，对于这部分情况我们难以给它分类。所以这才引出了$Logistic$回归</p><h1 id="假设陈述"><a href="#假设陈述" class="headerlink" title="假设陈述"></a>假设陈述</h1><p>我们引入$sigmoid$函数:<br><img src="/mlimg/sigmoid.png" alt=""><br>由图可知，如果用$sigmoid$函数，就可以把原来在值域的值转换到区间[0, 1]中，并且具体的数值可以用来近似表示分类为1(正例)的概率。<br>最后就有$h_{\theta}(X) = \frac{1}{1 + e^{-\theta^TX}}$</p><h1 id="决策边界"><a href="#决策边界" class="headerlink" title="决策边界"></a>决策边界</h1><p>决策边界是用来进行类别划分的边界函数，可以是线性函数也可以是非线性函数。<br><img src="/mlimg/decisionboundary.png" alt=""><br>在$Logistic$回归中，我们有如下预测：</p><ul><li>当$h_{\theta}(X) \geq 0.5$，即$\theta^TX \geq 0$，此时$y = 1$</li><li>当$h_{\theta}(X) &lt; 0.5$，即$\theta^TX &lt; 0$，此时$y = 0$<br>故边界由下述等式来确定：<br>$\theta^TX = 0$</li></ul><h1 id="最大似然估计"><a href="#最大似然估计" class="headerlink" title="最大似然估计"></a>最大似然估计</h1><p>最大似然估计是指在已知一组观测值和模型假设的情况下，求出能使得结果与观测值相同时最大可能性的模型参数。用人话来讲，就是我知道一组观测结果，知道模型的函数，但有些参数没确定，我需要确定这些参数，使得发生与观测情况相同事件的概率最大。</p><p>从另一个角度来说，对于函数$p(x | \theta)$，$x$表示一个具体的数据，$\theta$表示该模型的参数。</p><p>如果$\theta$已知，相当于就是概率函数，代入$x$就能求得$x$样本下时间发生的概率</p><p>如果$x$已知，相当于就是似然函数，它描述了对于不同的模型参数，出现$x$这个样本的概率</p><p>下面有个简单的例子，假设箱子里有一堆球，分别为黑白两色，假设某个人抽了100次，出现了60次白球，40次黑球，我们想知道白球占比是多少？<br>虽然是一个非常简单的问题，但是背后原理就是最大似然估计。<br>这个下面的模型就很简单，概率函数(出现白球)设为$p(x) = p$<br>它的最大似然估计为$p^{60}(1 - p)^{40}$<br>求导算出最大点的$p = 0.6$<br>这就是一个简单的最大似然估计的例子。</p><h1 id="代价函数"><a href="#代价函数" class="headerlink" title="代价函数"></a>代价函数</h1><p>我们先写出最终分类的概率函数：<br>$p(y | x;\theta) = (h_{\theta}(x))^y(1 - h_{\theta}(x))^{1 - y}$<br>对于一组m个的样本$(x_i, y_i)$，我们写出它的似然函数：<br>$L(\theta) = \prod_{i = 1}^m(h_{\theta}(x_i))^{y_i}(1 - h_{\theta}(x_i))^{1 - y_i}$<br>我们对其取对数似然：<br>$l(\theta) = logL(\theta) = \sum_{i = 1}^m(y_ilogh_{\theta}(x_i) + (1 - y_i)log(1 - h_{\theta}(x_i)))$<br>似然函数越大，表示拟合的越好；损失函数越小，同样表示拟合的越好，所以我们可以把似然函数取个反作为损失函数。<br>$J(\theta) = -l(\theta)$<br>这样我们就可以运用前面的梯度下降法来更新了<br>$\theta = \theta - \alpha\frac{1}{m}\frac{\partial J(\theta)}{\partial \theta}$<br>求导过程不写了，直接写最后结果：<br>$\theta_j = \theta_j - \alpha\sum_{i = 1}^m(h_{\theta}(x^{i}) - y^{(i)})x_j^{(i)}$</p><h1 id="多分类问题"><a href="#多分类问题" class="headerlink" title="多分类问题"></a>多分类问题</h1><p>感觉这上面多分类讲的有点简单啊，又查了查资料 + 看了下西瓜书，补充一些内容</p><p>我们已经知道了二分类问题，多分类问题就可以直接套用二分类的做法，只是需要多一个到二分类问题的转换。而这个转换的形式就有几种。</p><h2 id="一对一拆分-OvO"><a href="#一对一拆分-OvO" class="headerlink" title="一对一拆分(OvO)"></a>一对一拆分(OvO)</h2><p>一对一拆分就是最暴力的，对于$n$个分类，我们两两组合，构造$\frac{n(n - 1)}{2}$个二分类器，对于每一个分类器，我们把这两类的数据拿进去训练。对于一个样本，我们用每一个分类器都进行一次预测，最后取票数最高的作为最终预测值。</p><p>特点：分类器数目较多，需要的空间较大，每个分类器只使用两类数据。</p><h2 id="一对多拆分-OvR"><a href="#一对多拆分-OvR" class="headerlink" title="一对多拆分(OvR)"></a>一对多拆分(OvR)</h2><p>一对多拆分就是每次只选一个分类作为1(正例)，剩下的都作为反例，得到$n$个分类器。对于每个分类器都用所有数据去训练。对于一个样本，若有一个分类器为正类，则为该类别，否则取置信度最高的分类器识别的类别。</p><p>特点：分类器较少，每个分类器都需要训练全部数据。</p><h2 id="多对多拆分-MvM"><a href="#多对多拆分-MvM" class="headerlink" title="多对多拆分(MvM)"></a>多对多拆分(MvM)</h2><p>多对多拆分共有$m$个分类器，每个分类器将其中若干个类作为正类，剩下的作为反类，并采取纠错输出码(ECOC)<br>ECOC工作过程主要分为以下两步：<br>1.对N个类做M次划分，每次划分将一部分作为正类，一部分划分反类，从而形成一个二分类训练集。一共产生M个训练集，训练出M个分类器。<br>2.M个分类器分别对测试样本进行预测，这些预测标记组成一个编码。将这个预测编码与每个类各自的编码进行比较，返回其中距离最小的类别作为最终结果。<br><img src="/mlimg/ECOC.png" alt=""><br>如图所示，我们把样本拿到所有分类器中预测，得到一个ECOC码，我们根据码距找最近的，这里有两种码距，简单介绍一下：</p><ul><li>海明距离：简单来说就是有多少个不一样的距离就是多少</li><li>欧氏距离：类比空间里求欧氏距离的公式就可以求出</li></ul><p>特点：对同一个学习任务来说，ECOC编码越长，纠错能力越强。然而编码越长所需要的训练的分类器越多，计算存储开销都会增大；另一方面对于有限类别码长超过一定范围就没有意义了。对于同等长度的编码，理论上来说，任务两个类别之间的编码距离越远，则纠错能力越强。</p><p>最后附上内置数据集里的一个预测，跑的OvR，效果还挺不错的<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_iris <span class="comment">#导入IRIS数据集</span></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">iris = load_iris()</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line">x = iris[<span class="string">'data'</span>]</span><br><span class="line">x = x.tolist()</span><br><span class="line">y = iris[<span class="string">'target'</span>]</span><br><span class="line"></span><br><span class="line">w1 = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>)]</span><br><span class="line">w2 = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>)]</span><br><span class="line">w3 = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>)]</span><br><span class="line"><span class="comment">#print(w)</span></span><br><span class="line"></span><br><span class="line">lr = <span class="number">0.01</span></span><br><span class="line">m = len(x) // <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(x)):</span><br><span class="line">    x[i].append(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(w, x)</span>:</span></span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(w)):</span><br><span class="line">        res += w[i] * x[i]</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> / (<span class="number">1</span> + math.exp(-res))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> t <span class="keyword">in</span> range(<span class="number">1000000</span>):</span><br><span class="line">    i = random.randint(<span class="number">0</span>, <span class="number">20</span>) + random.randint(<span class="number">0</span>, <span class="number">2</span>) * <span class="number">50</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(len(w1)):</span><br><span class="line">        w1[j] = w1[j] - <span class="number">1</span> / m * lr * (f(w1, x[i]) - (<span class="number">1</span> <span class="keyword">if</span> y[i] == <span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span>)) * x[i][j]</span><br><span class="line">        w2[j] = w2[j] - <span class="number">1</span> / m * lr * (f(w2, x[i]) - (<span class="number">1</span> <span class="keyword">if</span> y[i] == <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span>)) * x[i][j]</span><br><span class="line">        w3[j] = w3[j] - <span class="number">1</span> / m * lr * (f(w3, x[i]) - (<span class="number">1</span> <span class="keyword">if</span> y[i] == <span class="number">2</span> <span class="keyword">else</span> <span class="number">0</span>)) * x[i][j]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">all = <span class="number">0</span></span><br><span class="line">correct = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">px = []</span><br><span class="line">py = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">150</span>):</span><br><span class="line">    all += <span class="number">1</span></span><br><span class="line">    p = [f(w1, x[i]), f(w2, x[i]), f(w3, x[i])]</span><br><span class="line">    flag = <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> max(p) == p[y[i]]:</span><br><span class="line">        correct += <span class="number">1</span></span><br><span class="line">        py.append(y[i])</span><br><span class="line">    <span class="keyword">else</span>: py.append(p.index(max(p)))</span><br><span class="line">    px.append(i)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(correct, all, correct / all)</span><br><span class="line"></span><br><span class="line">plt.plot(px, py, <span class="string">'.'</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;分类&quot;&gt;&lt;a href=&quot;#分类&quot; class=&quot;headerlink&quot; title=&quot;分类&quot;&gt;&lt;/a&gt;分类&lt;/h1&gt;&lt;p&gt;之前学习了线性回归问题，$Logistic$回归虽然还带了回归的字眼，但实际上是一个分类问题。&lt;/p&gt;
&lt;p&gt;分类问题和回归问题前面也做了区
      
    
    </summary>
    
      <category term="机器学习" scheme="http://yoursite.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>多变量线性回归</title>
    <link href="http://yoursite.com/2020/06/09/%E5%A4%9A%E5%8F%98%E9%87%8F%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/"/>
    <id>http://yoursite.com/2020/06/09/多变量线性回归/</id>
    <published>2020-06-09T07:30:43.000Z</published>
    <updated>2020-07-11T08:05:07.846Z</updated>
    
    <content type="html"><![CDATA[<h1 id="多功能"><a href="#多功能" class="headerlink" title="多功能"></a>多功能</h1><h2 id="一些定义"><a href="#一些定义" class="headerlink" title="一些定义"></a>一些定义</h2><ul><li>$x_i^{(j)}$:第$i$个样本的第$j$个特征</li></ul><h2 id="多变量形式"><a href="#多变量形式" class="headerlink" title="多变量形式"></a>多变量形式</h2><p>$h_{\theta}(x) = \theta_0 + \theta_1x_1 + \theta_2x_2 + \dots + \theta_nx_n$, 这里的$x_i$就代表第$i$个特征</p><h2 id="矩阵定义"><a href="#矩阵定义" class="headerlink" title="矩阵定义"></a>矩阵定义</h2><p>我们这里用矩阵来定义，后面我们将发现，运算过程可以变为矩阵的乘法。</p><ul><li><p>$\theta =<br>\left[<br>\begin{matrix}<br> \theta_0\\<br> \theta_1\\<br> \theta_2\\<br> .\\<br> .\\<br> \theta_n<br>\end{matrix}<br>\right]<br>$</p></li><li><p>$x =<br>\left[<br>\begin{matrix}<br> 1\\<br> x_1\\<br> x_2\\<br> .\\<br> .\\<br> x_n<br>\end{matrix}<br>\right]<br>$</p></li></ul><p>我们发现上面的$h_{\theta}(x)$可以写成$h_{\theta}(x) = \theta^Tx$</p><h1 id="多元梯度下降法"><a href="#多元梯度下降法" class="headerlink" title="多元梯度下降法"></a>多元梯度下降法</h1><p>其实就是把线性的拿来做了一个拓展，形式都完全一样</p><ul><li>$J(\theta_0, \theta_1, \theta_2\cdots, \theta_n) = \frac{1}{2m}\sum_{i = 1}^m(\theta_{i0} + \theta_1x_{i1} + \theta_2x_{i2} + \cdots + \theta_nx_{in} - y_i) ^ 2$</li></ul><p>那么我们有如下的更新方法：<br>$\theta_z = \theta_z - \alpha\frac{1}{m}\sum_{i = 1}^m(h_{\theta}(x^{(i)}) - y^{(i)})x_z{(i)}$，其中$x_0 = 1$</p><h1 id="特征放缩"><a href="#特征放缩" class="headerlink" title="特征放缩"></a>特征放缩</h1><p>在$h_{\theta}(x) = \theta_0 + \theta_1x_1 + \theta_2x_2 + \dots + \theta_nx_n$中，假设各个$x_i$的取值范围大小相差很大，在更新上会出现不稳定的问题。原因就是参数值大的出现的波动会更大，举个例子，假设各个参数$\theta_i$都增加0.01，那么取值范围较大的$x_i$特征就会使整个函数的波动更大，在等高线图上表现出来就是$x_i$越大$\theta_i$会显得越加扁平，会造成其他维度的更新较为缓慢。<strong>这样即造成迭代过程中很多轮次实际上是为了消除特征尺度上的不一致，</strong>故而增加了迭代的轮次，收敛速度变慢。<br><img src="\mlimg\equalheight1.png" alt=""></p><p>如果各个维度取值范围接近，那么在等高线图上看起来就会显得很均匀，比如二维平面上就是一个圆，三维平面上就是一个球。<br><img src="\mlimg\equalheight2.png" alt=""></p><p>明显从图中发现，越均匀就会减少很多”绕路”的更新，更直接的接近最小值。</p><p>特征放缩的方法有很多，最常用的是如下：<br>$x’ = \frac{x - \mu}{s}$，其中$s = max - min$，又称为标准差。<br>还有其他很多不同的方法，这里不赘述。</p><h1 id="多项式回归"><a href="#多项式回归" class="headerlink" title="多项式回归"></a>多项式回归</h1><p>多项式回归很简单，只需要把上述的多变量形式里面的$x_i$换成对应的幂次就行了。这个过程中要特别注意特征放缩的问题，因为多项式拟合里出现了幂次，很容易就使得某个原来$x$的取值范围变得很大。</p><h1 id="正规方程"><a href="#正规方程" class="headerlink" title="正规方程"></a>正规方程</h1><p>求解正规方程是不是就是最小二乘法的过程啊。。。</p><p>假设方程一共$n + 1$个特征，我们把每个训练的样本看作一个向量：<br>$x_i =<br>\left[<br>  \begin{matrix}<br>  x_i^{(0)}\\<br>  x_i^{(1)}\\<br>  x_i^{(2)}\\<br>  .\\<br>  .\\<br>  .\\<br>  x_i^{(n)}<br>  \end{matrix}<br>\right]<br>$ </p><p>我们就可以构造$X、y$矩阵:<br>$X =<br>\left[<br>  \begin{matrix}<br>  x_1\\<br>  x_2\\<br>  x_3\\<br>  .\\<br>  .\\<br>  .\\<br>  x_n<br>  \end{matrix}<br>\right]<br>$</p><p>$y =<br>\left[<br>  \begin{matrix}<br>  y_1\\<br>  y_2\\<br>  y_3\\<br>  .\\<br>  .\\<br>  .\\<br>  y_n<br>  \end{matrix}<br>\right]<br>$<br>最优化参数$\theta$矩阵就满足如下式子：<br>$\theta = (X^TX)^{-1}X^Ty$<br>这式子就跟最小二乘推导出的东西一毛一样嘛（应该说的就是一个东西）</p><p>关于梯度下降法和正规方程法的对比如下：<br><img src="/mlimg/comparegdandne.png" alt=""></p><h1 id="正规方程不可逆"><a href="#正规方程不可逆" class="headerlink" title="正规方程不可逆"></a>正规方程不可逆</h1><p>从上面式子看到，如果想要能求出正确结果，需要满足$X^TX$是可逆的，事实上可能会存在一些情况导致其不可逆，原因可能如下：</p><ul><li>特征太多，样本太少</li><li>特征之间不是独立关系</li></ul><p>第一点说的就是矩阵的秩太小，达不到满秩，自然就不可逆。<br>第二点说的是各个向量不是线性无关的，所以本质上秩在经过行列变换后会变小，达不到满秩。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;多功能&quot;&gt;&lt;a href=&quot;#多功能&quot; class=&quot;headerlink&quot; title=&quot;多功能&quot;&gt;&lt;/a&gt;多功能&lt;/h1&gt;&lt;h2 id=&quot;一些定义&quot;&gt;&lt;a href=&quot;#一些定义&quot; class=&quot;headerlink&quot; title=&quot;一些定义&quot;&gt;&lt;/a&gt;一些定
      
    
    </summary>
    
      <category term="机器学习" scheme="http://yoursite.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>单变量线性回归</title>
    <link href="http://yoursite.com/2020/06/08/%E5%8D%95%E5%8F%98%E9%87%8F%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/"/>
    <id>http://yoursite.com/2020/06/08/单变量线性回归/</id>
    <published>2020-06-08T02:31:51.000Z</published>
    <updated>2020-07-11T08:04:51.162Z</updated>
    
    <content type="html"><![CDATA[<h1 id="模型描述"><a href="#模型描述" class="headerlink" title="模型描述"></a>模型描述</h1><p>$y = \theta_0  +  \theta_1x$</p><h1 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h1><ul><li>$(x^{(i)}, y^{(i)})$表示训练集中第i对样本</li><li>$J(\theta_1, \theta_2  )$ $=$ $\frac{1}{2m}\sum_{i = 1}^m(h(x^{(i)})  - y^{(i)})^2$</li></ul><h1 id="梯度下降法"><a href="#梯度下降法" class="headerlink" title="梯度下降法"></a>梯度下降法</h1><ul><li>$\theta_i$ = $\theta_i$ - $\alpha \frac{\partial J(\theta_1, \theta_2)}{\theta_i}$，其中$\alpha$代表学习率</li></ul><p>其实根据高等数学知识可知，求偏导可以相当于把整个函数看作一元函数，我们已知一元导数表示在该点$x$增大，$y$增大的趋势。如果$x$增大$y$也增大，那么我们希望$x$减小，否则希望$x$增大，所以可以发现上面梯度下降的减号是很有道理的。<br>对于每一个变量我们都按上述操作进行更新，最后函数$J$就能往最小值逼近。</p><ul><li>梯度下降虽然是每次更新是让各个参数向着函数值减少值方向在变化，但并不一定是让各个参数一直在向最优的结果变化，举个例子：<br>$y = \theta_0  +  \theta_1x$<br>假设对于某个时刻，$\theta_1$很小，$\theta_0$很大，此时$loss$ $function$也很大，求导后发现$\theta_1$会继续减小，但实际上最优的情况比当前$\theta_1$要大。<br>但这并不影响什么，实际上只要迭代次数足够多，最后一定会绕回到非常靠近最优解的位置。</li></ul><p>附上一个小的test，拟合一条直线，数据随缘取的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">x = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">y = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>]</span><br><span class="line"></span><br><span class="line">w = [<span class="number">1000000</span>, <span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">lr = <span class="number">0.001</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1000000</span>):</span><br><span class="line">    k_sum = <span class="number">0</span></span><br><span class="line">    b_sum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(min(len(x), len(y))):</span><br><span class="line">        k_sum += (w[<span class="number">1</span>] * x[j] + w[<span class="number">0</span>] - y[j]) * x[j]</span><br><span class="line">        b_sum += (w[<span class="number">1</span>] * x[j] + w[<span class="number">0</span>] - y[j])</span><br><span class="line"></span><br><span class="line">    k_sum /= <span class="number">10</span></span><br><span class="line">    b_sum /= <span class="number">10</span></span><br><span class="line">    w[<span class="number">0</span>] = w[<span class="number">0</span>] - lr * b_sum</span><br><span class="line">    w[<span class="number">1</span>] = w[<span class="number">1</span>] - lr * k_sum</span><br><span class="line"></span><br><span class="line">print(w[<span class="number">0</span>], w[<span class="number">1</span>])</span><br></pre></td></tr></table></figure><p>最后得到k，b如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">k = <span class="number">1.9999999999994449</span></span><br><span class="line">b = <span class="number">1.0000000000011102</span></span><br></pre></td></tr></table></figure></p><p>发现非常接近准确值$y = 2x + 1$</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;模型描述&quot;&gt;&lt;a href=&quot;#模型描述&quot; class=&quot;headerlink&quot; title=&quot;模型描述&quot;&gt;&lt;/a&gt;模型描述&lt;/h1&gt;&lt;p&gt;$y = \theta_0  +  \theta_1x$&lt;/p&gt;
&lt;h1 id=&quot;损失函数&quot;&gt;&lt;a href=&quot;#损失函数&quot;
      
    
    </summary>
    
      <category term="机器学习" scheme="http://yoursite.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
</feed>

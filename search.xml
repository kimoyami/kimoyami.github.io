<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[多变量线性回归]]></title>
    <url>%2F2020%2F06%2F09%2F%E5%A4%9A%E5%8F%98%E9%87%8F%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92%2F</url>
    <content type="text"><![CDATA[多功能一些定义 $x_i^{(j)}$:第$i$个样本的第$j$个特征 多变量形式$h_{\theta}(x) = \theta_0 + \theta_1x_1 + \theta_2x_2 + \dots + \theta_nx_n$, 这里的$x_i$就代表第$i$个特征 矩阵定义我们这里用矩阵来定义，后面我们将发现，运算过程可以变为矩阵的乘法。 $\theta =\left[\begin{matrix} \theta_0\\ \theta_1\\ \theta_2\\ .\\ .\\ \theta_n\end{matrix}\right]$ $x =\left[\begin{matrix} 1\\ x_1\\ x_2\\ .\\ .\\ x_n\end{matrix}\right]$ 我们发现上面的$h_{\theta}(x)$可以写成$h_{\theta}(x) = \theta^Tx$ 多元梯度下降法其实就是把线性的拿来做了一个拓展，形式都完全一样 $J(\theta_0, \theta_1, \theta_2\cdots, \theta_n) = \frac{1}{2m}\sum_{i = 1}^m(\theta_{i0} + \theta_1x_{i1} + \theta_2x_{i2} + \cdots + \theta_nx_{in} - y_i) ^ 2$ 那么我们有如下的更新方法：$\theta_z = \theta_z - \alpha\frac{1}{m}\sum_{i = 1}^m(h_{\theta}(x^{(i)}) - y^{(i)})x_z{(i)}$，其中$x_0 = 1$ 特征放缩在$h_{\theta}(x) = \theta_0 + \theta_1x_1 + \theta_2x_2 + \dots + \theta_nx_n$中，假设各个$x_i$的取值范围大小相差很大，在更新上会出现不稳定的问题。原因就是参数值大的出现的波动会更大，举个例子，假设各个参数$\theta_i$都增加0.01，那么取值范围较大的$x_i$特征就会使整个函数的波动更大，在等高线图上表现出来就是$x_i$越大$\theta_i$会显得越加扁平，会造成其他维度的更新较为缓慢。这样即造成迭代过程中很多轮次实际上是为了消除特征尺度上的不一致，故而增加了迭代的轮次，收敛速度变慢。 如果各个维度取值范围接近，那么在等高线图上看起来就会显得很均匀，比如二维平面上就是一个圆，三维平面上就是一个球。 明显从图中发现，越均匀就会减少很多”绕路”的更新，更直接的接近最小值。 特征放缩的方法有很多，最常用的是如下：$x’ = \frac{x - \mu}{s}$，其中$s = max - min$，又称为标准差。还有其他很多不同的方法，这里不赘述。 多项式回归多项式回归很简单，只需要把上述的多变量形式里面的$x_i$换成对应的幂次就行了。这个过程中要特别注意特征放缩的问题，因为多项式拟合里出现了幂次，很容易就使得某个原来$x$的取值范围变得很大。 正规方程求解正规方程是不是就是最小二乘法的过程啊。。。 假设方程一共$n + 1$个特征，我们把每个训练的样本看作一个向量：$x_i =\left[ \begin{matrix} x_i^{(0)}\\ x_i^{(1)}\\ x_i^{(2)}\\ .\\ .\\ .\\ x_i^{(n)} \end{matrix}\right]$ 我们就可以构造$X、y$矩阵:$X =\left[ \begin{matrix} x_1\\ x_2\\ x_3\\ .\\ .\\ .\\ x_n \end{matrix}\right]$ $y =\left[ \begin{matrix} y_1\\ y_2\\ y_3\\ .\\ .\\ .\\ y_n \end{matrix}\right]$最优化参数$\theta$矩阵就满足如下式子：$\theta = (X^TX)^{-1}X^Ty$这式子就跟最小二乘推导出的东西一毛一样嘛（应该说的就是一个东西） 关于梯度下降法和正规方程法的对比如下： 正规方程不可逆从上面式子看到，如果想要能求出正确结果，需要满足$X^TX$是可逆的，事实上可能会存在一些情况导致其不可逆，原因可能如下： 特征太多，样本太少 特征之间不是独立关系 第一点说的就是矩阵的秩太小，达不到满秩，自然就不可逆。第二点说的是各个向量不是线性无关的，所以本质上秩在经过行列变换后会变小，达不到满秩。]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[单变量线性回归]]></title>
    <url>%2F2020%2F06%2F08%2F%E5%8D%95%E5%8F%98%E9%87%8F%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92%2F</url>
    <content type="text"><![CDATA[模型描述$y = \theta_0 + \theta_1x$ 损失函数 $(x^{(i)}, y^{(i)})$表示训练集中第i对样本 $J(\theta_1, \theta_2 )$ $=$ $\frac{1}{2m}\sum_{i = 1}^m(h(x^{(i)}) - y^{(i)})^2$ 梯度下降法 $\theta_i$ = $\theta_i$ - $\alpha \frac{\partial J(\theta_1, \theta_2)}{\theta_i}$，其中$\alpha$代表学习率 其实根据高等数学知识可知，求偏导可以相当于把整个函数看作一元函数，我们已知一元导数表示在该点$x$增大，$y$增大的趋势。如果$x$增大$y$也增大，那么我们希望$x$减小，否则希望$x$增大，所以可以发现上面梯度下降的减号是很有道理的。对于每一个变量我们都按上述操作进行更新，最后函数$J$就能往最小值逼近。 梯度下降虽然是每次更新是让各个参数向着函数值减少值方向在变化，但并不一定是让各个参数一直在向最优的结果变化，举个例子：$y = \theta_0 + \theta_1x$假设对于某个时刻，$\theta_1$很小，$\theta_0$很大，此时$loss$ $function$也很大，求导后发现$\theta_1$会继续减小，但实际上最优的情况比当前$\theta_1$要大。但这并不影响什么，实际上只要迭代次数足够多，最后一定会绕回到非常靠近最优解的位置。 附上一个小的test，拟合一条直线，数据随缘取的。 1234567891011121314151617181920x = [0, 1, 2, 3]y = [1, 3, 5, 7]w = [1000000, 0]lr = 0.001for i in range(1000000): k_sum = 0 b_sum = 0 for j in range(min(len(x), len(y))): k_sum += (w[1] * x[j] + w[0] - y[j]) * x[j] b_sum += (w[1] * x[j] + w[0] - y[j]) k_sum /= 10 b_sum /= 10 w[0] = w[0] - lr * b_sum w[1] = w[1] - lr * k_sumprint(w[0], w[1]) 最后得到k，b如下：12k = 1.9999999999994449b = 1.0000000000011102 发现非常接近准确值$y = 2x + 1$]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[初始机器学习]]></title>
    <url>%2F2020%2F06%2F06%2F%E5%88%9D%E5%A7%8B%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[监督学习这一章好像没啥内容，主要是区分几个概念。 监督学习利用一组已知类别的样本调整分类器的参数，使其达到所要求性能的过程 分类问题与回归问题由字面意思可得，分类问题解决的是把目标归属到某个类别当中，而回归问题解决的是通过一系列相关因素预测目标的一个值。 区别 分类问题的目标值是离散的，回归是连续的 二者$loss$ $function$函数性质不同，回归问题$loss$函数输出空间是度量空间，即可以”定量”，而分类问题$loss$函数输出空间不是度量空间，即只有正确和错误之分，只能”定性” 无监督学习无监督学习根据类别未知(没有被标记)的训练样本解决模式识别中的各种问题 无监督学习与有监督学习区别 有监督学习有$y$，而无监督学习无$y$上述说法只是表面现象，但感觉没有直击本质。搜集资料时看到一位网友的总结：标签$y$其实是一种施加于对$x$进行压缩过程中的约束。这就是有监督学习。换句话说，机器学习本质上是一种数据的压缩，有监督学习给了这种压缩一个约束，而无监督学习是让机器自己对数据进行重建，如下图： 让我们来举两个例子： 根据患者各方面情况判断是否得了某种病 有监督学习 根据新闻内容，内容相近的归为一个专题 无监督学习]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[多项式，永远滴神]]></title>
    <url>%2F2020%2F04%2F27%2F%E5%A4%9A%E9%A1%B9%E5%BC%8F%EF%BC%8C%E6%B0%B8%E8%BF%9C%E6%BB%B4%E7%A5%9E%2F</url>
    <content type="text"><![CDATA[FFT先咕 NTT先咕 FWTFWT是解决形如C_k = \sum_{i \ op \ j}A_i * B_j，其中op可以是$\&amp; | \bigoplus$等操作，普通方法肯定是$O(n^2)$的，考虑$FFT$是做了一种变化，然后变化后进行点乘，再逆变化回去，就可以把复杂度优化到$O(nlogn)$，$FWT$能不能采取类似的思路呢？答案是肯定的。我们需要构造$FWT(A)$，使得$FWT(A op B) = FWT(A) * FWT(B)$仔细观察，发现这个东西满足交换律：$FWT(A | B) = FWT(B | A)$再观察，发现这玩意还满足结合律：$FWT((A + B) | C) = FWT(A | C) + FWT(B | C)$我们对于一个多项式$A$，定义$A_0，A_1$，分别表示前一半和后一半多项式（二进制最高位为0和为1）。 or$FWT(A) = (FWT(A_0), FWT(A_0 + A_1))$你问括号里的加法是什么意思？就是可以把他们看成一个维度相同的向量，对应位置相加。你问括号里一个逗号什么意思，就是两个多项式拼起来。前面是前一半的结果，后面是后一半的结果。 考虑正确性，因为是或运算，FWT其实求的就是子集的前缀和（所有子集的和），首先前一半系数必然最高位都为0，所以只能是由$A_0$里面来产生的贡献。考虑后面，因为最高位必须为1，所以一部分贡献来自最高位为1的，同时考虑某个位置去掉最高位的1，会对应$A_0$中的某个位置，这部分贡献也会被包含，所以最终贡献就是$A_0 + A_1$然后我们就可以递归去做求的$or的FWT$了（事实上实现的时候我们采用循环） 考虑怎么反变换回来，其实很简单$IFWT(A) = (IFWT(A_0)，IFWT(A_1 - A_0))$ andand刚好是跟or反过来的，or的$FWT$表示的是某个集合所有的子集的和，而and的$FWT$是表示的某个集合所有包含它的集合的和，相当于可以描述为后缀和？那么它的$FWT$我们考虑表示$FWT(A) = FWT(FWT(A_0 + A_1), FWT(A_1))$。 考虑正确性证明，首先后一半的贡献必须全来自$A_1$，前一半$A_0$会产生贡献，$A_0$每一项加上最高位对应$A_1$中的每一项也会产生贡献，所以就是$A_0 + A_1$ 对应反变换也很好写$IFWT(A) = (IFWT(A_0 + A_1)，IFWT(A_1))$ xor异或的构造是最难的，也是唯一没法从$FMT$角度解释的一个，可以说是真正的$FWT$。这里给出构造$FWT(A) = (FWT(A_0 + A_1), FWT(A_0 - A_1))$ 给出正确性证明：$= FWT((A_0 \bigoplus B_0) + FWT(A_1 \bigoplus B_1), FWT(A_0 \bigoplus B_1) + FWT(A_1 \bigoplus B_0))$ = (FWT(A_0 \bigoplus B_0 + A_1 \bigoplus B_1 + A_1 \bigoplus B_0 + A_0 \bigoplus B_1),FWT(A_0 \bigoplus B_0 + A_1 \bigoplus B_1 - A_1 \bigoplus B_0 - A_0 \bigoplus B_1))= ((FWT(A_0) + FWT(A_1)) * (FWT(B_0) + FWT(B_1)),(FWT(A_0) - FWT(A_1)) * (FWT(B_0) - FWT(B_1)))= (FWT(A_0 + A_1) * FWT(B_0 + B_1),FWT(A_0 - A_1) * FWT(B_0 - B_1))= (FWT(A_0 + A_1), FWT(A_0 - A_1)) * (FWT(B_0 + B_1),FWT(B_0 - B_1)) = FWT(A) * FWT(B)]]></content>
      <categories>
        <category>多项式</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[论一类x次方计数问题的求解]]></title>
    <url>%2F2020%2F04%2F09%2F%E8%AE%BA%E4%B8%80%E7%B1%BBx%E6%AC%A1%E6%96%B9%E8%AE%A1%E6%95%B0%E9%97%AE%E9%A2%98%E7%9A%84%E6%B1%82%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[前言本文主要探究总结一类问题：统计某种情况下某个东西出现次数的x次方的问题的求解。 一次方我们先看一看一次方的情况我们一般怎么思考问题： CCPC-Wannafly Winter Camp Day8 Div2 穗乃果的考试询问一个01矩形中，所有子矩形包含1的个数的总和。枚举子矩形需要一个左上角和一个右下角，发现复杂度非常高，故而不能直接枚举矩形。考虑答案 = $\sum_{子矩形x}\sum a_{ij}$我们变换求和顺序:$\sum_{原矩形中每一个元素a_{ij}且a_{ij} == 1}\sum_{子矩形x}[x包含a_{ij}]$应该不难证明二者是等价的，我们发现枚举$a_{ij}$ 我们是可以接受的，且算有多少子矩形包含$a_{ij}$是非常容易的一件事情，那么问题就做完了。 一次好像非常显然，但是这只是给你开心开心的。 2次方还是先引入一个题目： CCPC-Wannafly Winter Camp Day8 Div1 穗乃果的考试我家果果是真的喜欢组合数学啊，还都是这么难的发现跟上一题的变化就是1次变为了2次，但是一下子就难了不少呢。我们还是冷静分析一波：答案 = $\sum_{子矩形x}\sum^2_{a_{ij}}a_{ij}$展开看一看：$\sum_{子矩形x}(a_n + a_{n + 1} + … + a_{m})(a_n + a_{n + 1} + … + a_{m})$PS：$(a_n + a_{n + 1} + …. + a_{m})$指的是$子矩形x$中所有的元素。还是变换求和顺序，我们看之前一次的时候，我们是从所有$a_{ij} == 1$中选一个出来，看有多少子矩形包含$a_{ij}$，本质是从后面每一个可能对答案产生贡献的项拿出来，看有多少情况包含它。我们看二次的后面的项：$(a_n + a_{n + 1} + … + a_{m})(a_n + a_{n + 1} + … + a_{m})$，把乘法展开，相当于枚举每一个不为0的项，然后看有多少子矩形包含这两项。那么答案 = $\sum_{(x = a_{ij}) == 1}\sum_{(y = a_{ij}) == 1} 包含x和y两个点的子矩形的数目$然后枚举一个点，另一个点分为四个方向，前缀和维护一下就做完了。 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef double db;typedef pair&lt;int, int&gt; pii;typedef vector&lt;int&gt; vi;typedef vector&lt;ll&gt; vl;typedef vector&lt;pii&gt; vp;const int inf = 1e9;const ll INF = 1e18;const db eps = 1e-10;#define fi first#define se second#define pb push_back#define eb emplace_back#define ep emplace#define mem(a) memset(a, 0, sizeof(a))#define copy(a, b) memcpy(a, b, sizeof(b))#define PA cout &lt;&lt; "pass\n"#define lowbit(x) (x &amp; -x)#define all(x) x.begin(), x.end()#define TM cout &lt;&lt; db(clock()) / CLOCKS_PER_SEC &lt;&lt; '\n'mt19937 mrand(chrono::high_resolution_clock::now().time_since_epoch().count());template&lt;class T&gt;inline void upmin(T &amp;x, T y) &#123;x = x &gt; y ? y : x;&#125;template&lt;class T&gt;inline void upmax(T &amp;x, T y) &#123;x = x &lt; y ? y : x;&#125;const int maxn = 2020;char s[maxn][maxn];int n, m;const int mod = 998244353;void add(int &amp;x, int y)&#123; x += y; if(x &gt;= mod) x -= mod;&#125;void sub(int &amp;x, int y)&#123; x -= y; if(x &lt; 0) x += mod;&#125;int s3[maxn][maxn];int s4[maxn][maxn];int c1[maxn][maxn], c2[maxn][maxn];int main()&#123; scanf("%d %d", &amp;n, &amp;m); for(int i = 1; i &lt;= n; i++) scanf("%s", s[i] + 1); for(int i = 1; i &lt;= n; i++)&#123; for(int j = 1; j &lt;= m; j++)&#123; if(s[i][j] == '1')&#123; add(s3[i][j], 1ll * i * j % mod); add(s4[i][j], 1ll * i * (m - j + 1) % mod); add(c1[i][j], 1); add(c2[i][j], 1); &#125; add(s3[i][j], s3[i - 1][j]); add(s3[i][j], s3[i][j - 1]); sub(s3[i][j], s3[i - 1][j - 1]); add(c1[i][j], c1[i - 1][j]); add(c1[i][j], c1[i][j - 1]); sub(c1[i][j], c1[i - 1][j - 1]); &#125; &#125; for(int i = 1; i &lt;= n; i++)&#123; for(int j = m; j; j--)&#123; add(s4[i][j], s4[i - 1][j]); add(s4[i][j], s4[i][j + 1]); sub(s4[i][j], s4[i - 1][j + 1]); add(c2[i][j], c2[i - 1][j]); add(c2[i][j], c2[i][j + 1]); sub(c2[i][j], c2[i - 1][j + 1]); &#125; &#125; int res = 0; for(int i = 1; i &lt;= n; i++)&#123; for(int j = 1; j &lt;= m; j++)&#123; if(s[i][j] == '0') continue; int a = n - i + 1; int b = m - j + 1; add(res, 1ll * a * b % mod * s3[i - 1][j - 1] % mod); b = j; add(res, 1ll * a * b % mod * s4[i - 1][j + 1] % mod); &#125; &#125; add(res, res); for(int i = 1; i &lt;= n; i++)&#123; int pre = 0; int tmp = 0; for(int j = 1; j &lt;= m; j++)&#123; if(s[i][j] == '0') continue; add(tmp, 1ll * (m - j + 1) * pre % mod); add(pre, j); &#125; tmp = 2ll * tmp * i % mod * (n - i + 1) % mod; add(res, tmp); &#125; for(int j = 1; j &lt;= m; j++)&#123; int pre = 0; int tmp = 0; for(int i = 1; i &lt;= n; i++)&#123; if(s[i][j] == '0') continue; add(tmp, 1ll * (n - i + 1) * pre % mod); add(pre, i); &#125; tmp = 2ll * tmp * j % mod * (m - j + 1) % mod; add(res, tmp); &#125; for(int i = 1; i &lt;= n; i++)&#123; for(int j = 1; j &lt;= m; j++)&#123; if(s[i][j] == '1') add(res, 1ll * (n - i + 1) * i % mod * (m - j + 1) % mod * j % mod); &#125; &#125; printf("%d\n", res); return 0;&#125; x次方根据上面的做法我们可以看出，对于求某种情况下某个东西x次方的贡献，我们把符合条件的点提出来变成一个序列，然后复制x次，问题就变成了这x个序列每个选1个，然后求同时包含这x个的情况一共有多少种。 再来看一个稍微硬核一点的题 Asia-Beijing Regional 2014 - F(Fluorescent)给定n栈灯，m个开关（n &lt;= 50, m &lt;= 50），每个开关连接一系列灯，并且能把这一系列灯的状态同时翻转，问所有情况下亮着灯数目三次方的期望是多少 考虑答案 = $\sum_{情况x}(a_1 + a_2 + … + a_n)^3$考虑变换求和顺序：对$(a_1 + a_2 + … + a_n)^3$中的每一组不为0的项，求有多少方案使得这三个位置最后都是亮着的。 这样我们就可以枚举三个位置，然后用状压dp求解了，最后求和就行了。 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef double db;typedef pair&lt;int, int&gt; pii;typedef vector&lt;int&gt; vi;typedef vector&lt;ll&gt; vl;typedef vector&lt;pii&gt; vp;const int inf = 1e9;const ll INF = 1e18;const db eps = 1e-10;#define fi first#define se second#define pb push_back#define eb emplace_back#define ep emplace#define mem(a) memset(a, 0, sizeof(a))#define copy(a, b) memcpy(a, b, sizeof(b))#define PA cout &lt;&lt; "pass\n"#define lowbit(x) (x &amp; -x)#define all(x) x.begin(), x.end()#define TM cout &lt;&lt; db(clock()) / CLOCKS_PER_SEC &lt;&lt; '\n'mt19937 mrand(chrono::high_resolution_clock::now().time_since_epoch().count());template&lt;class T&gt;inline void upmin(T &amp;x, T y) &#123;x = x &gt; y ? y : x;&#125;template&lt;class T&gt;inline void upmax(T &amp;x, T y) &#123;x = x &lt; y ? y : x;&#125;int T;int dp[55][8];int n, m;bool vis[55][55];const int mod = 1e9 + 7;void add(int &amp;x, int y)&#123; x += y; if(x &gt;= mod) x -= mod;&#125;int main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); cout &lt;&lt; fixed &lt;&lt; setprecision(10); cin &gt;&gt; T; for(int kase = 1; kase &lt;= T; kase++)&#123; cin &gt;&gt; n &gt;&gt; m; mem(vis); for(int i = 1; i &lt;= m; i++)&#123; int len; cin &gt;&gt; len; for(int j = 1; j &lt;= len; j++)&#123; int x; cin &gt;&gt; x; vis[i][x] = 1; &#125; &#125; int res = 0; for(int i = 1; i &lt;= n; i++)&#123; for(int j = 1; j &lt;= n; j++)&#123; for(int k = 1; k &lt;= n; k++)&#123; mem(dp); dp[0][0] = 1; for(int p = 1; p &lt;= m; p++)&#123; int t1 = 0, t2 = 0, t3 = 0; if(vis[p][i]) t1 = 1; if(vis[p][j]) t2 = 2; if(vis[p][k]) t3 = 4; for(int mask = 0; mask &lt; 8; mask++)&#123; add(dp[p][mask ^ t1 ^ t2 ^ t3], dp[p - 1][mask]); add(dp[p][mask], dp[p - 1][mask]); &#125; &#125; add(res, dp[m][7]); &#125; &#125; &#125; cout &lt;&lt; "Case #" &lt;&lt; kase &lt;&lt; ": " &lt;&lt; res &lt;&lt; '\n'; &#125; return 0;&#125; 再来个最难的 2018-2019 ACM-ICPC, Asia Xuzhou Regional Contest - D(Rikka with Subsequences)给定一种”好子序列”的定义，求所有本质相同好子序列个数三次方的和 直接考虑问题转换，既然是求本质相同的好子序列出现次数三次方的和，我们可以等价于求把原序列复制三份，在三份上各取一个子序列，且子序列相同的情况数。 考虑$dp[i][j][k]$为第一个好子序列最后为$i$结尾，第二个好子序列最后以$j$结尾，第三个好子序列最后以$k$结尾。考虑转移，对于某一个$dp[i][j][k]$，我们找前面有多少$dp[i’][j’][k’]$ $(i’ &lt; i, j’ &lt; j, k’ &lt; k)$，但由于还有好子序列的限制，所以我们要找到所有$a[i’] = a[i]$的点，剩下的就是找$j’$, $k’$，这相当于是个二位前缀和（因为只用限制一个点，剩下$a[j]$，$a[k]$，$a[j’]$，$a[k’]$必然相等。）也就是对于每个$i$，我们对所有满足$a[j] = a[i]$的$j$，$k$求一次前缀和，然后加速转移，同时在这里统计方案即可。 代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include&lt;bits/stdc++.h&gt;using namespace std; typedef long long ll;typedef unsigned long long ull;typedef double db;typedef pair&lt;int, int&gt; pii;typedef vector&lt;int&gt; vi;typedef vector&lt;ll&gt; vl;typedef vector&lt;pii&gt; vp;const int inf = 1e9;const ll INF = 1e18;const db eps = 1e-10; #define fi first#define se second#define pb push_back#define eb emplace_back#define ep emplace#define mem(a) memset(a, 0, sizeof(a))#define copy(a, b) memcpy(a, b, sizeof(b))#define PA cout &lt;&lt; "pass\n"#define lowbit(x) (x &amp; -x)#define all(x) x.begin(), x.end()#define TM cout &lt;&lt; db(clock()) / CLOCKS_PER_SEC &lt;&lt; '\n' mt19937 mrand(chrono::high_resolution_clock::now().time_since_epoch().count()); template&lt;class T&gt;inline void upmin(T &amp;x, T y) &#123;x = x &gt; y ? y : x;&#125;template&lt;class T&gt;inline void upmax(T &amp;x, T y) &#123;x = x &lt; y ? y : x;&#125; const int mod = 1e9 + 7;int n, T;const int maxn = 220;int dp[maxn][maxn], sum[maxn][maxn]; void add(int &amp;x, int y)&#123; x += y; if(x &gt;= mod) x -= mod;&#125; void sub(int &amp;x, int y)&#123; x -= y; if(x &lt; 0) x += mod;&#125; char s[maxn][maxn];int a[maxn]; int main()&#123; scanf("%d", &amp;T); while(T--)&#123; scanf("%d", &amp;n); for (int i = 1; i &lt;= n; ++i) &#123; scanf("%d", &amp;a[i]); &#125; for(int i = 0; i &lt;= n; i++)&#123; for(int j = 0; j &lt;= n; j++)&#123; dp[i][j] = 0; &#125; &#125; int res = 0; for(int i = 1; i &lt;= n; i++) scanf("%s", s[i] + 1); for(int i = 1; i &lt;= n; i++)&#123; for(int j = 1; j &lt;= n; j++)&#123; for(int k = 1; k &lt;= n; k++)&#123; sum[j][k] = s[a[j]][a[i]] == '1' ? dp[j][k] : 0; add(sum[j][k], sum[j - 1][k]); add(sum[j][k], sum[j][k - 1]); sub(sum[j][k], sum[j - 1][k - 1]); &#125; &#125; for(int j = 1; j &lt;= n; j++)&#123; for(int k = 1; k &lt;= n; k++)&#123; if(a[i] == a[j] &amp;&amp; a[j] == a[k])&#123; int tmp = 1; add(tmp, sum[j - 1][k - 1]); add(res, tmp); add(dp[j][k], tmp); &#125; &#125; &#125; &#125; printf("%d\n", res); &#125; return 0;&#125; 总结对于统计中$x$次方求和的问题，转换为把原来的东西复制$x$次，每个里面选一种方案，求原来有多少方案能使这$x$个方案同时满足。]]></content>
      <categories>
        <category>组合数学</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[CNN学习笔记]]></title>
    <url>%2F2020%2F04%2F05%2FCNN%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[CNN整体结构之前学习了全连接层，我们先再看看全连接层的结构：简单总结一下，我们发现就是由一堆 输入 -&gt; Affine层 -&gt; 激活函数 组成的。再来康康CNN的结构：我们发现前面的Affine层换成了Conv（卷积）层，并且多加入了一个Pooling（池化）层。当然最后还是保留了部分Affine层。 卷积层为什么要引入卷积层考虑引入卷积层，必然是以前的全连接层存在某些问题。首先，全连接层的运算量大，因为每两个点都必须有一个权值，所以边数是点数平方级别的。其次，CNN主要针对的是图像问题，在图像中，两个相距较远的像素可以认为是基本无关的，但全连接层中仍会考虑它们，相当于有很多无用的计算量。基于此，我们考虑用卷积层替换全连接层，卷积层就可以改良上述缺点。 卷积运算因为之前学过图想处理，感觉卷积运算理解起来就非常容易。直接看图吧，相当于就是拿一个窗口在图上滑动，然后对于每一个位置，直接做点积运算，得到的结果放到最终结果的对应位置（如果有偏置的话还要加上偏置的值）。 当然这只是一维情况，事实上只要不是黑白图片，一般都是三通道的，也就是三维的，那么卷积运算就是三个通道结果相加： 卷积层实现这个就比较偏编程技巧了，一般的想法是几层for循环就可以解决，然而这样效率比较慢。我们一般而言是先把数据向量化，也就是展开，也可以称作是降维：展开对应关系如下图所示：同样我们也可以把滤波器的展开，最后发现，我们的卷积运算就可以转换为矩阵乘法了，最后再把结果还原为原来的形状： 池化层为什么要引入卷积层池化是缩小高、长方向上的空间的运算。池化层可以增强对微小变化的鲁棒性。 池化运算其实跟卷积运算挺类似的，看图就能直接明白了。池化也有很多种，比如Max池化，Average池化等，一般来说Max池化用的比较多。 池化层实现池化层实现思想差不多，先把原来数据展开，进行运算，然后再还原回去：具体来说就是把每个滤波器能在的位置展开成一行，然后就可以变成对每一行进行操作，最后挨着还原回去就行了。 接下来去研究下pytorch去了。。。研究完再补。]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[仙人掌 & 圆方树学习笔记]]></title>
    <url>%2F2020%2F04%2F04%2F%E4%BB%99%E4%BA%BA%E6%8E%8C-%E5%9C%86%E6%96%B9%E6%A0%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[序言你敢信我学完基础的圆方树后理解最深的居然是tarjan？不知道这玩意有啥用，但据说很有用，但好像icpc都不太考这个东西？但感觉这个东西跟什么树问题都能有关系，而且还都是大码量题。。 仙人掌概念仙人掌是一种特殊的无向图，具有如下性质：1、图是连通的。2、每条边最多属于一个简单环。因为有特殊性，所以也就有特殊的方法处理这一类题目。 仙人掌的dfs生成树仙人掌dfs生成树也有着特殊的性质，我们将它的dfs生成树看成一个序列，返祖边看成一个区间，那么所有的区间都是不相交的。这样在用dfs生成树处理仙人掌的时候就能简化很多种复杂的情况。 圆方树概念圆方树是用来解决仙人掌问题的一种数据结构。其实圆方树的原理不难想，考虑前面我们说过，仙人掌每条边只属于一个简单环，换言之各个环之间不会嵌套。那么我们在环上考虑问题是比较复杂的，我们喜欢转成树，我们想到给每个环新建一个点，把所有环上的点去掉，并且跟新点相连。这个新点就好像一个中转站一样，巧妙的把环变为了链，把一般图变为了树。树上解决问题，我们可以采用的方法就会更多。 我们把新建的点叫做方点，原来的点叫做圆点。 Upd:我发现我好像一直学的是广义圆方树，不过好像它应用更广泛，也可以直接用在仙人掌上。。。。 性质圆方树有很多不错的性质：1、方点和方点之间不会直接相连。2、无论取哪个点为根，圆方树的形态是一样的。3、以r为根的仙人掌上p的子仙人掌就是圆方树中以r为根时，p子树中的所有圆点（还没理解，先嫖着）。4、方点儿子中的相邻的在原图环上也是相邻的（tarjan性质）。 构建方法圆方树的构建方法是通过魔改tarjan点双开始的。我们知道点双里面一个点可能属于多个点双，这类点就是割点，所以tarjan的时候我们都是存边，因为每条边只会属于一个连通分量。但这里我们可以存点，需要稍微改一改。12345678910111213141516171819202122232425262728void tarjan(int u) &#123; dfn[u] = low[u] = ++ntime; sta[++sz] = u; for (int i = 0; i &lt; G[u].size(); i++) &#123; int v = G[u][i]; if (!dfn[v]) &#123; tarjan(v); low[u] = min(low[u], low[v]); if(low[v] == dfn[u])&#123; ++tot; g[u].pb(tot); for(int x = 0; x != v; --sz)&#123; x = sta[sz]; g[tot].pb(x); &#125; &#125; &#125; else low[u] = min(low[u], dfn[v]); &#125; void find_bcc() &#123; sz = 0; tot = n; memset(dfn, 0, sizeof(dfn)); ntime = 0; for (int i = 1; i &lt;= n; ++i)if (!dfn[i])tarjan(i), --sz; &#125;&#125; 研究一下，其实反而跟tarjan求强连通分量很像，但是强连通分量是要把$u$一起弹出去，这里构建圆方树时我们只能弹到$v，u$必须继续保留在栈中（因为上层递归回去时我们还需要用$u$来建树）。最后如果图不连通需要把$sz - 1$（顶点没弹出来）（虽然仙人掌是一定连通的，但是有些题可能是多个森林仙人掌）。 考虑建出来的树，我们就可以利用树的算法完成仙人掌上的问题了，对于环，我们只用找树上方点进行特殊考虑即可。 例题求仙人掌的最大独立集bzoj-4316 考虑树的最大独立集，$dp[u][0]$表示u点不选，$dp[u][1]$表示$u$点要选，随便dp一下就解决了。对于仙人掌的最大独立集，我们对仙人掌建出圆方树，然后利用树的dp完成，圆点就直接同树的方法进行转移即可，我们需要着重考虑方点的计算方法。如图所示，当$x$选的时候，我们发现$u_1$和$u_4$不能选，也就是两端不能选，其它位置变成了序列上不能同时选相邻点的最大权问题（因为每个点所代表的权值是其子树最大的独立集大小）。对于方点，$dp[u][0]$表示它连的两端没有选，$dp[u][1]$表示它连的两端可以选的最大独立集。我们发现把方点问题转换为序列问题，然后再回到树上按照正常树形dp进行转移即可。 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135#include&lt;bits/stdc++.h&gt;using namespace std; typedef long long ll;typedef unsigned long long ull;typedef double db;typedef pair&lt;int, int&gt; pii;typedef vector&lt;int&gt; vi;typedef vector&lt;ll&gt; vl;typedef vector&lt;pii&gt; vp;const int inf = 1e9;const ll INF = 1e18;const db eps = 1e-10; #define fi first#define se second#define pb push_back#define eb emplace_back#define ep emplace#define mem(a) memset(a, 0, sizeof(a))#define copy(a, b) memcpy(a, b, sizeof(b))#define PA cout &lt;&lt; "pass\n"#define lowbit(x) (x &amp; -x)#define all(x) x.begin(), x.end()#define TM cout &lt;&lt; db(clock()) / CLOCKS_PER_SEC &lt;&lt; '\n' template&lt;class T&gt;inline void upmin(T &amp;x, T y) &#123;x = x &gt; y ? y : x;&#125;template&lt;class T&gt;inline void upmax(T &amp;x, T y) &#123;x = x &lt; y ? y : x;&#125; const int maxn = 1e5 + 233;int n, m; int dp1[maxn][2];int dp2[maxn][2]; struct Cactus &#123; vi G[maxn]; vi g[maxn * 2]; // new Round_Square_Tree int dfn[maxn]; int low[maxn]; int ntime; int tot; int sta[maxn]; int sz; void tarjan(int u) &#123; dfn[u] = low[u] = ++ntime; sta[++sz] = u; for (int i = 0; i &lt; G[u].size(); i++) &#123; int v = G[u][i]; if (!dfn[v]) &#123; tarjan(v); low[u] = min(low[u], low[v]); if(low[v] == dfn[u])&#123; ++tot; g[u].pb(tot); for(int x = 0; x != v; --sz)&#123; x = sta[sz]; g[tot].pb(x); &#125; &#125; &#125; else low[u] = min(low[u], dfn[v]); &#125; &#125; void find_bcc() &#123; sz = 0; tot = n; memset(dfn, 0, sizeof(dfn)); ntime = 0; for (int i = 1; i &lt;= n; ++i)if (!dfn[i])tarjan(i), --sz; &#125; void solve(int u)&#123; int cnt = 0; static int now[maxn * 2]; for(int i = 0; i &lt; g[u].size(); i++)&#123; int v = g[u][i]; now[++cnt] = v; &#125; dp2[1][0] = dp1[now[1]][0]; dp2[1][1] = -inf; for(int i = 2; i &lt;= cnt; i++) &#123; dp2[i][0] = max(dp2[i - 1][0], dp2[i - 1][1]) + dp1[now[i]][0]; dp2[i][1] = dp2[i - 1][0] + dp1[now[i]][1]; &#125; dp1[u][0] = dp2[cnt][0]; for(int i = 1; i &lt;= cnt; i++) &#123; dp2[i][0] = max(dp2[i - 1][0], dp2[i - 1][1]) + dp1[now[i]][0]; dp2[i][1] = dp2[i - 1][0] + dp1[now[i]][1]; &#125; dp1[u][1] = max(dp2[cnt][0], dp2[cnt][1]); &#125; void dfs(int u)&#123; dp1[u][0] = 0; dp1[u][1] = 1; for(int i = 0; i &lt; g[u].size(); i++)&#123; int v = g[u][i]; dfs(v); if(u &lt;= n)&#123; dp1[u][0] += max(dp1[v][0], dp1[v][1]); dp1[u][1] += dp1[v][0]; &#125; &#125; if(u &gt; n) solve(u); &#125; &#125;sol; int main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); cout &lt;&lt; fixed &lt;&lt; setprecision(10); cin &gt;&gt; n &gt;&gt; m; for(int i = 1; i &lt;= m; i++)&#123; int u, v; cin &gt;&gt; u &gt;&gt; v; sol.G[u].pb(v); sol.G[v].pb(u); &#125; sol.find_bcc(); sol.dfs(1); cout &lt;&lt; max(dp1[1][0], dp1[1][1]) &lt;&lt; '\n'; return 0;&#125; 求仙人掌的直径bzoj-1023 还是先建出圆方树，按照树dp的方法求直径，圆点的方法还是一样的，只用特殊考虑方点的。考虑两条链在某个方点合并，也就是方点儿子中的任意两个圆点都可能合并，假设是儿子$(u, v)$，他们在环上的顺序分别是$(i, j)(i &lt; j)$，那么贡献就是dp[u] + dp[v] + i - j，并且i，j之间的距离不能超过环长的一半（否则可以从环另一边绕过去），考虑破环为链，变为2倍，中间会空一个点（其实是方点的父亲，也是环上的一个点，但这里统计我们就不考虑），遇到这个点我们直接跳过，然后维护一个单调队列，统计方点的儿子对答案的贡献，统计后再把所有儿子的距离更新到方点上去，从两边较近的一方绕上去即可，其他的跟树形dp求直径都是完全一样的。 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141#include&lt;bits/stdc++.h&gt;using namespace std; typedef long long ll;typedef unsigned long long ull;typedef double db;typedef pair&lt;int, int&gt; pii;typedef vector&lt;int&gt; vi;typedef vector&lt;ll&gt; vl;typedef vector&lt;pii&gt; vp;const int inf = 1e9;const ll INF = 1e18;const db eps = 1e-10; #define fi first#define se second#define pb push_back#define eb push_back#define ep emplace#define mem(a) memset(a, 0, sizeof(a))#define copy(a, b) memcpy(a, b, sizeof(b))#define PA cout &lt;&lt; "pass\n"#define lowbit(x) (x &amp; -x)#define all(x) x.begin(), x.end()#define TM cout &lt;&lt; db(clock()) / CLOCKS_PER_SEC &lt;&lt; '\n' template&lt;class T&gt;inline void upmin(T &amp;x, T y) &#123;x = x &gt; y ? y : x;&#125;template&lt;class T&gt;inline void upmax(T &amp;x, T y) &#123;x = x &lt; y ? y : x;&#125; const int maxn = 1e5 + 233;int n, m; int dp[maxn];int res; struct Cactus &#123; vi G[maxn]; vi g[maxn * 2]; int dfn[maxn]; int low[maxn]; int ntime; int tot; int sta[maxn]; int sz; void tarjan(int u) &#123; dfn[u] = low[u] = ++ntime; sta[++sz] = u; for (int i = 0; i &lt; G[u].size(); i++) &#123; int v = G[u][i]; if (!dfn[v]) &#123; tarjan(v); low[u] = min(low[u], low[v]); if(low[v] == dfn[u])&#123; ++tot; g[u].pb(tot); for(int x = 0; x != v; --sz)&#123; x = sta[sz]; g[tot].pb(x); &#125; &#125; &#125; else low[u] = min(low[u], dfn[v]); &#125; &#125; void find_bcc() &#123; sz = 0; tot = n; memset(dfn, 0, sizeof(dfn)); ntime = 0; for (int i = 1; i &lt;= n; ++i)if (!dfn[i])tarjan(i), --sz; &#125; void solve(int u)&#123; int head = 1, tail = 0; static int que[maxn * 2], now[maxn * 2]; int cnt = 0; for(int i = 0; i &lt; g[u].size(); i++)&#123; int v = g[u][i]; now[++cnt] = v; &#125; int len = cnt + 1 &gt;&gt; 1; int stop = cnt + 1; for(int i = cnt + 2; i &lt;= 2 * cnt + 1; i++) now[i] = now[i - cnt - 1]; cnt = cnt * 2 + 1; for(int i = 1; i &lt;= cnt; i++)&#123; while(head &lt;= tail &amp;&amp; i - que[head] &gt; len) head++; if(i == stop) continue; if(head &lt;= tail) &#123; int t = que[head]; upmax(res, i + dp[now[i]] + dp[now[t]] - t); &#125; while(head &lt;= tail &amp;&amp; dp[now[que[tail]]] - que[tail] &lt;= dp[now[i]] - i) tail--; que[++tail] = i; &#125; for(int i = 1; i &lt; stop; i++)&#123; upmax(dp[u], dp[now[i]] + min(i, stop - i) - 1); &#125; &#125; void dfs(int u)&#123; for(int i = 0; i &lt; g[u].size(); i++)&#123; int v = g[u][i]; dfs(v); if(u &lt;= n)&#123; upmax(res, dp[u] + dp[v] + 1); upmax(dp[u], dp[v] + 1); &#125; &#125; if(u &gt; n) solve(u); &#125; &#125;sol; int main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); cout &lt;&lt; fixed &lt;&lt; setprecision(10); cin &gt;&gt; n &gt;&gt; m; for(int i = 1; i &lt;= m; i++)&#123; int len; cin &gt;&gt; len; int last = 0; for (int j = 0; j &lt; len; ++j) &#123; int x; cin &gt;&gt; x; if(j) sol.G[x].eb(last), sol.G[last].eb(x); last = x; &#125; &#125; sol.find_bcc(); sol.dfs(1); cout &lt;&lt; res &lt;&lt; '\n'; return 0;&#125; 求仙人掌上的最短路bzoj-2125 建出圆方树，考虑树上求最短路，我们使用LCA就行了，还是要特殊考虑方点的情况。考虑LCA为圆点，那没问题，直接按树那样求最短路即可。考虑LCA为方点，我们发现我们需要找到两个点在方点下对应的圆点的位置，然后找两个圆点在环上的最小距离。其实这里挺麻烦的，我们考虑建树的时候就要把环的每条边值分配到圆方树对应的位置，我是把最后一条找到的返祖边分配到方点和它父亲上，剩下的分配到方点和它的儿子圆点上。那么这里tarjan里就需要改一改（如果用map其实就很简单，但想把log给去掉）。考虑用一个栈来维护边权，我们发现到父亲的边我们不能加入栈中，得把父亲判掉。其次我们发现如果点双大小为2，我们只需要pop出一条边（点双个数 - 1），否则需要pop出点双个数条边（环），所以pop的时候我们还要记录一下点双大小，看它跟2的关系（实际上最上面那个点我们要保留，所以就是跟1的关系）。对于环上处理最小值，我们考虑给每个环开个vector记录点顺序，那么两个点在上面的顺序就等于两条路径取min，vector上找到对应位置直接正反取一下就可以得出结果。然后处理环的同时我们可以同时把圆点到方点的距离处理出来，把距离更新上去即可。真的是码农题，细节也特别烦。。 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182#include&lt;bits/stdc++.h&gt;using namespace std; typedef long long ll;typedef unsigned long long ull;typedef double db;typedef pair&lt;int, int&gt; pii;typedef vector&lt;int&gt; vi;typedef vector&lt;ll&gt; vl;typedef vector&lt;pii&gt; vp;const int inf = 1e9;const ll INF = 1e18;const db eps = 1e-10; #define fi first#define se second#define pb push_back#define eb emplace_back#define ep emplace#define mem(a) memset(a, 0, sizeof(a))#define copy(a, b) memcpy(a, b, sizeof(b))#define PA cout &lt;&lt; "pass\n"#define lowbit(x) (x &amp; -x)#define all(x) x.begin(), x.end()#define TM cout &lt;&lt; db(clock()) / CLOCKS_PER_SEC &lt;&lt; '\n' template&lt;class T&gt;inline void upmin(T &amp;x, T y) &#123;x = x &gt; y ? y : x;&#125;template&lt;class T&gt;inline void upmax(T &amp;x, T y) &#123;x = x &lt; y ? y : x;&#125; const int maxn = 1e5 + 233;int n, m, q; struct Cactus &#123; vp G[maxn]; vp g[maxn * 2]; int f[maxn][20]; ll dis[maxn]; int dfn[maxn]; int low[maxn]; int ntime; int tot; int sta[maxn]; int sz; int val[maxn]; int idx; int d[maxn]; int pre[maxn * 2]; ll all[maxn * 2]; int ord[maxn * 2]; vector&lt;pair&lt;ll, ll&gt; &gt; tmp[maxn * 2]; void tarjan(int u, int fa) &#123; dfn[u] = low[u] = ++ntime; sta[++sz] = u; for (int i = 0; i &lt; G[u].size(); i++) &#123; int v = G[u][i].fi; int w = G[u][i].se; if(!dfn[v] || (dfn[u] &gt; dfn[v] &amp;&amp; v != fa)) val[++idx] = w; if (!dfn[v]) &#123; tarjan(v, u); low[u] = min(low[u], low[v]); if(low[v] == dfn[u])&#123; ++tot; pre[tot] = w; g[u].pb(pii(tot, w)); int ff = 0; for(int x = 0; x != v; --sz, --idx) &#123; x = sta[sz]; ff++; g[tot].pb(pii(x, val[idx])); &#125; if(ff &gt; 1) idx--; &#125; &#125; else low[u] = min(low[u], dfn[v]); &#125; &#125; void find_bcc() &#123; d[1] = 1; sz = 0; tot = n; memset(dfn, 0, sizeof(dfn)); ntime = 0; for (int i = 1; i &lt;= n; ++i)if (!dfn[i])tarjan(i, 0), --sz; &#125; void dfs(int u)&#123; static pii now[maxn * 2]; for(int i = 1; i &lt;= 19; i++) f[u][i] = f[f[u][i - 1]][i - 1]; if(u &gt; n)&#123; int cnt = 0; ll sum = 0; for(int i = 0; i &lt; g[u].size(); i++)&#123; now[++cnt] = g[u][i]; sum += now[cnt].se; tmp[u].pb(pair&lt;ll, ll&gt;&#123;now[cnt].fi, sum&#125;); ord[now[cnt].fi] = i; &#125; ll tt = 0; all[u] = sum + pre[u]; for(int i = 1; i &lt;= cnt; i++)&#123; tt += now[i].se; dis[now[i].fi] = dis[u] + min(tt - pre[u], sum - tt); &#125; &#125; else&#123; for(int i = 0; i &lt; g[u].size(); i++)&#123; int v = g[u][i].fi; int w = g[u][i].se; dis[v] = dis[u] + w; &#125; &#125; for(int i = 0; i &lt; g[u].size(); i++)&#123; int v = g[u][i].fi; d[v] = d[u] + 1; f[v][0] = u; dfs(v); &#125; &#125; int lca(int u, int v)&#123; if(d[u] &gt; d[v]) swap(u, v); for(int i = 19; i &gt;= 0; i--) if(d[u] &lt;= d[f[v][i]]) v = f[v][i]; if(u == v) return u; for(int i = 19; i &gt;= 0; i--) if(f[u][i] != f[v][i]) u = f[u][i], v = f[v][i]; return f[u][0]; &#125; pii lca2(int u, int v)&#123; bool ff = false; if(d[u] &gt; d[v]) swap(u, v), ff = 1; for(int i = 19; i &gt;= 0; i--) if(d[u] &lt;= d[f[v][i]]) v = f[v][i]; for(int i = 19; i &gt;= 0; i--) if(f[u][i] != f[v][i]) u = f[u][i], v = f[v][i]; if(ff) swap(u, v); return pii(u, v); &#125;&#125;sol; int main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); cout &lt;&lt; fixed &lt;&lt; setprecision(10); cin &gt;&gt; n &gt;&gt; m &gt;&gt; q; for(int i = 1; i &lt;= m; i++)&#123; int u, v, w; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; sol.G[u].pb(pii(v, w)); sol.G[v].pb(pii(u, w)); &#125; sol.find_bcc(); sol.dfs(1); for(int i = 1; i &lt;= q; i++)&#123; int x, y; cin &gt;&gt; x &gt;&gt; y; int lc = sol.lca(x, y); if(lc &lt;= n || lc == x || lc == y) cout &lt;&lt; sol.dis[x] + sol.dis[y] - 2 * sol.dis[lc] &lt;&lt; '\n'; else&#123; pii t = sol.lca2(x, y); ll res = sol.dis[x] - sol.dis[t.fi] + sol.dis[y] - sol.dis[t.se]; int t1 = sol.ord[t.fi]; int t2 = sol.ord[t.se]; if(t1 &gt; t2) swap(t1, t2); ll tt = sol.tmp[lc][t2].se - sol.tmp[lc][t1].se; tt = min(tt, sol.all[lc] - tt); res += tt; cout &lt;&lt; res &lt;&lt; '\n'; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>圆方树</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[二分图通关全攻略]]></title>
    <url>%2F2020%2F03%2F30%2F%E4%BA%8C%E5%88%86%E5%9B%BE%E9%80%9A%E5%85%B3%E5%85%A8%E6%94%BB%E7%95%A5%2F</url>
    <content type="text"><![CDATA[二分图概念二分图简单来说，就是一个无向图，可以把点集分为两个，且边都是从一个点集指向另一个点集。二分图有另一个等价的定义：没有奇环。相对而言这个性质更加重要。 二分图最大匹配二分图算法挺多的，说几个常见的吧，主要是复杂度有差异。 匈牙利算法复杂度：O(nm)匈牙利算法比较暴力，每次对某一个点都暴力找增广路，因为找的时候可能把所有边都看一遍，所以找一次增广路的复杂度是O(m)的。1234567891011121314bool dfs(int u) &#123; vis[u] = 1; for (int i = 0; i &lt; G[u].size(); i++) &#123; int v = G[u][i]; if (!vis[v]) &#123; vis[v] = 1; if (link[v] == -1 || dfs(link[v])) &#123; link[v] = u; return true; &#125; &#125; &#125; return false;&#125; Dinic复杂度：O(n\sqrt(m))这个就不讲了，正常网络流建图即可。复杂度相对来说是这几个里面看起来最好的一个。 Hopcroft-Karp复杂度：O(m\sqrt(n)) 二分图的一些非常重要的定理Hall定理内容Hall定理可以说是匈牙利算法的基础，也是二分图中非常基本的一个定理。Hall定理说的是这么个东西，假设二分图两个点集为X，Y。令n = min(|X|, |Y|)。如果二分图有完美匹配，则对于任意X中任意k个点的集合1 \leq k \leq n，他们能到达Y里的点的点集的大小一定大于等于k。反过来也是成立的。 证明考虑反证法，首先如果不满足后面的条件：对于某一个k，到达的Y集合的点没有k个，显然不可能达成完美匹配，倒过来是成立的。考虑正向：如果对于任意k都满足这个条件，没有完美匹配代表至少X集合中有一个点没有匹配，而它能到的Y中有一个点跟其他点匹配了，我们找到它匹配的那个其他点（X中的），这个点能到的一定还有其它点（不然它和前面那个没匹配的X中的点加起来就只能到一个地方，不满足条件），这样一直推下去发现最后一定会推出矛盾，所以正向也是成立的。 最小点覆盖内容求最少的点集，使得每一条边至少都有端点在这个点集中。 定理最小点覆盖 = 最大匹配 方案求解从左边点集没出发的点开始，从左到右走没有流的边，从右到左走有流的边，沿着路径dfs打标记，左边点集中没打标记的所有点和右边点集中所有打了标记的点构成一个最小点覆盖集。我们发现，对于一个联通块，我们必然是从左边开始，并且在左边结束。因为从左边点集到右边点集走的是没有匹配的边，如果在右边停下了，说明右边那个点没匹配边，明显可以跟左边点匹配，不符合完美匹配，所以一定是从左边开始到左边停止。那么这条交错路径，我们全部选位于右边标记过的点就好了，这时候发现匹配数 = 选的点数。 证明首先我们证明最大匹配 \leq 最小点覆盖，我们在每个匹配边两端任意选一个点，如果还有边没被覆盖，说明那条边两端都没点被选过，这显然不可能，所以最大匹配 \leq 最小点覆盖，反过来也好证，把所有匹配边抽出来，一定不重复，这时最少就需要选这么多条边个点。 12345678// 求最小点覆盖，从s出发，左边没标记过的点和右边标记过的点构成最小点覆盖。void dfs1(int u)&#123; ok[u] = 1; for(int i = 0; i &lt; G[u].size(); i++)&#123; edge &amp;e = edges[G[u][i]]; if(e.cap &gt; e.flow &amp;&amp; !ok[e.to]) dfs1(e.to); &#125;&#125; 最大独立集内容一个最大的点的集合，使得任意两个点之间没有直接边连接。 定理最大独立集 = 点数 - 最大匹配 方案求解同最小点覆盖，只不过左边取打了标记的点，右边取没打标记的点就行了。 证明先证最大独立集 \leq 点数 - 最大匹配。最初没有边，独立集数目等于点数。考虑每有一个匹配，就会让独立集数目 - 1，证明完毕。再证：最大独立集 \geq 点数 - 最大匹配，考虑构造出来的方案，我们发现最大独立集 \geq 点数 - 最大匹配。证明完毕所以最后最大独立集 = 点数 - 最大匹配。证明完毕 最大团内容一个最大的点的集合，该集合内的任意两点都有边相连。 定理二分图的最大团 = 二分图补图的最大独立集 方案求解找补图的最大独立集即可。。 证明好像没啥好证明的吧，根据定义发现取补图后就完全相等了。 有向无环图的最小链覆盖与最长反链内容图论角度最小链覆盖也称最小路径覆盖，要求每条路径上不能有重复的点。 最小链覆盖：从边中选出若干点不相交的链，使得这些链覆盖所有的点，并且链的条数最小。（链的定义是一条连续路径，并且不经过重复的点。路径可以只是一个单独的边，不包含边）最长反链：首先纠正一下，反链不是链，而是集合。链代表的是一个集合内，任意两个点(u, v)，要嘛u能走到v，要嘛v能走到u。反链是指的一个点集，集合内两个点谁也不能走到谁。最长反链就是找一个点数最多的这样的集合。 这是从图的角度来解读的，我们再从偏序集的角度来解释一下。设\leq是一个偏序关系，我们知道满足以下条件可以构成偏序集：1、自反性：\forall a \in A, a \leq a2、反对称性：\forall a, b \in A, 若a \leq b，b \leq a，则a = b3、传递性：\forall a, b, c \in A，若a \leq b，b \leq c 则a \leq c全序集：若对于集合\forall a, b \in B，都有a \leq b或 b \leq a（两元素互相可比），则称(B, \leq)为一个全序集。反链：若偏序集(B, \leq)中的元素两两不可比，则称B为反链。 定理最长反链 = 最小链覆盖 Dilworth定理最少的全序集 = 最长反链最少反链划分 = 最大全序集 例题问题：给定一个序列，求最少能将序列划分为多少个不单增的子序列。 考虑将序列拓展为二元关系（a，b），a代表下标，b代表数据的值。我们定义当两个对应位置都严格大于或者小于时，它们是可比的，否则是不可比的。我们发现按照定义，在一个不单增子序列中任意两个元素是不可比的，也就是说一个不单增的子序列构成一个反链，问题变为了求偏序集上的最少反链划分，根据定理可知等于最大全序集的大小，也就是最长上升子序列的大小，所以求一个最长上升子序列即可。 回到图上，考虑偏序集上因为是偏序关系，是不可能存在环的偏序关系的，这也就对应了为什么图上一定是DAG。 解法再强调一遍，必须是DAG才能做，并且是不重点的。将原图每个点拆为两个，分别位于二分图的两端。对于每一条边(u, v)，从新点中左边点集中的u连向右边点集中的v，最后答案等于点数 - 新二分图最大匹配。 方案构造从每个没有访问过的点开始出发，沿着匹配边一直走，路上所有点打标记，走到不能走为止，便对应了一条路径。 证明可以感性证明一下，假设一开始图没有边，最长反链为n，最小链覆盖此时也为n。考虑一个匹配边对应合并两个点，此时反链会 - 1，最小链覆盖数也会 - 1，感性认知二者是等价的。具体证明就不证了（主要是不太想看），有空再补吧。 最小链覆盖中可作为链端点的点opentrain上的一个好题。考虑一个点能作为起点，代表如果我们删去这个点，最小链覆盖的数目不会增加（如果是一个点就减少、否则不变）。我们先考虑起点（二分图左边的点），首先单独的未匹配点一定可以，考虑沿着它找一条交错路径，我们发现交错路径覆盖到的左边的点都可以作为起点（可以替换匹配边，使得它变为未匹配点）。那么我们从左半边找一次。考虑终点也是同样的，不过是从二分图右半边开始找未匹配点，然后走交错路径，给右边的覆盖的点打上标记，最后只要在这个点左边或者右边被覆盖过一次，它就可以作为端点。（记得如果是dinic先把s，t给标记了，不标记我也不知道会不会出错。） 12345678910111213141516void solve()&#123; pre[s] = pre[t] = suf[s] = suf[t] = 1; dfs2(s, pre, 0); dfs2(t, suf, 1); for(int i = 1; i &lt;= n; i++)&#123; if(pre[i] || suf[i + n]) //可以作为端点 &#125;&#125;void dfs2(int u, bool *ok, bool f)&#123; ok[u] = 1; for(int i = 0; i &lt; G[u].size(); i++)&#123; edge &amp;e = edges[G[u][i]]; if(!ok[e.to] &amp;&amp; ((e.cap &gt; e.flow) ^ f)) dfs1(e.to, ok, f); &#125;&#125;]]></content>
      <categories>
        <category>二分图</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Round 366 (Div. 1)-B(Ant Man)]]></title>
    <url>%2F2020%2F03%2F28%2FCodeforces-Round-366-Div-1-B-Ant-Man%2F</url>
    <content type="text"><![CDATA[题目链接思路：考虑按位置插入，原来位置是一个从小位置指向大位置的，插入后变成了两个小的指向一个大的，相当于有一个原来大的变成了小的。我们发现每次操作都是把一个原本是大的的转换为小的，所以我们每次取大的里面最大的，贪心即可。1234567891011121314151617181920212223242526272829303132333435363738#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 5050;int ne[maxn];typedef long long ll;typedef pair&lt;ll, int&gt; pii;int a[maxn], b[maxn], c[maxn], d[maxn], x[maxn], n, s, e;ll f(int p, int q)&#123; if(p &lt; q) return 1ll * x[q] - x[p] + d[p] + a[q]; return 1ll * x[p] - x[q] + c[p] + b[q]; &#125;int main()&#123; scanf("%d %d %d", &amp;n, &amp;s, &amp;e); for(int i = 1; i &lt;= n; i++) scanf("%d", x + i); for(int i = 1; i &lt;= n; i++) scanf("%d", a + i); for(int i = 1; i &lt;= n; i++) scanf("%d", b + i); for(int i = 1; i &lt;= n; i++) scanf("%d", c + i); for(int i = 1; i &lt;= n; i++) scanf("%d", d + i); ne[s] = e; for(int i = 1; i &lt;= n; i++)&#123; if(i == s || i == e) continue; pii t = pii(1e18, 0); for(int j = s; j != e; j = ne[j])&#123; t = min(t, pii(f(j, i) + f(i, ne[j]) - f(j, ne[j]), j)); &#125; ne[i] = ne[t.second]; ne[t.second] = i; &#125; ll res = 0; for(int i = s; i != e; i = ne[i])&#123; res += f(i, ne[i]); &#125; printf("%lld\n", res); return 0;&#125; 还有一个dp的做法，dp[i][j]表示考虑前i个点，形成了j条链。转移就四种方向：1、i的出边从左到右，入边从右到左，那么会合并两条链，所以要求 p \geq 2，dp_{i+1,p-1} += dp_{i,p}+a_i+c_i2、的出边从右到左，入边从左到右，那么会形成一条新的链，所以dp_{i+1,p+1} += dp_{i,p}+b_i+d_i3、i 连边都是从左到右，链数没有变化，但是以 ee 结尾的链是不能连出边的，所以要求p>[i>e]，dp_{i+1,p} += dp_{i,p}+a_i+d_i4、i 连边都是从左到右，链数没有变化，但是以 ee 结尾的链是不能连出边的，所以要求p>[i>e]，dp_{i+1,p} += dp_{i,p}+a_i+d_i当有s和t的时候我们要特殊考虑，s的时候只考虑入边，t的时候只考虑出边即可。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef double db;typedef pair&lt;int, int&gt; pii;typedef vector&lt;int&gt; vi;typedef vector&lt;ll&gt; vl;typedef vector&lt;pii&gt; vp;const int inf = 1e9;const ll INF = 1e18;const db eps = 1e-10;#define fi first#define se second#define pb push_back#define eb emplace_back#define ep emplace#define mem(a) memset(a, 0, sizeof(a))#define copy(a, b) memcpy(a, b, sizeof(b))#define PA cout &lt;&lt; "pass\n"#define lowbit(x) (x &amp; -x)#define all(x) x.begin(), x.end()#define TM cout &lt;&lt; db(clock()) / CLOCKS_PER_SEC &lt;&lt; '\n'mt19937 mrand(chrono::high_resolution_clock::now().time_since_epoch().count());template&lt;class T&gt;inline void upmin(T &amp;x, T y) &#123;x = x &gt; y ? y : x;&#125;template&lt;class T&gt;inline void upmax(T &amp;x, T y) &#123;x = x &lt; y ? y : x;&#125;const int maxn = 5050;int n, s, e;ll f[maxn], g[maxn], a[maxn], b[maxn], c[maxn], d[maxn], x[maxn];int main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); cout &lt;&lt; fixed &lt;&lt; setprecision(10); cin &gt;&gt; n &gt;&gt; s &gt;&gt; e; for (int i = 1; i &lt;= n; ++i) cin &gt;&gt; x[i]; for (int i = 1; i &lt;= n; ++i) cin &gt;&gt; a[i]; for (int i = 1; i &lt;= n; ++i) cin &gt;&gt; b[i]; for (int i = 1; i &lt;= n; ++i) cin &gt;&gt; c[i]; for (int i = 1; i &lt;= n; ++i) cin &gt;&gt; d[i]; for(int i = 1; i &lt;= n; i++) g[i] = INF; for(int i = 1; i &lt;= n; i++) &#123; for (int j = 0; j &lt;= n; j++) f[j] = INF; if (i == s) &#123; for (int j = (i &gt; e); j &lt; n; j++) upmin(f[j + 1], g[j] + d[i] - x[i]); for (int j = 1; j &lt;= n; j++) upmin(f[j], g[j] + x[i] + c[i]); &#125; else if (i == e) &#123; for (int j = (i &gt; s); j &lt; n; j++) upmin(f[j + 1], g[j] + b[i] - x[i]); for (int j = 1; j &lt;= n; j++) upmin(f[j], g[j] + a[i] + x[i]); &#125; else &#123; for (int j = (i &gt; e) + 1; j &lt;= n; j++) upmin(f[j], g[j] + a[i] + d[i]); for (int j = (i &gt; s) + 1; j &lt;= n; j++) upmin(f[j], g[j] + b[i] + c[i]); for (int j = (i &gt; e) + (i &gt; s); j &lt;= n; j++) upmin(f[j + 1], g[j] + b[i] + d[i] - 2 * x[i]); for (int j = 2; j &lt;= n; j++) upmin(f[j - 1], g[j] + 2 * x[i] + a[i] + c[i]); &#125; swap(f, g); &#125; cout &lt;&lt; g[1] &lt;&lt; '\n'; return 0;&#125; ​]]></content>
      <categories>
        <category>贪心</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Round 323 (Div. 1)-D(Number of Binominal Coefficients)]]></title>
    <url>%2F2020%2F03%2F28%2FCodeforces-Round-323-Div-1-D-Number-of-Binominal-Coefficients%2F</url>
    <content type="text"><![CDATA[题目链接思路：先介绍一个定理，不然这个题做不了。 库莫尔定理设m, n为正整数，p为素数，则C_{m + n}^m喊p的幂次等于m + n在p进制下的进位次数。证明：我们发现p是素数，我们知道C_{m + n}^n = \frac{(m + n)!}{m!n!}，那么C_{m + n}^n含有p的幂次等于\sum_{i = 1}^{\infty}\lfloor\frac{n + m}{p^i}\rfloor - \lfloor\frac{n}{p^i}\rfloor - \lfloor\frac{m}{p^i}\rfloor我们发现对于每一个i，答案不会超过1，考虑什么时候为1，可以发现是在p进制下第i位发生进位时取到。 题目这一类题目都是库莫尔定理 + 数位dp的，考虑dp[i][j][k][l]表示考虑了前i个位置，进了j次位，前面已经等于/小于边界，上一位是否需要进位。那么剩下的问题就是转移的时候的组合数，即我们要统计在这一位有多少对(k, n)满足条件（可能有进位，并且另一个位置还要在可行范围内），可以以p为边界分开计算，然后转移即可。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397#include&lt;bits/stdc++.h&gt;using namespace std; typedef long long ll;typedef unsigned long long ull;typedef double db;typedef pair&lt;int, int&gt; pii;typedef vector&lt;int&gt; vi;typedef vector&lt;ll&gt; vl;typedef vector&lt;pii&gt; vp;const int inf = 1e9;const ll INF = 1e18;const db eps = 1e-10; #define fi first#define se second#define pb push_back#define eb emplace_back#define ep emplace#define mem(a) memset(a, 0, sizeof(a))#define copy(a, b) memcpy(a, b, sizeof(b))#define PA cout &lt;&lt; "pass\n"#define lowbit(x) (x &amp; -x)#define all(x) x.begin(), x.end()#define TM cout &lt;&lt; db(clock()) / CLOCKS_PER_SEC &lt;&lt; '\n' mt19937 mrand(chrono::high_resolution_clock::now().time_since_epoch().count()); template&lt;class T&gt;inline void upmin(T &amp;x, T y) &#123;x = x &gt; y ? y : x;&#125;template&lt;class T&gt;inline void upmax(T &amp;x, T y) &#123;x = x &lt; y ? y : x;&#125;#define MAXN 9999#define MAXSIZE 500#define DLEN 4 class BigNum&#123;private: ll a[5000]; int len; public: BigNum()&#123; len = 1;memset(a,0,sizeof(a)); &#125; BigNum(const int); BigNum(const char*); BigNum(const BigNum &amp;); BigNum &amp;operator=(const BigNum &amp;); friend istream&amp; operator&gt;&gt;(istream&amp;, BigNum&amp;); friend ostream&amp; operator&lt;&lt;(ostream&amp;, BigNum&amp;); BigNum operator+(const BigNum &amp;) const; BigNum operator-(const BigNum &amp;) const; BigNum operator*(const BigNum &amp;) const; BigNum operator/(const int &amp;) const; BigNum operator^(const int &amp;) const; ll operator%(const int &amp;) const; bool operator&gt;(const BigNum &amp; T)const; bool operator&gt;(const int &amp; t)const; void print(); &#125;;BigNum::BigNum(const int b) &#123; int c,d = b; len = 0; memset(a,0,sizeof(a)); while(d &gt; MAXN) &#123; c = d - (d / (MAXN + 1)) * (MAXN + 1); d = d / (MAXN + 1); a[len++] = c; &#125; a[len++] = d;&#125;BigNum::BigNum(const char*s) &#123; int t,k,index,l,i; memset(a,0,sizeof(a)); l=strlen(s); len=l/DLEN; if(l%DLEN) len++; index=0; for(i=l-1;i&gt;=0;i-=DLEN) &#123; t=0; k=i-DLEN+1; if(k&lt;0) k=0; for(int j=k;j&lt;=i;j++) t=t*10+s[j]-'0'; a[index++]=t; &#125;&#125;BigNum::BigNum(const BigNum &amp; T) : len(T.len) &#123; int i; memset(a,0,sizeof(a)); for(i = 0 ; i &lt; len ; i++) a[i] = T.a[i];&#125;BigNum &amp; BigNum::operator=(const BigNum &amp; n) &#123; int i; len = n.len; memset(a,0,sizeof(a)); for(i = 0 ; i &lt; len ; i++) a[i] = n.a[i]; return *this;&#125;istream&amp; operator&gt;&gt;(istream &amp; in, BigNum &amp; b) //�������������&#123; char ch[MAXSIZE*4]; int i = -1; in&gt;&gt;ch; int l=strlen(ch); int count=0,sum=0; for(i=l-1;i&gt;=0;) &#123; sum = 0; int t=1; for(int j=0;j&lt;4&amp;&amp;i&gt;=0;j++,i--,t*=10) &#123; sum+=(ch[i]-'0')*t; &#125; b.a[count]=sum; count++; &#125; b.len =count++; return in; &#125;ostream&amp; operator&lt;&lt;(ostream&amp; out, BigNum&amp; b) &#123; int i; cout &lt;&lt; b.a[b.len - 1]; for(i = b.len - 2 ; i &gt;= 0 ; i--) &#123; cout.width(DLEN); cout.fill('0'); cout &lt;&lt; b.a[i]; &#125; return out;&#125; BigNum BigNum::operator+(const BigNum &amp; T) const &#123; BigNum t(*this); int i,big; //λ�� big = T.len &gt; len ? T.len : len; for(i = 0 ; i &lt; big ; i++) &#123; t.a[i] +=T.a[i]; if(t.a[i] &gt; MAXN) &#123; t.a[i + 1]++; t.a[i] -=MAXN+1; &#125; &#125; if(t.a[big] != 0) t.len = big + 1; else t.len = big; return t;&#125;BigNum BigNum::operator-(const BigNum &amp; T) const &#123; int i,j,big; bool flag; BigNum t1,t2; if(*this&gt;T) &#123; t1=*this; t2=T; flag=0; &#125; else &#123; t1=T; t2=*this; flag=1; &#125; big=t1.len; for(i = 0 ; i &lt; big ; i++) &#123; if(t1.a[i] &lt; t2.a[i]) &#123; j = i + 1; while(t1.a[j] == 0) j++; t1.a[j--]--; while(j &gt; i) t1.a[j--] += MAXN; t1.a[i] += MAXN + 1 - t2.a[i]; &#125; else t1.a[i] -= t2.a[i]; &#125; t1.len = big; while(t1.a[t1.len - 1] == 0 &amp;&amp; t1.len &gt; 1) &#123; t1.len--; big--; &#125; if(flag) t1.a[big-1]=0-t1.a[big-1]; return t1;&#125; BigNum BigNum::operator*(const BigNum &amp; T) const &#123; BigNum ret; int i,j,up; int temp,temp1; for(i = 0 ; i &lt; len ; i++) &#123; up = 0; for(j = 0 ; j &lt; T.len ; j++) &#123; temp = a[i] * T.a[j] + ret.a[i + j] + up; if(temp &gt; MAXN) &#123; temp1 = temp - temp / (MAXN + 1) * (MAXN + 1); up = temp / (MAXN + 1); ret.a[i + j] = temp1; &#125; else &#123; up = 0; ret.a[i + j] = temp; &#125; &#125; if(up != 0) ret.a[i + j] = up; &#125; ret.len = i + j; while(ret.a[ret.len - 1] == 0 &amp;&amp; ret.len &gt; 1) ret.len--; return ret;&#125;BigNum BigNum::operator/(const int &amp; b) const &#123; BigNum ret; int i; ll down = 0; for(i = len - 1 ; i &gt;= 0 ; i--) &#123; ret.a[i] = (a[i] + down * (MAXN + 1)) / b; down = a[i] + down * (MAXN + 1) - ret.a[i] * b; &#125; ret.len = len; while(ret.a[ret.len - 1] == 0 &amp;&amp; ret.len &gt; 1) ret.len--; return ret;&#125; ll BigNum::operator %(const int &amp; b) const &#123; int i; ll d=0; for (i = len-1; i&gt;=0; i--) &#123; d = ((d * (MAXN+1))% b + a[i])% b; &#125; return d;&#125;BigNum BigNum::operator^(const int &amp; n) const &#123; BigNum t,ret(1); int i; if(n&lt;0) exit(-1); if(n==0) return 1; if(n==1) return *this; int m=n; while(m&gt;1) &#123; t=*this; for( i=1;i&lt;&lt;1&lt;=m;i&lt;&lt;=1) &#123; t=t*t; &#125; m-=i; ret=ret*t; if(m==1) ret=ret*(*this); &#125; return ret;&#125;bool BigNum::operator&gt;(const BigNum &amp; T) const &#123; int ln; if(len &gt; T.len) return true; else if(len == T.len) &#123; ln = len - 1; while(a[ln] == T.a[ln] &amp;&amp; ln &gt;= 0) ln--; if(ln &gt;= 0 &amp;&amp; a[ln] &gt; T.a[ln]) return true; else return false; &#125; else return false;&#125;bool BigNum::operator &gt;(const int &amp; t) const &#123; BigNum b(t); return *this&gt;b;&#125; void BigNum::print() &#123; int i; cout &lt;&lt; a[len - 1]; for(i = len - 2 ; i &gt;= 0 ; i--) &#123; cout.width(DLEN); cout.fill('0'); cout &lt;&lt; a[i]; &#125; cout &lt;&lt; endl;&#125; int p, a;const int mod = 1e9 + 7;void add(int &amp;x, int y)&#123; x += y; if(x &gt;= mod) x -= mod;&#125; const int maxn = 3500;int dp[maxn][maxn][2][2];ll b[maxn];BigNum tmp; inline int Sum(ll l,ll r) &#123; return 1ll*(l+r)*(r-l+1)/2%mod; &#125; inline int cal(ll l,ll r) &#123; l = max(l, 0ll); if (l &gt; r) return 0; ll tot = 0; if (r &gt;= p - 1) tot += (2 * p - 1) * (r - max(l, p - 1ll) + 1) - Sum(max(l, p - 1ll), r), r = p - 2; if (l &lt;= r) tot += Sum(l + 1, r + 1); return (tot % mod + mod) % mod;&#125; int dfs(int len, int now, bool z, int c) &#123; if (len &lt; 0) &#123; if (c == 0 &amp;&amp; now &gt;= a) return 1; return 0; &#125; if (dp[len][now][z][c] != -1) return dp[len][now][z][c]; int e = !z ? p - 1 : b[len]; int res = 0; if (!c) &#123; add(res, 1ll * cal(0, e - 1) * dfs(len - 1, now, 0, 0) % mod); add(res, 1ll * cal(e, e) * dfs(len - 1, now, z, 0) % mod); add(res, 1ll * cal(0, e - 2) * dfs(len - 1, now, 0, 1) % mod); add(res, 1ll * cal(e - 1, e - 1) * dfs(len - 1, now, z, 1) % mod); &#125; else &#123; add(res, 1ll * cal(p, p + e - 1) * dfs(len - 1, now + 1, 0, 0) % mod); add(res, 1ll * cal(p + e, p + e) * dfs(len - 1, now + 1, z, 0) % mod); add(res, 1ll * cal(p - 1, p + e - 2) * dfs(len - 1, now + 1, 0, 1) % mod); add(res, 1ll * cal(p + e - 1, p + e - 1) * dfs(len - 1, now + 1, z, 1) % mod); &#125; dp[len][now][z][c] = res; return res;&#125; int len; int solve()&#123; len = 0; memset(dp, -1, sizeof(dp)); while(tmp &gt; 0)&#123; b[len++] = tmp % p; tmp = tmp / p; &#125; return dfs(len - 1, 0, 1, 0);&#125; int main()&#123; cin &gt;&gt; p &gt;&gt; a &gt;&gt; tmp; cout &lt;&lt; solve() &lt;&lt; '\n'; return 0;&#125;]]></content>
      <categories>
        <category>数位dp</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[XX Open Cup named after E.V. Pankratiev. Grand Prix of Korea, Division 1-I(Minimum Diameter Spanning Tree)]]></title>
    <url>%2F2020%2F03%2F25%2FXX-Open-Cup-named-after-E-V-Pankratiev-Grand-Prix-of-Korea-Division-1-I-Minimum-Diameter-Spanning-Tree%2F</url>
    <content type="text"><![CDATA[题目链接思路：最小直径生成树也算是一个比较固定的东西了。考虑要求最小直径。一个比较容易想到的做法是求某个点，剩下点中最短路最大的两个点组成直径。但是发现显然是错的，因为最大的两个最短路可能共用了一些边，不符合直径的定义。最小直径生成树其实其实有一个等价的定义，图的绝对中心，就是图上到各点距离最大值最小的点，这个绝对中心可以在边上。很显然，绝对中心到其他点的距离最大值会出现两次。最小直径生成树的直径就是绝对中心到其他点的距离最大值*2。那么我们只要求出绝对中心，这题就解决了。我们考虑枚举一条边(u, v)，找两个点x, y到u, v。首先我们可以发现，如果某个点到u, v的距离均大于另一个点到u, v的距离，那么另一个点就不可能成为x或者y，换言之，成为决策的点中，按到u距离从小到大排序，那么它们到v的距离一定是从大到小的。那么考虑另一个问题，就是怎么判断x, y是否共用了一些边作为它们的最短路呢，我们发现，如果x到u的距离大于y到u的距离，x到v的距离却小于y到v的距离，那么它们一定是从边(u, v)两侧过来的，不会共用最短路边。而我们要求的是加起来最大的值，前面又说过，它们到u，v距离增减性是刚好反过来的。所以我们只需要枚举相邻的即可。另一种理解可以看这个图：这是已经删掉无用点后的图，其实也就是求每个峰对应的答案。写代码的时候并不用真的删点，只需要记录一下上一次用过的在哪里就行了。还有一个问题就是求出了最小直径生成树的直径，怎么求最小直径生成树呢？答案就是从绝对中心开始跑一边最短路径树就行了，记住是绝对中心不是u或者v开始跑。代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef double db;typedef pair&lt;int, int&gt; pii;typedef vector&lt;int&gt; vi;typedef vector&lt;ll&gt; vl;typedef vector&lt;pii&gt; vp;const int inf = 1e9;const ll INF = 1e18;const db eps = 1e-10;#define fi first#define se second#define pb push_back#define eb emplace_back#define ep emplace#define mem(a) memset(a, 0, sizeof(a))#define copy(a, b) memcpy(a, b, sizeof(b))#define PA cout &lt;&lt; "pass\n"#define lowbit(x) (x &amp; -x)#define all(x) x.begin(), x.end()#define TM cout &lt;&lt; db(clock()) / CLOCKS_PER_SEC &lt;&lt; '\n'mt19937 mrand(chrono::high_resolution_clock::now().time_since_epoch().count());template&lt;class T&gt;inline void upmin(T &amp;x, T y) &#123;x = x &gt; y ? y : x;&#125;template&lt;class T&gt;inline void upmax(T &amp;x, T y) &#123;x = x &lt; y ? y : x;&#125;int n, m;const int maxn = 505;template&lt;class T&gt;struct MSDT&#123;#define pdi pair&lt;double, int&gt; T dp[maxn][maxn]; int ord[maxn][maxn]; int mp[maxn][maxn]; double d[maxn]; int s, t; T infinity; int pre[maxn]; void init(T infinity)&#123; this-&gt;infinity = infinity; memset(mp, -1, sizeof(mp)); for(int i = 1; i &lt;= n; i++)&#123; for(int j = 1; j &lt;= n; j++)&#123; dp[i][j] = infinity; &#125; dp[i][i] = 0; &#125; &#125; void floyd()&#123; for(int k = 1; k &lt;= n; k++)&#123; for(int i = 1; i &lt;= n; i++)&#123; for(int j = 1; j &lt;= n; j++)&#123; dp[i][j] = min(dp[i][j], dp[i][k] + dp[k][j]); &#125; &#125; &#125; &#125; T center()&#123; for(int i = 1; i &lt;= n; i++)&#123; for(int j = 1; j &lt;= n; j++) ord[i][j] = j; for(int j = 1; j &lt;= n; j++)&#123; for(int k = j + 1; k &lt;= n; k++)&#123; if(dp[i][ord[i][j]] &gt; dp[i][ord[i][k]]) swap(ord[i][j], ord[i][k]); &#125; &#125; &#125; T ans = infinity; s = t = -1; for(int i = 1; i &lt;= n; i++)&#123; if(dp[i][ord[i][n]] * 2 &lt; ans)&#123; ans = dp[i][ord[i][n]] * 2; s = t = i; d[s] = 0; &#125; for(int j = 1; j &lt;= n; j++)&#123; if(mp[i][j] != -1)&#123; for(int cmp = n, k = n - 1; k &gt;= 1; k--)&#123; if(dp[j][ord[i][k]] &gt; dp[j][ord[i][cmp]])&#123; T tmp = dp[i][ord[i][k]] + dp[j][ord[i][cmp]] + mp[i][j]; if(tmp &lt; ans)&#123; ans = tmp; s = i; t = j; d[s] = (double)tmp / 2 - dp[i][ord[i][k]]; d[t] = (double)mp[i][j] - d[s]; &#125; cmp = k; &#125; &#125; &#125; &#125; &#125; return ans; &#125; void dijskra()&#123; for(int i = 1; i &lt;= n; i++) &#123; if(i != s &amp;&amp; i != t) d[i] = infinity; &#125; priority_queue&lt;pdi, vector&lt;pdi&gt;, greater&lt;pdi&gt; &gt; q; memset(pre, -1, sizeof(pre)); q.ep(d[s], s); if(s != t)&#123; q.ep(d[t], t); pre[t] = s; &#125; while(!q.empty())&#123; pdi now = q.top(); q.pop(); int u = now.se; if(d[u] &lt; now.fi) continue; d[u] = now.fi; for(int v = 1; v &lt;= n; v++)&#123; if(mp[u][v] != -1)&#123; if(d[v] &gt; d[u] + mp[u][v])&#123; d[v] = d[u] + mp[u][v]; pre[v] = u; q.ep(d[v], v); &#125; &#125; &#125; &#125; for(int i = 1; i &lt;= n; i++)&#123; if(pre[i] != -1) cout &lt;&lt; pre[i] &lt;&lt; ' ' &lt;&lt; i &lt;&lt; '\n'; &#125; &#125; void solve()&#123; floyd(); cout &lt;&lt; center() &lt;&lt; '\n'; dijskra(); &#125;&#125;;MSDT&lt;ll&gt; sol;int main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); cout &lt;&lt; fixed &lt;&lt; setprecision(10); cin &gt;&gt; n &gt;&gt; m; sol.init(INF); for(int i = 1; i &lt;= m; i++)&#123; int u, v, w; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; sol.mp[u][v] = sol.mp[v][u] = sol.dp[u][v] = sol.dp[v][u] = w; &#125; sol.solve(); return 0;&#125;]]></content>
      <categories>
        <category>最小生成树</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[深入浅出欧拉回路]]></title>
    <url>%2F2020%2F03%2F25%2F%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E6%AC%A7%E6%8B%89%E5%9B%9E%E8%B7%AF%2F</url>
    <content type="text"><![CDATA[欧拉回路欧拉回路简单来说就是一笔画问题，要求一条路径使得每条边都刚好经过一次。 无向图无向图有欧拉回路当且仅当每个顶点度数为偶数 有向图无向图有欧拉回路当且仅当每个点入度等于出度 Hierholzer算法Hierholzer算法是一种高效求解欧拉回路的算法，复杂度为O(E)。 Hierholzer算法流程1、随便选择一个点作为初始点。2、进行dfs，将走过的点标记，只能走没有标记过的边（无向图需要来回都标记）。3、当做完所有边后，将该点压栈。4、将栈从栈底到栈顶输出，即是一条欧拉回路。 感觉也没啥正确性证明的，因为算法本身模拟的路径就是欧拉回路。。。 注意点dfs的时候对边要进行当前弧优化！看了网上一半以上的板子都是错的，估计也是很少被卡。但是不进行弧优化的复杂度确实是错的。 123456789void dfs(int u)&#123; for(; cur[u] &lt; G[u].size(); cur[u]++)&#123; int i = G[u][cur[u]]; edge &amp;e = edges[i]; if(vis[i] || vis[i ^ 1]) continue; vis[i] = 1; dfs(e.to); &#125;&#125; Fluery不想写了，感觉这算法听弱智的，复杂度也高，没啥必要。。。]]></content>
      <categories>
        <category>欧拉回路</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[各种最优化方法总结]]></title>
    <url>%2F2020%2F03%2F22%2F%E5%90%84%E7%A7%8D%E6%9C%80%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[本文主要记录各种最优化方法的原理 GD随机梯度下降法（SGD）W \leftarrow W - \eta\frac{\partial L}{\partial W}SGD其实跟我们最直接的想法一样。梯度是函数在某点指向最大值的向量，那么我们要想要一个W，使得Loss函数值最小，我们就沿着梯度的反方向更新（远离最大值）。\eta是一个参数，用来限制每次更新影响的大小。缺点如上图，因为是固定的参数，所以会绕很多路，最后才能走到最小值点。 批量梯度下降法（BGD）W \leftarrow W - \eta\frac{1}{m}\sum_{i = 1}^m\frac{\partial L_i}{\partial W}假设一共有m个数据，BGD就是用所有数据直接做一次SGD，换言之就是一次拿一批数据去做SGD的更新。批量的优点是不会绕很多路，但是一次训练要全部数据，花费时间太久。 小批量梯度下降法（SBGD）那有没有方法将前面两种的优点结合一下呢。显然做法是一次用一个小数据集来训练，这样既避免了绕很多路，训练时间也相对可以接受一点。式子与BGD是一样的，不过m代表一个mini_batch的数据大小。 Momentum普通MomentumMomentum也成为动量法，它借鉴了物理上关于位移-速度-加速度的原理，L相当于是位移，W相当于是加速度。位移和加速度实际上是没有本质上的联系，必须通过速度建立连接。 v\leftarrow\alpha v - \eta\frac{\partial L}{\partial W}W \leftarrow W + v看图可知与SGD相比，Momentum绕路的程度有所改善。 Nesterov普通动量就是算当前点的梯度，但Nesterov认为即使当前梯度为0，由于动量存在，梯度依然会更新。就好像物理中即使速度为0，但由于加速度不为0，所以物体还是会运动。 now\_x \leftarrow x + \alpha vv\leftarrow\alpha v - \eta\frac{\partial L}{\partial W}(now\_x处)W \leftarrow W + vAdaGrad &amp; RMSProp &amp; ADAMAdaGrad之前式子中的\eta，实际上是被称为学习率。神经网络学习中，学习率是个非常重要的参数。学习率过小，会花费过多时间学习，学习率过大，会导致学习发散不能正确学习。AdaGrad采用了学习率衰减的方法，即越早学习率越高，越晚学习率越低。其实这个很好理解，就好比我先给你指一个大概的方向，你往这个方法大步走，保证大方向不会错。当越接近目标时，就走的越来越小心，即学习得越来越慢。 h \leftarrow h + \frac{\partial L}{\partial W} \odot \frac{\partial L}{\partial W}W \leftarrow W - \eta\frac{1}{\sqrt(h)}\frac{\partial L}{\partial W}也可以参考原论文的方式，大同小异。当更新次数越多，h就越大，W的学习率就越小。如图所示，绕路现象基本已经很微弱了。 RMSPropRMSProp是对AdaGrad的一种改进。 h \leftarrow \rho h + (1 - \rho)\frac{\partial L}{\partial W} \odot \frac{\partial L}{\partial W}W \leftarrow W - \eta\frac{1}{\sqrt(h)}\frac{\partial L}{\partial W}RMSProp算法不是像AdaGrad算法那样暴力直接的累加平方梯度，而是加了一个衰减系数来控制历史信息的获取多少。据说RMSProp在非凸条件下表现非常好，而神经网络都是非凸的，不是很懂为什么。。。起到的效果是在参数空间更为平缓的方向，会取得更大的进步（因为平缓，所以历史梯度平方和较小，对应学习下降的幅度较小），并且能够使得陡峭的方向变得平缓，从而加快训练速度。 ADAMADAM是RMSProp和AdaGrad的一个结合，综合了二者的优点。原论文描述具体原理不是很懂，挖坑，先意会一下。。。整体来说，ADAM是现在最主流使用的方法。]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Round 290 (Div. 1)-D(Fox And Travelling)]]></title>
    <url>%2F2020%2F03%2F20%2FCodeforces-Round-290-Div-1-D-Fox-And-Travelling%2F</url>
    <content type="text"><![CDATA[题目链接思路：考虑能到的点抽出来构成一个森林，并且每个树分为两种，有根和无根。有根我们发现直接树形dp，树上背包合并一下即可。无根的考虑把每一个点当成根，我们发现，一种方案有x个点，会被统计sz - x次(x &lt; sz)，x = sz时刚好会被统计一次。所以我们把一整个树拿出来，每个点来树形dp，然后再合并到答案上去即可。关于合并时的方法数计算，可以用组合公式推，但一个更简单的方法是可以预处理f[i][j]表示i个和j个合并的方案数，这个非常好递推。代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162#include&lt;bits/stdc++.h&gt;using namespace std; typedef long long ll;typedef unsigned long long ull;typedef double db;typedef pair&lt;int, int&gt; pii;typedef vector&lt;int&gt; vi;typedef vector&lt;ll&gt; vl;typedef vector&lt;pii&gt; vp;const int inf = 1e9;const ll INF = 1e18;const db eps = 1e-10; #define fi first#define se second#define pb push_back#define eb emplace_back#define ep emplace#define mem(a) memset(a, 0, sizeof(a))#define copy(a, b) memcpy(a, b, sizeof(b))#define PA cout &lt;&lt; "pass\n"#define lowbit(x) (x &amp; -x)#define all(x) x.begin(), x.end()#define TM cout &lt;&lt; db(clock()) / CLOCKS_PER_SEC &lt;&lt; '\n' mt19937 mrand(chrono::high_resolution_clock::now().time_since_epoch().count()); template&lt;class T&gt;inline void upmin(T &amp;x, T y) &#123;x = x &gt; y ? y : x;&#125;template&lt;class T&gt;inline void upmax(T &amp;x, T y) &#123;x = x &lt; y ? y : x;&#125; const int maxn = 105;int f[maxn][maxn], dp[maxn][maxn]; const int mod = 1e9 + 9; void add(int &amp;x, int y)&#123; x += y; if(x &gt;= mod) x -= mod;&#125; int pow_mod(int q, int w)&#123; int ret = 1; while(w)&#123; if(w &amp; 1) ret = 1ll * ret * q % mod; q = 1ll * q * q % mod; w &gt;&gt;= 1; &#125; return ret;&#125; int n, m;vi G[maxn];int deg[maxn];bool vis[maxn], ok[maxn];int sz[maxn];int res[maxn];int ans[maxn]; void bfs()&#123; queue&lt;int&gt; q; for(int i = 1; i &lt;= n; i++) if(deg[i] &lt;= 1) q.ep(i); while(!q.empty())&#123; int x = q.front(); q.pop(); if(vis[x]) continue; vis[x] = 1; for(auto v : G[x])&#123; --deg[v]; if(deg[v] == 1) q.ep(v); &#125; &#125;&#125; void dfs(int u, int fa, bool z)&#123; sz[u] = 1; if(z) ok[u] = 1; dp[u][0] = 1; for(auto v : G[u])&#123; if(v == fa || !vis[v]) continue; dfs(v, u, z); sz[u] += sz[v]; for(int j = sz[u]; j &gt;= 0; j--)&#123; for(int k = 1; k &lt;= min(sz[v], j); k++)&#123; add(dp[u][j], 1ll * dp[u][j - k] * dp[v][k] % mod * f[j - k][k] % mod); &#125; &#125; &#125; add(dp[u][sz[u]], dp[u][sz[u] - 1]);&#125; int getans(int u, int fa)&#123; mem(dp); dfs(u, 0, 0); for(int j = 0; j &lt;= n; j++) add(ans[j], dp[u][j]); ok[u] = 1; int cnt = 1; for(auto v : G[u])&#123; if(v == fa) continue; cnt += getans(v, u); &#125; return cnt;&#125; int main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); cout &lt;&lt; fixed &lt;&lt; setprecision(10); f[0][0] = 1; for (int i = 0; i &lt; maxn; ++i) &#123; for (int j = 0; j &lt; maxn; ++j) &#123; if(i) add(f[i][j], f[i - 1][j]); if(j) add(f[i][j], f[i][j - 1]); &#125; &#125; cin &gt;&gt; n &gt;&gt; m; for(int i = 1; i &lt;= m; i++)&#123; int u, v; cin &gt;&gt; u &gt;&gt; v; G[u].eb(v); G[v].eb(u); deg[u]++, deg[v]++; &#125; bfs(); res[0] = 1; for(int i = 1; i &lt;= n; i++)&#123; if(vis[i]) continue; for(auto v : G[i])&#123; if(ok[v] || !vis[v]) continue; dfs(v, 0, 1); for(int j = n; j &gt;= 0; j--) &#123; for(int k = 1; k &lt;= min(sz[v], j); k++)&#123; add(res[j], 1ll * res[j - k] * dp[v][k] % mod * f[j - k][k] % mod); &#125; &#125; &#125; &#125; for(int i = 1; i &lt;= n; i++)&#123; if(ok[i] || !vis[i]) continue; mem(ans); int cnt = getans(i, 0); for(int j = 0; j &lt; cnt; j++) ans[j] = 1ll * ans[j] * pow_mod(cnt - j, mod - 2) % mod; for(int j = n; j &gt;= 0; j--) &#123; for(int k = 1; k &lt;= min(cnt, j); k++)&#123; add(res[j], 1ll * res[j - k] * ans[k] % mod * f[j - k][k] % mod); &#125; &#125; &#125; for(int i = 0; i &lt;= n; i++)&#123; cout &lt;&lt; res[i] &lt;&lt; "\n"; &#125; return 0;&#125;]]></content>
      <categories>
        <category>树形dp</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[深入SAM & 广义SAM]]></title>
    <url>%2F2020%2F03%2F19%2F%E6%B7%B1%E5%85%A5SAM-%E5%B9%BF%E4%B9%89SAM%2F</url>
    <content type="text"><![CDATA[一直想借个契机重新了解下认真学下SAM，终于板子出问题了不得不深入探究一下。 SAMSAM的构造基本内容先暂时不写吧，以后有空再补 fail树的性质fail树是SAM中最重要的东西（应该是一切自动机算法上最重要的东西）。所以熟悉掌握fail树的性质很有必要。1、树上每个点代表了根据right集合划分出的一个等价类。2、某个点的right集合等于他所有儿子的right集合或者他所有儿子的right集合 + 1（自身）（但广义SAM中不一定，广义SAM正确的写法一个点就可能有多次）。3、两个串的最长公共后缀对应fail树上两节点的lca点内的某个串。4、求某个字串出现了多少次，就是求该串对应点的子树的right集合的大小。5、对于每个点都暴力跳fail链，总复杂度是$O(n\sqrt(n))$ 广义SAM其实本文的重点是广义SAM，因为广义SAM各种乱七八糟的写法，大多数都不能完全应对所有情况，主要分析每种写法的问题在哪里。 间隔符简而言之就是SA留下的后遗症，用间隔符把多个串串起来，然后就变成了单串SAM了。这个方法主要是可能会存在各种特判问题，所以非常不推荐，我写不会去写这玩意。。。 直接last = 1大多数都是直接在不同串插入以前，将last重置为1，然后就按照单串插入去做了，我们先来看看会有什么问题。假设加入两个串：3201和0结束后last = 6，很明显我们发现不对，没有任何路径能到6。原因是因为单串SAM构造时，last点一定不可能通过当前加入的点转移到最新的点，因为整个串一定是最新的没有被加入过的，但是多串的时候可能就存在已经加入过的问题，那么当有不连续情况存在时，就会新建节点，将fail上所有关于c的转移全部给到新建节点上，最后就会得到如图情况。如果要做right集合线段树合并等需要在树上对应点操作的事情，就会出问题了，你可能构造的时候做到了点6上，但是最后访问到的是点7，就会出错误。怎么办呢，发现复制的新建点是我们想要的last点，所以特判一下last节点应该是哪个点即可。 假设加入两个串：3201、0、0发现最后6、8都是多余的状态，所以还可能产生某些多余的状态。 如果我们要统计各个点出现次数，只要我们不用基数排序，dfs或者拓扑排序都不会出现问题，因为他的链接是对的，只是出现了多余的状态，但不会有路径能走的到多余的状态。 正确如下：last最后是7不是6，也不会产生多余状态，这样就需要在SAM里多两个特判就行了。 好像还有关于bfs和dfs建广义SAM的区别，后面有空再补。]]></content>
      <categories>
        <category>后缀自动机</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Round 286 (Div. 1)-C(Mr. Kitayuta vs. Bamboos)]]></title>
    <url>%2F2020%2F03%2F16%2FCodeforces-Round-286-Div-1-C-Mr-Kitayuta-vs-Bamboos%2F</url>
    <content type="text"><![CDATA[题目链接思路：因为有小于0就取0的限制，使得这个题非常不好做。考虑小于0取0，实际上是让你赚了一部分，如果二分答案mid，最后如果每一根都小于某个值，我们发现他最多赚了mid - x，我们将赚的这部分放到最后去，再倒过来做，那么这时我们发现整个过程就不能有小于0的时候，因为一旦有代表那个位置你必须变为0，最后结果一定会大于mid，所以我们发现这样做就把小于0取0的限制去掉了，原问题变成了从mid开始逆过程，不能有小于0的部分，最后结果要大于等于它给你的初始值，我们发现这样的话，每次我们选择最近快要到0的点进行拔高是最优的，一旦后面不需要再拔它就能满足要求了，我们就把它扔掉，最后看集合是否为空即可，用优先队列模拟一下就行了。思想就是通过放缩可以忽略掉某一种操作/某一维的限制。 includeusing namespace std; typedef long long ll;typedef unsigned long long ull;typedef double db;typedef pair pii;typedef vector vi;typedef vector vl;typedef vector vp;const int inf = 1e9;const ll INF = 1e18;const db eps = 1e-10; define fi firstdefine se seconddefine pb push_backdefine eb emplace_backdefine ep emplacedefine mem(a) memset(a, 0, sizeof(a))define copy(a, b) memcpy(a, b, sizeof(b))define PA cout &lt;&lt; “pass\n”define lowbit(x) (x &amp; -x)define all(x) x.begin(), x.end()define TM cout &lt;&lt; db(clock()) / CLOCKS_PER_SEC &lt;&lt; ‘\n’mt19937 mrand(chrono::high_resolution_clock::now().time_since_epoch().count()); templateinline void upmin(T &amp;x, T y) {x = x &gt; y ? y : x;}templateinline void upmax(T &amp;x, T y) {x = x &lt; y ? y : x;} int now;ll mid;int n, m, p, k; struct node{ ll c, cnt, id; bool operator &lt;(const node &amp;r) const{ return cnt &gt; r.cnt; }};const int maxn = 1e5 + 233;ll a[maxn], h[maxn]; bool check(ll x){ priority_queue q; for (int i = 1; i &lt;= n; ++i) { if(x - 1ll m a[i] &lt; h[i]) q.push(node{0, x / a[i], i}); } for(int i = 1; i &lt;= m; i++){ if(q.empty()) return true; int c = k; while(!q.empty() &amp;&amp; c—){ node t = q.top(); q.pop(); if(x + t.c p - i a[t.id] &lt; 0) return false; t.c++; if(x + t.c p - m a[t.id] &gt;= h[t.id]) continue; t.cnt = (x + t.c * p) / a[t.id]; q.push(t); } } return q.empty();} int main(){ ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); cout &lt;&lt; fixed &lt;&lt; setprecision(10); cin &gt;&gt; n &gt;&gt; m &gt;&gt; k &gt;&gt; p; for (int i = 1; i &lt;= n; ++i) { cin &gt;&gt; h[i] &gt;&gt; a[i]; } ll l = 0, r = INF, ans = INF; while(r &gt;= l){ ll mid = r + l &gt;&gt; 1; if(check(mid)) r = mid - 1, ans = mid; else l = mid + 1; } cout &lt;&lt; ans &lt;&lt; ‘\n’; return 0;}~~~]]></content>
      <categories>
        <category>贪心</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Round 310 (Div. 1)-E(Case of Computer Network)]]></title>
    <url>%2F2020%2F03%2F16%2FCodeforces-Round-310-Div-1-E-Case-of-Computer-Network%2F</url>
    <content type="text"><![CDATA[题目链接思路：考虑如果能形成环，我们肯定愿意形成环，而且环上两点可以任意到达，所以我们发现如果做双连通分量，同一个分量内的两个点一定能满足，问题变成了给一个森林，然后多对起点和终点，让你判断是否能给边定向使得能满足到达。一开始想树剖，后来发现不需要，直接用两个数组树上差分即可，只要不同时大于0就能满足，否则就不能满足。马上要修一下tarjan的板子了。。。代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156#include&lt;bits/stdc++.h&gt;using namespace std; typedef long long ll;typedef unsigned long long ull;typedef double db;typedef pair&lt;int, int&gt; pii;typedef vector&lt;int&gt; vi;typedef vector&lt;ll&gt; vl;typedef vector&lt;pii&gt; vp;const int inf = 1e9;const ll INF = 1e18;const db eps = 1e-10; #define fi first#define se second#define pb push_back#define eb emplace_back#define ep emplace#define mem(a) memset(a, 0, sizeof(a))#define copy(a, b) memcpy(a, b, sizeof(b))#define PA cout &lt;&lt; "pass\n"#define lowbit(x) (x &amp; -x)#define all(x) x.begin(), x.end()#define TM cout &lt;&lt; db(clock()) / CLOCKS_PER_SEC &lt;&lt; '\n' const int maxn = 2e5 + 233; int q, n, m;vi G[maxn], g[maxn]; struct EBCC &#123; int dfn[maxn]; int low[maxn]; int sccno[maxn]; int scount[maxn]; int ntime; int bcc_cnt; int sta[maxn]; int sz; void tarjan(int u, int f) &#123; dfn[u] = low[u] = ++ntime; sta[sz++] = u; int flag = 0; for (int i = 0; i &lt; G[u].size(); i++) &#123; int v = G[u][i]; if(v == f) &#123; flag++; if(flag == 1) continue; &#125; if (!dfn[v]) &#123; tarjan(v, u); low[u] = min(low[u], low[v]); &#125; else low[u] = min(low[u], dfn[v]); &#125; if (low[u] == dfn[u]) &#123; bcc_cnt++; int tmp; do &#123; --sz; tmp = sta[sz]; sccno[tmp] = bcc_cnt; scount[bcc_cnt]++; &#125; while (tmp != u); &#125; &#125; void find_bcc() &#123; sz = 0; memset(sccno, 0, sizeof(sccno)); memset(dfn, 0, sizeof(dfn)); memset(scount, 0, sizeof(scount)); ntime = bcc_cnt = 0; for (int i = 1; i &lt;= n; ++i)if (!dfn[i]) tarjan(i, 0); &#125;&#125;sol; int f[maxn][20];int bel[maxn], idx;int d[maxn]; void dfs(int u)&#123; for(int i = 1; i &lt;= 19; i++) f[u][i] = f[f[u][i - 1]][i - 1]; bel[u] = idx; for(auto &amp;v : g[u])&#123; if(!bel[v])d[v] = d[u] + 1, f[v][0] = u, dfs(v); &#125;&#125; int lca(int x, int y)&#123; if(d[x] &gt; d[y]) swap(x, y); for(int i = 19; i &gt;= 0; i--) if(d[f[y][i]] &gt;= d[x]) y = f[y][i]; if(x == y) return x; for(int i = 19; i &gt;= 0; i--) if(f[x][i] != f[y][i]) x = f[x][i], y = f[y][i]; return f[x][0];&#125; int a[maxn], b[maxn];bool vis[maxn];void getans(int u)&#123; vis[u] = 1; for(auto &amp;v : g[u])&#123; if(!vis[v]) getans(v), a[u] += a[v], b[u] += b[v]; &#125;&#125; int u[maxn], v[maxn]; int main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); cout &lt;&lt; fixed &lt;&lt; setprecision(10); cin &gt;&gt; n &gt;&gt; m &gt;&gt; q; for(int i = 1; i &lt;= m; i++)&#123; cin &gt;&gt; u[i] &gt;&gt; v[i]; G[u[i]].eb(v[i]); G[v[i]].eb(u[i]); &#125; sol.find_bcc(); for(int i = 1; i &lt;= m; i++)&#123; if(sol.sccno[u[i]] == sol.sccno[v[i]]) continue; g[sol.sccno[u[i]]].eb(sol.sccno[v[i]]); g[sol.sccno[v[i]]].eb(sol.sccno[u[i]]); &#125; for(int i = 1; i &lt;= sol.bcc_cnt; i++)&#123; if(!bel[i]) ++idx, d[i] = 1, dfs(i); &#125; while(q--)&#123; int x, y; cin &gt;&gt; x &gt;&gt; y; x = sol.sccno[x]; y = sol.sccno[y]; if(x == y) continue; if(bel[x] != bel[y])&#123; cout &lt;&lt; "No\n"; return 0; &#125; int lc = lca(x, y); a[x]++; a[lc]--; b[y]++; b[lc]--; &#125; for(int i = 1; i &lt;= sol.bcc_cnt; i++) if(!vis[i]) getans(i); for(int i = 1; i &lt;= sol.bcc_cnt; i++)&#123; if(a[i] &amp;&amp; b[i])&#123; cout &lt;&lt; "No\n"; return 0; &#125; &#125; cout &lt;&lt; "Yes\n"; return 0;&#125;]]></content>
      <categories>
        <category>tarjan强连通分量</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Round 319 (Div. 1)-D(Flights for Regular Customers)]]></title>
    <url>%2F2020%2F03%2F16%2FCodeforces-Round-319-Div-1-D-Flights-for-Regular-Customers%2F</url>
    <content type="text"><![CDATA[题目链接思路：已经忘了最基本的邻接矩阵的性质了，真的服了自己了。。可达矩阵中的$A_{ij}为1表示从i可以走到j$，$A^n_{ij}为1表示从i可以走恰好n步走到j$，如果是从某一些点出发，我们需要维护一个初始矩阵，能作为出发点的$i，base_{ii} = 1$，转移矩阵就是用来维护走x步后能从哪些点走到哪些点。考虑本题，转移矩阵最多有m种，每种我们都可以得到从1开始能到达的位置，然后从这些位置bfs一下更新最小值，不同种转移矩阵用矩阵快速幂进行转移即可。考虑是可达矩阵，只有0/1两个值，所以可以用bitset优化，复杂度$O(\frac{n^3mlog(m)}{w})$代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130#include&lt;bits/stdc++.h&gt;using namespace std; typedef long long ll;typedef unsigned long long ull;typedef double db;typedef pair&lt;int, int&gt; pii;typedef vector&lt;int&gt; vi;typedef vector&lt;ll&gt; vl;typedef vector&lt;pii&gt; vp;const int inf = 1e9 + 100000;const ll INF = 1e18;const db eps = 1e-10; #define fi first#define se second#define pb push_back#define eb emplace_back#define ep emplace#define mem(a) memset(a, 0, sizeof(a))#define copy(a, b) memcpy(a, b, sizeof(b))#define PA cout &lt;&lt; "pass\n"#define lowbit(x) (x &amp; -x)#define all(x) x.begin(), x.end()#define TM cout &lt;&lt; db(clock()) / CLOCKS_PER_SEC &lt;&lt; '\n' mt19937 mrand(chrono::high_resolution_clock::now().time_since_epoch().count()); template&lt;class T&gt;inline void upmin(T &amp;x, T y) &#123;x = x &gt; y ? y : x;&#125;template&lt;class T&gt;inline void upmax(T &amp;x, T y) &#123;x = x &lt; y ? y : x;&#125;const int maxn = 155;struct node&#123; int u, v, w; bool operator &lt;(const node &amp;r) const&#123; return w &lt; r.w; &#125;&#125;e[maxn]; int n, m; struct matrix&#123; bitset&lt;maxn&gt; v[maxn];&#125;; matrix rotate(matrix a)&#123; matrix c; for(int i = 1; i &lt;= n; i++)&#123; for(int j = 1; j &lt;= n; j++)&#123; c.v[i][j] = a.v[j][i]; &#125; &#125; return c;&#125; matrix operator *(matrix a, matrix b)&#123; matrix c; b = rotate(b); for(int i = 1; i &lt;= n; i++)&#123; for(int j = 1; j &lt;= n; j++)&#123; c.v[i][j] = (a.v[i] &amp; b.v[j]).any(); &#125; &#125; return c;&#125; matrix quick_pow(matrix q, int w)&#123; matrix res; for(int i = 1; i &lt;= n; i++) res.v[i][i] = 1; while(w)&#123; if(w &amp; 1) res = res * q; q = q * q; w &gt;&gt;= 1; &#125; return res;&#125; queue&lt;int&gt; q;int f[maxn];bool vis[maxn];matrix base, now; int bfs()&#123; mem(vis); while(!q.empty())&#123; int x = q.front(); q.pop(); if(vis[x]) continue; vis[x] = 1; for(int i = 1; i &lt;= n; i++)&#123; if(vis[i] || !now.v[x][i]) continue; upmin(f[i], f[x] + 1); q.ep(i); &#125; &#125; return f[n];&#125; int res; int main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); cout &lt;&lt; fixed &lt;&lt; setprecision(10); cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= m; ++i) &#123; cin &gt;&gt; e[i].u &gt;&gt; e[i].v &gt;&gt; e[i].w; &#125; sort(e + 1, e + m + 1); if(e[1].w)&#123; cout &lt;&lt; "Impossible\n"; return 0; &#125; base.v[1][1] = 1; res = inf; for(int i = 1; i &lt;= n; i++) f[i] = inf; e[m + 1].w = inf; for(int i = 1; i &lt;= m + 1; i++) &#123; matrix tmp = base * quick_pow(now, e[i].w - e[i - 1].w); for (int j = 1; j &lt;= n; j++) &#123; if (base.v[1][j]) q.ep(j), f[j] = 0; else f[j] = inf; &#125; upmin(res, e[i - 1].w + bfs()); base = tmp; now.v[e[i].u][e[i].v] = 1; &#125; if(res == inf) cout &lt;&lt; "Impossible\n"; else cout &lt;&lt; res &lt;&lt; '\n'; return 0;&#125;]]></content>
      <categories>
        <category>矩阵快速幂</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[误差反向传播法]]></title>
    <url>%2F2020%2F03%2F08%2F%E8%AF%AF%E5%B7%AE%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[概念误差反向传播法相对于数值微分而言，是一种高效计算权重参数的梯度的方法。上图是计算图，每个点都表示一个不可再拆分的运算，表明了整个运算的流程。通过正向运算得到我们的输出结果，将运算结果由反向带回，再根据每个点的导数，根据链式法则，我们就可以由结果回推出每个点的梯度。由于链式法则是非常基本的东西，这里就不再赘述了。 几个比较重要的运算/函数ReLUReLU函数如图所示表达式为： f(x)=\left\{ \begin{aligned} x \ &(x > 0)\\ 0 \ &(x \leq 0) \end{aligned} \right.考虑求导： \frac{\partial y}{\partial x} = \left\{ \begin{aligned} 1 \ &(x > 0)\\ 0 \ &(x \leq 0) \end{aligned} \right.发现如果小于等于0，则停止反向传播，否则原封不动将后面内容传给前面 SigmoidReLU函数如图所示表达式为： f(x)=\frac{1}{1 + e^{-x}}考虑求导： f'(x)=y(1 - y)AffineAffine就涉及矩阵的求导运算了，我好像不是很会矩阵的求导运算，但是如果看成变量的求导形式上发现差不多。。 Y = XW + B考虑求导： \frac{\partial L}{\partial X} = \frac{\partial L}{\partial Y} \cdot W^T\frac{\partial L}{\partial W} = X^T \cdot \frac{\partial L}{\partial Y}\frac{\partial L}{\partial B} = \frac{\partial L}{\partial Y}证明以后会了回来补。。。。 Softmax个人理解softmax有点类似于归一化的一个函数，可以算出每个离散点的概率 y_i=\frac{e^{z_i}}{\sum_t e^{z_t}}考虑求导： \frac{\partial y_i}{\partial z_j} = \frac{\partial \frac{e^{z_i}}{\sum_t e^{z_t}}}{\partial z_j}$当i = j时：$ \frac{e_{z_i} \cdot \sum_t e^{z_t} - e^{z_i} \cdot e^{z_j}}{(\sum_t e_{z_t})^2} = y_i(1 - y_i)$当i != j时：$ \frac{0 \cdot \sum_t e^{z_t} - e^{z_i} \cdot e^{z_j}}{(\sum_t e_{z_t})^2} = -y_iy_jCross-entropy我觉得讲交叉熵之前，其实有必要说说跟它相关的几个东西。 信息熵大学物理里面学过一点，不过讲的比较理论，这玩意说的比较通俗一点，就是用来衡量一个事情所包含的信息量。举个例子，今天太阳会下山，这句话就是句废话，因为人人都知道太阳每天会下山，所以这句话的信息量为0。简而言之，越不可能发生的事情，包含的信息量越大。我们给出信息熵的定义： s(x) = -\sum_iP(x_i)logP(x_i)我们发现当概率为1时，信息熵为0。 Cross-entropy交叉熵用来衡量两个信息之间的相似程度，给出定义： H(p, q) = -\sum p(x)log q(x)我们来推导一下交叉熵的求导: \frac{\partial H(y, t)}{\partial y_i} = \frac{\partial (-\sum t_ilogy_i)}{\partial y_i} = -\frac{t_i}{y_i}Softmax + Cross-entropy很多时候这两个函数搭配使用，前者用来归一化为概率，后者用来作为损失函数，效果就非常好，而且它求导出来的结果非常简单！ \frac{\partial H(t, y)}{\partial z_j} = \sum_i \frac{\partial H(y, t)}{\partial y_i} \cdot \frac{\partial y_i}{\partial z_j} = \sum_i -\frac{t_i}{y_i} \cdot((y_i(1 - y_i))_{i == j} - (y_iy_j)_{i != j})= -t_j + t_jy_j + \sum_{i != j} t_i = -t_j + y_j \sum_i t_i = y_j - t_j发现最后就是真实值和推测值之间的差。 KL散度KL散度来计算两个分布间的不同，简单理解就是相对差距。KL散度 = 交叉熵 - 信息熵，给出定义： D_{KL}(A || B) = H(A, B) - S(A)展开后如下： D_{KL}(A || B) = \sum_i P_A(x_i)logP_A(x_i) - P_A(x_i)logP_B(x_i)]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[初探圆的反演]]></title>
    <url>%2F2020%2F03%2F03%2F%E5%88%9D%E6%8E%A2%E5%9C%86%E7%9A%84%E5%8F%8D%E6%BC%94%2F</url>
    <content type="text"><![CDATA[适用场景反演变换适用于题目中存在多个圆/直线之间的相切关系的情况。利用反演变换的性质，在反演空间求解问题，可以大幅简化计算。 圆的反演定义给定反演中心O和反演半径R，平面上点$P和反演点P’$满足如下性质：$P’在OP的射线上$$|OP| \cdot |OP’| = R^2$其中R可以任意指定。 圆的反演性质1、$圆O外的点的反演点在圆O内，反之亦然；圆O上的点的反演点为其自身。$2、$不过点O的圆，其反演图形也是不过点O的圆。$过点O的圆，其反演图形是不过点O的直线。两个图形相切，则他们的反演图形也相切其中3、4点非常重要，是一般圆反演题目求解的核心。 变换记圆A半径为$r_1$，反演圆半径为$r_2$，则有：$r_2 = \frac{r_1R^2}{|OA|^2 - r_1^2}$$|OB| = \frac{|OA|r_b}{r_a}$如反演点坐标为$O(x_0, y_0)$，A上一坐标为$x_1, y_1$，则反演圆B上对应坐标为$x_2 = x_0 + \frac{|OB|}{|OA|}(x_1 - x_0)$$y_2 = y_0 + \frac{|OB|}{|OA|}(y_1 - y_0)$ 一些题目icpc 2013 杭州赛区 Problem of Apollonius这个题发现直接求外切列方程不好解，考虑反演，由于是圆外一个点，反演后两个圆仍然是圆，公切圆变成了直线，问题变成了在反演空间求两圆的公切线。再根据位置关系观察得到要求的是外公切线，且两圆和反演点必须在直线同一侧（原来离反演中心越远，反演后越近），随便叉积判一下就行了。代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef double db;typedef pair&lt;int, int&gt; pii;typedef vector&lt;int&gt; vi;typedef vector&lt;ll&gt; vl;typedef vector&lt;pii&gt; vp;const int inf = 1e9;const ll INF = 1e18;const db eps = 1e-10;#define fi first#define se second#define pb push_back#define eb emplace_back#define ep emplace#define mem(a) memset(a, 0, sizeof(a))#define copy(a, b) memcpy(a, b, sizeof(b))#define PA cout &lt;&lt; "pass\n"#define lowbit(x) (x &amp; -x)#define all(x) x.begin(), x.end()#define TM cout &lt;&lt; db(clock()) / CLOCKS_PER_SEC &lt;&lt; '\n'const db pi = acos(-1);int dcmp(db x) &#123; return x&lt;-eps?-1:x&gt;eps;&#125;db myacos(db x)&#123; if(x&lt;-1) x = -1; if(x&gt;1) x = 1; return acos(x);&#125;db myasin(db x)&#123; if(x&lt;-1) x = -1; if(x&gt;1) x = 1; return asin(x);&#125;db mysqrt(db x)&#123; return x&lt;0?0:sqrt(x);&#125;typedef struct P &#123; db x, y; P(db x = 0, db y = 0) : x(x), y(y) &#123;&#125; P operator+(P r)&#123;return P(x+r.x,y+r.y);&#125; P operator-(P r)&#123;return P(x-r.x,y-r.y);&#125; P operator*(db r)&#123;return P(x*r,y*r);&#125; P operator/(db r)&#123;return P(x/r,y/r);&#125; bool operator&lt;(const P &amp;r)const&#123;return x&lt;r.x||(x==r.x&amp;&amp;y&lt;r.y);&#125; bool operator==(const P &amp;r)const&#123;return dcmp(x-r.x)==0&amp;&amp;dcmp(y-r.y)==0;&#125; bool upper()&#123;return y &gt; 0 || (y == 0 &amp;&amp; x &gt; 0);&#125; void read()&#123; scanf("%lf %lf", &amp;x, &amp;y); &#125; void print()&#123; printf("%.2f %.2f\n", x, y);&#125;&#125;V;struct Circle &#123; P c; db r; Circle()&#123;&#125; Circle(P c, db r) : c(c), r(r) &#123;&#125; //通过圆心角确定圆上坐标 P point(db a) &#123; return P(c.x + cos(a)*r, c.y + sin(a)*r); &#125;&#125;;//向量点积db Dot(V A, V B) &#123; return A.x*B.x + A.y*B.y; &#125;//向量长度db Length(V A) &#123; return mysqrt(Dot(A, A)); &#125;//向量夹角db Angle(V A, V B) &#123; return myacos(Dot(A, B) / Length(A) / Length(B)); &#125;//向量叉积db Cross(V A, V B) &#123; return A.x*B.y - A.y*B.x; &#125;int GetTangents(Circle A, Circle B, P *a, P *b) &#123; int cnt = 0; if(A.r &lt; B.r) &#123; swap(A, B); swap(a, b); &#125; db d2 = (A.c.x - B.c.x)*(A.c.x - B.c.x) + (A.c.y - B.c.y)*(A.c.y - B.c.y); db rdiff = A.r - B.r; db rsum = A.r + B.r; if(dcmp(d2 - rdiff*rdiff) &lt; 0) return 0; //内含 db base = atan2(B.c.y - A.c.y, B.c.x - A.c.x); if(dcmp(d2) == 0 &amp;&amp; dcmp(A.r - B.r) == 0) return -1; //无限多条切线 if(dcmp(d2 - rdiff*rdiff) == 0) &#123; //内切一条切线 return 0; a[cnt] = A.point(base); b[cnt] = B.point(base); cnt++; return 1; &#125; //有外共切线 db ang = myacos((A.r-B.r) / mysqrt(d2)); a[cnt] = A.point(base+ang); b[cnt] = B.point(base+ang); cnt++; a[cnt] = A.point(base-ang); b[cnt] = B.point(base-ang); cnt++; /* if(dcmp(d2 - rsum*rsum) == 0) &#123; //一条内公切线 a[cnt] = A.point(base); b[cnt] = B.point(pi+base); cnt++; &#125; else if(dcmp(d2 - rsum*rsum) &gt; 0) &#123; //两条内公切线 db ang = myacos((A.r + B.r) / mysqrt(d2)); a[cnt] = A.point(base+ang); b[cnt] = B.point(pi+base+ang); cnt++; a[cnt] = A.point(base-ang); b[cnt] = B.point(pi+base-ang); cnt++; &#125;*/ return cnt;&#125;P GetLineProjection(P p, P A, P B) &#123; V v = B - A; return A + v * (Dot(v, p - A) / Dot(v, v));&#125;const db R = 10;db getdis(P a, P b)&#123; return Length(a - b);&#125;Circle invcir(Circle now, P o)&#123; Circle res; db oa = getdis(o, now.c); res.r = now.r * R * R / (oa * oa - now.r * now.r); db ob = oa * res.r / now.r; res.c = o + (now.c - o) * (ob / oa ); return res;&#125;Circle invline(P o, P a, P b) &#123; P p = GetLineProjection(o, a, b); db d = getdis(p, o); db rb = R * R / 2 / d; V v = (p - o) / d * rb; return Circle(o + v, rb);&#125;Circle a, b;int T;P t;P t1[10], t2[10];vector&lt;Circle&gt; ans;int main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); cout &lt;&lt; fixed &lt;&lt; setprecision(10); cin &gt;&gt; T; while(T--)&#123; ans.clear(); cin &gt;&gt; a.c.x &gt;&gt; a.c.y &gt;&gt; a.r &gt;&gt; b.c.x &gt;&gt; b.c.y &gt;&gt; b.r &gt;&gt; t.x &gt;&gt; t.y; Circle ta = invcir(a, t); Circle tb = invcir(b, t); int len = GetTangents(ta, tb, t1, t2); for(int i = 0; i &lt; len; i++)&#123; if(dcmp(Cross(t - t1[i], t2[i] - t1[i])) * dcmp(Cross(ta.c - t1[i], t2[i] - t1[i])) &gt; 0) ans.eb(invline(t, t1[i], t2[i])); &#125; cout &lt;&lt; ans.size() &lt;&lt; '\n'; for(auto &amp;it : ans)&#123; cout &lt;&lt; it.c.x &lt;&lt; ' ' &lt;&lt; it.c.y &lt;&lt; ' ' &lt;&lt; it.r &lt;&lt; '\n'; &#125; &#125; return 0;&#125; icpc 2017 南宁赛区网络赛 Finding the Radius for an Inserted Circle第一个圆的圆心可以建系计算出来，我们以最上面的交点为中心反演，两个相切圆变成了两条直线，这一系列圆反演后都是一样的大小，与两条直线相切，半径都完全一样，我们只需要递推就可以算出每个圆的半径了。代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef double db;typedef pair&lt;int, int&gt; pii;typedef vector&lt;int&gt; vi;typedef vector&lt;ll&gt; vl;typedef vector&lt;pii&gt; vp;const int inf = 1e9;const ll INF = 1e18;const db eps = 1e-10;#define fi first#define se second#define pb push_back#define eb emplace_back#define ep emplace#define mem(a) memset(a, 0, sizeof(a))#define copy(a, b) memcpy(a, b, sizeof(b))#define PA cout &lt;&lt; "pass\n"#define lowbit(x) (x &amp; -x)#define all(x) x.begin(), x.end()#define TM cout &lt;&lt; db(clock()) / CLOCKS_PER_SEC &lt;&lt; '\n'const db pi = acos(-1);int dcmp(db x) &#123; return x&lt;-eps?-1:x&gt;eps;&#125;db myacos(db x)&#123; if(x&lt;-1) x = -1; if(x&gt;1) x = 1; return acos(x);&#125;db myasin(db x)&#123; if(x&lt;-1) x = -1; if(x&gt;1) x = 1; return asin(x);&#125;db mysqrt(db x)&#123; return x&lt;0?0:sqrt(x);&#125;typedef struct P &#123; db x, y; P(db x = 0, db y = 0) : x(x), y(y) &#123;&#125; P operator+(P r)&#123;return P(x+r.x,y+r.y);&#125; P operator-(P r)&#123;return P(x-r.x,y-r.y);&#125; P operator*(db r)&#123;return P(x*r,y*r);&#125; P operator/(db r)&#123;return P(x/r,y/r);&#125; bool operator&lt;(const P &amp;r)const&#123;return x&lt;r.x||(x==r.x&amp;&amp;y&lt;r.y);&#125; bool operator==(const P &amp;r)const&#123;return dcmp(x-r.x)==0&amp;&amp;dcmp(y-r.y)==0;&#125; bool upper()&#123;return y &gt; 0 || (y == 0 &amp;&amp; x &gt; 0);&#125; void read()&#123; scanf("%lf %lf", &amp;x, &amp;y); &#125; void print()&#123; printf("%.2f %.2f\n", x, y);&#125;&#125;V;struct Circle &#123; P c; db r; Circle()&#123;&#125; Circle(P c, db r) : c(c), r(r) &#123;&#125; //通过圆心角确定圆上坐标 P point(db a) &#123; return P(c.x + cos(a)*r, c.y + sin(a)*r); &#125;&#125;;//向量点积db Dot(V A, V B) &#123; return A.x*B.x + A.y*B.y; &#125;//向量长度db Length(V A) &#123; return mysqrt(Dot(A, A)); &#125;//向量夹角db Angle(V A, V B) &#123; return myacos(Dot(A, B) / Length(A) / Length(B)); &#125;//向量叉积db Cross(V A, V B) &#123; return A.x*B.y - A.y*B.x; &#125;int GetTangents(Circle A, Circle B, P *a, P *b) &#123; int cnt = 0; if(A.r &lt; B.r) &#123; swap(A, B); swap(a, b); &#125; db d2 = (A.c.x - B.c.x)*(A.c.x - B.c.x) + (A.c.y - B.c.y)*(A.c.y - B.c.y); db rdiff = A.r - B.r; db rsum = A.r + B.r; if(dcmp(d2 - rdiff*rdiff) &lt; 0) return 0; //内含 db base = atan2(B.c.y - A.c.y, B.c.x - A.c.x); if(dcmp(d2) == 0 &amp;&amp; dcmp(A.r - B.r) == 0) return -1; //无限多条切线 if(dcmp(d2 - rdiff*rdiff) == 0) &#123; //内切一条切线 return 0; a[cnt] = A.point(base); b[cnt] = B.point(base); cnt++; return 1; &#125; //有外共切线 db ang = myacos((A.r-B.r) / mysqrt(d2)); a[cnt] = A.point(base+ang); b[cnt] = B.point(base+ang); cnt++; a[cnt] = A.point(base-ang); b[cnt] = B.point(base-ang); cnt++; /* if(dcmp(d2 - rsum*rsum) == 0) &#123; //一条内公切线 a[cnt] = A.point(base); b[cnt] = B.point(pi+base); cnt++; &#125; else if(dcmp(d2 - rsum*rsum) &gt; 0) &#123; //两条内公切线 db ang = myacos((A.r + B.r) / mysqrt(d2)); a[cnt] = A.point(base+ang); b[cnt] = B.point(pi+base+ang); cnt++; a[cnt] = A.point(base-ang); b[cnt] = B.point(pi+base-ang); cnt++; &#125;*/ return cnt;&#125;P GetLineProjection(P p, P A, P B) &#123; V v = B - A; return A + v * (Dot(v, p - A) / Dot(v, v));&#125;const db R = 10;db getdis(P a, P b)&#123; return Length(a - b);&#125;Circle invcir(Circle now, P o)&#123; Circle res; db oa = getdis(o, now.c); res.r = now.r * R * R / (oa * oa - now.r * now.r); db ob = oa * res.r / now.r; res.c = o + (now.c - o) * (ob / oa ); return res;&#125;Circle invline(P o, P a, P b) &#123; P p = GetLineProjection(o, a, b); db d = getdis(p, o); db rb = R * R / 2 / d; V v = (p - o) / d * rb; return Circle(o + v, rb);&#125;int T;db r;int k;P o;db res[100];int main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); cout &lt;&lt; fixed &lt;&lt; setprecision(0); cin &gt;&gt; T &gt;&gt; r; P m = P(0, -sqrt(3) * r) / 3; res[1] = getdis(m, P(0, -sqrt(3) * r + r)); o = P(0, 0); db nr = R * R / r / 2; db now = sqrt(3) * r - r - 2 * res[1]; for(int i = 2; i &lt;= 10; i++)&#123; res[i] = nr * now * now / (2 * nr * now + R * R); now -= 2 * res[i]; &#125; while(T--)&#123; cin &gt;&gt; k; if(k == -1) break; cout &lt;&lt; k &lt;&lt; ' ' &lt;&lt; floor(res[k]) &lt;&lt; '\n'; &#125; return 0;&#125;]]></content>
      <categories>
        <category>计算几何</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Grand Prix of America 2017-F(Heaps of Fun)]]></title>
    <url>%2F2020%2F03%2F02%2FGrand-Prix-of-America-2017-F-Heaps-of-Fun%2F</url>
    <content type="text"><![CDATA[链接：题目链接思路：看懂之后瞬间人都不好了，感觉自己被羞辱了一般。。。先介绍两个函数：$f_u(x)：当u的值为x时，u的子树能构成最小堆的概率$$F_u(x)：点u的值小于等于x时，u的子树能构成最小堆的概率，等于\int_0^xf_u(x)$设$mn[u]$代表u的子树内所有b限制中最小的，显然u的取值不能大于$mn[u]$假设我们计算出了所有子节点的$f、F$，考虑如何往父节点合并。根据概率式子我们可以得到$f_u(x) = \frac{1}{b[u]}\int_x^{mn[u]} \prod f_v(x)dt$我们惊奇的发现一个事情，f函数是关于x的一个多项式，合并过程就相当于是一个多项式的乘法，因为是多项式，积分就非常好求了，直接跟多项式的指数有关，剩下的模拟一下这个过程就行了。代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef double db;typedef pair&lt;int, int&gt; pii;typedef vector&lt;int&gt; vi;typedef vector&lt;ll&gt; vl;typedef vector&lt;pii&gt; vp;const int inf = 1e9;const ll INF = 1e18;const db eps = 1e-10;#define fi first#define se second#define pb push_back#define eb emplace_back#define ep emplace#define mem(a) memset(a, 0, sizeof(a))#define copy(a, b) memcpy(a, b, sizeof(b))#define PA cout &lt;&lt; "pass\n"#define lowbit(x) (x &amp; -x)#define all(x) x.begin(), x.end()#define TM cout &lt;&lt; db(clock()) / CLOCKS_PER_SEC &lt;&lt; '\n'mt19937 mrand(chrono::high_resolution_clock::now().time_since_epoch().count());const int mod = 1e9 + 7;const int maxn = 505;vi G[maxn];int a[maxn];int mn[maxn];int rt, n;vi f[maxn];int pow_mod(int q, int w)&#123; int ret = 1; while(w)&#123; if(w &amp; 1) ret = 1ll * ret * q % mod; q = 1ll * q * q % mod; w &gt;&gt;= 1; &#125; return ret;&#125;vi integrate(vi a)&#123; vi res(a.size() + 1, 0); for(int i = 0; i &lt; a.size(); i++) res[i + 1] = 1ll * a[i] * pow_mod(i + 1, mod - 2) % mod; return res;&#125;int evalue(vi a, int x)&#123; int res = 0; for(int i = a.size() - 1; i &gt;= 0; i--)&#123; res = (1ll * res * x + a[i]) % mod; &#125; return res;&#125;vi mul(vi a, vi b)&#123; vi res(a.size() + b.size() - 1, 0); for(int i = 0; i &lt; a.size(); i++)&#123; for(int j = 0; j &lt; b.size(); j++)&#123; res[i + j] = (res[i + j] + 1ll * a[i] * b[j]) % mod; &#125; &#125; return res;&#125;void dfs(int u)&#123; mn[u] = a[u]; f[u].eb(pow_mod(a[u], mod - 2)); for(auto &amp;v : G[u])&#123; dfs(v); mn[u] = min(mn[u], mn[v]); f[u] = mul(f[u], f[v]); &#125; f[u] = integrate(f[u]); f[u][0] = evalue(f[u], mn[u]); for(int i = 1; i &lt; f[u].size(); i++) f[u][i] = (mod - f[u][i]) % mod;&#125;int main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); cout &lt;&lt; fixed &lt;&lt; setprecision(10); cin &gt;&gt; n; for(int i = 1; i &lt;= n; i++)&#123; int fa; cin &gt;&gt; a[i] &gt;&gt; fa; if(fa == 0) rt = i; else G[fa].eb(i); &#125; dfs(rt); cout &lt;&lt; f[rt][0] &lt;&lt; '\n'; return 0;&#125;]]></content>
      <categories>
        <category>积分</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[NEERC-2017-G(The Great Wall)]]></title>
    <url>%2F2020%2F02%2F24%2FNEERC-2017-G-The-Great-Wall%2F</url>
    <content type="text"><![CDATA[链接：题目链接思路：首先很显然需要二分，然后问题变为了统计所有≤x的区间对数。考虑两种情况，第一种是两个没有重叠，第二个是两个有重叠。没有重叠的情况枚举第二个区间的起点，前面用平衡树维护，非常容易计算出来。考虑有重叠的部分，我们把式子写出来，首先令$b[i]−=a[i],c[i]−=a[i]$，用sa,sb,sc代表a，b，c的前缀和，那么式子就是$sb[y−1]−sb[x−1]+sb[y+r−1]−sb[x+r−1]+sc[x+r−1]−sc[y−1]$，分为x和y两个部分，枚举一个另一个用平衡树维护。需要非常注意一点是，当r = 1的时候没有重叠的部分，但是如果你的写法不优雅（比如我）就容易在这里需要特判，如果忘了就会被卡很久。。代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef double db;typedef pair&lt;int, int&gt; pii;typedef vector&lt;int&gt; vi;typedef vector&lt;ll&gt; vl;typedef vector&lt;pii&gt; vp;const int inf = 1e9;const ll INF = 1e18;const db eps = 1e-10;#define fi first#define se second#define pb push_back#define eb emplace_back#define ep emplace#define mem(a) memset(a, 0, sizeof(a))#define copy(a, b) memcpy(a, b, sizeof(b))#define PA cout &lt;&lt; "pass\n"#define lowbit(x) (x &amp; -x)#define all(x) x.begin(), x.end()#define TM cout &lt;&lt; db(clock()) / CLOCKS_PER_SEC &lt;&lt; '\n'#define myrand mt19937 mrand(chrono::high_resolution_clock::now().time_since_epoch().count())void debug()&#123;cout &lt;&lt; '\n';&#125;template&lt;class T, class... U&gt;void debug(const T&amp; h,const U&amp;... t)&#123; cout&lt;&lt; h &lt;&lt; ' '; debug(t...);&#125;const int maxn = 5e5 + 233;struct node&#123; ll v; int k, cnt, sz; int ch[2];&#125;t[maxn];int sz;struct Treap &#123;#define ls t[o].ch[0]#define rs t[o].ch[1] int root; void clear()&#123; for(int i = 0; i &lt;= sz; i++)&#123; mem(t[i].ch); t[i].v = t[i].k = t[i].cnt = t[i].sz = 0; &#125; root = 0; sz = 0; &#125; void update(int o) &#123; t[o].sz = t[ls].sz + t[rs].sz + t[o].cnt; &#125; void rotate(int &amp;o, int d) &#123; int son = t[o].ch[d]; t[o].ch[d] = t[son].ch[d ^ 1]; t[son].ch[d ^ 1] = o; update(o); update(o = son); &#125; void insert(int &amp;o, ll v) &#123; if (!o) &#123; o = ++sz; t[o].cnt = t[o].sz = 1; t[o].k = rand(); t[o].v = v; return; &#125; t[o].sz++; if (t[o].v == v) &#123;t[o].cnt++; return;&#125; int d = v &gt; t[o].v; insert(t[o].ch[d], v); if (t[o].k &gt; t[t[o].ch[d]].k) rotate(o, d); &#125; void del(int &amp;o, ll v) &#123; if (!o) return; if (t[o].v == v) &#123; if (t[o].cnt &gt; 1) &#123; t[o].cnt--, t[o].sz--; return; &#125; bool d = t[ls].k &gt; t[rs].k; if (!ls || !rs) o = ls + rs; else rotate(o, d), del(o, v); &#125; else t[o].sz--, del(t[o].ch[t[o].v &lt; v], v); &#125; int rank(int o, ll v) &#123; if (!o) return 0; if (t[o].v == v) return t[ls].sz + t[o].cnt; if (t[o].v &gt; v) return rank(ls, v); else return t[ls].sz + t[o].cnt + rank(rs, v); &#125; int kth(int o, int k) &#123; while (1) &#123; if (k &lt;= t[ls].sz) o = ls; else if (k &gt; t[ls].sz + t[o].cnt) k -= t[ls].sz + t[o].cnt, o = rs; else return t[o].v; &#125; &#125; ll pre(int o, ll v) &#123; if (!o) return -INF; if (t[o].v &gt;= v) return pre(ls, v); else return max(t[o].v, pre(rs, v)); &#125; ll nxt(int o, ll v) &#123; if (!o) return INF; if (t[o].v &lt;= v) return nxt(rs, v); else return min(t[o].v, nxt(ls, v)); &#125;#undef ls#undef rs&#125;tr;int a[maxn], b[maxn], c[maxn];ll sa[maxn], sb[maxn], sc[maxn];int n, r;ll base, k;bool check(ll x)&#123; x -= base; tr.clear(); ll res = 0; for(int i = 1; i &lt; r &amp;&amp; i + r - 1 &lt;= n; i++)&#123; tr.insert(tr.root, sb[i - 1] + sb[i + r - 1] - sc[i - 1]); &#125; if(r != 1) &#123; for (int i = 1; i &lt;= n - r + 1; i++) &#123; tr.del(tr.root, sb[i - 1] + sb[i + r - 1] - sc[i - 1]); int p = i + r - 1; if (p + r - 1 &lt;= n &amp;&amp; r != 1) &#123; tr.insert(tr.root, sb[p - 1] + sb[p + r - 1] - sc[p - 1]); &#125; res += tr.rank(tr.root, x - (sc[i + r - 1] - sb[i - 1] - sb[i + r - 1])); &#125; &#125; tr.clear(); for(int i = 1; i + r - 1 &lt;= n; i++)&#123; res += tr.rank(tr.root, x - (sb[i + r - 1] - sb[i - 1])); if(i - r + 1 &gt;= 1)&#123; tr.insert(tr.root, sb[i] - sb[i - r]); &#125; &#125; return res &gt;= k;&#125;int main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); cout &lt;&lt; fixed &lt;&lt; setprecision(10); cin &gt;&gt; n &gt;&gt; r &gt;&gt; k; srand(time(0)); base = 0; for (int i = 1; i &lt;= n; ++i) &#123; cin &gt;&gt; a[i]; base += a[i]; sa[i] = sa[i - 1] + a[i]; &#125; for (int i = 1; i &lt;= n; ++i) &#123; cin &gt;&gt; b[i]; b[i] -= a[i]; sb[i] = sb[i - 1] + b[i]; &#125; for (int i = 1; i &lt;= n; ++i) &#123; cin &gt;&gt; c[i]; c[i] -= a[i]; sc[i] = sc[i - 1] + c[i]; &#125; ll lb = base, ub = INF, ans = INF; while(ub &gt;= lb)&#123; ll mid = ub + lb &gt;&gt; 1; if(check(mid)) ub = mid - 1, ans = mid; else lb = mid + 1; &#125; cout &lt;&lt; ans &lt;&lt; '\n'; return 0;&#125;]]></content>
      <categories>
        <category>二分</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[NEERC-2017-L(Laminar Family)]]></title>
    <url>%2F2020%2F02%2F24%2FNEERC-2017-L-Laminar-Family%2F</url>
    <content type="text"><![CDATA[链接：题目链接思路:比赛口胡了一个点分治，感觉多少有点问题但总是想不出问题在哪而且写起来很复杂。事实上这个题需要稍微转换下题意，我们按路径长度从大到小加入，给路径染色，加入当前某一条，要嘛经过所有点的颜色都一样，要嘛所有点都没被染过色（0其实也可以看成一种颜色，这样就统一了）。那么问题就变成了求路径上是否只有一种颜色，这个树剖 + 线段树维护最大最小值可以做，染色就是区间赋值，这个线段树也可以做，这个题就做完了。代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef double db;typedef pair&lt;int, int&gt; pii;typedef vector&lt;int&gt; vi;typedef vector&lt;ll&gt; vl;typedef vector&lt;pii&gt; vp;const int inf = 1e9;const ll INF = 1e18;const db eps = 1e-10;#define fi first#define se second#define pb push_back#define eb emplace_back#define ep emplace#define mem(a) memset(a, 0, sizeof(a))#define copy(a, b) memcpy(a, b, sizeof(b))#define PA cout &lt;&lt; "pass\n"#define lowbit(x) (x &amp; -x)#define all(x) x.begin(), x.end()#define TM cout &lt;&lt; db(clock()) / CLOCKS_PER_SEC &lt;&lt; '\n'const int maxn = 2e5 + 233;int mx[maxn &lt;&lt; 2], mn[maxn &lt;&lt; 2], tag[maxn &lt;&lt; 2];int sz[maxn], top[maxn], f[maxn][20], son[maxn], rk[maxn], id[maxn], out[maxn], d[maxn];vi G[maxn];int idx, n, m;void dfs1(int u, int fa)&#123; f[u][0] = fa; for(int i = 1; i &lt;= 19; i++) f[u][i] = f[f[u][i - 1]][i - 1]; d[u] = d[fa] + 1; sz[u] = 1; for(auto &amp;v : G[u])&#123; if(v == fa) continue; dfs1(v, u); sz[u] += sz[v]; if(sz[v] &gt; sz[son[u]]) son[u] = v; &#125;&#125;void dfs2(int u, int t)&#123; top[u] = t; id[u] = ++idx; rk[idx] = u; if(son[u]) dfs2(son[u], t); for(auto &amp;v : G[u])&#123; if(v == f[u][0] || v == son[u]) continue; dfs2(v, v); &#125; out[u] = idx;&#125;#define ls o &lt;&lt; 1#define rs o &lt;&lt; 1 | 1void pushup(int o)&#123; mx[o] = max(mx[ls], mx[rs]); mn[o] = min(mn[ls], mn[rs]);&#125;void pushdown(int o)&#123; if(tag[o] != -1)&#123; tag[ls] = tag[rs] = mx[ls] = mx[rs] = mn[ls] = mn[rs] = tag[o]; tag[o] = -1; return; &#125;&#125;void build(int o, int l, int r)&#123; mx[o] = mn[o] = 0; tag[o] = -1; if(l == r) return; int mid = l + r &gt;&gt; 1; build(ls, l, mid); build(rs, mid + 1, r); pushup(o);&#125;void update(int o, int tl, int tr, int l, int r, int v)&#123; if(l &gt; tr || tl &gt; r) return; if(l &lt;= tl &amp;&amp; tr &lt;= r)&#123; tag[o] = mx[o] = mn[o] = v; return; &#125; pushdown(o); int mid = tl + tr &gt;&gt; 1; update(ls, tl, mid, l, r, v); update(rs, mid + 1, tr, l, r, v); pushup(o);&#125;int query(int o, int tl, int tr, int l, int r, bool op)&#123; if(tl &gt; r || l &gt; tr)&#123; if(!op) return inf; else return 0; &#125; if(l &lt;= tl &amp;&amp; tr &lt;= r)&#123; if(!op) return mn[o]; else return mx[o]; &#125; pushdown(o); int mid = tl + tr &gt;&gt; 1; if(!op) return min(query(ls, tl, mid, l, r, op), query(rs, mid + 1, tr, l, r, op)); else return max(query(ls, tl, mid, l, r, op), query(rs, mid + 1, tr, l, r, op));&#125;int lca(int u, int v)&#123; if(d[u] &gt; d[v]) swap(u, v); for(int i = 19; i &gt;= 0; i--)&#123; if(d[f[v][i]] &gt;= d[u]) v = f[v][i]; &#125; if(u == v) return u; for(int i = 19; i &gt;= 0; i--)&#123; if(f[u][i] != f[v][i]) u = f[u][i], v = f[v][i]; &#125; return f[u][0];&#125;int x[maxn], y[maxn], ord[maxn], len[maxn];int col[maxn];int main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); cin &gt;&gt; n &gt;&gt; m; for(int i = 1; i &lt; n; i++)&#123; int u, v; cin &gt;&gt; u &gt;&gt; v; G[u].eb(v); G[v].eb(u); &#125; dfs1(1, 0); dfs2(1, 1); build(1, 1, n); for(int i = 1; i &lt;= m; i++)&#123; cin &gt;&gt; x[i] &gt;&gt; y[i]; int lc = lca(x[i], y[i]); len[i] = d[x[i]] + d[y[i]] - 2 * d[lc]; ord[i] = i; &#125; sort(ord + 1, ord + m + 1, [](int a, int b)&#123;return len[a] &gt; len[b];&#125;); bool ok = true; for(int i = 1; i &lt;= m; i++) &#123; int a = x[ord[i]], b = y[ord[i]]; bool ff = true; int num = 0; while (top[a] != top[b]) &#123; if (d[top[a]] &lt; d[top[b]]) swap(a, b); int t1 = query(1, 1, n, id[top[a]], id[a], 0); int t2 = query(1, 1, n, id[top[a]], id[a], 1); if(t1 != t2)&#123; ff = false; &#125; if(col[t1] != i)&#123; col[t1] = i; num++; &#125; a = f[top[a]][0]; &#125; if (d[a] &gt; d[b]) swap(a, b); int t1 = query(1, 1, n, id[a], id[b], 0); int t2 = query(1, 1, n, id[a], id[b], 1); if(t1 != t2)&#123; ff = false; &#125; if(col[t1] != i) &#123; col[t1] = i; num++; &#125; if(num &gt; 1)&#123; ff = false; &#125; if(!ff)&#123; ok = false; break; &#125; a = x[ord[i]], b = y[ord[i]]; while (top[a] != top[b]) &#123; if (d[top[a]] &lt; d[top[b]]) swap(a, b); update(1, 1, n, id[top[a]], id[a], i); a = f[top[a]][0]; &#125; if (d[a] &gt; d[b]) swap(a, b); update(1, 1, n, id[a], id[b], i); &#125; if(ok) cout &lt;&lt; "Yes\n"; else cout &lt;&lt; "No\n"; return 0;&#125;]]></content>
      <categories>
        <category>树链剖分</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[NEERC-2017-A(Archery Tournament)]]></title>
    <url>%2F2020%2F02%2F24%2FNEERC-2017-A-Archery-Tournament%2F</url>
    <content type="text"><![CDATA[链接：题目链接思路：一个非常重要的性质，一条竖线最多会跟log个已经存在的圆相交。证明很好证，最坏就是贴着放，因为不相交，所以每次至少要放大一个倍数，下来就是log的。那么我们可以把每个插入的圆暴力插到每个点上面去，用set维护。但考虑如果遍历插，复杂度有问题，可能多次插入删除导致复杂度退化，所以用线段树维护set，区间修改，单点查询即可。像这种线段树上维护其他玩意的，要嘛单点修改区间询问，单点就一路改到底，区间找到log个区间询问；要嘛区间修改单点询问，那么区间修改只放到log个区间，单点查询一路要查到底才行；暂时应该没想到能区间修改区间查询的办法？代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef double db;typedef pair&lt;int, int&gt; pii;typedef vector&lt;int&gt; vi;typedef vector&lt;ll&gt; vl;typedef vector&lt;pii&gt; vp;const int inf = 1e9;const ll INF = 1e18;const db eps = 1e-10;#define fi first#define se second#define pb push_back#define eb emplace_back#define ep emplace#define mem(a) memset(a, 0, sizeof(a))#define copy(a, b) memcpy(a, b, sizeof(b))#define PA cout &lt;&lt; "pass\n"#define lowbit(x) (x &amp; -x)#define all(x) x.begin(), x.end()#define TM cout &lt;&lt; db(clock()) / CLOCKS_PER_SEC &lt;&lt; '\n'vi pos;const int maxn = 6e5 + 233;int n;int op[maxn], x[maxn], y[maxn];set&lt;int&gt; s[maxn &lt;&lt; 2];inline int read() &#123; int s = 0, w = 1; char ch = getchar(); while (ch &lt; '0' || ch &gt; '9') &#123; if (ch == '-')w = -1; ch = getchar(); &#125; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') s = s * 10 + ch - '0', ch = getchar(); return s * w;&#125;void update(int o, int tl, int tr, int l, int r, int v, bool f)&#123; if(tl &gt; r || l &gt; tr) return; if(l &lt;= tl &amp;&amp; tr &lt;= r)&#123; if(!f) s[o].insert(v); else s[o].erase(v); return; &#125; int mid = tl + tr &gt;&gt; 1; update(o &lt;&lt; 1, tl, mid, l, r, v, f); update(o &lt;&lt; 1 | 1, mid + 1, tr, l, r, v, f);&#125;int now;void query(int o, int tl, int tr, int l, int r, int p)&#123; if(tl &gt; r || l &gt; tr) return; if(now != -1) return; if(tl &lt;= l &amp;&amp; r &lt;= tr)&#123; for(auto &amp;it : s[o])&#123; if(1ll * (x[it] - x[p]) * (x[it] - x[p]) + 1ll * (y[it] - y[p]) * (y[it] - y[p]) &lt; 1ll * y[it] * y[it])&#123; now = it; return; &#125; &#125; &#125; if(tl == tr) return; int mid = tl + tr &gt;&gt; 1; query(o &lt;&lt; 1, tl, mid, l, r, p); query(o &lt;&lt; 1 | 1, mid + 1, tr, l, r, p);&#125;int main()&#123; n = read(); for(int i = 1; i &lt;= n; i++)&#123; op[i] = read(); x[i] = read(); y[i] = read(); pos.eb(x[i]); pos.eb(x[i] - y[i]); pos.eb(x[i] + y[i]); &#125; sort(all(pos)); pos.resize(unique(all(pos)) - pos.begin()); for(int i = 1; i &lt;= n; i++)&#123; if(op[i] == 1) &#123; int l = lower_bound(all(pos), x[i] - y[i]) - pos.begin(); int r = lower_bound(all(pos), x[i] + y[i]) - pos.begin(); update(1, 0, pos.size(), l, r, i, 0); &#125; else&#123; int t = lower_bound(all(pos), x[i]) - pos.begin(); now = -1; query(1, 0, pos.size(), t, t, i); if(now != -1) &#123; int l = lower_bound(all(pos), x[now] - y[now]) - pos.begin(); int r = lower_bound(all(pos), x[now] + y[now]) - pos.begin(); update(1, 0, pos.size(), l, r, now, 1); &#125; printf("%d\n", now); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>计算几何</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Round 616 (Div. 1)-C(Prefix Enlightenment)]]></title>
    <url>%2F2020%2F02%2F03%2FCodeforces-Round-616-Div-1-C-Prefix-Enlightenment%2F</url>
    <content type="text"><![CDATA[链接：https://codeforces.com/contest/1290/problem/C思路：很显然每个点最多两个灯、一开始想的是在这个点可以把两个点拆了合并成一个等价的新的，结果是对的，但复杂度不对。 考虑每个点的两个灯根据该点灯亮的情况要嘛开关状态相同，要嘛相反，发现就是个可以用带权并查集维护的东西，并且维护每个点子树内选0需要选多少灯，选1需要选多少灯，那么如果一个点有两个灯，我们将他们在并查集上合并，并且更新两个数组。如果只有一个灯，就代表这个灯必选/必不选，相当于并查集上该点只能强制选其中一种情况，考虑如果在该点强制了，其实只有这个连通块内的信息改变了，我们又是维护的子树内的信息，所以我们只需要找到它的根，把对应的另一个的选灯个数设为inf即可，每次都是取min来求得新加入的贡献。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef double db;typedef pair&lt;int, int&gt; pii;typedef vector&lt;int&gt; vi;typedef vector&lt;ll&gt; vl;typedef vector&lt;pii&gt; vp;const int inf = 1e9;const ll INF = 1e18;const db eps = 1e-10;#define fi first#define se second#define pb push_back#define eb emplace_back#define ep emplace#define mem(a) memset(a, 0, sizeof(a))#define copy(a, b) memcpy(a, b, sizeof(b))#define PA cout &lt;&lt; "pass\n"#define lowbit(x) (x &amp; -x)#define all(x) x.begin(), x.end()#define TM cout &lt;&lt; db(clock()) / CLOCKS_PER_SEC &lt;&lt; '\n'const int maxn = 3e5 + 233;int f[maxn], val[maxn], g1[maxn], g2[maxn], n, k;int res;int find(int x)&#123; if(x == f[x]) return x; int t = find(f[x]); val[x] ^= val[f[x]]; f[x] = t; return f[x];&#125;void merge(int x, int y, int z)&#123; int fx = find(x); int fy = find(y); if(fx == fy)return; res -= min(g1[fx], g2[fx]); res -= min(g1[fy], g2[fy]); f[fy] = fx; val[fy] = val[x] ^ z ^ val[y]; if(val[fy]) &#123; g1[fx] = min(inf, g1[fx] + g2[fy]); g2[fx] = min(inf, g2[fx] + g1[fy]); &#125; else&#123; g1[fx] = min(inf, g1[fx] + g1[fy]); g2[fx] = min(inf, g2[fx] + g2[fy]); &#125; res += min(g1[fx], g2[fx]);&#125;void trace(int x, int z)&#123; int t = find(x); res -= min(g1[t], g2[t]); if(val[x] ^ z) g2[t] = inf; else g1[t] = inf; res += min(g1[t], g2[t]);&#125;string s;vi pos[maxn];int main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); cin &gt;&gt; n &gt;&gt; k; cin &gt;&gt; s; for(int i = 1; i &lt;= k; i++) f[i] = i, g1[i] = 1, g2[i] = 0; for(int i = 1; i &lt;= k; i++)&#123; int t; cin &gt;&gt; t; for(int j = 1; j &lt;= t; j++)&#123; int x; cin &gt;&gt; x; pos[x].eb(i); &#125; &#125; for(int i = 1; i &lt;= n; i++)&#123; if(pos[i].size() == 1)&#123; trace(pos[i][0], (s[i - 1] - '0') ^ 1); &#125; if(pos[i].size() == 2)&#123; merge(pos[i][0], pos[i][1], (s[i - 1] - '0') ^ 1); &#125; cout &lt;&lt; res &lt;&lt; '\n'; &#125; return 0;&#125;]]></content>
      <categories>
        <category>并查集</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[矩阵树定理初探]]></title>
    <url>%2F2020%2F01%2F30%2F%E7%9F%A9%E9%98%B5%E6%A0%91%E5%AE%9A%E7%90%86%E5%88%9D%E6%8E%A2%2F</url>
    <content type="text"><![CDATA[矩阵树概念一般来说，矩阵树定理是用来解决生成树计数的问题，并且介绍广义矩阵树定理。本文不会证明矩阵树的原理（事实上也不会） 矩阵树定理我们定义矩阵D为度数矩阵： D_{i, j}=\left\{ \begin{aligned} deg_i &&& {i = j}\\ 0 &&& {i \neq j } \end{aligned} \right.我们定义矩阵C为邻接矩阵： C_{i, j}=\left\{ \begin{aligned} 0 &&& {i = j}\\ C &&& {i \neq j 且点i与j之间有c条重边} \end{aligned} \right.我们定义矩阵A = D - C为基尔霍夫矩阵： A_{i, j}=\left\{ \begin{aligned} deg_i &&& {i = j}\\ -C &&& {i \neq j 且点i与j之间有c条重边} \end{aligned} \right.无向图如果图是无向图，根据上面算出来的基尔霍夫矩阵，我们求它任意一个余子式的行列式值就是最后生成树个数的答案。 求余子式，其实就是一个矩阵的行列式，很显然是需要用高斯消元，复杂度是O(n^3)。 有向图有向图比较麻烦一点，需要分为外向树和内向树。外向树指的是选定一个结点为根，构造出的树需要满足根节点能到达任意一个节点。内向树指的是选定一个结点为根，构造出的树需要满足任意一个节点能够到达根节点。 内向树和外向树只在度数矩阵D的定义上有差别。 外向树对于一条有向边(u, v)，则deg_v++ 内向树对于一条有向边(u, v)，则deg_u++ 将A去掉第i行和第i列（i \in [1,n]），将它当做一个行列式求解，则det(A)就是以i为根的外向/内向树形图个数。很多时候我们会发现A的对角线上某数为A_{i,i} = 0，删去第i行和第i列可以干掉0。只有这样行列式才不等于0，其实也就是说只能从i出发有解了。 一些注意点矩阵树定理是把所有的点都要拿来参与生成树的构造，我们只需要求原图的一部分点的”子生成树”的方案数，我们需要把这些点抠出来用矩阵树定理，不然方案数永远都是0。 例题bzoj-4031(小Z的房间)矩阵树定理裸题，需要把所有房间的点抠出来做生成树，但这个题模数不是质数，所以除法没法用逆元来表示，我们用辗转相减法来模拟高斯校园中两行相减的那个过程，具体见代码。代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include&lt;bits/stdc++.h&gt;using namespace std; typedef long long ll;typedef double db;typedef pair&lt;int, int&gt; pii;typedef vector&lt;int&gt; vi;typedef vector&lt;ll&gt; vl;typedef vector&lt;pii&gt; vp;const int inf = 1e9;const ll INF = 1e18;const db eps = 1e-10; #define fi first#define se second#define pb push_back#define eb emplace_back#define ep emplace#define mem(a) memset(a, 0, sizeof(a))#define copy(a, b) memcpy(a, b, sizeof(b))#define PA cout &lt;&lt; "pass\n"#define lowbit(x) (x &amp; -x)#define all(x) x.begin(), x.end()#define TM cout &lt;&lt; db(clock()) / CLOCKS_PER_SEC &lt;&lt; '\n' const int maxn = 110;int a[maxn][maxn]; const int mod = inf;char s[maxn][maxn]; void addedge(int u, int v)&#123; a[u][u]++, a[v][v]++; a[u][v]--, a[v][u]--;&#125; int tot, n, m; int gauss()&#123; int res = 1; for(int i = 1; i &lt; tot; i++)&#123; for(int j = i + 1; j &lt; tot; j++)&#123; while(a[j][i])&#123; int t = a[i][i] / a[j][i]; for(int k = 1; k &lt; tot; k++)&#123; int tmp = ((a[i][k] - 1ll * t * a[j][k]) % mod + mod) % mod; a[i][k] = a[j][k]; a[j][k] = tmp; &#125; res = -res; &#125; &#125; &#125; for(int i = 1; i &lt; tot; i++) res = 1ll * res * a[i][i] % mod; return (res + mod) % mod;&#125; bool ok(int x, int y)&#123; return x &gt;= 1 &amp;&amp; x &lt;= n &amp;&amp; y &gt;= 1 &amp;&amp; y &lt;= m &amp;&amp; s[x][y] == '.';&#125; int id[maxn][maxn]; int main()&#123; scanf("%d %d", &amp;n, &amp;m); for(int i = 1; i &lt;= n; i++)&#123; scanf("%s", s[i] + 1); &#125; for(int i = 1; i &lt;= n; i++)&#123; for(int j = 1; j &lt;= m; j++)&#123; if(s[i][j] == '.') id[i][j] = ++tot; &#125; &#125; for(int i = 1; i &lt;= n; i++)&#123; for(int j = 1; j &lt;= m; j++)&#123; if(s[i][j] == '.')&#123; if(ok(i + 1, j)) addedge(id[i][j], id[i + 1][j]); if(ok(i, j + 1)) addedge(id[i][j], id[i][j + 1]); &#125; &#125; &#125; printf("%d\n", gauss()); return 0;&#125; bzoj-4894(天赋)内向树模板题，其实这里就不用辗转相减了。代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include&lt;bits/stdc++.h&gt;using namespace std; typedef long long ll;typedef double db;typedef pair&lt;int, int&gt; pii;typedef vector&lt;int&gt; vi;typedef vector&lt;ll&gt; vl;typedef vector&lt;pii&gt; vp;const int inf = 1e9;const ll INF = 1e18;const db eps = 1e-10; #define fi first#define se second#define pb push_back#define eb emplace_back#define ep emplace#define mem(a) memset(a, 0, sizeof(a))#define copy(a, b) memcpy(a, b, sizeof(b))#define PA cout &lt;&lt; "pass\n"#define lowbit(x) (x &amp; -x)#define all(x) x.begin(), x.end()#define TM cout &lt;&lt; db(clock()) / CLOCKS_PER_SEC &lt;&lt; '\n' const int maxn = 310;int a[maxn][maxn]; const int mod = 1e9 + 7; int n; int gauss()&#123; int res = 1; for(int i = 1; i &lt; n; i++)&#123; for(int j = i + 1; j &lt; n; j++)&#123; while(a[j][i])&#123; int t = a[i][i] / a[j][i]; for(int k = 1; k &lt; n; k++)&#123; int tmp = ((a[i][k] - 1ll * t * a[j][k]) % mod + mod) % mod; a[i][k] = a[j][k]; a[j][k] = tmp; &#125; res = -res; &#125; &#125; &#125; for(int i = 1; i &lt; n; i++) res = 1ll * res * a[i][i] % mod; return (res + mod) % mod;&#125; int main()&#123; scanf("%d", &amp;n); for(int i = 1; i &lt;= n; i++)&#123; for(int j = 1; j &lt;= n; j++)&#123; int x; scanf("%1d", &amp;x); if(x == 1) a[j][j]++, a[i][j]--; &#125; &#125; for(int i = 1; i &lt; n; i++)&#123; for(int j = 1; j &lt; n; j++)&#123; a[i][j] = a[i + 1][j + 1]; &#125; &#125; printf("%d\n", gauss()); return 0;&#125; bzoj-4596(黑暗前的幻想乡)暴力枚举哪些公司要参加道路修建，然后矩阵树定理求解方案，容斥即可。代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#include&lt;bits/stdc++.h&gt;using namespace std; typedef long long ll;typedef double db;typedef pair&lt;int, int&gt; pii;typedef vector&lt;int&gt; vi;typedef vector&lt;ll&gt; vl;typedef vector&lt;pii&gt; vp;const int inf = 1e9;const ll INF = 1e18;const db eps = 1e-10; #define fi first#define se second#define pb push_back#define eb emplace_back#define ep emplace#define mem(a) memset(a, 0, sizeof(a))#define copy(a, b) memcpy(a, b, sizeof(b))#define PA cout &lt;&lt; "pass\n"#define lowbit(x) (x &amp; -x)#define all(x) x.begin(), x.end()#define TM cout &lt;&lt; db(clock()) / CLOCKS_PER_SEC &lt;&lt; '\n' const int maxn = 20;int a[maxn][maxn];const int mod = 1e9 + 7;int n; void addedge(int u, int v)&#123; a[u][u]++, a[v][v]++; a[u][v]--, a[v][u]--;&#125; void init()&#123; mem(a);&#125; int gauss()&#123; int res = 1; for(int i = 1; i &lt; n; i++)&#123; for(int j = i + 1; j &lt; n; j++)&#123; while(a[j][i])&#123; int t = a[i][i] / a[j][i]; for(int k = 1; k &lt; n; k++)&#123; int tmp = ((a[i][k] - 1ll * t * a[j][k]) % mod + mod) % mod; a[i][k] = a[j][k]; a[j][k] = tmp; &#125; res = -res; &#125; &#125; &#125; for(int i = 1; i &lt; n; i++) res = 1ll * res * a[i][i] % mod; return (res + mod) % mod;&#125; vp b[maxn]; int main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); cin &gt;&gt; n; for(int i = 0; i &lt; n - 1; i++)&#123; int len; cin &gt;&gt; len; for(int j = 1; j &lt;= len; j++)&#123; int x, y; cin &gt;&gt; x &gt;&gt; y; b[i].pb(pii(x, y)) ; &#125; &#125; int res = 0; for(int i = 0; i &lt; (1 &lt;&lt; (n - 1)); i++)&#123; int cnt = __builtin_popcount(i); init(); for(int j = 0; j &lt; n - 1; j++)&#123; if(!(i &gt;&gt; j &amp; 1)) continue; for(int k = 0; k &lt; b[j].size(); k++)&#123; addedge(b[j][k].fi, b[j][k].se); &#125; &#125; if((n - 1 - cnt) &amp; 1) res = (res - gauss() + mod) % mod; else res = (res + gauss()) % mod; &#125; cout &lt;&lt; res &lt;&lt; '\n'; return 0;&#125; luogu-P4208(最小生成树计数)这个题就比较有趣了，先提两个比较容易脑补的性质，但不证明因为不太会：1、所有最小生成树的方案中每种权值边的数量是一定的。2、所有最小生成树的方案中每种权值边造成所有点的连通性是一致的。 可能第二点不太好理解，意思就是加入现在一条边没有，只加入每种方案中某种权值的边，哪些点在一个连通块里都是一样的。 有了这两个性质我们考虑，先做一次最小生成树，然后按权值分类，每次我们枚举一种权值，找到原图中所有这种权值的边来构造基尔霍夫矩阵，然后把之前最小生成树中该权值的边都删除，把一个连通快缩成一个点，在这个缩点后的图上来跑一次矩阵树定理，就可以得出这种权值的方案数。最后我们把所有权值方案数相乘就是答案。 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef double db;typedef pair&lt;int, int&gt; pii;typedef vector&lt;int&gt; vi;typedef vector&lt;ll&gt; vl;typedef vector&lt;pii&gt; vp;const int inf = 1e9;const ll INF = 1e18;const db eps = 1e-10;#define fi first#define se second#define pb push_back#define eb emplace_back#define ep emplace#define mem(a) memset(a, 0, sizeof(a))#define copy(a, b) memcpy(a, b, sizeof(b))#define PA cout &lt;&lt; "pass\n"#define lowbit(x) (x &amp; -x)#define all(x) x.begin(), x.end()#define TM cout &lt;&lt; db(clock()) / CLOCKS_PER_SEC &lt;&lt; '\n'const int mod = 31011;const int maxn = 110;int a[maxn][maxn], f[maxn], n, m;int find(int x)&#123; return x == f[x] ? x : f[x] = find(f[x]);&#125;struct edge&#123; int u, v, w; bool operator &lt;(const edge &amp;r) const&#123; return w &lt; r.w; &#125;&#125;;vector&lt;edge&gt; edges, tmp;vi pos;void addedge(int u, int v, int w)&#123; edges.push_back(edge&#123;u, v, w&#125;);&#125;void kruskal()&#123; sort(all(edges)); for(int i = 1; i &lt;= n; i++) f[i] = i; for(int i = 0; i &lt; edges.size(); i++)&#123; int u = edges[i].u; int v = edges[i].v; int fx = find(u); int fy = find(v); if(fx == fy) continue; f[fy] = fx; tmp.push_back(edges[i]); pos.eb(edges[i].w); &#125;&#125;int id[maxn], cnt;int gauss()&#123; int res = 1; for(int i = 1; i &lt; cnt; i++)&#123; for(int j = i + 1; j &lt; cnt; j++)&#123; while(a[j][i])&#123; int t = a[i][i] / a[j][i]; for(int k = 1; k &lt; cnt; k++)&#123; int tp = ((a[i][k] - a[j][k] * t) % mod + mod) % mod; a[i][k] = a[j][k]; a[j][k] = tp; &#125; res = -res; &#125; &#125; &#125; for(int i = 1; i &lt; cnt; i++) res = res * a[i][i] % mod; return (res + mod) % mod;&#125;int main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); cin &gt;&gt; n &gt;&gt; m; for(int i = 1; i &lt;= m; i++)&#123; int u, v, w; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; addedge(u, v, w); &#125; kruskal(); sort(all(pos)); pos.resize(unique(all(pos)) - pos.begin()); int res = 1; for(int i = 0; i &lt; pos.size(); i++)&#123; for(int j = 1; j &lt;= n; j++) f[j] = j; for(int j = 0; j &lt; tmp.size(); j++)&#123; auto &amp;e = tmp[j]; if(e.w == pos[i]) continue; int fx = find(e.u); int fy = find(e.v); f[fy] = fx; &#125; mem(id); mem(a); cnt = 0; for(int j = 1; j &lt;= n; j++)&#123; int now = find(j); if(!id[now]) id[now] = ++cnt; &#125; for(int j = 0; j &lt; edges.size(); j++)&#123; auto &amp;e = edges[j]; if(e.w == pos[i])&#123; int fx = find(e.u); int fy = find(e.v); if(fx == fy) continue; int x = id[fx]; int y = id[fy]; a[x][x]++, a[y][y]++; a[x][y]--, a[y][x]--; &#125; &#125; res = res * gauss() % mod; &#125; cout &lt;&lt; res &lt;&lt; '\n'; return 0;&#125; 广义矩阵树定理所以广义矩阵树做了个推广，直接定义基尔霍夫矩阵A如下： A_{i, j}=\left\{ \begin{aligned} \sum_{k = 1}^n & -A_{i, k} &&&& {i = j}\\ &-w_{i, j} &&&& {i \neq j } \end{aligned} \right.简单来说，如果i = j，求的就是与i相连的所有边权和，如果i \neq j，就是边(i, j)上的边权所有边的边权和的相反数，最后矩阵树得到的是所有生成树方案的边的乘积和。 例题bzoj-3534(重建)我们要求的是\sum_{T}\prod_{e \in T}p_e\prod_{e \notin T}(1 - p_e)考虑做个变换： \sum_{T}\prod_{e \in T}\frac{p_e}{1 - p_e}\prod_{e}(1 - p_e)发现后面是个常数，前面就是广义矩阵树定理可以求的东西，套上去即可。注意如果有等于p = 1的边我们把1 - p设为eps，不然会出现除0的情况。代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include&lt;bits/stdc++.h&gt;using namespace std; typedef long long ll;typedef double db;typedef pair&lt;int, int&gt; pii;typedef vector&lt;int&gt; vi;typedef vector&lt;ll&gt; vl;typedef vector&lt;pii&gt; vp;const int inf = 1e9;const ll INF = 1e18;const db eps = 1e-10; #define fi first#define se second#define pb push_back#define eb emplace_back#define ep emplace#define mem(a) memset(a, 0, sizeof(a))#define copy(a, b) memcpy(a, b, sizeof(b))#define PA cout &lt;&lt; "pass\n"#define lowbit(x) (x &amp; -x)#define all(x) x.begin(), x.end()#define TM cout &lt;&lt; db(clock()) / CLOCKS_PER_SEC &lt;&lt; '\n' int n;const int maxn = 55;db a[maxn][maxn]; db gauss()&#123; db res = 1; for(int i = 1; i &lt; n; i++)&#123; int p = i; for(int j = i + 1; j &lt; n; j++)&#123; if(fabs(a[j][i]) &gt; fabs(a[p][i])) p = i; &#125; for(int j = 1; j &lt; n; j++) swap(a[i][j], a[p][j]); if(a[i][i] &lt; eps) return 0; for(int j = i + 1; j &lt; n; j++)&#123; db t = a[j][i] / a[i][i]; for(int k = 1; k &lt; n; k++)&#123; a[j][k] -= t * a[i][k]; &#125; &#125; &#125; for(int i = 1; i &lt; n; i++) res *= a[i][i]; return res;&#125; int main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); cin &gt;&gt; n; cout &lt;&lt; fixed &lt;&lt; setprecision(10); db sum = 1; for(int i = 1; i &lt;= n; i++)&#123; for(int j = 1; j &lt;= n; j++)&#123; cin &gt;&gt; a[i][j]; if(i == j) continue; if(a[i][j] &lt; eps) a[i][j] = eps; if(i &gt; j) sum *= (1 - a[i][j]); a[i][j] /= (1 - a[i][j]); &#125; &#125; for(int i = 1; i &lt;= n; i++)&#123; for(int j = 1; j &lt;= n; j++)&#123; if(i == j) continue; a[i][i] += a[i][j], a[i][j] = -a[i][j]; &#125; &#125; cout &lt;&lt; gauss() * sum &lt;&lt; '\n'; return 0;&#125;]]></content>
      <categories>
        <category>矩阵树</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[三元环/四元环计数]]></title>
    <url>%2F2020%2F01%2F29%2F%E4%B8%89%E5%85%83%E7%8E%AF-%E5%9B%9B%E5%85%83%E7%8E%AF%E8%AE%A1%E6%95%B0%2F</url>
    <content type="text"><![CDATA[概论三元环/四元环问题计数其实很简单，写一写主要是怕自己忘了，但这玩意确实一看就懂。 三元环计数无向图最朴素的暴力枚举，考虑枚举三个点，看之间是否有边，复杂度O(n^3)，或者枚举一条边，再枚举一个点，复杂度O(mn)，如果是稀疏图，n，m同阶的情况下我们对这个复杂度不是很满意。 一个比较简单的做法就是给边定向，我们考虑让所有边从小度数的指向大度数的，按照如下步骤找三元环：1、枚举一条边2、将边的其中一个点连接的其他点全部打上标记3、枚举这条边的另一个的邻点，如果打上了标记就计数 来分析一下复杂度，这里就要用图中经常用到的一个分大小点的方法来分析，我们将度数大于\sqrt(m)的称为大点，其它点称为小点，很显然的是大点个数是O(sqrt(m))级别的，小点个数是O(n)级别的（这里我们认为n，m同阶）。考虑大点被枚举的次数，大点因为是被小点指向的，所以被枚举的次数是O(m)级别的，所有大点被枚举次数是O(m\sqrt(m))级别的。再来考虑小点，小点因为原图上度数小于O(\sqrt(m))，所以定向后能指向它的点也最多是O(\sqrt(m))级别的，总的复杂度也是O(m\sqrt(m))级别的。 无向图三元环计数就这么简单，当然主要是针对n，m同阶的情况，基本接近于完全图的话最坏复杂度就和暴力没啥差别了。Counting Stars 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef double db;typedef pair&lt;int, int&gt; pii;typedef vector&lt;int&gt; vi;typedef vector&lt;ll&gt; vl;typedef vector&lt;pii&gt; vp;const int inf = 1e9;const ll INF = 1e18;const db eps = 1e-10;#define fi first#define se second#define pb push_back#define eb emplace_back#define ep emplace#define mem(a) memset(a, 0, sizeof(a))#define copy(a, b) memcpy(a, b, sizeof(b))#define PA cout &lt;&lt; "pass\n"#define lowbit(x) (x &amp; -x)#define all(x) x.begin(), x.end()#define TM cout &lt;&lt; db(clock()) / CLOCKS_PER_SEC &lt;&lt; '\n'const int maxn = 2e5 + 233;int deg[maxn];int n, m;vp G[maxn];int u[maxn * 2], v[maxn * 2];int vis[maxn];int cnt[maxn * 2];int pos[maxn * 2];int main()&#123; while(~scanf("%d %d", &amp;n, &amp;m))&#123; for(int i = 1; i &lt;= n; i++)&#123; G[i].clear(); deg[i] = vis[i] = 0; &#125; for(int i = 1; i &lt;= m; i++)&#123; cnt[i] = 0; scanf("%d %d", &amp;u[i], &amp;v[i]); deg[u[i]]++, deg[v[i]]++; &#125; for(int i = 1; i &lt;= m; i++)&#123; if(deg[u[i]] &gt; deg[v[i]] || (deg[u[i]] == deg[v[i]] &amp;&amp; u[i] &gt; v[i])) G[v[i]].eb(u[i], i); else G[u[i]].eb(v[i], i); &#125; for(int i = 1; i &lt;= m; i++)&#123; for(auto &amp;it : G[u[i]]) vis[it.fi] = i, pos[it.fi] = it.se; for(auto &amp;j : G[v[i]])&#123; if(vis[j.fi] == i) cnt[i]++, cnt[j.se]++, cnt[pos[j.fi]]++; &#125; &#125; ll res = 0; for(int i = 1; i &lt;= m; i++) &#123; if(cnt[i] &gt; 1) res += 1ll * cnt[i] * (cnt[i] - 1) / 2; &#125; printf("%lld\n", res); &#125; return 0;&#125; 有向图你把它按无向图做，对于每个找出来的三元环看看原来的有向图是否满足不就好了？ 竞赛图竞赛图有特别牛逼的公式 \tbinom{n}{3} - \sum_{i = 1}^n\tbinom{outdeg_i}{2}很显然任意两条出边在一个点上不可能形成三元环，就这么简单容斥一下就好了 四元环四元环计数找了找资料发现都是18年焦作站之后才有的？19年WC上还专门出了一道四元环的题目。 无向图四元环计数的思路就比较神奇了，不知道怎么想出来的，先说做法。1、将原图按度数从小到大排序，得到每个点的rank2、将原图的边定向，由小的rank指向大的3、枚举一个点u，再枚举原图上u的一个邻点v，再枚举定向后的图上v的一个邻点w，如果rank[w] &gt; rank[u]，则res += cnt[w]，cnt[w]++4、在枚举完v和w后将cnt清空。我们画一画最后定向出来的图本质不同的就这三种，我们惊奇的发现运用这个算法这三种图都只会被计算一次。这才是真正的杂技戏耍啊。 最终boss来个最后的boss题吧，基本就能解决三元环/四元环计数问题了，也非常能阐释出这类问题的一个解决的思想。2018-2019 ACM-ICPC, Asia Jiaozuo Regional Contest-L(Connected Subgraphs)题目问给你一张无向图，任取4条边，是连通子图的数目有多少？画一画，发现就5种不同的情况情况1，2比较复杂，我们等会儿来说，先看情况3，非常好算，直接枚举点3，然后组合数一下就没了。 再来看情况四，也好算，枚举点2，然后该点三元环数目 * （度数 - 1）就完了，三元环板子拿来改改就行了 再来看情况五，好算，四元环板子拿来就没了 只剩情况1和2了，我们来看情况1，这种肯定枚举对称中心的点，考虑枚举它的邻点，用一个sum来记录已经枚举过的邻点的(度数 - 1)的和，每次用枚举的(邻点度数 - 1) * sum，再把sum += 邻点度数 - 1，就可以得到情况1的答案，但发现有重复的点导致并不是真正的情况1，我们来看一下，首先点2，4一定是不相同的，枚举发现有如下三种情况：1、1和4相同，2和5不相同：发现是第4种情况，而且会多枚举2次，所以减去2 * 情况42、1和5相同：发现是四元环，且会被多枚举4次，所以减去4 * 情况53、 1和4相同，2和5相同：发现是三元环，且会被多枚举到3次，减去3 * 三元环数目这样情况1就计算完了。 考虑情况2，枚举2，4之间的这条边，这样我们在2中任意选两个点，4中任意选一个点，组合数算一下就行了，但有重复，考虑1，5或者1，3相同，最后都是情况4，会被重复枚举2次，所以减去2 * 情况4 最后加起来就是最终的答案了。这个题也告诉我们，对于这种环的计数问题，先找好算的枚举方法（尽量找图形对称点或者边进行枚举），然后找重复计算的减掉。 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef double db;typedef pair&lt;int, int&gt; pii;typedef vector&lt;int&gt; vi;typedef vector&lt;ll&gt; vl;typedef vector&lt;pii&gt; vp;const int inf = 1e9;const ll INF = 1e18;const db eps = 1e-10;#define fi first#define se second#define pb push_back#define eb emplace_back#define ep emplace#define mem(a) memset(a, 0, sizeof(a))#define copy(a, b) memcpy(a, b, sizeof(b))#define PA cout &lt;&lt; "pass\n"#define lowbit(x) (x &amp; -x)#define all(x) x.begin(), x.end()#define TM cout &lt;&lt; db(clock()) / CLOCKS_PER_SEC &lt;&lt; '\n'const int maxn = 2e5 + 233;vi G[maxn], g[maxn];int T, n, m;int u[maxn], v[maxn], rk[maxn], vis[maxn], deg[maxn], cnt[maxn];const int mod = 1e9 + 7;int ord[maxn], num[maxn];int res;void init()&#123; for(int i = 1; i &lt;= n; i++)&#123; vis[i] = rk[i] = 0; g[i].clear(); &#125;&#125;void clear()&#123; init(); for(int i = 1; i &lt;= n; i++) G[i].clear(), deg[i] = num[i] = 0; res = 0;&#125;void add(int &amp;x, int y)&#123; x += y; if(x &gt;= mod) x -= mod;&#125;void sub(int &amp;x, int y)&#123; x -= y; if(x &lt; 0) x += mod;&#125;void three()&#123; init(); for(int i = 1; i &lt;= m; i++)&#123; if(deg[u[i]] &gt; deg[v[i]] || (deg[u[i]] == deg[v[i]] &amp;&amp; u[i] &gt; v[i])) g[v[i]].eb(u[i]); else g[u[i]].eb(v[i]); &#125; for(int i = 1; i &lt;= m; i++)&#123; for(auto &amp;x : g[u[i]]) vis[x] = i; for(auto &amp;x : g[v[i]])&#123; if(vis[x] == i) &#123; add(num[u[i]], 1); add(num[v[i]], 1); add(num[x], 1); &#125; &#125; &#125;&#125;bool cmp(int x, int y)&#123; return deg[x] &lt; deg[y] || (deg[x] == deg[y] &amp;&amp; x &lt; y);&#125;int four()&#123; int tmp = 0; init(); for(int i = 1; i &lt;= n; i++) ord[i] = i; sort(ord + 1, ord + n + 1, cmp); for(int i = 1; i &lt;= n; i++) rk[ord[i]] = i; for(int i = 1; i &lt;= m; i++)&#123; if(rk[u[i]] &lt; rk[v[i]]) g[u[i]].eb(v[i]); else g[v[i]].eb(u[i]); &#125; for(int i = 1; i &lt;= n; i++)&#123; for(auto &amp;x : G[i])&#123; for(auto &amp;y : g[x])&#123; if(rk[y] &gt; rk[i]) add(tmp, cnt[y]), add(cnt[y], 1); &#125; &#125; for(auto &amp;x : G[i])&#123; for(auto &amp;y : g[x])&#123; if(rk[y] &gt; rk[i]) cnt[y] = 0; &#125; &#125; &#125; return tmp;&#125;int pow_mod(int q, int w)&#123; int ret = 1; while(w)&#123; if(w &amp; 1) ret = 1ll * ret * q % mod; q = 1ll * q * q % mod; w &gt;&gt;= 1; &#125; return ret;&#125;void solve()&#123; three(); int t4 = four(); for(int i = 1; i &lt;= n; i++)&#123; add(res, 1ll * deg[i] * (deg[i] - 1) % mod * (deg[i] - 2) % mod * (deg[i] - 3) % mod * pow_mod(24, mod - 2) % mod); &#125; for(int i = 1; i &lt;= m; i++)&#123; add(res, 1ll * (deg[u[i]] - 1) * (deg[u[i]] - 2) / 2 % mod * (deg[v[i]] - 1) % mod); add(res, 1ll * (deg[v[i]] - 1) * (deg[v[i]] - 2) / 2 % mod * (deg[u[i]] - 1) % mod); &#125; int t3 = 0; for(int i = 1; i &lt;= n; i++)&#123; add(t3, 1ll * (deg[i] - 2) * num[i] % mod); &#125; int sum = 0; for(int i = 1; i &lt;= n; i++)&#123; int tmp = 0; for(auto &amp;x : G[i])&#123; add(sum, 1ll * tmp * (deg[x] - 1) % mod); add(tmp, deg[x] - 1); &#125; &#125; add(res, sum); sub(res, 3ll * t4 % mod); sub(res, 3ll * t3 % mod); for(int i = 1; i &lt;= n; i++) sub(res, num[i]);&#125;int main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); cin &gt;&gt; T; while(T--)&#123; cin &gt;&gt; n &gt;&gt; m; clear(); for(int i = 1; i &lt;= m; i++)&#123; cin &gt;&gt; u[i] &gt;&gt; v[i]; deg[u[i]]++; deg[v[i]]++; G[u[i]].eb(v[i]); G[v[i]].eb(u[i]); &#125; solve(); cout &lt;&lt; res &lt;&lt; '\n'; &#125; return 0;&#125;]]></content>
      <categories>
        <category>三元环/四元环</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[树套树杂技]]></title>
    <url>%2F2020%2F01%2F28%2F%E6%A0%91%E5%A5%97%E6%A0%91%E6%9D%82%E6%8A%80%2F</url>
    <content type="text"><![CDATA[树套树概念一直觉得树套树是非常高深的oi玩的数据结构，我一个非oi选手不配玩这个。 最近沉迷数据结构（王伟），当然免不了树套树啦。 感觉很多情况下一个题可以用树套树 或者 整体二分/cdq分治同时做，区别就是在线离线了。一般来说，离线的整体二分和cdq分治时间复杂度更优，常数更小，但是对于有些在线题目以及某些题目树套树码量会非常小，但有些树套树码量又会非常大，所以多掌握几种方法，根据题目来选择做法就会显得更加从容。 一般来说，树套树中如果有一个是bit，那么码量就不会太大，如果是线段树 + 平衡树/线段树，码量就会比较大，树套树也有很多种，我们只学习最基本常用的几种，有些感觉比较偏了难了就不学了。 树套树探究线段树/树状数组套平衡树这应该是一类最常见的树套树了，入门的树套树也都是这个，主要可以用来维护多维偏序下的一些东西。外层一般用个bit或者线段树，里面用平衡树（我就会treap和pbds）比如二逼平衡树，用的线段树套treap，码量就会挺大的了，不过它无法很好处理求第k大的问题，只能通过二分后来查看rank来求第k大，这样是3个log的。代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef double db;typedef pair&lt;int, int&gt; pii;typedef vector&lt;int&gt; vi;typedef vector&lt;ll&gt; vl;typedef vector&lt;pii&gt; vp;const int inf = 2147483647;const ll INF = 1e18;const db eps = 1e-10;#define fi first#define se second#define pb push_back#define eb emplace_back#define ep emplace#define mem(a) memset(a, 0, sizeof(a))#define copy(a, b) memcpy(a, b, sizeof(b))#define PA cout &lt;&lt; "pass\n"#define lowbit(x) (x &amp; -x)#define all(x) x.begin(), x.end()#define TM cout &lt;&lt; db(clock()) / CLOCKS_PER_SEC &lt;&lt; '\n'const int maxn = 1e5 + 233;struct node&#123; int v, k, cnt, sz; int ch[2];&#125;t[maxn * 40];int sz;struct Treap &#123;#define ls t[o].ch[0]#define rs t[o].ch[1] int root; void update(int o) &#123; t[o].sz = t[ls].sz + t[rs].sz + t[o].cnt; &#125; void rotate(int &amp;o, int d) &#123; int son = t[o].ch[d]; t[o].ch[d] = t[son].ch[d ^ 1]; t[son].ch[d ^ 1] = o; update(o); update(o = son); &#125; void insert(int &amp;o, int v) &#123; if (!o) &#123; o = ++sz; t[o].cnt = t[o].sz = 1; t[o].k = rand(); t[o].v = v; return; &#125; t[o].sz++; if (t[o].v == v) &#123;t[o].cnt++; return;&#125; int d = v &gt; t[o].v; insert(t[o].ch[d], v); if (t[o].k &gt; t[t[o].ch[d]].k) rotate(o, d); &#125; void del(int &amp;o, int v) &#123; if (!o) return; if (t[o].v == v) &#123; if (t[o].cnt &gt; 1) &#123; t[o].cnt--, t[o].sz--; return; &#125; bool d = t[ls].k &gt; t[rs].k; if (!ls || !rs) o = ls + rs; else rotate(o, d), del(o, v); &#125; else t[o].sz--, del(t[o].ch[t[o].v &lt; v], v); &#125; int rank(int o, int v) &#123; if (!o) return 0; if (t[o].v == v) return t[ls].sz; if (t[o].v &gt; v) return rank(ls, v); else return t[ls].sz + t[o].cnt + rank(rs, v); &#125; int kth(int o, int k) &#123; while (1) &#123; if (k &lt;= t[ls].sz) o = ls; else if (k &gt; t[ls].sz + t[o].cnt) k -= t[ls].sz + t[o].cnt, o = rs; else return t[o].v; &#125; &#125; int pre(int o, int v) &#123; if (!o) return -inf; if (t[o].v &gt;= v) return pre(ls, v); else return max(t[o].v, pre(rs, v)); &#125; int nxt(int o, int v) &#123; if (!o) return inf; if (t[o].v &lt;= v) return nxt(rs, v); else return min(t[o].v, nxt(ls, v)); &#125;#undef ls#undef rs&#125;a[maxn &lt;&lt; 2];int b[maxn], n, m;struct Segment_Tree&#123;#define ls o &lt;&lt; 1#define rs o &lt;&lt; 1 | 1 void build(int o, int l, int r)&#123; for(int i = l; i &lt;= r; i++) a[o].insert(a[o].root, b[i]); if(l == r) return; int mid = l + r &gt;&gt; 1; build(ls, l, mid); build(rs, mid + 1, r); &#125; int rank(int o, int tl, int tr, int l, int r, int v)&#123; if(l &gt; tr || tl &gt; r) return 0; if(l &lt;= tl &amp;&amp; tr &lt;= r) return a[o].rank(a[o].root, v); int mid = tl + tr &gt;&gt; 1; return rank(ls, tl, mid, l, r, v) + rank(rs, mid + 1, tr, l, r, v); &#125; int kth(int l, int r, int k)&#123; int ub = 1e8, lb = 0, ans = 0; while(ub &gt;= lb)&#123; int mid = ub + lb &gt;&gt; 1; if(rank(1, 1, n, l, r, mid) + 1 &lt;= k) lb = mid + 1, ans = mid; else ub = mid - 1; &#125; return ans; &#125; void update(int o, int tl, int tr, int pos, int v)&#123; if(tl &gt; pos || pos &gt; tr) return; a[o].del(a[o].root, b[pos]); a[o].insert(a[o].root, v); if(tl == tr) return; int mid = tl + tr &gt;&gt; 1; update(ls, tl, mid, pos, v); update(rs, mid + 1, tr, pos, v); &#125; int pre(int o, int tl, int tr, int l, int r, int v)&#123; if(tl &gt; r || l &gt; tr) return -inf; if(l &lt;= tl &amp;&amp; tr &lt;= r) return a[o].pre(a[o].root, v); int mid = tl + tr &gt;&gt; 1; return max(pre(ls, tl, mid, l, r, v), pre(rs, mid + 1, tr, l, r, v)); &#125; int nxt(int o, int tl, int tr, int l, int r, int v)&#123; if(tl &gt; r || l &gt; tr) return inf; if(l &lt;= tl &amp;&amp; tr &lt;= r) return a[o].nxt(a[o].root, v); int mid = tl + tr &gt;&gt; 1; return min(nxt(ls, tl, mid, l, r, v), nxt(rs, mid + 1, tr, l, r, v)); &#125;#undef ls#undef rs&#125;tr;int main()&#123; srand(time(0)); ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); cin &gt;&gt; n &gt;&gt; m; for(int i = 1; i &lt;= n; i++) cin &gt;&gt; b[i]; tr.build(1, 1, n); for(int i = 1; i &lt;= m; i++)&#123; int op, l, r, k; cin &gt;&gt; op &gt;&gt; l &gt;&gt; r; if(op != 3) cin &gt;&gt; k; if(op == 1) cout &lt;&lt; tr.rank(1, 1, n, l, r, k) + 1 &lt;&lt; '\n'; if(op == 2) cout &lt;&lt; tr.kth(l, r, k) &lt;&lt; '\n'; if(op == 3) tr.update(1, 1, n, l, r), b[l] = r; if(op == 4) cout &lt;&lt; tr.pre(1, 1, n, l, r, k) &lt;&lt; '\n'; if(op == 5) cout &lt;&lt; tr.nxt(1, 1, n, l, r, k) &lt;&lt; '\n'; &#125; return 0;&#125; 对于这个动态逆序对也是，这里为了方便写的bit套pbds，代码量就非常短，比cdq还短很多，就不太容易出错代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include&lt;bits/stdc++.h&gt;#include&lt;bits/extc++.h&gt;using namespace std;using namespace __gnu_pbds;typedef long long ll;typedef double db;typedef pair&lt;int, int&gt; pii;typedef vector&lt;int&gt; vi;typedef vector&lt;ll&gt; vl;typedef vector&lt;pii&gt; vp;const int inf = 1e9;const ll INF = 1e18;const db eps = 1e-10;#define fi first#define se second#define pb push_back#define eb emplace_back#define ep emplace#define mem(a) memset(a, 0, sizeof(a))#define copy(a, b) memcpy(a, b, sizeof(b))#define PA cout &lt;&lt; "pass\n"#define lowbit(x) (x &amp; -x)#define all(x) x.begin(), x.end()#define TM cout &lt;&lt; db(clock()) / CLOCKS_PER_SEC &lt;&lt; '\n'const int maxn = 1e5 + 233;tree&lt;pii, null_type, less&lt;pii&gt;, rb_tree_tag, tree_order_statistics_node_update&gt; t[maxn];int pos[maxn];int b[maxn];int n, m;void add(int x, int p)&#123; while(x &lt;= n)&#123; t[x].insert(pii(b[p], p)); x += lowbit(x); &#125;&#125;void del(int x, int p)&#123; while(x &lt;= n)&#123; t[x].erase(pii(b[p], p)); x += lowbit(x); &#125;&#125;int query(int x, int p)&#123; int ret = 0; while(x)&#123; ret += t[x].order_of_key(pii(p, -inf)); x -= lowbit(x); &#125; return ret;&#125;int main()&#123; srand(time(0)); scanf("%d %d", &amp;n, &amp;m); ll res = 0; for(int i = 1; i &lt;= n; i++)&#123; scanf("%d", &amp;b[i]); pos[b[i]] = i; res += i - 1 - query(n, b[i]); add(i, i); &#125; for(int i = 1; i &lt;= m; i++)&#123; int x; scanf("%d", &amp;x); printf("%lld\n", res); del(pos[x], pos[x]); res -= query(n, x) - query(pos[x] - 1, x) + query(pos[x], inf) - query(pos[x], x); &#125; return 0;&#125; 总的来说，这类树套树基本是万能的，一般是能维护二维平面上的各种情况（包括取max，取min，可以用平衡树实现动态插入和删除），比较万能通用。一般来说，如果外层的区间能转换为两个前缀的逆运算的话，推荐用bit而不是线段树，毕竟复杂度和码量都占了很大的优势。 树状数组套主席树这一类也非常常见，为了实现主席树的单点修改，就需要用这一类操作，但它所能干的事情也就是主席树能干的事情。主席树是基于前缀逆运算的原理，所以形如取max这种没有逆运算的东西就没法维护了。题目的话去看看今年icpc徐州的H题以及南京的F题吧，都是同一个东西。 树状数组套线段树一般来说线段树放在内层，就需要动态开点了，其实感觉跟主席树基本就是一个东西了，这里给个题目吧(这个题关于cdq解法我也会写，栽cdq的专栏里面，树套树就显得比较无脑了)。序列这个题目有个显著特点就是维护的都是前缀的东西，所以这里bit就可以拿来维护前缀的最值了。代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef double db;typedef pair&lt;int, int&gt; pii;typedef vector&lt;int&gt; vi;typedef vector&lt;ll&gt; vl;typedef vector&lt;pii&gt; vp;const int inf = 1e9;const ll INF = 1e18;const db eps = 1e-10;#define fi first#define se second#define pb push_back#define eb emplace_back#define ep emplace#define mem(a) memset(a, 0, sizeof(a))#define copy(a, b) memcpy(a, b, sizeof(b))#define PA cout &lt;&lt; "pass\n"#define lowbit(x) (x &amp; -x)#define all(x) x.begin(), x.end()#define TM cout &lt;&lt; db(clock()) / CLOCKS_PER_SEC &lt;&lt; '\n'const int maxn = 4e5 + 233;int root[maxn * 40], mx[maxn * 40], ls[maxn * 40], rs[maxn * 40];int idx, n, m;void update(int &amp;o, int l, int r, int pos, int v)&#123; if(!o) o = ++idx; mx[o] = max(mx[o], v); if(l == r) return; int mid = l + r &gt;&gt; 1; if(pos &lt;= mid) update(ls[o], l, mid, pos, v); else update(rs[o], mid + 1, r, pos, v);&#125;int N;int query(int o, int l, int r, int pos)&#123; if(l == r) return mx[o]; int mid = l + r &gt;&gt; 1; if(pos &lt;= mid) return query(ls[o], l, mid, pos); else return max(mx[ls[o]], query(rs[o], mid + 1, r, pos));&#125;void add(int x, int d, int pos)&#123; while(x &lt;= N)&#123; update(root[x], 1, N, pos, d); x += lowbit(x); &#125;&#125;int query(int x, int pos)&#123; int ret = 0; while(x)&#123; ret = max(ret, query(root[x], 1, N, pos)); x -= lowbit(x); &#125; return ret;&#125;int a[maxn], b[maxn], c[maxn];int main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); cin &gt;&gt; n &gt;&gt; m; for(int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i], b[i] = c[i] = a[i], N = max(N, a[i]); for(int i = 1; i &lt;= m; i++)&#123; int x, y; cin &gt;&gt; x &gt;&gt; y; b[x] = min(b[x], y); c[x] = max(c[x], y); N = max(N, y); &#125; int res = 0; for(int i = 1; i &lt;= n; i++)&#123; int tmp = query(a[i], b[i]) + 1; res = max(res, tmp); add(c[i], tmp, a[i]); &#125; cout &lt;&lt; res &lt;&lt; '\n'; return 0;&#125; 常规操作就这样了，有什么花的东西以后再来补。。。]]></content>
      <categories>
        <category>树套树</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[cdq分治浅谈]]></title>
    <url>%2F2020%2F01%2F26%2Fcdq%E5%88%86%E6%B2%BB%E6%B5%85%E8%B0%88%2F</url>
    <content type="text"><![CDATA[cdq的东西和整体二分有点类似，就一起学了，学了后发现原理还是挺简单的，就是可能需要多了解一些应用和套路 cdq分治概述cdq分治利用分治过程中统计左半部分对右半部分的贡献，从而可以解决一些特殊的问题。主要解决的就是多维偏序的问题。 cdq分治详解二维偏序二维偏序其实并不用cdq分治，只用一维排序然后bit维护一下即可。二维数点其实本质也是拆成了四个二维偏序来统计的，静态的二维排序是非常简单的，但是可能会有动态的二维偏序问题，这里先提一下，后面三维偏序的时候再说。 三维偏序三维偏序是教科书般的cdq分治解决的问题。考虑对于其中任意一维排好序，对第二纬采取类似归并排序的方法，先处理各自两边的贡献，然后两边都已经分别排好序了，我们将它们按照第二维的顺序合并起来。（这里合并过程中第一维可能就不满足顺序关系了，但是不影响，因为这样一定保证如果满足偏序关系的元素之间归并后一定还满足偏序关系，原因是右边的第一维一定比左边的大，而归并过程中保证了第二维满足偏序关系，所以归并前若满足偏序关系，归并后一定还满足）。如果在左边，我们将它的第三纬加入bit中，如果在右边，我们算左半边对该点的贡献（bit中的某个前缀和），这样边归并边统计答案，非常类似于利用归并排序统计逆序对个数的过程。 这里有个三维偏序的裸题，具体代码见里面：陌上花开代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include&lt;bits/stdc++.h&gt;using namespace std; typedef long long ll;typedef double db;typedef pair&lt;int, int&gt; pii;typedef vector&lt;int&gt; vi;typedef vector&lt;ll&gt; vl;typedef vector&lt;pii&gt; vp;const int inf = 1e9;const ll INF = 1e18;const db eps = 1e-10; #define fi first#define se second#define pb push_back#define eb emplace_back#define ep emplace#define mem(a) memset(a, 0, sizeof(a))#define copy(a, b) memcpy(a, b, sizeof(b))#define PA cout &lt;&lt; "pass\n"#define lowbit(x) (x &amp; -x)#define all(x) x.begin(), x.end()#define TM cout &lt;&lt; db(clock()) / CLOCKS_PER_SEC &lt;&lt; '\n' const int maxn = 2e5 + 233;struct node&#123; int x, y, z, w, s; bool operator &lt;(const node &amp;r) const&#123; return x &lt; r.x || (x == r.x &amp;&amp; y &lt; r.y) || (x == r.x &amp;&amp; y == r.y &amp;&amp; z &lt; r.z); &#125; bool operator != (const node &amp;r) const&#123; return x != r.x || y != r.y || z != r.z; &#125;&#125;a[maxn], tmp[maxn]; int n, k;int c[maxn]; void add(int x, int d)&#123; while(x &lt; maxn)&#123; c[x] += d; x += lowbit(x); &#125;&#125; int query(int x)&#123; int ret = 0; while(x)&#123; ret += c[x]; x -= lowbit(x); &#125; return ret;&#125; void cdq(int l, int r)&#123; if(l == r) return; int mid = l + r &gt;&gt; 1; cdq(l, mid); cdq(mid + 1, r); int pl = l, pr = mid + 1, tot = l; while(pl &lt;= mid &amp;&amp; pr &lt;= r)&#123; if(a[pl].y &lt;= a[pr].y) add(a[pl].z, a[pl].w), tmp[tot++] = a[pl++]; else tmp[tot] = a[pr], tmp[tot++].s += query(a[pr++].z); &#125; while(pl &lt;= mid) add(a[pl].z, a[pl].w), tmp[tot++] = a[pl++]; while(pr &lt;= r) tmp[tot] = a[pr], tmp[tot++].s += query(a[pr++].z); for(int i = l; i &lt;= mid; i++) add(a[i].z, -a[i].w); for(int i = l; i &lt;= r; i++) a[i] = tmp[i];&#125; int res[maxn]; int main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); cin &gt;&gt; n &gt;&gt; k; for (int i = 1; i &lt;= n; ++i) &#123; cin &gt;&gt; a[i].x &gt;&gt; a[i].y &gt;&gt; a[i].z; &#125; sort(a + 1, a + n + 1); int len = 0; a[0].x = -inf; for(int i = 1; i &lt;= n; i++)&#123; if(a[i] != a[i - 1]) a[++len] = a[i]; a[len].w++; &#125; cdq(1, len); for(int i = 1; i &lt;= len; i++)&#123; res[a[i].s + a[i].w - 1] += a[i].w; &#125; for(int i = 0; i &lt; n; i++)&#123; cout &lt;&lt; res[i] &lt;&lt; '\n'; &#125; return 0;&#125; 更高维的偏序更高维的偏序如果采用cdq的方法，就需要嵌套了，每高一层就需要嵌套一层，复杂度就会多一个log，这里就不多讲了没什么实际的意义，但有个四维偏序的题目cdq套cdq之后可以补一下。 还有一种方法是利用bitset来解决高维偏序，题目:Scores 假设是k纬的，复杂度是O(\frac{kn^2}{w})我们需要用bitset维护每一纬前i小的并集是多少，这空间是O(n^2)的，基本就mle或者tle了，这里还得用一下分块。考虑每一纬维护sqrt(n)个块，假设是第k个块，表示前k个块的总的并集是某个集合。这样我们查询的时候直接二分到某个点，根据它在哪个块，然后剩下元素暴力更新即可，即可通过这个题。代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef double db;typedef pair&lt;int, int&gt; pii;typedef vector&lt;int&gt; vi;typedef vector&lt;ll&gt; vl;typedef vector&lt;pii&gt; vp;const int inf = 1e9;const ll INF = 1e18;const db eps = 1e-10;#define fi first#define se second#define pb push_back#define eb emplace_back#define ep emplace#define mem(a) memset(a, 0, sizeof(a))#define copy(a, b) memcpy(a, b, sizeof(b))#define PA cout &lt;&lt; "pass\n"#define lowbit(x) (x &amp; -x)#define all(x) x.begin(), x.end()#define TM cout &lt;&lt; db(clock()) / CLOCKS_PER_SEC &lt;&lt; '\n'const int sz = 230;const int maxn = 50010;bitset&lt;maxn&gt; mp[5][sz + 10];int T, n, m, q;int a[5][maxn];int b[maxn];int ord[5][maxn];bool cmp(int x, int y)&#123; return b[x] &lt; b[y];&#125;bitset&lt;maxn&gt; all;inline int read() &#123; int s = 0, w = 1; char ch = getchar(); while (ch &lt; '0' || ch &gt; '9') &#123; if (ch == '-')w = -1; ch = getchar(); &#125; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') s = s * 10 + ch - '0', ch = getchar(); return s * w;&#125;int main()&#123; T = read(); while(T--)&#123; for(int i = 0; i &lt; 5; i++)&#123; for(int j = 1; j &lt;= sz; j++)&#123; mp[i][j].reset(); &#125; &#125; cin &gt;&gt; n &gt;&gt; m; for(int i = 1; i &lt;= n; i++)&#123; for(int j = 0; j &lt; 5; j++)&#123; a[j][i] = read(); ord[j][i] = i; &#125; &#125; for(int i = 0; i &lt; 5; i++)&#123; for(int j = 1; j &lt;= n; j++) b[j] = a[i][j]; sort(ord[i] + 1, ord[i] + n + 1, cmp); &#125; for(int i = 0; i &lt; 5; i++)&#123; for(int j = 1; j &lt;= sz; j++)&#123; mp[i][j] |= mp[i][j - 1]; for(int k = 1; k &lt;= sz &amp;&amp; k + (j - 1) * sz &lt;= n; k++)&#123; int now = ord[i][(j - 1) * sz + k]; mp[i][j][now] = 1; &#125; &#125; &#125; all.reset(); for(int i = 1; i &lt;= n; i++) all[i] = 1; cin &gt;&gt; q; int last = 0; while(q--)&#123; int t[5]; for(int i = 0; i &lt; 5; i++) t[i] = read(), t[i] ^= last; bitset&lt;maxn&gt; res = all; for(int i = 0; i &lt; 5; i++)&#123; int lb = 1, ub = n, ans = 0; while(ub &gt;= lb)&#123; int mid = ub + lb &gt;&gt; 1; if(a[i][ord[i][mid]] &lt;= t[i]) lb = mid + 1, ans = mid; else ub = mid - 1; &#125; if(!ans) &#123; res.reset(); break; &#125; int block = ans / sz; int le = ans % sz; bitset&lt;maxn&gt; tmp = mp[i][block]; for(int j = 1; j &lt;= le; j++)&#123; int now = ord[i][block * sz + j]; tmp[now] = 1; &#125; res &amp;= tmp; &#125; printf("%d\n", last = res.count()); &#125; &#125; return 0;&#125; 广义多维偏序这里还是主要讲三维偏序。其实很多时候我们并不是要统计三维偏序的数目是多少，更广义的情况是，我们可以将某个问题转换为，当前点的答案只跟它在某维偏序下比它小的操作有关。可能这句话听着有点绕，我们拿最简单的，也是前面提到的二维数点问题来解释。 假设二维数点现在可以带修改了（事实上就是一个三维偏序问题了，因为时间也算做一个维度了），我们根据差分可以知道，一个矩形可以拆成四个二维空间上前缀的加减，每一个前缀都只和它在二维偏序下严格小于它的操作有关（这里我们需要把每个点看成插入进去，修改的话看成删除后再插入一个新值），所以只要问题模型能够转换为最终答案只跟多维偏序下的操作有关，我们就可以用cdq分治来解决这个问题。 再回到带修改的二维数点问题上，我们将操作顺序排好，默认时间t已经排好了序，然后用cdq解决剩下两维的偏序问题，如果修改就是将它之前的值删除，再重新插入一个新值，这样带修改二维数点就很简单解决了。 优化dp的转移如果dp的过程中是在某维偏序下有关（比如三维偏序下的和，以及取最值之类的操作），那么就可以用cdq分治来优化转移，但是跟普通的cdq分治顺序有所不一样，我们来分析一下。 我们希望把一个点作为已经算好的点拿去更新其他点的前提是，它已经是最终答案了，不会再有其他还没有结束的点再来更新它了，在偏序下的意思就是偏序比它小的都已经更新完了。我们考虑原来的cdq分治，我们是先处理两边再归并上来处理，归并的时候再考虑左边对右边的贡献。但考虑左边既然对右边有贡献，先处理右边的话明显不对，右边的某些点会拿去更新其它点，但明显它们自己还没有更新完。所以我们考虑调整顺序：1、处理左边2、将右边按第二维排序3、处理左边对右边的贡献4、将右边按第一维进行排序5、处理右边6、归并第四步一定不要忘了，第一次写这个就是忘了第四步，因为你第二步已经打乱了第一维的顺序，直接处理右边第一维不是默认有序的。例如这个题目：bzoj-4553(序列)分析一下dp就可以发现可以转换成二维平面上的一个前缀的max问题（因为还有时间这一维，所以就是三维偏序），就可以用cdq分治来优化dp的转移了。代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142#include&lt;bits/stdc++.h&gt;using namespace std; typedef long long ll;typedef double db;typedef pair&lt;int, int&gt; pii;typedef vector&lt;int&gt; vi;typedef vector&lt;ll&gt; vl;typedef vector&lt;pii&gt; vp;const int inf = 1e9;const ll INF = 1e18;const db eps = 1e-10; #define fi first#define se second#define pb push_back#define eb emplace_back#define ep emplace#define mem(a) memset(a, 0, sizeof(a))#define copy(a, b) memcpy(a, b, sizeof(b))#define PA cout &lt;&lt; "pass\n"#define lowbit(x) (x &amp; -x)#define all(x) x.begin(), x.end()#define TM cout &lt;&lt; db(clock()) / CLOCKS_PER_SEC &lt;&lt; '\n' const int maxn = 1e5 + 233; struct node&#123; int op, x, y, t, id; bool operator &lt;(const node &amp;r) const&#123; return x &lt; r.x; &#125;&#125;a[maxn * 10], tmp[maxn * 10]; bool cmp(node a, node b)&#123; return a.t &lt; b.t;&#125; int f[maxn], n, m;int c[maxn]; void add(int x, int d)&#123; while(x &lt; maxn)&#123; c[x] = max(c[x], d); x += lowbit(x); &#125;&#125; void del(int x)&#123; while(x &lt; maxn)&#123; c[x] = 0; x += lowbit(x); &#125;&#125; int query(int x)&#123; int ret = 0; while(x)&#123; ret = max(ret, c[x]); x -= lowbit(x); &#125; return ret;&#125; void cdq(int l, int r)&#123; if(l == r) return; int mid = l + r &gt;&gt; 1; cdq(l, mid); sort(a + mid + 1, a + r + 1); int pl = l, pr = mid + 1, tot = l; while(pl &lt;= mid &amp;&amp; pr &lt;= r)&#123; if(a[pl].x &lt;= a[pr].x) &#123; if(!a[pl].op) add(a[pl].y, f[a[pl].id]); tmp[tot++] = a[pl++]; &#125; else &#123; if(a[pr].op) f[a[pr].id] = max(f[a[pr].id], query(a[pr].y) + 1); tmp[tot++] = a[pr++]; &#125; &#125; while(pl &lt;= mid)&#123; if(!a[pl].op) add(a[pl].y, f[a[pl].id]); tmp[tot++] = a[pl++]; &#125; while(pr &lt;= r) &#123; if(a[pr].op) f[a[pr].id] = max(f[a[pr].id], query(a[pr].y) + 1); tmp[tot++] = a[pr++]; &#125; for(int i = l; i &lt;= mid; i++) if(!a[i].op) del(a[i].y); sort(a + mid + 1, a + r + 1, cmp); cdq(mid + 1, r); pl = l, pr = mid + 1, tot = l; while(pl &lt;= mid &amp;&amp; pr &lt;= r)&#123; if(a[pl].x &lt;= a[pr].x) tmp[tot++] = a[pl++]; else tmp[tot++] = a[pr++]; &#125; while(pl &lt;= mid)tmp[tot++] = a[pl++]; while(pr &lt;= r) tmp[tot++] = a[pr++]; for(int i = l; i &lt;= r; i++) a[i] = tmp[i];&#125; int mx[maxn], mn[maxn];int b[maxn]; int main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); cin &gt;&gt; n &gt;&gt; m; int cnt = 0; for(int i = 1; i &lt;= n; i++)&#123; f[i] = 1; cin &gt;&gt; b[i]; mn[i] = b[i]; mx[i] = b[i]; &#125; for(int i = 1; i &lt;= m; i++)&#123; int x, y; cin &gt;&gt; x &gt;&gt; y; mx[x] = max(mx[x], y); mn[x] = min(mn[x], y); &#125; int num = 0; a[++cnt] = &#123;0, 1, 1, ++num, 0&#125;; for(int i = 1; i &lt;= n; i++)&#123; a[++cnt] = node&#123;1, mn[i], b[i], ++num, i&#125;; a[++cnt] = node&#123;0, b[i], mx[i], ++num, i&#125;; &#125; cdq(1, cnt); int res = 0; for(int i = 1; i &lt;= n; i++) res = max(res, f[i]); cout &lt;&lt; res &lt;&lt; '\n'; return 0;&#125; cdq分治一些题目1、陌上花开见上2、bzoj-1935(Tree 园丁的烦恼)静态二维数点，可不用cdq，不过学习cdq时候还是用cdq写写练手。代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108#include&lt;bits/stdc++.h&gt;using namespace std; typedef long long ll;typedef double db;typedef pair&lt;int, int&gt; pii;typedef vector&lt;int&gt; vi;typedef vector&lt;ll&gt; vl;typedef vector&lt;pii&gt; vp;const int inf = 1e9;const ll INF = 1e18;const db eps = 1e-10; #define fi first#define se second#define pb push_back#define eb emplace_back#define ep emplace#define mem(a) memset(a, 0, sizeof(a))#define copy(a, b) memcpy(a, b, sizeof(b))#define PA cout &lt;&lt; "pass\n"#define lowbit(x) (x &amp; -x)#define all(x) x.begin(), x.end()#define TM cout &lt;&lt; db(clock()) / CLOCKS_PER_SEC &lt;&lt; '\n' const int maxn = 3e6 + 233; struct node&#123; int op, x, y, c, id; bool operator &lt;(const node &amp;r) const&#123; return x == r.x ? op &lt; r.op : x &lt; r.x; &#125;&#125;a[maxn], tmp[maxn]; int c[maxn * 5]; void add(int x, int d)&#123; while(x &lt; maxn * 5)&#123; c[x] += d; x += lowbit(x); &#125;&#125; int query(int x)&#123; int ret = 0; while(x)&#123; ret += c[x]; x -= lowbit(x); &#125; return ret;&#125; int res[maxn]; void cdq(int l, int r)&#123; if(l == r) return; int mid = l + r &gt;&gt; 1; cdq(l, mid); cdq(mid + 1, r); int pl = l, pr = mid + 1, tot = l; while(pl &lt;= mid &amp;&amp; pr &lt;= r)&#123; if(a[pl].x &lt;= a[pr].x)&#123; if(!a[pl].op) add(a[pl].y, a[pl].c); tmp[tot++] = a[pl++]; &#125; else&#123; if(a[pr].op) res[a[pr].id] += a[pr].c * query(a[pr].y); tmp[tot++] = a[pr++]; &#125; &#125; while(pl &lt;= mid) &#123; if(!a[pl].op) add(a[pl].y, a[pl].c); tmp[tot++] = a[pl++]; &#125; while(pr &lt;= r)&#123; if(a[pr].op) res[a[pr].id] += a[pr].c * query(a[pr].y); tmp[tot++] = a[pr++]; &#125; for(int i = l; i &lt;= mid; i++) if(!a[i].op) add(a[i].y, -a[i].c); for(int i = l; i &lt;= r; i++) a[i] = tmp[i];&#125; int n, m; int main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); cin &gt;&gt; n &gt;&gt; m; int cnt = 0; for(int i = 1; i &lt;= n; i++)&#123; int x, y; cin &gt;&gt; x &gt;&gt; y; x++, y++; a[++cnt] = node&#123;0, x, y, 1, i&#125;; &#125; for(int i = 1; i &lt;= m; i++)&#123; int x1, y1, x2, y2; cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2; x1++, y1++, x2++, y2++; a[++cnt] = node&#123;1, x1 - 1, y1 - 1, 1, i&#125;; a[++cnt] = node&#123;1, x2, y1 - 1, -1, i&#125;; a[++cnt] = node&#123;1, x1 - 1, y2, -1, i&#125;; a[++cnt] = node&#123;1, x2, y2, 1, i&#125;; &#125; cdq(1, cnt); for(int i = 1; i &lt;= m; i++) cout &lt;&lt; res[i] &lt;&lt; '\n'; return 0;&#125; 3、bzoj-3295(动态逆序对)考虑将时间作为一维，并且默认排好序，我们只用维护二维的带修改的操作，本质跟二维带修改的数点一样，我们只用首先将所有点插入并且过程中动态维护各个点插入时的逆序对贡献到0处，然后对于每一个删除我们都能找到它的贡献，依次放到1-m处，最后求一个前缀和就可以了。抄着板子写写写完发现过不了样例，怀疑人生，怀疑cdq是不是不能解决这个问题。然后冷静思考发现了一个问题，求逆序对的偏序是两部分：当x &lt; nowx，你需要求y &gt; nowy的部分，当x &gt; nowx，你需要求y &lt; nowy的部分，于是懒得改，cdq复制了一遍，正着求一次左上角的偏序反着求一次右下角的偏序就对了，但是代码就很难看，可以合到一起写的代码量瞬间少一大半。代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151#include&lt;bits/stdc++.h&gt;using namespace std; typedef long long ll;typedef double db;typedef pair&lt;int, int&gt; pii;typedef vector&lt;int&gt; vi;typedef vector&lt;ll&gt; vl;typedef vector&lt;pii&gt; vp;const int inf = 1e9;const ll INF = 1e18;const db eps = 1e-10; #define fi first#define se second#define pb push_back#define eb emplace_back#define ep emplace#define mem(a) memset(a, 0, sizeof(a))#define copy(a, b) memcpy(a, b, sizeof(b))#define PA cout &lt;&lt; "pass\n"#define lowbit(x) (x &amp; -x)#define all(x) x.begin(), x.end()#define TM cout &lt;&lt; db(clock()) / CLOCKS_PER_SEC &lt;&lt; '\n' const int maxn = 1e6 + 233; int c[maxn]; void add(int x, int d)&#123; while(x &lt; maxn)&#123; c[x] += d; x += lowbit(x); &#125;&#125; int query(int x)&#123; int ret = 0; while(x)&#123; ret += c[x]; x -= lowbit(x); &#125; return ret;&#125; struct node&#123; int op, x, y, c, id;&#125;a[maxn], tmp[maxn]; ll res[maxn];int n, m; void cdq1(int l, int r)&#123; if(l == r) return; int mid = l + r &gt;&gt; 1; cdq1(l, mid); cdq1(mid + 1, r); int pl = l, pr = mid + 1, tot = l; while(pl &lt;= mid &amp;&amp; pr &lt;= r)&#123; if(a[pl].x &gt;= a[pr].x)&#123; if(!a[pl].op) add(a[pl].y, a[pl].c); tmp[tot++] = a[pl++]; &#125; else&#123; if(a[pr].op) &#123; res[a[pr].id] += a[pr].c * query(a[pr].y - 1); &#125; tmp[tot++] = a[pr++]; &#125; &#125; while(pl &lt;= mid)&#123; if(!a[pl].op) add(a[pl].y, a[pl].c); tmp[tot++] = a[pl++]; &#125; while(pr &lt;= r)&#123; if(a[pr].op) &#123; res[a[pr].id] += a[pr].c * query(a[pr].y - 1); &#125; tmp[tot++] = a[pr++]; &#125; for(int i = l; i &lt;= mid; i++) if(!a[i].op) add(a[i].y, -a[i].c); for(int i = l; i &lt;= r; i++) a[i] = tmp[i];&#125; void cdq2(int l, int r)&#123; if(l == r) return; int mid = l + r &gt;&gt; 1; cdq2(l, mid); cdq2(mid + 1, r); int pl = l, pr = mid + 1, tot = l; while(pl &lt;= mid &amp;&amp; pr &lt;= r)&#123; if(a[pl].x &lt;= a[pr].x)&#123; if(!a[pl].op) add(a[pl].y, a[pl].c); tmp[tot++] = a[pl++]; &#125; else&#123; if(a[pr].op) &#123; res[a[pr].id] += a[pr].c * (query(n) - query(a[pr].y)); &#125; tmp[tot++] = a[pr++]; &#125; &#125; while(pl &lt;= mid)&#123; if(!a[pl].op) add(a[pl].y, a[pl].c); tmp[tot++] = a[pl++]; &#125; while(pr &lt;= r)&#123; if(a[pr].op) &#123; res[a[pr].id] += a[pr].c * (query(n) - query(a[pr].y)); &#125; tmp[tot++] = a[pr++]; &#125; for(int i = l; i &lt;= mid; i++) if(!a[i].op) add(a[i].y, -a[i].c); for(int i = l; i &lt;= r; i++) a[i] = tmp[i];&#125; int pos[maxn];int x[maxn], y[maxn]; int main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); cin &gt;&gt; n &gt;&gt; m; int cnt = 0; for(int i = 1; i &lt;= n; i++)&#123; cin &gt;&gt; x[i]; pos[x[i]] = i; a[++cnt] = node&#123;0, i, x[i], 1, 0&#125;; a[++cnt] = node&#123;1, i, x[i], 1, 0&#125;; &#125; for(int i = 1; i &lt;= m; i++)&#123; cin &gt;&gt; y[i]; a[++cnt] = node&#123;0, pos[y[i]], y[i], -1, i&#125;; a[++cnt] = node&#123;1, pos[y[i]], y[i], -1, i&#125;; &#125; cdq1(1, cnt); cnt = 0; for(int i = 1; i &lt;= n; i++)&#123; pos[x[i]] = i; a[++cnt] = node&#123;0, i, x[i], 1, 0&#125;; a[++cnt] = node&#123;1, i, x[i], 1, 0&#125;; &#125; for(int i = 1; i &lt;= m; i++)&#123; a[++cnt] = node&#123;0, pos[y[i]], y[i], -1, i&#125;; a[++cnt] = node&#123;1, pos[y[i]], y[i], -1, i&#125;; &#125; cdq2(1, cnt); for(int i = 1; i &lt;= m; i++) res[i] += res[i - 1]; for(int i = 0; i &lt; m; i++) cout &lt;&lt; res[i] &lt;&lt; '\n'; return 0;&#125; 4、2019-ICPC-Asia-Nanjing-Onsite-F-Paper-Grading见那边吧。。。。 还有很多新奇的姿势后面学到了再补吧。。]]></content>
      <categories>
        <category>cdq分治</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[luogu-P3527(MET-Meteors)]]></title>
    <url>%2F2020%2F01%2F26%2Fluogu-P3527-MET-Meteors%2F</url>
    <content type="text"><![CDATA[链接：https://www.luogu.com.cn/problem/P3527思路：这个题有些细节对理解整体二分挺有好处的：1.首先对于环的情况，如果x &lt;= y就是正常区间更新，否则拆成两段即可。2.这里二分的是时间t，我们把所有的询问放在更新后面（即所有陨石后面），考虑整体二分的过程，我们是对于[L, R]的序列操作是有序的，而我们希望的是将所有插入都做完后再进行询问，我们的板子写法是可以边询问边插入的，所以我们这里要将询问放在所有更新的后面。3.我们需要在最后放一个inf的对于所有轨道的陨石，考虑整体二分的过程，如果入口是[1, k]的陨石，那么最后每个点的答案一定也会落到[1, k]以内，因为一直得不到满足所以一定会分到最后面去，那么就无法区分真正能在k满足和不能满足的了，所以我们需要多增加一个k + 1的点，用来区分那些不能满足的。4.学到一个新技巧，如果是区间更新，但是只要单点查询的话，我们可以用一个bit来维护，考虑维护某个点的更新的差分序列，假设是[x, y]内更新z，我们在x处 +z，y + 1处-z，最后查询的时候查某个处的前缀和 + 原来的值就是更新后的值了，但只适用于单点查询。代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef double db;typedef pair&lt;int, int&gt; pii;typedef vector&lt;int&gt; vi;typedef vector&lt;ll&gt; vl;typedef vector&lt;pii&gt; vp;const int inf = 1e9;const ll INF = 1e18;const db eps = 1e-10;#define fi first#define se second#define pb push_back#define eb emplace_back#define ep emplace#define mem(a) memset(a, 0, sizeof(a))#define copy(a, b) memcpy(a, b, sizeof(b))#define PA cout &lt;&lt; "pass\n"#define lowbit(x) (x &amp; -x)#define all(x) x.begin(), x.end()#define TM cout &lt;&lt; db(clock()) / CLOCKS_PER_SEC &lt;&lt; '\n'const int maxn = 3e5 + 233;struct node&#123; int op, x, y, v, pos;&#125;q[maxn * 2], q1[maxn * 2], q2[maxn * 2];int res[300005];ll c[maxn];inline void add(int x, int d)&#123; while(x &lt; maxn)&#123; c[x] += d; x += lowbit(x); &#125;&#125;inline void update(int l, int r, int d)&#123; add(l, d); add(r + 1, -d);&#125;ll query(int x)&#123; ll ret = 0; while(x)&#123; ret += c[x]; x -= lowbit(x); &#125; return ret;&#125;int n, m, k;vi id[300005];inline void solve(int l, int r, int L, int R)&#123; if(l &gt; r || L &gt; R) return; if(l == r)&#123; for(int i = L; i &lt;= R; i++)&#123; if(q[i].op) res[q[i].pos] = l; &#125; return; &#125; int mid = l + r &gt;&gt; 1, cnt1 = 0, cnt2 = 0; for(int i = L; i &lt;= R; i++)&#123; if(q[i].op)&#123; ll tmp = 0; for(auto &amp;v : id[q[i].pos]) &#123; tmp += query(v); if(tmp &gt;= q[i].v) break; &#125; if(q[i].v &lt;= tmp) q1[++cnt1] = q[i]; else q[i].v -= tmp, q2[++cnt2] = q[i]; &#125; else&#123; if(q[i].pos &lt;= mid) &#123; if(q[i].x &lt;= q[i].y) update(q[i].x, q[i].y, q[i].v); else add(q[i].x,q[i].v),add(1,q[i].v),add(q[i].y+1,-q[i].v); q1[++cnt1] = q[i]; &#125; else q2[++cnt2] = q[i]; &#125; &#125; for(int i = 1; i &lt;= cnt1; i++) &#123; if(!q1[i].op) &#123; if(q1[i].x &lt;= q1[i].y) update(q1[i].x, q1[i].y, -q1[i].v); else add(q1[i].x, -q1[i].v),add(1,-q1[i].v),add(q1[i].y+1,q1[i].v); &#125; &#125; for(int i = 1; i &lt;= cnt1; i++) q[L + i - 1] = q1[i]; for(int i = 1; i &lt;= cnt2; i++) q[L + i + cnt1 - 1] = q2[i]; solve(l, mid, L, L + cnt1 - 1); solve(mid + 1, r, L + cnt1, R);&#125;int p[300005];inline int read() &#123; int s = 0, w = 1; char ch = getchar(); while (ch &lt; '0' || ch &gt; '9') &#123; if (ch == '-')w = -1; ch = getchar(); &#125; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') s = s * 10 + ch - '0', ch = getchar(); return s * w;&#125;int main()&#123; n = read(); m = read(); int cnt = 0; for(int i = 1; i &lt;= m; i++)&#123; int x = read(); id[x].eb(i); &#125; for(int i = 1; i &lt;= n; i++)&#123; p[i] = read(); &#125; k = read(); for(int i = 1; i &lt;= k; i++)&#123; int x = read(), y = read(), z = read(); q[++cnt] = node&#123;0, x, y, z, i&#125;; &#125; q[++cnt] = node&#123;0, 1, m, inf, k + 1&#125;; for(int i = 1; i &lt;= n; i++)&#123; q[++cnt] = node&#123;1, 0, 0, p[i], i&#125;; &#125; solve(0, k + 1, 1, cnt); for(int i = 1; i &lt;= n; i++)&#123; if(res[i] == k + 1) puts("NIE"); else printf("%d\n", res[i]); &#125; return 0;&#125;]]></content>
      <categories>
        <category>整体二分</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[整体二分浅谈]]></title>
    <url>%2F2020%2F01%2F25%2F%E6%95%B4%E4%BD%93%E4%BA%8C%E5%88%86%E6%B5%85%E8%B0%88%2F</url>
    <content type="text"><![CDATA[家里蹲得无聊，趁机多学点新东西吧，好久前就看到这玩意，直接现在终于有机会看了。 整体二分概念整体二分讲的是个什么事情呢，我们考虑普通二分，二分一个值，然后我们去check它，对于单次询问可以非常容易解决。但如果有多组询问，我们对于每一个询问都来一次普通二分的话，复杂度就爆炸了。事实上考虑二分过程中有很多check操作是重复的，我们如果能把他们一起拿来二分，并且根据mid值将他们分为两组，一组到[l, mid]里面继续去check，一组到[mid + 1, r]里面继续去check，这样复杂度就被降下来了，这也是一个非常直观的想法，整体二分就是用来干这个的。 整体二分流程首先我们把操作分为插入操作和查询操作，我们假设原序列为空，所有的数都是需要插入进去的。查询操作就顾名思义了。 整体二分我们考虑递归来做，用四元组(l, r, L, R)表示对于二分值域[l, r]，要处理操作序列[L, R]的结果。注意这里对于L以前的操作一定都被处理过了，具体原因见后。 我们找到mid(mid = (l + r ) / 2)，我们查看序列[l, r]内所有操作，如果他是插入操作并且小于等于mid，我们把他分到左边，并且更新对应的值（bit/线段树/其他），否则我们把它分到右边。如果他是查询操作，我们看他是否达到要求（比如查询第k小就看是否已经大于第k小，根据情况分到左右两边去），最后我们就得到一个根据mid分出来的两个原来的操作序列。 分出来以后，记得得把之前用来分序列时候在bit/线段树/其他上的更新给撤销回来，然后根据分出来的序列重新排一下原来操作序列，并且递归到左右两边去做即可。这里我们发现更新完右边区间一定在左边区间后面处理，所以之前说的l以前的序列操作一定都已经处理过了。 当l == r的时候，我们对于[L, R]上的所有查询操作更新对应位置的答案即可。 一些例题1、可持久化线段树这个题可以用整体二分来做，最基本的模板题代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef double db;typedef pair&lt;int, int&gt; pii;typedef vector&lt;int&gt; vi;typedef vector&lt;ll&gt; vl;typedef vector&lt;pii&gt; vp;const int inf = 1e9;const ll INF = 1e18;const db eps = 1e-10;#define fi first#define se second#define pb push_back#define eb emplace_back#define ep emplace#define mem(a) memset(a, 0, sizeof(a))#define copy(a, b) memcpy(a, b, sizeof(b))#define PA cout &lt;&lt; "pass\n"#define lowbit(x) (x &amp; -x)#define all(x) x.begin(), x.end()#define TM cout &lt;&lt; db(clock()) / CLOCKS_PER_SEC &lt;&lt; '\n'const int maxn = 5e5 + 233;struct node&#123; int op, x, y, k, pos;&#125;q[maxn], ql[maxn], qr[maxn];int res[maxn];int c[maxn];void add(int x, int d)&#123; while(x &lt; maxn)&#123; c[x] += d; x += lowbit(x); &#125;&#125;int query(int x)&#123; int ret = 0; while(x)&#123; ret += c[x]; x -= lowbit(x); &#125; return ret;&#125;void solve(int l, int r, int L, int R)&#123; if(l &gt; r || L &gt; R) return; if(l == r)&#123; for(int i = L; i &lt;= R; i++)&#123; if(q[i].op) res[q[i].pos] = l; &#125; return; &#125; int mid = l + r &gt;&gt; 1, cnt1 = 0, cnt2 = 0; for(int i = L; i &lt;= R; i++)&#123; if(q[i].op)&#123; int tmp = query(q[i].y) - query(q[i].x - 1); if(tmp &gt;= q[i].k) ql[++cnt1] = q[i]; else q[i].k -= tmp, qr[++cnt2] = q[i]; &#125; else&#123; if(q[i].x &lt;= mid) ql[++cnt1] = q[i], add(q[i].pos, q[i].y); else qr[++cnt2] = q[i]; &#125; &#125; for(int i = 1; i &lt;= cnt1; i++) if(!ql[i].op) add(ql[i].pos, -ql[i].y); for(int i = 1; i &lt;= cnt1; i++) q[L + i - 1] = ql[i]; for(int i = 1; i &lt;= cnt2; i++) q[L + cnt1 + i - 1] = qr[i]; solve(l, mid, L, L + cnt1 - 1); solve(mid + 1, r, L + cnt1, R);&#125;int n, m;int main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); cin &gt;&gt; n &gt;&gt; m; int cnt = 0; for(int i = 1; i &lt;= n; i++) &#123; int x; cin &gt;&gt; x; q[++cnt] = node&#123;0, x, 1, 0, i&#125;; &#125; for(int i = 1; i &lt;= m; i++)&#123; int x, y, k; cin &gt;&gt; x &gt;&gt; y &gt;&gt; k; q[++cnt] = node&#123;1, x, y, k, i&#125;; &#125; solve(-inf, inf, 1, cnt); for (int i = 1; i &lt;= m; ++i) &#123; cout &lt;&lt; res[i] &lt;&lt; '\n'; &#125; return 0;&#125; 2、bzoj3110 k大数查询需要稍微转换一下，因为值域为[-n, n]，考虑把k大关于n对称一下变成n - val + 1，这样就变成了求第k小，最后求得答案ans时再通过res = n - ans + 1变换回来即可。因为操作是区间更新这里用线段树即可。代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114#include&lt;bits/stdc++.h&gt;using namespace std; typedef long long ll;typedef double db;typedef pair&lt;int, int&gt; pii;typedef vector&lt;int&gt; vi;typedef vector&lt;ll&gt; vl;typedef vector&lt;pii&gt; vp;const int inf = 1e9;const ll INF = 1e18;const db eps = 1e-10; #define fi first#define se second#define pb push_back#define eb emplace_back#define ep emplace#define mem(a) memset(a, 0, sizeof(a))#define copy(a, b) memcpy(a, b, sizeof(b))#define PA cout &lt;&lt; "pass\n"#define lowbit(x) (x &amp; -x)#define all(x) x.begin(), x.end()#define TM cout &lt;&lt; db(clock()) / CLOCKS_PER_SEC &lt;&lt; '\n' const int maxn = 1e5 + 233;ll sum[maxn &lt;&lt; 2], tag[maxn &lt;&lt; 2]; void pushup(int o)&#123; sum[o] = sum[o &lt;&lt; 1] + sum[o &lt;&lt; 1 | 1];&#125; void pushdown(int o, int m)&#123; if(tag[o])&#123; tag[o &lt;&lt; 1] += tag[o]; tag[o &lt;&lt; 1 | 1] += tag[o]; sum[o &lt;&lt; 1] += tag[o] * (m - (m &gt;&gt; 1)); sum[o &lt;&lt; 1 | 1] += tag[o] * (m &gt;&gt; 1); tag[o] = 0; &#125;&#125; void update(int o, int tl, int tr, int l, int r, int v)&#123; if(l &gt; tr || tl &gt; r) return; if(l &lt;= tl &amp;&amp; tr &lt;= r)&#123; sum[o] += 1ll * (tr - tl + 1) * v; tag[o] += v; return; &#125; pushdown(o, tr - tl + 1); int mid = tl + tr &gt;&gt; 1; update(o &lt;&lt; 1, tl, mid, l, r, v); update(o &lt;&lt; 1 | 1, mid + 1, tr, l, r, v); pushup(o);&#125; ll query(int o, int tl, int tr, int l, int r)&#123; if(l &gt; tr || tl &gt; r) return 0; if(l &lt;= tl &amp;&amp; tr &lt;= r) return sum[o]; pushdown(o, tr - tl + 1); int mid = tl + tr &gt;&gt; 1; return query(o &lt;&lt; 1, tl, mid, l, r) + query(o &lt;&lt; 1 | 1, mid + 1, tr, l, r);&#125; struct node&#123; ll op, x, y, k, pos;&#125;q[maxn], q1[maxn], q2[maxn]; ll res[maxn];int n, m; void solve(int l, int r, int L, int R)&#123; if(l &gt; r || L &gt; R) return; if(l == r)&#123; for(int i = L; i &lt;= R; i++)&#123; if(q[i].op) res[q[i].pos] = n - l + 1; &#125; return; &#125; int mid = l + r &gt;&gt; 1, cnt1 = 0, cnt2 = 0; for(int i = L; i &lt;= R; i++)&#123; if(q[i].op)&#123; ll tmp = query(1, 1, n, q[i].x, q[i].y); if(q[i].k &lt;= tmp) q1[++cnt1] = q[i]; else q[i].k -= tmp, q2[++cnt2] = q[i]; &#125; else&#123; if(q[i].k &lt;= mid) q1[++cnt1] = q[i], update(1, 1, n, q[i].x, q[i].y, 1); else q2[++cnt2] = q[i]; &#125; &#125; for(int i = 1; i &lt;= cnt1; i++) if(!q1[i].op) update(1, 1, n, q1[i].x, q1[i].y, -1); for(int i = 1; i &lt;= cnt1; i++) q[L + i - 1] = q1[i]; for(int i = 1; i &lt;= cnt2; i++) q[L + cnt1 + i - 1] = q2[i]; solve(l, mid, L, L + cnt1 - 1); solve(mid + 1, r, L + cnt1, R);&#125; int main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); cin &gt;&gt; n &gt;&gt; m; int tot = 0; for(int i = 1; i &lt;= m; i++)&#123; ll op, x, y, k; cin &gt;&gt; op &gt;&gt; x &gt;&gt; y &gt;&gt; k; if(op == 1) q[i] = node&#123;0, x, y, n - k + 1, i&#125;; else q[i] = node&#123;1, x, y, k, ++tot&#125;; &#125; solve(-n, n, 1, m); for (int i = 1; i &lt;= tot; ++i) &#123; cout &lt;&lt; res[i] &lt;&lt; '\n'; &#125; return 0;&#125; 3、[国家集训队]矩阵乘法这个题跟第一个差不多，只用把里面的树状数组换成二维的bit就行了，这里注意可以离散化后直接对下标二分，这样常数可以少好几倍。代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef double db;typedef pair&lt;int, int&gt; pii;typedef vector&lt;int&gt; vi;typedef vector&lt;ll&gt; vl;typedef vector&lt;pii&gt; vp;const int inf = 1e9;const ll INF = 1e18;const db eps = 1e-10;#define fi first#define se second#define pb push_back#define eb emplace_back#define ep emplace#define mem(a) memset(a, 0, sizeof(a))#define copy(a, b) memcpy(a, b, sizeof(b))#define PA cout &lt;&lt; "pass\n"#define lowbit(x) (x &amp; -x)#define all(x) x.begin(), x.end()#define TM cout &lt;&lt; db(clock()) / CLOCKS_PER_SEC &lt;&lt; '\n'const int maxn = 550;int c[maxn][maxn];void add(int x, int y, int d)&#123; for(int i = x; i &lt; maxn; i += lowbit(i))&#123; for(int j = y; j &lt; maxn; j += lowbit(j))&#123; c[i][j] += d; &#125; &#125;&#125;int sum(int x, int y)&#123; int ret = 0; for(int i = x; i; i -= lowbit(i))&#123; for(int j = y; j; j -= lowbit(j))&#123; ret += c[i][j]; &#125; &#125; return ret;&#125;int query(int x1, int y1, int x2, int y2)&#123; return sum(x2, y2) - sum(x1 - 1, y2) - sum(x2, y1 - 1) + sum(x1 - 1, y1 - 1);&#125;const int maxm = 1e6 + 233;struct node&#123; int op, x1, y1, x2, y2, k, pos;&#125;q[maxm], q1[maxm], q2[maxm];int n, m;int res[maxm];vi pos;void solve(int l, int r, int L, int R)&#123; if(l &gt; r || L &gt; R) return; if(l == r)&#123; for(int i = L; i &lt;= R; i++)&#123; if(q[i].op) res[q[i].pos] = pos[l]; &#125; return; &#125; int mid = l + r &gt;&gt; 1, cnt1 = 0, cnt2 = 0; for(int i = L; i &lt;= R; i++)&#123; if(q[i].op)&#123; int tmp = query(q[i].x1, q[i].y1, q[i].x2, q[i].y2); if(tmp &gt;= q[i].k) q1[++cnt1] = q[i]; else q[i].k -= tmp, q2[++cnt2] = q[i]; &#125; else&#123; if(q[i].x2 &lt;= pos[mid]) add(q[i].x1, q[i].y1, 1), q1[++cnt1] = q[i]; else q2[++cnt2] = q[i]; &#125; &#125; for(int i = 1; i &lt;= cnt1; i++) if(!q1[i].op) add(q1[i].x1, q1[i].y1, -1); for(int i = 1; i &lt;= cnt1; i++) q[L + i - 1] = q1[i]; for(int i = 1; i &lt;= cnt2; i++) q[L + i + cnt1 - 1] = q2[i]; solve(l, mid, L, L + cnt1 - 1); solve(mid + 1, r, L + cnt1, R);&#125;int main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); cin &gt;&gt; n &gt;&gt; m; int cnt = 0; for(int i = 1; i &lt;= n; i++)&#123; for(int j = 1; j &lt;= n; j++)&#123; int t; cin &gt;&gt; t; q[++cnt] = node&#123;0, i, j, t, 1, 0, 0&#125;; pos.eb(t); &#125; &#125; sort(all(pos)); pos.resize(unique(all(pos)) - pos.begin()); for(int i = 1; i &lt;= m; i++)&#123; int x1, y1, x2, y2, k; cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2 &gt;&gt; k; q[++cnt] = node&#123;1, x1, y1, x2, y2, k, i&#125;; &#125; solve(0, pos.size() - 1, 1, cnt); for (int i = 1; i &lt;= m; ++i) &#123; cout &lt;&lt; res[i] &lt;&lt; '\n'; &#125; return 0;&#125;]]></content>
      <categories>
        <category>整体二分</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2020 CCPC-Wannafly Winter Camp Day2 (Div.1&2)-F(采蘑菇的克拉莉丝)]]></title>
    <url>%2F2020%2F01%2F21%2F2020-CCPC-Wannafly-Winter-Camp-Day2-Div-1-2-F-%E9%87%87%E8%98%91%E8%8F%87%E7%9A%84%E5%85%8B%E6%8B%89%E8%8E%89%E4%B8%9D%2F</url>
    <content type="text"><![CDATA[链接：https://ac.nowcoder.com/acm/contest/4010/F思路：非常好的利用了轻重链的思想，一开始想法是，一个点更新后，对除了它到根节点这条链上的点以外，对其他点的贡献都是他们父亲那条边的权值 * x，但是这条链上的就非常不好办了。事实上这个题的做法就非常有启发性，因为我们没法同时维护多个儿子的贡献和（因为他们边权不一样），我们考虑只维护重儿子的，这样我们可以用dfs序建树状数组，对于重儿子的贡献我们直接查子树内修改了多少即可。对于轻儿子的贡献我们考虑暴力更新。那么当一个点修改后，我们一直跳链，只要他不是父亲的重儿子，我们把贡献更新到父亲上，一直跳到根节点为止，这个过程是O(logn)的，所以总复杂度是O(nlogn)代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef double db;typedef pair&lt;int, int&gt; pii;typedef vector&lt;int&gt; vi;typedef vector&lt;ll&gt; vl;typedef vector&lt;pii&gt; vp;const int inf = 1e9;const ll INF = 1e18;const db eps = 1e-10;#define fi first#define se second#define pb push_back#define eb emplace_back#define ep emplace#define mem(a) memset(a, 0, sizeof(a))#define copy(a, b) memcpy(a, b, sizeof(b))#define PA cout &lt;&lt; "pass\n"#define lowbit(x) (x &amp; -x)#define all(x) x.begin(), x.end()#define TM cout &lt;&lt; db(clock()) / CLOCKS_PER_SEC &lt;&lt; '\n'const int maxn = 1e6 + 233;int f[maxn], son[maxn], top[maxn], sz[maxn], d[maxn], rk[maxn], id[maxn], dfs_clock;vi G[maxn];int cost[maxn], out[maxn], w[maxn];ll c[maxn], cnt[maxn];struct edge&#123; int from, to, dist;&#125;;vector&lt;edge&gt; edges;void addedge(int from, int to, int dist)&#123; edges.push_back(edge&#123;from, to, dist&#125;); G[from].push_back(edges.size() - 1);&#125;int n, q;void dfs1(int u, int fa)&#123; f[u] = fa; d[u] = d[fa] + 1; sz[u] = 1; for(int i = 0; i &lt; G[u].size(); i++)&#123; int v = edges[G[u][i]].to; if(v == fa) continue; dfs1(v, u); cost[v] = edges[G[u][i]].dist; sz[u] += sz[v]; if(sz[v] &gt; sz[son[u]]) son[u] = v; &#125;&#125;void dfs2(int u, int t)&#123; top[u] = t; id[u] = ++dfs_clock; rk[dfs_clock] = u; if(son[u]) dfs2(son[u], t); for(int i = 0; i &lt; G[u].size(); i++)&#123; int v = edges[G[u][i]].to; if(v == son[u]) w[u] = edges[G[u][i]].dist; if(v != son[u] &amp;&amp; v != f[u]) dfs2(v, v); &#125; out[u] = dfs_clock;&#125;void add(int x, int d)&#123; while(x &lt; maxn)&#123; c[x] += d; x += lowbit(x); &#125;&#125;ll query(int x) &#123; ll ret = 0; while (x) &#123; ret += c[x]; x -= lowbit(x); &#125; return ret;&#125;inline int read() &#123; char ch = getchar(); int x = 0, f = 1; while(ch &lt; '0' || ch &gt; '9') &#123; if(ch == '-') f = -1; ch = getchar(); &#125; while('0' &lt;= ch &amp;&amp; ch &lt;= '9') &#123; x = x * 10 + ch - '0'; ch = getchar(); &#125; return x * f;&#125;int main() &#123; n = read(); for (int i = 1; i &lt; n; i++) &#123; int u = read(), v = read(), w = read(); addedge(u, v, w); addedge(v, u, w); &#125; dfs1(1, 0); dfs2(1, 1); q = read(); int now = 1; while (q--) &#123; int op, x, y; op = read(); x = read(); if (op == 1) &#123; y = read(); add(id[x], y); while (1) &#123; if (!x) break; int tmp = f[x]; if (son[tmp] != x) cnt[tmp] += 1ll * y * cost[x]; x = f[top[x]]; &#125; &#125; else &#123; now = x; &#125; ll t1 = 0; if (son[now]) t1 = 1ll * (query(out[son[now]]) - query(id[son[now]] - 1)) * w[now]; ll t2 = 1ll * cost[now] * (query(n) - (query(out[now]) - query(id[now] - 1))); printf("%lld\n", t1 + t2 + cnt[now]); &#125; return 0;&#125;]]></content>
      <categories>
        <category>树链剖分</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2020 CCPC-Wannafly Winter Camp Day2 (Div.1&2)-E(阔力梯的树)]]></title>
    <url>%2F2020%2F01%2F16%2F2020-CCPC-Wannafly-Winter-Camp-Day2-Div-1-2-E-%E9%98%94%E5%8A%9B%E6%A2%AF%E7%9A%84%E6%A0%91%2F</url>
    <content type="text"><![CDATA[链接：https://ac.nowcoder.com/acm/contest/4010/E思路：南昌深受伤害后果然看到这个题第一反应就是拿数据结构维护下dsu on tree，这里用个set就行了，如果可能出现一样的点就用multiset，然后讨论下插入时在开头，结尾和中间三种情况即可。代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef double db;typedef pair&lt;int, int&gt; pii;typedef vector&lt;int&gt; vi;typedef vector&lt;ll&gt; vl;typedef vector&lt;pii&gt; vp;const int inf = 1e9;const ll INF = 1e18;const db eps = 1e-10;#define fi first#define se second#define pb push_back#define eb emplace_back#define ep emplace#define mem(a) memset(a, 0, sizeof(a))#define copy(a, b) memcpy(a, b, sizeof(b))#define PA cout &lt;&lt; "pass\n"#define lowbit(x) (x &amp; -x)#define all(x) x.begin(), x.end()#define TM cout &lt;&lt; db(clock()) / CLOCKS_PER_SEC &lt;&lt; '\n'multiset&lt;int&gt; s;const int maxn = 1e5 + 233;vi G[maxn];int n;int son[maxn], sz[maxn];int a[maxn];ll res[maxn];ll ans;void getroot(int u)&#123; sz[u] = 1; for(auto &amp;v : G[u])&#123; getroot(v); sz[u] += sz[v]; if(sz[son[u]] &lt; sz[v]) son[u] = v; &#125;&#125;void getans(int u, bool op) &#123; if (op) &#123; auto it = s.lower_bound(a[u]); if (s.begin() == s.end()) &#123; &#125; else &#123; if (it == s.begin()) &#123; ans += 1ll * a[u] * a[u] + 1ll * (*it) * (*it) - 2ll * a[u] * (*it); &#125; if (it == s.end()) &#123; auto now = it--; ans += 1ll * a[u] * a[u] + 1ll * (*it) * (*it) - 2ll * a[u] * (*it); it = now; &#125; else if(it != s.begin() &amp;&amp; it != s.end()) &#123; ans += 2ll * a[u] * a[u]; auto now = it; it--; ans += 2ll * (*it) * (*now); ans -= 2ll * a[u] * (*it) + 2ll * a[u] * (*now); &#125; &#125; s.insert(a[u]); &#125; else&#123; s.erase(s.find(a[u])); auto it = s.lower_bound(a[u]); if (s.begin() == s.end()) &#123; &#125; else &#123; if (it == s.begin()) &#123; ans -= 1ll * a[u] * a[u] + 1ll * (*it) * (*it) - 2ll * a[u] * (*it); &#125; if (it == s.end()) &#123; auto now = it--; ans -= 1ll * a[u] * a[u] + 1ll * (*it) * (*it) - 2ll * a[u] * (*it); it = now; &#125; else if(it != s.begin() &amp;&amp; it != s.end()) &#123; ans -= 2ll * a[u] * a[u]; auto now = it; it--; ans -= 2ll * (*it) * (*now); ans += 2ll * a[u] * (*it) + 2ll * a[u] * (*now); &#125; &#125; &#125; for(auto &amp;v : G[u])&#123; getans(v, op); &#125;&#125;void dfs(int u, bool ok)&#123; for(auto &amp;v : G[u])&#123; if(v == son[u]) continue; dfs(v, 0); &#125; if(son[u])&#123; dfs(son[u], 1); &#125; for(auto &amp;v : G[u])&#123; if(v == son[u]) continue; getans(v, 1); &#125; auto it = s.lower_bound(a[u]); if (s.begin() == s.end()) &#123; &#125; else &#123; if (it == s.begin()) &#123; ans += 1ll * a[u] * a[u] + 1ll * (*it) * (*it) - 2ll * a[u] * (*it); &#125; if (it == s.end()) &#123; auto now = it; it--; ans += 1ll * a[u] * a[u] + 1ll * (*it) * (*it) - 2ll * a[u] * (*it); it = now; &#125; if(it != s.begin() &amp;&amp; it != s.end()) &#123; ans += 2ll * a[u] * a[u]; auto now = it; it--; ans += 2ll * (*it) * (*now); ans -= 2ll * a[u] * (*it) + 2ll * a[u] * (*now); &#125; &#125; s.insert(a[u]); res[u] = ans; if(!ok) getans(u, 0);&#125;int main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); cin &gt;&gt; n; for (int i = 1; i &lt;= n; ++i) &#123; a[i] = i; &#125; for(int i = 2; i &lt;= n; i++)&#123; int u; cin &gt;&gt; u; G[u].eb(i); &#125; getroot(1); dfs(1, 0); for(int i = 1; i &lt;= n; i++) cout &lt;&lt; res[i] &lt;&lt; '\n'; return 0;&#125;]]></content>
      <categories>
        <category>dsu on tree</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2020 CCPC-Wannafly Winter Camp Day2 (Div.1&2)-D(卡拉巴什的字符串)]]></title>
    <url>%2F2020%2F01%2F16%2F2020-CCPC-Wannafly-Winter-Camp-Day2-Div-1-2-D-%E5%8D%A1%E6%8B%89%E5%B7%B4%E4%BB%80%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[链接：https://ac.nowcoder.com/acm/contest/4010/D思路：考虑后缀自动机动态加字符，那么对于每个有子节点的点，说明这个节点代表的串一定有是某两个后缀串的公共后缀，考虑把期中某个延长到当前的加入节点，其实也就是两个后置的最长公共前缀，并且发现一个性质，后面再怎么加，这个点在SAM上的长度信息是不会改变的了。所以我们只需要在新建点的时候，只要他有子节点了，就把他的长度标记一下，然后看最短的没有标记过的长度是多少就行了。（注意点1因为是虚点，所以需要至少两个子节点才能成为两个串的前缀）。代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef double db;typedef pair&lt;int, int&gt; pii;typedef vector&lt;int&gt; vi;typedef vector&lt;ll&gt; vl;typedef vector&lt;pii&gt; vp;const int inf = 1e9;const ll INF = 1e18;const db eps = 1e-10;#define fi first#define se second#define pb push_back#define eb emplace_back#define ep emplace#define mem(a) memset(a, 0, sizeof(a))#define copy(a, b) memcpy(a, b, sizeof(b))#define PA cout &lt;&lt; "pass\n"#define lowbit(x) (x &amp; -x)#define all(x) x.begin(), x.end()#define TM cout &lt;&lt; db(clock()) / CLOCKS_PER_SEC &lt;&lt; '\n'#define sigma_size 28using namespace std;const int maxn = 1e6 + 5;int len[maxn * 2]; //最长子串的长度(该节点字串数量=len[x]-len[f[x]])int f[maxn * 2]; //后缀链接(最短串前部减少一个字符所到达的状态)int cnt[maxn * 2]; //被后缀连接的数int ch[maxn * 2][sigma_size]; //状态转移(尾部加一个字符的下一个状态)(图)int idx; //节点编号int last; //最后节点ll epos[maxn * 2]; // enpos数（该状态子串出现数量）char s[maxn];bool vis[maxn * 2];int tmp;void init() &#123; //初始化 last = idx = 1; //1表示root起始点 空集 f[1] = len[1] = 0; memset(ch[1], 0, sizeof(ch[1]));&#125;//SAM建图void add(int c) &#123; //插入字符，为字符ascll码值 int x = ++idx; //创建一个新节点x; len[x] = len[last] + 1; // 长度等于最后一个节点+1 epos[x] = 1; //接受节点子串除后缀连接还需加一 int p; //第一个有C转移的节点; for (p = last; p &amp;&amp; !ch[p][c]; p = f[p])ch[p][c] = x;//沿着后缀连接 将所有没有字符c转移的节点直接指向新节点 if (!p)f[x] = 1, cnt[1]++; //全部都没有c的转移 直接将新节点后缀连接到起点 else &#123; int q = ch[p][c]; //p通过c转移到的节点 if (len[p] + 1 == len[q]) //pq是连续的 f[x] = q, cnt[q]++; //将新节点后缀连接指向q即可,q节点的被后缀连接数+1 else &#123; int nq = ++idx; //不连续 需要复制一份q节点 len[nq] = len[p] + 1; //令nq与p连续 f[nq] = f[q]; //因后面link[q]改变此处不加cnt vis[len[nq]] = 1; memcpy(ch[nq], ch[q], sizeof(ch[q])); //复制q的信息给nq for (; p &amp;&amp; ch[p][c] == q; p = f[p]) ch[p][c] = nq; //沿着后缀连接 将所有通过c转移为q的改为nq f[q] = f[x] = nq; //将x和q后缀连接改为nq cnt[nq] += 2; // nq增加两个后缀连接 &#125; &#125; last = x; //更新最后处理的节点 if(f[x] != 1) vis[len[f[x]]] = 1; if(f[x] == 1) tmp++; if(tmp &gt; 1) vis[0] = 1;&#125;int T, n;int main() &#123; scanf("%d", &amp;T); while(T--)&#123; scanf("%s", s + 1); for(int i = 0; i &lt;= idx; i++)&#123; f[i] = len[i] = vis[i] = 0; mem(ch[i]); &#125; tmp = 0; init(); n = strlen(s + 1); int res = 0; for(int i = 1; i &lt;= n; i++)&#123; add(s[i] - 'a'); while(vis[res]) res++; printf("%d%c", res, i == n ? '\n' : ' '); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>后缀自动机</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2020 CCPC-Wannafly Winter Camp Day2 (Div.1&2)-B(萨博的方程式)]]></title>
    <url>%2F2020%2F01%2F16%2F2020-CCPC-Wannafly-Winter-Camp-Day2-Div-1-2-B-%E8%90%A8%E5%8D%9A%E7%9A%84%E6%96%B9%E7%A8%8B%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[链接：https://ac.nowcoder.com/acm/contest/4010/B思路：考虑从高到低位枚举，假设前面都贴着边界，那么该位所有本来上限为0的地方只能填0，上限为1的地方可以填0和1，我们发现如果填0，其他位可以按满足限制随便填，这样这一位一定能确定一个唯一解。如果有多个填0，那么有一个用来确定唯一解，其他都可以随便填。如果填1，后面可以按限制随便填，那么这里的这个过程我们可以用dp来计数。考虑如果所有的本来为1的位置都填了1，就得枚举下一位了，发现是一个子问题，同样方法计算即可。最后把和k在这一位奇偶相同的地方求和就是答案。代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef double db;typedef pair&lt;int, int&gt; pii;typedef vector&lt;int&gt; vi;typedef vector&lt;ll&gt; vl;typedef vector&lt;pii&gt; vp;const int inf = 1e9;const ll INF = 1e18;const db eps = 1e-10;#define fi first#define se second#define pb push_back#define eb emplace_back#define ep emplace#define mem(a) memset(a, 0, sizeof(a))#define copy(a, b) memcpy(a, b, sizeof(b))#define PA cout &lt;&lt; "pass\n"#define lowbit(x) (x &amp; -x)#define all(x) x.begin(), x.end()#define TM cout &lt;&lt; db(clock()) / CLOCKS_PER_SEC &lt;&lt; '\n'const int maxn = 100;int x[maxn];int n;int dp[maxn][maxn];int k;const int mod = 1e9 + 7;int main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); while(cin &gt;&gt; n &gt;&gt; k)&#123; int res = 0; int sum = 0; for (int i = 1; i &lt;= n; ++i) &#123; cin &gt;&gt; x[i]; sum ^= x[i]; &#125; if(sum == k) res++; for(int i = 31; i &gt;= 0; i--)&#123; sort(x + 1, x + n + 1, greater&lt;int&gt;()); int cnt = n; while(cnt &gt; 0 &amp;&amp; !(x[cnt] &amp; (1 &lt;&lt; i))) cnt--; if(k &amp; (1 &lt;&lt; i) &amp;&amp; cnt == 0) break; if(!cnt) continue; int tmp = 1; for(int i = cnt + 1; i &lt;= n; i++)&#123; tmp = 1ll * tmp * (x[i] + 1) % mod; &#125; mem(dp); dp[0][0] = tmp; for(int j = 0; j &lt; cnt; j++)&#123; for(int p = 0; p &lt;= j; p++)&#123; if(j == p) dp[j + 1][p] = (dp[j + 1][p] + dp[j][p]) % mod; else dp[j + 1][p] = (dp[j + 1][p] + 1ll * dp[j][p] * (1 &lt;&lt; i)) % mod; dp[j + 1][p + 1] = (dp[j + 1][p + 1] + 1ll * dp[j][p] * (x[j + 1] - (1 &lt;&lt; i) + 1)) % mod; &#125; &#125; bool f = k &amp; (1 &lt;&lt; i); for(int j = f; j &lt; cnt; j += 2)&#123; res = (res + dp[cnt][j]) % mod; &#125; if((cnt &amp; 1) != f) break; for(int j = 1; j &lt;= cnt; j++) x[j] -= 1 &lt;&lt; i; &#125; cout &lt;&lt; res &lt;&lt; '\n'; &#125; return 0;&#125;]]></content>
      <categories>
        <category>基础dp</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2019 ICPC Asia Xuzhou Regional-I(Interesting game)]]></title>
    <url>%2F2019%2F12%2F14%2F2019-ICPC-Asia-Xuzhou-Regional-I-Interesting-game%2F</url>
    <content type="text"><![CDATA[链接：https://nanti.jisuanke.com/t/42548思路：注意到这么三个问题：1、博弈结果最多只跟四个物品有关（a最高两个和b最高两个）。2、如果b想让结果更优，必须要经过删除当前a最大的那个物品的过程，但删除a最大物品不一定会使结果变得更优。3、删除物品多少和最终结果是具有单调性的。所以我们每次都贪心删掉a最大的物品，并且维护这个过程中每次删除后的最小值即可。代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef double db;typedef pair&lt;int, int&gt; pii;typedef vector&lt;int&gt; vi;typedef vector&lt;ll&gt; vl;typedef vector&lt;pii&gt; vp;const int inf = 1e9;const ll INF = 1e18;const db eps = 1e-10;#define fi first#define se second#define pb push_back#define eb emplace_back#define ep emplace#define mem(a) memset(a, 0, sizeof(a))#define copy(a, b) memcpy(a, b, sizeof(b))#define PA cout &lt;&lt; "pass\n"#define lowbit(x) (x &amp; -x)#define all(x) x.begin(), x.end()#define TM cout &lt;&lt; db(clock()) / CLOCKS_PER_SEC &lt;&lt; '\n'set&lt;pii, greater&lt;pii&gt;&gt; s1, s2;int n;const int maxn = 3e5 + 233;int a[maxn], b[maxn];int getans()&#123; auto a1 = s1.begin(), b1 = s2.begin(); auto a2 = next(a1), b2 = next(b1); int res = a1-&gt;fi; if(a1-&gt;se == b1-&gt;se) res -= b2-&gt;fi; else res -= b1-&gt;fi; int ans = a[b1-&gt;se] - b2-&gt;fi; return max(res, ans);&#125;int main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); cin &gt;&gt; n; for (int i = 1; i &lt;= n; ++i) &#123; cin &gt;&gt; a[i] &gt;&gt; b[i]; s1.ep(a[i], i), s2.ep(b[i], i); &#125; int res = inf; for(int i = 0; i &lt;= n - 2; i++)&#123; res = min(res, getans()); int x = s1.begin()-&gt;se; s1.erase(pii(a[x], x)); s2.erase(pii(b[x], x)); cout &lt;&lt; res &lt;&lt; '\n'; &#125; return 0;&#125;]]></content>
      <categories>
        <category>贪心</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2019 ICPC Asia Xuzhou Regional-H(Yuuki and a problem)]]></title>
    <url>%2F2019%2F12%2F14%2F2019-ICPC-Asia-Xuzhou-Regional-H-Yuuki-and-a-problem%2F</url>
    <content type="text"><![CDATA[链接：https://nanti.jisuanke.com/t/42547思路：一看又是带修改主席树的样子，只是操作二怎么做成了问题，考虑如果当前我们知道now以内的都可以表示，那我们需要查看now + 1处是否有值，如果没有最小不能表示的就是now + 1，否则now = now + now + 1。我们考虑最坏需要枚举的路径，是1，2，4，8，16……发现最多log次就到2e5了，所有我们对于操作2暴力计算就行了，复杂度O(nlog^3n)代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef double db;typedef pair&lt;int, int&gt; pii;typedef vector&lt;int&gt; vi;typedef vector&lt;ll&gt; vl;typedef vector&lt;pii&gt; vp;const int inf = 1e9;const ll INF = 1e18;const db eps = 1e-10;#define fi first#define se second#define pb push_back#define eb emplace_back#define ep emplace#define mem(a) memset(a, 0, sizeof(a))#define copy(a, b) memcpy(a, b, sizeof(b))#define PA cout &lt;&lt; "pass\n"#define lowbit(x) (x &amp; -x)#define all(x) x.begin(), x.end()#define TM cout &lt;&lt; db(clock()) / CLOCKS_PER_SEC &lt;&lt; '\n'const int maxn = 2e5 + 5;int root[maxn], ls[maxn * 150], rs[maxn * 150];ll sum[maxn * 150];int pl[maxn], pr[maxn];int idx, cnt1, cnt2;int n, q;int a[maxn];void update(int pre, int &amp;o, int l, int r, int p, int v)&#123; if(!o) o = ++idx; ls[o] = ls[pre], rs[o] = rs[pre], sum[o] = sum[pre] + v; if(l == r) return; int mid = l + r &gt;&gt; 1; if(p &lt;= mid) update(ls[pre], ls[o], l, mid, p, v); else update(rs[pre], rs[o], mid + 1, r, p, v);&#125;ll query(int l, int r, int k)&#123; int mid = l + r &gt;&gt; 1; ll x = 0; if(l == r) &#123; for(int i = 1; i &lt;= cnt1; i++) x -= sum[pl[i]]; for(int i = 1; i &lt;= cnt2; i++) x += sum[pr[i]]; return x; &#125; if(k &lt;= mid) &#123; for(int i = 1; i &lt;= cnt1; i++) pl[i] = ls[pl[i]]; for(int i = 1; i &lt;= cnt2; i++) pr[i] = ls[pr[i]]; return query(l, mid, k); &#125; for(int i = 1; i &lt;= cnt1; i++) x -= sum[ls[pl[i]]]; for(int i = 1; i &lt;= cnt2; i++) x += sum[ls[pr[i]]]; for(int i = 1; i &lt;= cnt1; i++) pl[i] = rs[pl[i]]; for(int i = 1; i &lt;= cnt2; i++) pr[i] = rs[pr[i]]; return x + query(mid + 1, r, k);&#125;void add(int p, int d)&#123; for(int i = p; i &lt;= maxn; i += lowbit(i)) update(root[i], root[i], 1, maxn, a[p], d);&#125;ll prequery(int l, int r, int p)&#123; cnt1 = cnt2 = 0; for(int i = l; i; i -= lowbit(i)) pl[++cnt1] = root[i]; for(int i = r; i; i -= lowbit(i)) pr[++cnt2] = root[i]; return query(1, maxn, p);&#125;int main()&#123; scanf("%d %d", &amp;n, &amp;q); for(int i = 1; i &lt;= n; i++) &#123; scanf("%d", &amp;a[i]); add(i, a[i]); &#125; while(q--)&#123; int op, x, y; scanf("%d %d %d", &amp;op, &amp;x, &amp;y); if(op == 1)&#123; add(x, -a[x]); a[x] = y; add(x, a[x]); &#125; else&#123; ll now = 1; while(1)&#123; ll tmp = prequery(x - 1, y, now); if(tmp &lt; now)&#123; break; &#125; if(tmp &gt; maxn)&#123; now = prequery(x - 1, y, maxn) + 1; break; &#125; now = tmp + 1; &#125; printf("%lld\n", now); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>树套树</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2019 ICPC Asia Nanjing Onsite-I(Space Station)]]></title>
    <url>%2F2019%2F12%2F14%2F2019-ICPC-Asia-Nanjing-Onsite-I-Space-Station%2F</url>
    <content type="text"><![CDATA[链接：https://codeforces.com/gym/257756/problem/I思路：分析发现当总和大于等于最大的数后就可以任意选了，我们只需要考虑如下情况：最后一次小于最大max值，且下一个选了后大雨等于最大的max值。打表发现50以内划分数的总和在2e6左右，对于每一种划分方案，我们用个map记录一下，并枚举一下符合条件的下一个数选什么，如果选了后大于max，我们计入答案内，否则将贡献转移到另一个方案里。最后所有大于等于mx和一定都被统计过了，即可得到最终的答案。代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef double db;typedef pair&lt;int, int&gt; pii;typedef vector&lt;int&gt; vi;typedef vector&lt;ll&gt; vl;typedef vector&lt;pii&gt; vp;const int inf = 1e9;const ll INF = 1e18;const db eps = 1e-10;#define fi first#define se second#define pb push_back#define eb emplace_back#define ep emplace#define mem(a) memset(a, 0, sizeof(a))#define copy(a, b) memcpy(a, b, sizeof(b))#define PA cout &lt;&lt; "pass\n"#define lowbit(x) (x &amp; -x)#define all(x) x.begin(), x.end()#define TM cout &lt;&lt; db(clock()) / CLOCKS_PER_SEC &lt;&lt; '\n'map&lt;vi, int&gt; dp;int res;const int mod = 1e9 + 7;const int maxn = 2e5 + 233;int a[55], cnt[55], b[maxn], n, mx;int fac[maxn];void add(int &amp;x, int y)&#123; x += y; if(x &gt;= mod) x -= mod;&#125;void dfs(int now, int sum)&#123; if(sum &gt;= mx)&#123; int num = 0; vi t; for(int i = 1; i &lt;= mx; i++) &#123; t.eb(a[i]), num += cnt[i] - a[i]; &#125; add(res, 1ll * dp[t] * fac[num] % mod); return; &#125; if(now &gt; mx)&#123; vi t; int num = 0; for(int i = 1; i &lt;= mx; i++) &#123; t.eb(a[i]), num += cnt[i] - a[i]; &#125; int x = dp[t]; if(!x) return; for(int i = 1; i &lt;= mx &amp;&amp; i &lt;= sum; i++)&#123; if(cnt[i] &gt; a[i]) &#123; if (sum + i &gt;= mx) &#123; add(res, 1ll * x * (cnt[i] - a[i]) % mod * fac[num - 1] % mod); &#125; else&#123; t[i - 1]++; add(dp[t], 1ll * x * (cnt[i] - a[i]) % mod); t[i - 1]--; &#125; &#125; &#125; return; &#125; for(int i = 0; i &lt;= cnt[now] &amp;&amp; sum + i * now &lt;= mx; i++) &#123; a[now] = i; dfs(now + 1, sum + i * now); &#125;&#125;int main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); scanf("%d", &amp;n); for(int i = 0; i &lt;= n; i++)&#123; scanf("%d", &amp;b[i]); cnt[b[i]]++; mx = max(mx, b[i]); &#125; fac[0] = 1; for(int i = 1; i &lt; maxn; i++) fac[i] = 1ll * fac[i - 1] * i % mod; vi t; for(int i = 1; i &lt;= mx; i++) t.eb(0); if(b[0] == 0)&#123; if(cnt[0] == n + 1) res = fac[n]; else res = 0; cout &lt;&lt; res &lt;&lt; '\n'; return 0; &#125; t[b[0] - 1]++; dp[t] = 1; dfs(1, 0); for(int i = n - cnt[0] + 1; i &lt;= n; i++) res = 1ll * res * i % mod; cout &lt;&lt; res &lt;&lt; '\n'; return 0;&#125;]]></content>
      <categories>
        <category>暴力</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2019 ICPC Asia Nanjing Onsite-F(Paper Grading)]]></title>
    <url>%2F2019%2F12%2F14%2F2019-ICPC-Asia-Nanjing-Onsite-F-Paper-Grading%2F</url>
    <content type="text"><![CDATA[链接：https://codeforces.com/gym/257756/problem/F思路：将问题转换到trie上，即变为询问一个点，求其子树内在l - r范围的值有多少个，并且支持单点修改。范围个数统计很容易想到主席树，单点修改即在主席树外面套一个bit即可。注意本题把所有串在trie上结束位置记录下来，不然操作2复杂度就不对了。代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190#include&lt;bits/stdc++.h&gt;using namespace std; typedef long long ll;typedef double db;typedef pair&lt;int, int&gt; pii;typedef vector&lt;int&gt; vi;typedef vector&lt;ll&gt; vl;typedef vector&lt;pii&gt; vp;const int inf = 1e9;const ll INF = 1e18;const db eps = 1e-10; #define fi first#define se second#define pb push_back#define eb emplace_back#define ep emplace#define mem(a) memset(a, 0, sizeof(a))#define copy(a, b) memcpy(a, b, sizeof(b))#define PA cout &lt;&lt; "pass\n"#define lowbit(x) (x &amp; -x)#define all(x) x.begin(), x.end()#define TM cout &lt;&lt; db(clock()) / CLOCKS_PER_SEC &lt;&lt; '\n' const int maxn = 2e5 + 5;int root[maxn], ls[maxn * 200], rs[maxn * 200], sum[maxn * 200], pl[maxn], pr[maxn];int idx, cnt1, cnt2;int n, m;vector&lt;char&gt; s[maxn]; int now[maxn];int ch[maxn][26];int sz;int in[maxn], out[maxn], dfs_clock;int pos[maxn]; void init()&#123; sz = 1; memset(ch[0],0,sizeof(ch[0]));&#125; int p; void insert(char *s) &#123; int u = 0; for (int i = 0; i &lt; p; i++) &#123; int c = s[i] - 'a'; if (!ch[u][c]) &#123; memset(ch[sz], 0, sizeof(ch[sz])); ch[u][c] = sz++; &#125; u = ch[u][c]; &#125;&#125; void dfs(int u)&#123; in[u] = ++dfs_clock; for(int i = 0; i &lt; 26; i++)&#123; if(ch[u][i]) dfs(ch[u][i]); &#125; out[u] = dfs_clock;&#125; void update(int pre, int &amp;o, int l, int r, int p, int v)&#123; o = ++idx; ls[o] = ls[pre], rs[o] = rs[pre], sum[o] = sum[pre] + v; if(l == r) return; int mid = l + r &gt;&gt; 1; if(p &lt;= mid) update(ls[pre], ls[o], l, mid, p, v); else update(rs[pre], rs[o], mid + 1, r, p, v);&#125; int query(int l, int r, int k)&#123; if(l == r)&#123; int x = 0; for(int i = 1; i &lt;= cnt1; i++) x -= sum[pl[i]]; for(int i = 1; i &lt;= cnt2; i++) x += sum[pr[i]]; return x; &#125; int mid = l + r &gt;&gt; 1, x = 0; for(int i = 1; i &lt;= cnt1; i++) x -= sum[ls[pl[i]]]; for(int i = 1; i &lt;= cnt2; i++) x += sum[ls[pr[i]]]; if(k &gt; mid) &#123; for(int i = 1; i &lt;= cnt1; i++) pl[i] = rs[pl[i]]; for(int i = 1; i &lt;= cnt2; i++) pr[i] = rs[pr[i]]; return x + query(mid + 1, r, k); &#125; for(int i = 1; i &lt;= cnt1; i++) pl[i] = ls[pl[i]]; for(int i = 1; i &lt;= cnt2; i++) pr[i] = ls[pr[i]]; return query(l, mid, k);&#125; void add(int x, int p, int d)&#123; for(int i = x; i &lt;= dfs_clock; i += lowbit(i)) update(root[i], root[i], 0, n, p, d);&#125; int querypre(int l, int r, int L, int R)&#123; cnt1 = cnt2 = 0; for(int i = L; i; i -= lowbit(i)) pl[++cnt1] = root[i]; for(int i = R; i; i -= lowbit(i)) pr[++cnt2] = root[i]; int s = query(0, n, r); cnt1 = 0; cnt2 = 0; for(int i = L; i; i -= lowbit(i)) pl[++cnt1] = root[i]; for(int i = R; i; i -= lowbit(i)) pr[++cnt2] = root[i]; return s - query(0, n, l - 1);&#125; inline int read() &#123; int X = 0, w = 0; char ch = 0; while (!isdigit(ch)) &#123; w |= ch == '-'; ch = getchar(); &#125; while (isdigit(ch)) X = (X &lt;&lt; 3) + (X &lt;&lt; 1) + (ch ^ 48), ch = getchar(); return w ? -X : X;&#125; inline void write(int x) &#123; if (x &lt; 0) putchar('-'), x = -x; if (x &gt; 9) write(x / 10); putchar(x % 10 + '0');&#125; char tmp[maxn];int len[maxn]; int main()&#123; init(); n = read(), m = read(); for(int i = 1; i &lt;= n; i++)&#123; scanf("%s", tmp); len[i] = strlen(tmp); p = len[i]; for(int j = 0; j &lt; len[i]; j++) s[i].eb(tmp[j]); insert(tmp); now[i] = i; &#125; dfs(0); for(int i = 1; i &lt;= n; i++)&#123; int u = 0; for(int j = 0; j &lt; s[i].size(); j++) u = ch[u][s[i][j] - 'a']; pos[i] = u; add(in[u], i, 1); &#125; for(int i = 1; i &lt;= m; i++)&#123; int op, l, r, k; op = read(); if(op == 2)&#123; scanf("%s", tmp); k = read(); l = read(); r = read(); int u = 0; bool f = true; for(int j = 0; j &lt; k; j++) &#123; if(!ch[u][tmp[j] - 'a'])&#123; f = false; break; &#125; u = ch[u][tmp[j] - 'a']; &#125; if(!f) puts("0"); else write(querypre(l, r, in[u] - 1, out[u])), putchar('\n'); &#125; else&#123; l = read(); r = read(); if(l == r) continue; int u = pos[now[l]]; add(in[u], l, -1); add(in[u], r, 1); u = pos[now[r]]; add(in[u], r, -1); add(in[u], l, 1); swap(now[l], now[r]); &#125; &#125; return 0;&#125; 补一个cdq的做法，考虑第一维是时间t，按照操作顺序默认排好序了，第二维是dfs序，第三维是字符串的下标，将第一维时间线看成修改操作，那么就是一个典型的带修改二维数点问题，直接套用cdq分治即可。代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef double db;typedef pair&lt;int, int&gt; pii;typedef vector&lt;int&gt; vi;typedef vector&lt;ll&gt; vl;typedef vector&lt;pii&gt; vp;const int inf = 1e9;const ll INF = 1e18;const db eps = 1e-10;#define fi first#define se second#define pb push_back#define eb emplace_back#define ep emplace#define mem(a) memset(a, 0, sizeof(a))#define copy(a, b) memcpy(a, b, sizeof(b))#define PA cout &lt;&lt; "pass\n"#define lowbit(x) (x &amp; -x)#define all(x) x.begin(), x.end()#define TM cout &lt;&lt; db(clock()) / CLOCKS_PER_SEC &lt;&lt; '\n'const int maxn = 2e5 + 233;const int sigma_size = 26;int ch[maxn][sigma_size], sz, dfs_clock;int val[maxn], in[maxn], out[maxn], pos[maxn];char s[maxn];void init() &#123; sz = 1; memset(ch[0], 0, sizeof(ch[0]));&#125;int idx(char c) &#123; return c - 'a';&#125;void insert(int v = 1) &#123; scanf("%s", s); int n = strlen(s); int u = 0; for (int i = 0; i &lt; n; i++) &#123; int c = idx(s[i]); if (!ch[u][c]) &#123; ch[u][c] = sz; memset(ch[sz], 0, sizeof(ch[sz])); val[sz++] = 0; &#125; u = ch[u][c]; &#125; val[u] = v; pos[v] = u;&#125;void dfs(int u)&#123; in[u] = ++dfs_clock; for(int i = 0; i &lt; sigma_size; i++)&#123; if(ch[u][i]) dfs(ch[u][i]); &#125; out[u] = dfs_clock;&#125;struct node&#123; int op, x, y, c, id;&#125;a[maxn * 5], tmp[maxn * 5];int n, m;char str[maxn];int res[maxn];int c[maxn];void add(int x, int d)&#123; while(x &lt; maxn)&#123; c[x] += d; x += lowbit(x); &#125;&#125;int query(int x)&#123; int ret = 0; while(x)&#123; ret += c[x]; x -= lowbit(x); &#125; return ret;&#125;void cdq(int l, int r)&#123; if(l == r) return; int mid = l + r &gt;&gt; 1; cdq(l, mid); cdq(mid + 1, r); int pl = l, pr = mid + 1, tot = l; while(pl &lt;= mid &amp;&amp; pr &lt;= r)&#123; if(a[pl].x &lt;= a[pr].x)&#123; if(!a[pl].op) add(a[pl].y, a[pl].c); tmp[tot++] = a[pl++]; &#125; else&#123; if(a[pr].op) res[a[pr].id] += a[pr].c * query(a[pr].y); tmp[tot++] = a[pr++]; &#125; &#125; while(pl &lt;= mid) &#123; if(!a[pl].op) add(a[pl].y, a[pl].c); tmp[tot++] = a[pl++]; &#125; while(pr &lt;= r) &#123; if(a[pr].op) res[a[pr].id] += a[pr].c * query(a[pr].y); tmp[tot++] = a[pr++]; &#125; for(int i = l; i &lt;= mid; i++) if(!a[i].op) add(a[i].y, -a[i].c); for(int i = l; i &lt;= r; i++) a[i] = tmp[i];&#125;bool ok[maxn];int main()&#123; init(); scanf("%d %d", &amp;n, &amp;m); int cnt = 0; for(int i = 1; i &lt;= n; i++) &#123; insert(i); &#125; dfs(0); for(int i = 1; i &lt;= n; i++)&#123; a[++cnt] = node&#123;0, in[pos[i]], i, 1, i&#125;; &#125; for(int i = 1; i &lt;= m; i++)&#123; int op, k, l, r; scanf("%d", &amp;op); if(op == 1)&#123; scanf("%d %d", &amp;l, &amp;r); a[++cnt] = node&#123;0, in[pos[l]], l, -1, i&#125;; a[++cnt] = node&#123;0, in[pos[r]], r, -1, i&#125;; a[++cnt] = node&#123;0, in[pos[l]], r, 1, i&#125;; a[++cnt] = node&#123;0, in[pos[r]], l, 1, i&#125;; swap(pos[l], pos[r]); &#125; else&#123; ok[i] = 1; scanf("%s %d %d %d", str, &amp;k, &amp;l, &amp;r); int p = 0; bool f = true; for(int j = 0; j &lt; k; j++)&#123; int c = str[j] - 'a'; if(ch[p][c]) p = ch[p][c]; else&#123; f = false; break; &#125; &#125; if(!f) continue; a[++cnt] = &#123;1, in[p] - 1, l - 1, 1, i&#125;; a[++cnt] = &#123;1, in[p] - 1, r, -1, i&#125;; a[++cnt] = &#123;1, out[p], l - 1, -1, i&#125;; a[++cnt] = &#123;1, out[p], r, 1, i&#125;; &#125; &#125; cdq(1, cnt); for(int i = 1; i &lt;= m; i++)&#123; if(ok[i]) printf("%d\n", res[i]); &#125; return 0;&#125;]]></content>
      <categories>
        <category>树套树</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2019 ICPC Asia Nanchang Onsite-A(9102)]]></title>
    <url>%2F2019%2F12%2F08%2F2019-ICPC-Asia-Nanchang-Onsite-A-9102%2F</url>
    <content type="text"><![CDATA[链接：https://codeforces.com/gym/259514/problem/A思路：题目里透着一股浓浓的可持久化并查集的味道，然而仔细看看并不用，可以按照询问建树，然后树上dfs，进去的时候加上某个操作或者回答询问，出来的时候撤销掉之前的操作即可。操作1简单的按秩合并，撤销就还原rank数组和father即可。操作2用个数组标记一下是否已经毁掉即可。操作三如果正常做可能有些问题，涉及到把一个点所有的儿子都挂到他父亲下面，删掉这个点并且放到另一个点的祖先下去，复杂度不太好证明且写着非常繁琐。事实上可以开一个新点，原来那个点指向新点，新点挂到新位置下即可，同时改变对应的统计信息。操作4和5就是正常的询问，没什么难度，就是注意一下细节就好，比如已经有某个family毁掉了操作就不再进行，并且询问就输出No/0等。代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155#include&lt;bits/stdc++.h&gt;using namespace std; typedef long long ll;typedef double db;typedef pair&lt;int, int&gt; pii;typedef vector&lt;int&gt; vi;typedef vector&lt;ll&gt; vl;typedef vector&lt;pii&gt; vp;const int inf = 1e9;const ll INF = 1e18;const db eps = 1e-10; #define fi first#define se second#define pb push_back#define eb emplace_back#define ep emplace#define mem(a) memset(a, 0, sizeof(a))#define copy(a, b) memcpy(a, b, sizeof(b))#define PA cout &lt;&lt; "pass\n"#define lowbit(x) (x &amp; -x)#define all(x) x.begin(), x.end()#define TM cout &lt;&lt; db(clock()) / CLOCKS_PER_SEC &lt;&lt; '\n' const int maxn = 1e6 + 233; int f[2 * maxn], n, m;int cnt[2 * maxn], op[maxn], id[2 * maxn], num[2 * maxn], sz;vi G[maxn];bool vis[2 * maxn];int res[maxn]; int find(int x)&#123; return x == f[x] ? x : find(f[x]);&#125; struct ASK&#123; int a, b;&#125;q[maxn]; void dfs(int u)&#123; int p1, p2, p3; bool ok = false; if(op[u] == 1)&#123; int fx = find(id[q[u].a]); int fy = find(id[q[u].b]); if(fx != fy &amp;&amp; vis[q[u].a] &amp;&amp; vis[q[u].b])&#123; ok = true; if(cnt[fx] &lt; cnt[fy]) swap(fx, fy); f[fy] = fx; p3 = fx; p2 = fy; p1 = cnt[fx]; cnt[fx] = max(cnt[fx], cnt[fy] + 1); num[fx] += num[fy]; &#125; &#125; if(op[u] == 2)&#123; int tmp = id[q[u].a]; if(vis[q[u].a]) &#123; ok = true; vis[q[u].a] = 0; int fx = find(tmp); num[fx]--; &#125; &#125; if(op[u] == 3)&#123; int tmp = id[q[u].a]; int fx = find(id[q[u].a]); int fy = find(id[q[u].b]); if(fx != fy &amp;&amp; vis[q[u].a] &amp;&amp; vis[q[u].b])&#123; ok = true; id[q[u].a] = ++sz; id[sz] = sz; vis[sz] = 1; int np = find(id[q[u].b]); p3 = tmp; p2 = np; f[sz] = np; num[np]++; np = find(tmp); num[np]--; p1 = np; &#125; &#125; if(op[u] == 4)&#123; int fx = find(id[q[u].a]); int fy = find(id[q[u].b]); if(vis[q[u].a] &amp;&amp; vis[q[u].b]) res[u] = (fx == fy); &#125; if(op[u] == 5)&#123; if(vis[q[u].a]) res[u] = num[find(id[q[u].a])]; &#125; for(auto &amp;v : G[u])&#123; dfs(v); &#125; if(op[u] == 1)&#123; if(ok) &#123; cnt[p3] = p1; f[p2] = p2; num[p3] -= num[p2]; &#125; &#125; if(op[u] == 2)&#123; int tmp = id[q[u].a]; if(ok)&#123; vis[q[u].a] = 1; int fx = find(tmp); num[fx]++; &#125; &#125; if(op[u] == 3)&#123; int tmp = id[q[u].a]; if(ok)&#123; id[q[u].a] = tmp; num[p1]++; num[p2]--; id[q[u].a] = p3; vis[sz] = 0; sz--; &#125; &#125;&#125; int main()&#123; scanf("%d %d", &amp;n, &amp;m); for(int i = 1; i &lt;= n; i++) f[i] = i, cnt[i] = 1, vis[i] = 1, num[i] = 1, id[i] = i; sz = n; for(int i = 1; i &lt;= m; i++)&#123; int u; scanf("%d %d %d", &amp;op[i], &amp;u, &amp;q[i].a); G[u].eb(i); if(op[i] == 1 || op[i] == 3 || op[i] == 4) scanf("%d", &amp;q[i].b); &#125; dfs(0); for(int i = 1; i &lt;= m; i++) &#123; if(op[i] == 4)&#123; if(res[i]) puts("Yes"); else puts("No"); &#125; else if(op[i] == 5) printf("%d\n", res[i]); &#125; return 0;&#125;]]></content>
      <categories>
        <category>并查集</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2019 ICPC Asia Nanchang Onsite-M(XOR Sum)]]></title>
    <url>%2F2019%2F12%2F08%2F2019-ICPC-Asia-Nanchang-Onsite-M-XOR-Sum%2F</url>
    <content type="text"><![CDATA[链接：https://codeforces.com/gym/259514/problem/M思路：首先观察异或的前缀和跟4的余数有关：f(i) = i (i % 4 == 0), f(i) = 1 (i % 4 == 1), f(i) = i + 1 (i % 4 == 2), f(i) = 0 (i % 4 == 3)，然后我们变换一下公式求和顺序。 \sum_{i = x}^y\sum_{k = 1}^tf(i, k)里面按4余数分类进行求和，发现余1和余3都是常数，余2多一个常数1，我们把2的倍数拉出来讨论，发现是一个等比数列求和。考虑没有外面那一层求和，里面2的倍数的项显然是一个k次多项式。再对所有2的部分求前缀和，那么应该是一个t + 1次多项式（从生成函数的角度去看幂次可能更清楚一点，简而言之就是求一次前缀和次数增加一次）。那么我们用1 - t + 2个偶点去插值，求出所有2倍数项的等比数列的前缀和，其他项分类讨论即可得出答案。（注意插值板子，里面分母上不能直接乘了后再乘逆元，因为数比模数大，可能刚好是模数的倍数就取模等于0了，得搞个靠谱板子）。代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef double db;typedef pair&lt;int, int&gt; pii;typedef vector&lt;int&gt; vi;typedef vector&lt;ll&gt; vl;typedef vector&lt;pii&gt; vp;const int inf = 1e9;const ll INF = 1e18;const db eps = 1e-10;#define fi first#define se second#define pb push_back#define eb emplace_back#define ep emplace#define mem(a) memset(a, 0, sizeof(a))#define copy(a, b) memcpy(a, b, sizeof(b))#define PA cout &lt;&lt; "pass\n"#define lowbit(x) (x &amp; -x)#define all(x) x.begin(), x.end()#define TM cout &lt;&lt; db(clock()) / CLOCKS_PER_SEC &lt;&lt; '\n'const int mod = 1e9 + 7;int pow_mod(ll q, ll w)&#123; int ret = 1; q %= mod; while(w)&#123; if(w &amp; 1) ret = 1ll * ret * q % mod; q = 1ll * q * q % mod; w &gt;&gt;= 1; &#125; return ret;&#125;const int maxn = 1e5 + 233;int fac[maxn], inv[maxn];int x[maxn], y[maxn];int t;ll l, r;int get(int n) &#123; return (1ll * (mod + 1 - pow_mod(n, t + 1)) * pow_mod(mod + 1 - n, mod - 2) % mod + mod - 1) % mod;&#125;int d1[maxn], d2[maxn];int getans(ll n)&#123; if(n &lt;= t + 2) return y[n]; d1[0] = d2[0] = 1; for(int i = 1; i &lt;= t + 2; i++) &#123; d1[i] = 1ll * d1[i - 1] * ((n - i) % mod) % mod; d2[i] = 1ll * d2[i - 1] * ((n - t - 2 + i - 1) % mod) % mod; &#125; int res = 0; for(int i = 1; i &lt;= t + 2; i++)&#123; int ans = 1ll * d1[i - 1] * d2[t + 2 - i] % mod * y[i] % mod; ans = 1ll * ans * inv[i - 1] % mod * inv[t + 2 - i] % mod; if((t + 2 - i) &amp; 1) ans = (mod - ans) % mod; res = (res + ans) % mod; &#125; return res;&#125;int solve(ll n)&#123; ll k = n / 2; int res = getans(k); res = (res + 1ll * (n / 4 % mod) * (t + t / 2 + 1)) % mod; if(n % 4 == 1) res = (res + t) % mod; if(n % 4 == 2) res = (res + t + 1) % mod; if(n % 4 == 3) res = (res + t + t / 2 + 1) % mod; return res;&#125;int main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); cin &gt;&gt; t &gt;&gt; l &gt;&gt; r; fac[0] = inv[0] = 1; for(int i = 1; i &lt; maxn; i++) fac[i] = 1ll * fac[i - 1] * i % mod; inv[maxn - 1] = pow_mod(fac[maxn - 1], mod - 2); for(int i = maxn - 2; i; i--) inv[i] = 1ll * inv[i + 1] * (i + 1) % mod; for(int i = 1; i &lt;= t + 2; i++)&#123; x[i] = i; int tmp = get(2 * i); y[i] = (y[i - 1] + tmp) % mod; &#125; cout &lt;&lt; (solve(r) - solve(l - 1) + mod) % mod &lt;&lt; '\n'; return 0;&#125;]]></content>
      <categories>
        <category>拉格朗日插值法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2019 ICPC Asia Nanchang Onsite-F(Dynamic Suffix Array)]]></title>
    <url>%2F2019%2F12%2F08%2F2019-ICPC-Asia-Nanchang-Onsite-F-Dynamic-Suffix-Array%2F</url>
    <content type="text"><![CDATA[链接：https://codeforces.com/gym/259514/problem/F思路：现场想了个假性质，以为直接倒着删就完了。。。结果发现完全错的。题目有强调数据随机生成，用概率算一下前15位都一样的概率基本为0，这样我们先把所有询问读进来，前十五位拉出来排序离散化，然后开bit动态维护所有后缀大于等于15的点，小于15的点手动暴力查询，这样对于每一个询问我们只用先把他的后缀串查一下在离散化里的排名，然后bit求一下前缀和，再和那些没有满15的后缀点进行暴力比较，统计有多少地方答案比他小即可。代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef double db;typedef pair&lt;int, int&gt; pii;typedef vector&lt;int&gt; vi;typedef vector&lt;ll&gt; vl;typedef vector&lt;pii&gt; vp;const int inf = 1e9;const ll INF = 1e18;const db eps = 1e-10;#define fi first#define se second#define pb push_back#define eb emplace_back#define ep emplace#define mem(a) memset(a, 0, sizeof(a))#define copy(a, b) memcpy(a, b, sizeof(b))#define PA cout &lt;&lt; "pass\n"#define lowbit(x) (x &amp; -x)#define all(x) x.begin(), x.end()#define TM cout &lt;&lt; db(clock()) / CLOCKS_PER_SEC &lt;&lt; '\n'vector&lt;string&gt; pos;int q;const int maxn = 1e6 + 233;int op[maxn], a[maxn];char s[maxn];int num[maxn];int c[maxn];string now[maxn];void add(int x, int d)&#123; while(x &lt; maxn)&#123; c[x] += d; x += lowbit(x); &#125;&#125;int query(int x)&#123; int ret = 0; while(x)&#123; ret += c[x]; x -= lowbit(x); &#125; return ret;&#125;int main()&#123; scanf("%d", &amp;q); int len = 0; for(int i = 1; i &lt;= q; i++) &#123; scanf("%d", &amp;op[i]); if(op[i] == 1) &#123; char ch[2]; scanf("%s", ch); s[++len] = ch[0]; &#125; else scanf("%d", &amp;a[i]); num[i] = len; &#125; for(int i = 1; i &lt;= len - 14; i++)&#123; now[i] = ""; for(int j = i; j &lt;= i + 14; j++) now[i] += s[j]; pos.eb(now[i]); &#125; sort(all(pos)); pos.resize(unique(all(pos)) - pos.begin()); for(int i = 1; i &lt;= q; i++)&#123; if(op[i] == 1)&#123; if(num[i] &gt;= 15)&#123; int p = lower_bound(all(pos), now[num[i] - 14]) - pos.begin() + 1; add(p, 1); &#125; &#125; else&#123; if(a[i] &lt;= num[i] - 14)&#123; int p = upper_bound(all(pos), now[a[i]]) - pos.begin(); int res = query(p); for(int j = max(1, num[i] - 13); j &lt;= num[i]; j++)&#123; string tt = ""; for(int k = j; k &lt;= num[i]; k++)&#123; tt += s[k]; &#125; if(now[a[i]] &gt; tt) res++; &#125; printf("%d\n", res); &#125; else&#123; string tmp = ""; for(int j = a[i]; j &lt;= num[i]; j++) tmp += s[j]; int p = upper_bound(all(pos), tmp) - pos.begin(); int res = query(p); for(int j = max(1, num[i] - 13); j &lt;= num[i]; j++)&#123; if(a[i] == j) continue; string tt = ""; for(int k = j; k &lt;= num[i]; k++) tt += s[k]; if(tmp &gt; tt) res++; &#125; printf("%d\n", res + 1); &#125; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>暴力</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2019 ICPC Asia Nanchang Onsite-K(Tree)]]></title>
    <url>%2F2019%2F12%2F08%2F2019-ICPC-Asia-Nanchang-Onsite-K-Tree%2F</url>
    <content type="text"><![CDATA[链接：https://codeforces.com/gym/259514/problem/K思路： dsu on treedsu on tree又称树上启发式合并，统计的是树上 每一个子树内的某种信息，朴素的做法是枚举每个子树进行统计，复杂度是O(n^2)的，dsu on tree利用了树的特性，继承重儿子的信息，这样只有轻儿子的信息会被清除，可以证明如果没有其他额外操作的话，复杂度是O(nlogn) 步骤1、统计每个轻儿子内部的答案，并清除这些点的影响。2、统计重儿子内部的答案，保留重儿子的信息。3、补充上轻儿子的信息，并同时统计当前树内需要的答案。4、补上这个点的贡献5、根据是否是父节点的重儿子决定是否清空这个树内的贡献 本题考虑本题，由于点对不能有辈分关系，那么我们考虑每一个点对我们都在他们的lca处统计。由于还要满足w[u] + w[v] = 2 * w[lca]，并且d_{uv} \leq k，这里可以用平衡树来维护（pbds真好用），同时进行dsu on tree，对于更新我们采用先统计某一个子树的对答案的贡献，再把整个子树更新上去的方法，复杂度O(nlognlogn)。代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include&lt;bits/stdc++.h&gt;#include&lt;bits/extc++.h&gt;using namespace std;using namespace __gnu_pbds;const int maxn = 2e5 + 233;typedef long long ll;typedef double db;typedef pair&lt;int, int&gt; pii;typedef vector&lt;int&gt; vi;typedef vector&lt;ll&gt; vl;typedef vector&lt;pii&gt; vp;const int inf = 1e9;const ll INF = 1e18;const db eps = 1e-10;#define fi first#define se second#define pb push_back#define eb emplace_back#define ep emplace#define mem(a) memset(a, 0, sizeof(a))#define copy(a, b) memcpy(a, b, sizeof(b))#define PA cout &lt;&lt; "pass\n"#define lowbit(x) (x &amp; -x)#define all(x) x.begin(), x.end()#define TM cout &lt;&lt; db(clock()) / CLOCKS_PER_SEC &lt;&lt; '\n'tree&lt;pii, null_type, less&lt;pii&gt;, rb_tree_tag, tree_order_statistics_node_update&gt; tr[maxn];int w[maxn];int n, k;vi G[maxn];int son[maxn], sz[maxn], d[maxn];ll res;void dfs(int u)&#123; sz[u] = 1; for(auto &amp;v : G[u])&#123; d[v] = d[u] + 1; dfs(v); sz[u] += sz[v]; if(sz[v] &gt; sz[son[u]]) son[u] = v; &#125;&#125;void getans(int u, int lca)&#123; int x = 2 * w[lca] - w[u]; if(x &gt;= 0) res += tr[x].order_of_key(pii(k + 2 * d[lca] - d[u], inf)); for(auto &amp;v : G[u])&#123; getans(v, lca); &#125;&#125;void update(int u, int lca, int op)&#123; if(op == 1) tr[w[u]].insert(pii(d[u], u)); else tr[w[u]].erase(pii(d[u], u)); for(auto &amp;v : G[u])&#123; update(v, lca, op); &#125;&#125;void dfs2(int u, bool ok)&#123; for(auto &amp;v : G[u])&#123; if(v == son[u]) continue; dfs2(v, 0); &#125; if(son[u]) dfs2(son[u], 1); for(auto &amp;v : G[u])&#123; if(v == son[u]) continue; getans(v, u); update(v, u, 1); &#125; tr[w[u]].insert(pii(d[u], u)); if(!ok) update(u, u, -1);&#125;int main()&#123; scanf("%d %d", &amp;n, &amp;k); for(int i = 1; i &lt;= n; i++)&#123; scanf("%d", &amp;w[i]); &#125; for (int i = 2; i &lt;= n; ++i) &#123; int u; scanf("%d", &amp;u); G[u].eb(i); &#125; dfs(1); dfs2(1, 1); printf("%lld\n", 2 * res); return 0;&#125;]]></content>
      <categories>
        <category>dsu on tree</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Educational Codeforces Round 7-F(The Sum of the k-th Powers)]]></title>
    <url>%2F2019%2F11%2F30%2FEducational-Codeforces-Round-7-F-The-Sum-of-the-k-th-Powers%2F</url>
    <content type="text"><![CDATA[链接：https://codeforces.com/contest/622/problem/F思路：咕咕咕了这么久重新回来了，一切重新开始吧。。 拉格朗日插值法假设我们知道某个多项式最高项是n次的且知道n + 1个点，那么我们可以用如下公式构造多项式： f(x) = \sum_{i = 0}^n\prod_{j \ne i}\frac{x - x_j}{x_i - x_j}y_i复杂度是O(n^2)的，但如果x_i的值是连续的，我们可以预处理阶乘和逆元将它变为O(n) 自然数k次幂前缀和形如1^k + 2^k + 3^k + \cdots + n^k称为自然数k次幂前缀和，其处理方法一般有三种：伯努利数，拉格朗日插值，斯特林数。鉴于我现在只会拉格朗日插值的方法，剩下的就待补吧。。。自然数k次幂前缀和可以表示为k + 1次多项式，这个证明在组合数学书的第7章卡特兰数的部分有介绍，那么我们就可以暴力算出k + 2项的值，因为满足连续性质，就可以预处理阶乘快速插值。当单组询问时，我们可以预处理分母的后缀积。如果多组询问分母x变化怎么办呢，我们发现k + 1项中分母每次都只少了一个不同的部分，我们可以先求出所有部分的积，然后少的部分用逆元去掉即可，这样也可以做到单组O(k)的查询了。代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef double db;typedef pair&lt;int, int&gt; pii;typedef vector&lt;int&gt; vi;typedef vector&lt;ll&gt; vl;typedef vector&lt;pii&gt; vp;const int inf = 1e9;const ll INF = 1e18;const db eps = 1e-10;#define fi first#define se second#define pb push_back#define eb emplace_back#define ep emplace#define mem(a) memset(a, 0, sizeof(a))#define copy(a, b) memcpy(a, b, sizeof(b))#define PA cout &lt;&lt; "pass\n"#define lowbit(x) (x &amp; -x)#define all(x) x.begin(), x.end()#define TM cout &lt;&lt; db(clock()) / CLOCKS_PER_SEC &lt;&lt; '\n'const int maxn = 1e6 + 233;int n, k;int x[maxn], y[maxn];int fac[maxn], inv[maxn];int suf[maxn];const int mod = 1e9 + 7;int pow_mod(int q, int w)&#123; int ret = 1; while(w)&#123; if(w &amp; 1) ret = 1ll * ret * q % mod; q = 1ll * q * q % mod; w &gt;&gt;= 1; &#125; return ret;&#125;int main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); scanf("%d %d", &amp;n, &amp;k); suf[0] = fac[0] = 1; for(int i = 1; i &lt;= k + 2; i++) suf[i] = 1ll * suf[i - 1] * (n - i) % mod, fac[i] = 1ll * fac[i - 1] * i % mod, inv[i] = pow_mod(fac[i], mod - 2), x[i] = i, y[i] = (y[i - 1] + pow_mod(i, k)) % mod; int res = 0; if(n &lt;= k + 2)&#123; printf("%d\n", y[n]); return 0; &#125; for(int i = 1; i &lt;= k + 2; i++)&#123; int tmp = 1ll * fac[i - 1] * fac[k + 2 - i] % mod; if(k + 2 - i &amp; 1) tmp = (mod - tmp) % mod; tmp = pow_mod(tmp, mod - 2); res = (res + 1ll * y[i] * tmp % mod * suf[k + 2] % mod * pow_mod(n - i, mod - 2)) % mod; &#125; printf("%d\n", res); return 0;&#125;]]></content>
      <categories>
        <category>拉格朗日插值法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[The 2019 China Collegiate Programming Contest Harbin Site-A(Artful Paintings)]]></title>
    <url>%2F2019%2F11%2F05%2FThe-2019-China-Collegiate-Programming-Contest-Harbin-Site-A-Artful-Paintings%2F</url>
    <content type="text"><![CDATA[链接：https://codeforces.com/gym/102394/problem/A思路：很久没更了，最近实在太忙了，可能是icpc出征前最后一更？希望今年能有好成绩吧。。感觉自己以前都学了假的差分约束系统 差分约束系统现在有一堆不等式x_i - x_j \leq k或者x_i - x_j \geq k，最后我们要求x_p - x_q的最大值或者最小值，其中x_q的值已经给定。考虑最短路模型，其实两点之间的最短路模型就满足d_u + w >= d_v，所以由此我们受到启发，可以用最短路解决这种约束问题。 建图方式这里有个结论，我们假设要求的是x_n - x_1，其中x_1已知，如果我们要求最大值，那么我们要跑最短路，如果求最小值，我们跑最长路（自行证明）。最大值：把所有约束整理成d_u + w \geq d_v的形式，然后从u到v连一条长度为w的边，最后跑最短路即可。最小值：把所有约束整理成d_u + w \leq d_v的形式，然后从u到v连一条长度为w的边，最后跑最长路即可。 一些技巧如果是大于小于怎么办呢，很简单那就+1或者-1调整一下即可。如果是等于号怎么办呢，考虑拆成一个大于等于和一个小于等于，建两条边即可。 本题观察发现，涂的cube越多越容易满足，所以总数量满足二分性质。我们考虑构造数量的前缀，这样区间数量就变成两个前缀相减，就可以构造差分方程，由于是求sum[r] - sum[0]的最小值，我们要跑最长路。对于第一种操作，我们从l - 1向r连一条长度为k的边对于第二种操作，我们从r向l - 1连一条长度为k - mid的边（mid为二分值）相邻两个的差在0和1之间，连两条边特别特别别忘了，总的数量是mid，所以0到n连两条边，最后跑看是否有解即可。本题还有没有log的做法，据说很难，就不补了。代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef double db;typedef pair&lt;int, int&gt; pii;typedef vector&lt;int&gt; vi;typedef vector&lt;ll&gt; vl;typedef vector&lt;pii&gt; vp;const int inf = 1e9;const ll INF = 1e18;const db eps = 1e-10;#define fi first#define se second#define pb push_back#define eb emplace_back#define ep emplace#define mem(a) memset(a, 0, sizeof(a))#define copy(a, b) memcpy(a, b, sizeof(b))#define PA cout &lt;&lt; "pass\n"#define lowbit(x) (x &amp; -x)#define all(x) x.begin(), x.end()#define TM cout &lt;&lt; db(clock()) / CLOCKS_PER_SEC &lt;&lt; '\n'const int maxn = 6010;int n, T, m1, m2;struct node&#123; int to,next,w;&#125;edges[3000 * 3010];int g[maxn], idx;bool inq[maxn];int d[maxn];int cnt[maxn];int l[maxn * 2], r[maxn * 2], k[maxn * 2];int Q[3010 * 3010 * 2], head, tail;void init() &#123; idx = 1; memset(g, -1, sizeof(g));&#125;void addedge(int u, int v, int w) &#123; edges[idx].to = v; edges[idx].w = w; edges[idx].next = g[u]; g[u] = idx; idx++;&#125;bool spfa(int s) &#123; for (int i = 0; i &lt;= n; i++) &#123; d[i] = -1e9; cnt[i] = inq[i] = 0; &#125; d[s] = 0; head = tail = 0; Q[head] = s; while (head &lt;= tail) &#123; int u = Q[head]; head++; inq[u] = false; for (int i = g[u]; i != -1; i = edges[i].next) &#123; if (d[edges[i].to] &lt; d[u] + edges[i].w) &#123; d[edges[i].to] = d[u] + edges[i].w; if (!inq[edges[i].to]) &#123; Q[++tail] = edges[i].to; inq[edges[i].to] = true; if (++cnt[edges[i].to] &gt; n + 3) &#123; return false; &#125; &#125; &#125; &#125; &#125; return true;&#125;int main()&#123; scanf("%d", &amp;T); while(T--)&#123; scanf("%d %d %d", &amp;n, &amp;m1, &amp;m2); for(int i = 1; i &lt;= m1; i++)&#123; scanf("%d %d %d", &amp;l[i], &amp;r[i], &amp;k[i]); &#125; for (int i = m1 + 1; i &lt;= m1 + m2; ++i) &#123; scanf("%d %d %d", &amp;l[i], &amp;r[i], &amp;k[i]); &#125; int lb = 0, ub = n, ans = n; while(ub &gt;= lb)&#123; int mid = ub + lb &gt;&gt; 1; init(); for (int i = 1; i &lt;= m1; ++i) &#123; addedge(l[i] - 1, r[i], k[i]); &#125; for(int i = m1 + 1; i &lt;= m1 + m2; i++)&#123; addedge(r[i], l[i] - 1, k[i] - mid); &#125; for(int i = 0; i &lt; n; i++) &#123; addedge(i + 1, i, -1); addedge(i, i + 1, 0); &#125; addedge(0, n, mid); spfa(0); if(mid &gt;= d[n]) ub = mid - 1, ans = mid; else lb = mid + 1; &#125; printf("%d\n", ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>差分约束系统</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2018-2019 ACM-ICPC, Asia Shenyang Regional Contest-M(Renaissance Past in Nancy)]]></title>
    <url>%2F2019%2F10%2F05%2F2018-2019-ACM-ICPC-Asia-Shenyang-Regional-Contest-M-Renaissance-Past-in-Nancy%2F</url>
    <content type="text"><![CDATA[链接：https://codeforces.com/gym/101955/problem/M思路：这个题是可逆背包基于生成函数的一个应用，我们先来了解一下可逆背包。 可逆背包一般的背包可能是需要取max，或者求方案数等运算，我们把这里面运算可逆的称为可逆背包。比如取max就不是可逆背包，因为如果我们取max，如果退掉一个物品的贡献，我们没法把结果退回去，但如果是求方案数，我们可以把根据背包的dp顺序倒着把贡献退回去，这样的背包叫做可逆背包。 可逆背包与生成函数考虑一个物品的重量为a，有b个（如果是多重背包）。那么我们写出几种背包的生成函数：01背包：1 + x^a01退背包：1 - x^a完全背包：\sum_{i = 0}^{\infty}x^{ai} = \frac{1}{1 - x^a}多重背包：\sum_{i = 0}^{b}x^{ai} = \frac{1 - x^{a(b + 1)}}{1 - x^a}不知道是否观察出了什么性质？通过生成函数我们可以得知，在背包是可逆背包的情况下，多重背包可以由一个完全重量为a的完全背包和一个重量为a(b + 1)的01退背包得到，它们俩得到的东西是完全一样的。那么我们如果要退掉这个背包的贡献怎么办呢，考虑在生成函数上，退掉它就是乘一个它的倒数，那么转换为背包上，就是以a(b + 1)重量做一个完全背包和a做一个01退背包。 本题在本题中，我们可以对多重背包维护一个前缀和f，对多重可逆背包也维护一个前缀和g，那么考虑[l, r]区间的方案数，最终答案就是f[x] * g[y] (x + y = c) 一些思考背包其实和多项式在一定程度上是完全相同的，背包的方案数就对应了多项式的系数，两个背包合并对应了多项式乘法，所以求解是两个前缀背包合并的本质是在做一个卷积。代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef double db;typedef pair&lt;int, int&gt; pii;typedef vector&lt;int&gt; vi;typedef vector&lt;ll&gt; vl;typedef vector&lt;pii&gt; vp;const int inf = 1e9;const ll INF = 1e18;const db eps = 1e-10;#define fi first#define se second#define pb push_back#define eb emplace_back#define ep emplace#define mem(a) memset(a, 0, sizeof(a))#define copy(a, b) memcpy(a, b, sizeof(b))#define PA cout &lt;&lt; "pass\n"#define lowbit(x) (x &amp; -x)#define all(x) x.begin(), x.end()#define TM cout &lt;&lt; db(clock()) / CLOCKS_PER_SEC &lt;&lt; '\n'int T, n, m;int f[10010][1010], g[10010][1010];const int mod = 1e9 + 7;void add(int &amp;x, int y)&#123; x += y; if(x &gt;= mod) x -= mod;&#125;void sub(int &amp;x, int y)&#123; x -= y; if(x &lt; 0) x += mod;&#125;void insert(int *f, int x)&#123; for(int i = 0; i + x &lt;= 1000; i++) add(f[i + x], f[i]);&#125;void move(int *f, int x)&#123; for(int i = 1000; i &gt;= x; i--) sub(f[i], f[i - x]);&#125;int main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); cin &gt;&gt; T; int kase = 0; while(T--)&#123; cout &lt;&lt; "Case #" &lt;&lt; ++kase &lt;&lt; ":\n"; int last = 0; cin &gt;&gt; n &gt;&gt; m; f[0][0] = 1; g[0][0] = 1; for (int i = 1; i &lt;= n; ++i) &#123; int a, b; cin &gt;&gt; b &gt;&gt; a; copy(f[i], f[i - 1]); copy(g[i], g[i - 1]); insert(f[i], a); move(f[i], a * (b + 1)); insert(g[i], a * (b + 1)); move(g[i], a); &#125; for(int i = 1; i &lt;= n; i++)&#123; for(int j = 1; j &lt;= 1000; j++)&#123; add(f[i][j], f[i][j - 1]); &#125; &#125; while(m--)&#123; int l, r, c; cin &gt;&gt; l &gt;&gt; r &gt;&gt; c; int t1 = (l + last) % n + 1; int t2 = (r + last) % n + 1; l = min(t1, t2), r = max(t1, t2); int res = 0; for(int i = 0; i &lt;= c; i++) add(res, 1ll * f[r][i] * g[l - 1][c - i] % mod); last = res; cout &lt;&lt; res &lt;&lt; '\n'; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>生成函数</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2017 ACM-ICPC World Finals-L(Visual Python++)]]></title>
    <url>%2F2019%2F10%2F05%2F2017-ACM-ICPC-World-Finals-L-Visual-Python%2F</url>
    <content type="text"><![CDATA[链接：https://codeforces.com/gym/101471/attachments思路：不难发现，如果我们按x坐标从右到左把右括号加入，对于一个左括号，我们一定是找到一个刚好比他y大的右括号，画图可以证明没有其他情况比它构造出来的更优，这样我们很容易就能得出一组配对方案，难点在于怎么check这个方案是否合法。我们得把x和y分开来check，因为边界重叠也算重叠，把所有坐标相同的区间拉出来排序，看是否有重叠即可。代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148#include&lt;bits/stdc++.h&gt;using namespace std; typedef long long ll;typedef double db;typedef pair&lt;int, int&gt; pii;typedef vector&lt;int&gt; vi;typedef vector&lt;ll&gt; vl;typedef vector&lt;pii&gt; vp;const int inf = 1e9;const ll INF = 1e18;const db eps = 1e-10; #define fi first#define se second#define pb push_back#define eb emplace_back#define ep emplace#define mem(a) memset(a, 0, sizeof(a))#define copy(a, b) memcpy(a, b, sizeof(b))#define PA cout &lt;&lt; "pass\n"#define lowbit(x) (x &amp; -x)#define all(x) x.begin(), x.end()#define TM cout &lt;&lt; db(clock()) / CLOCKS_PER_SEC &lt;&lt; '\n' const int maxn = 2e5 + 233;struct node&#123; int x, y, type, id; bool operator &lt;(const node &amp;r) const&#123; return y &lt; r.y; &#125;&#125;q[maxn]; bool cmp(node &amp;a, node &amp;b)&#123; return a.x &lt; b.x || (a.x == b.x &amp;&amp; a.type &lt; b.type);&#125; int n;set&lt;node&gt; s;int res[maxn];int back[maxn];pii tmp[maxn];int vis[maxn]; int main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); cin &gt;&gt; n; for (int i = 1; i &lt;= n; ++i) &#123; cin &gt;&gt; q[i].x &gt;&gt; q[i].y; q[i].type = -1; q[i].id = i; &#125; for (int i = n + 1; i &lt;= 2 * n; ++i) &#123; cin &gt;&gt; q[i].x &gt;&gt; q[i].y; q[i].type = 1; q[i].id = i - n; &#125; sort(q + 1, q + 2 * n + 1, cmp); bool f = true; for (int i = 2 * n; i; i--) &#123; if(q[i].type == 1)&#123; auto it = s.lower_bound(q[i]); if(it != s.end() &amp;&amp; (*it).y == q[i].y)&#123; f = false; break; &#125; s.insert(q[i]); continue; &#125; auto it = s.lower_bound(q[i]); if(it == s.end())&#123; f = false; break; &#125; res[q[i].id] = (*it).id; back[(*it).id] = q[i].id; tmp[q[i].id].fi = q[i].y; tmp[q[i].id].se = (*it).y; s.erase(it); &#125; for (int i = 1; i &lt;= 2 * n; i++) &#123; int j = i; vector&lt;pii&gt; now; vector&lt;int&gt; p; int id = q[j].type == -1 ? q[j].id : back[q[j].id]; now.eb(tmp[id]); vis[id] = i; while(j &lt; 2 * n &amp;&amp; q[j].x == q[j + 1].x)&#123; j++; id = q[j].type == -1 ? q[j].id : back[q[j].id]; if(vis[id] != i)&#123; vis[id] = i; now.eb(tmp[id]); &#125; &#125; sort(all(now)); for(int j = 1; j &lt; now.size(); j++)&#123; if(now[j].fi &lt; now[j - 1].se)&#123; f = false; break; &#125; &#125; i = j; &#125; if(!f) cout &lt;&lt; "syntax error\n"; else&#123; set&lt;int&gt; t; for(int i = 1; i &lt;= 2 * n; i++)&#123; if(q[i].type == -1)&#123; auto it = t.lower_bound(tmp[q[i].id].fi); if(it != t.end())&#123; if((*it) &lt;= tmp[q[i].id].se)&#123; f = false; break; &#125; &#125; t.ep(tmp[q[i].id].fi); t.ep(tmp[q[i].id].se); &#125; else&#123; auto it = t.upper_bound(tmp[back[q[i].id]].fi); if(it != t.end())&#123; if((*it) &lt; tmp[back[q[i].id]].se)&#123; f = false; break; &#125; &#125; t.erase(tmp[back[q[i].id]].fi); t.erase(tmp[back[q[i].id]].se); &#125; &#125; if(!f) cout &lt;&lt; "syntax error\n"; else&#123; for(int i = 1; i &lt;= n; i++) cout &lt;&lt; res[i] &lt;&lt; '\n'; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>思维</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2017 ACM-ICPC World Finals-D(Money for Nothing)]]></title>
    <url>%2F2019%2F10%2F05%2F2017-ACM-ICPC-World-Finals-D-Money-for-Nothing%2F</url>
    <content type="text"><![CDATA[链接：https://codeforces.com/gym/101471/attachments思路：问题可以转换为平面上给定两个点集A，B，从A中选一个作为矩形的左下角，从B中选一个作为矩形的右下角，问矩形最大面积是多少。第一反应跟最近公共点对好像啊，似乎是个分支题，但对于分治中两边怎么合并答案一直找不到很好的方法。结果这个题有一个很强的性质，但光看是不可能看出来的，也是提醒了自己，没有想法时候得写式子试着推一推。我们考虑一定存在一些点对是不可能作为答案的，否则这个题复杂度永远过不去。首先我们可以剔除一些点，在A集合中对于某个点，如果存在点在它左下方，那么它一定不会成为答案，B集合同理。最后我们得到一个新的A，B集合，使得按x排序后他们的y都是递减的。那么我们考虑对于点集A中的点i，它在B中的最优点是j，那么对于点i + 1，j以前的点一定不会成为答案！考虑有(x_j - x_i) * (y_j - y_i) > (x_{j - 1} - x_i) * (y_{j - 1} - y_i)展开后可得：x_jy_j - x_iy_j - x_jy_i > x_{j - 1}y_{j - 1} - x_iy_{j - 1} - x_{j - 1}y_i假设有(x_{j - 1} - x_{i + 1}) * (y_{j - 1} - y_{i + 1}) > (x_{j } - x_{i + 1}) * (y_{j} - y_{i + 1})展开后可得: x_{j - 1}y_{j - 1} - x_{i + 1}y_{j - 1} - x_{j - 1}y_{i + 1} > x_jy_j - x_{i + 1}y_{j} - x_{j}y_{i + 1}两式相加可得：x_iy_j + x_jy_i + x_{i + 1}y_{j - 1} + x_{j - 1}y_{i + 1} < x_iy_{j - 1} + x_{j - 1}y_i + x_{i + 1}y_j + x_jy_{i + 1}合并可得：x_i(y_j - y_{j - 1}) + x_j(y_i - y_{i + 1}) + x_{i + 1}(y_{j - 1} - y_j) + x_{j - 1}(y_{i + 1} - y_i) < 0继续合并:(x_i - x_{i + 1})(y_j - y_{j - 1}) + (x_j - x_{j + 1})(y_i - y_{i + 1}) < 0发现这个式子在x和y成反比的时候显然矛盾，于是我们得出了一个性质：即如果把B点集看作dp中的待转移状态，A点集看作dp中的转移状态，那么他们之间转移具有决策单调性，直接分治即可。但是可能分治的时候这一段B都没有A的决策能转移过来（必须满足A在B的左下角），这时候我们就把只分治到A点集的左半边就好了，因为右半边一定也无解。确实是非常经典的好题！代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include&lt;bits/stdc++.h&gt;using namespace std; typedef long long ll;typedef double db;typedef pair&lt;int, int&gt; pii;typedef vector&lt;int&gt; vi;typedef vector&lt;ll&gt; vl;typedef vector&lt;pii&gt; vp;const int inf = 1e9;const ll INF = 1e18;const db eps = 1e-10; #define fi first#define se second#define pb push_back#define eb emplace_back#define ep emplace#define mem(a) memset(a, 0, sizeof(a))#define copy(a, b) memcpy(a, b, sizeof(b))#define PA cout &lt;&lt; "pass\n"#define lowbit(x) (x &amp; -x)#define all(x) x.begin(), x.end()#define TM cout &lt;&lt; db(clock()) / CLOCKS_PER_SEC &lt;&lt; '\n' vp t1, t2;int n, m;const int maxn = 5e5 + 233;pii a[maxn];ll res; void solve(int l, int r, int L, int R) &#123; if (l &gt; r) return; int mid = l + r &gt;&gt; 1; int pos = R; ll tmp = -1e18; for (int i = L; i &lt;= R; i++) &#123; if (t1[mid].fi &gt; t2[i].fi) continue; if (tmp &lt; 1ll * (t2[i].fi - t1[mid].fi) * (t2[i].se - t1[mid].se)) &#123; tmp = 1ll * (t2[i].fi - t1[mid].fi) * (t2[i].se - t1[mid].se); pos = i; &#125; &#125; res = max(res, tmp); solve(l, mid - 1, L, pos); solve(mid + 1, r, pos, R);&#125; int main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; ++i) &#123; cin &gt;&gt; a[i].fi &gt;&gt; a[i].se; &#125; sort(a + 1, a + n + 1); for(int i = n; i; i--)&#123; while(t1.size() &amp;&amp; t1.back().se &gt;= a[i].se) t1.pop_back(); t1.eb(a[i]); &#125; reverse(t1.begin(), t1.end()); for (int i = 1; i &lt;= m; ++i) &#123; cin &gt;&gt; a[i].fi &gt;&gt; a[i].se; &#125; sort(a + 1, a + m + 1); for (int i = 1; i &lt;= m; ++i) &#123; while(t2.size() &amp;&amp; t2.back().se &lt;= a[i].se) t2.pop_back(); t2.eb(a[i]); &#125; solve(0, t1.size() - 1, 0, t2.size() - 1); cout &lt;&lt; res &lt;&lt; '\n'; return 0;&#125;]]></content>
      <categories>
        <category>决策单调性</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2017 ACM-ICPC World Finals-C(Mission Improbable)]]></title>
    <url>%2F2019%2F10%2F05%2F2017-ACM-ICPC-World-Finals-C-Mission-Improbable%2F</url>
    <content type="text"><![CDATA[链接：https://codeforces.com/gym/101471/attachments思路：仔细分析一下性质，首先0的地方必须保持为0，非0的地方我们可以先全部拿到只剩1。要想三视图不变，各个行列的最大值不能变。如果对于某一个行和某一个列的最大值不同，我们发现不管怎么样都必须要放两个最大值上去，这个减少不了。如果相同，我们发现只用在交错的地方放一个，可以减少一个。那么如果有多个最大值相同的行和列怎么办，我们就是要能减少的量最多，也就是行和列匹配数最多，我们用二分图求最大匹配即可（因为多个争匹配时，他们的最大值根据传递性可得一定都相等，所以我们不需要用带权匹配）。代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include&lt;bits/stdc++.h&gt;using namespace std; typedef long long ll;typedef double db;typedef pair&lt;int, int&gt; pii;typedef vector&lt;int&gt; vi;typedef vector&lt;ll&gt; vl;typedef vector&lt;pii&gt; vp;const int inf = 1e9;const ll INF = 1e18;const db eps = 1e-10; #define fi first#define se second#define pb push_back#define eb emplace_back#define ep emplace#define mem(a) memset(a, 0, sizeof(a))#define copy(a, b) memcpy(a, b, sizeof(b))#define PA cout &lt;&lt; "pass\n"#define lowbit(x) (x &amp; -x)#define all(x) x.begin(), x.end()#define TM cout &lt;&lt; db(clock()) / CLOCKS_PER_SEC &lt;&lt; '\n' const int maxn = 310; //注意编号从1开始vector&lt;int&gt; G[maxn];bool vis[maxn];int link[maxn];int n, m; void init(int nx, int ny) &#123; for (int i = 0; i &lt;= nx + ny; i++)G[i].clear();&#125; inline void addedge(int from, int to) &#123; G[from].push_back(to);&#125; bool dfs(int u) &#123; vis[u] = 1; for (int i = 0; i &lt; G[u].size(); i++) &#123; int v = G[u][i]; if (!vis[v]) &#123; vis[v] = 1; if (link[v] == -1 || dfs(link[v])) &#123; link[v] = u; return true; &#125; &#125; &#125; return false;&#125; int v[maxn][maxn];int r[maxn], c[maxn]; int main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); memset(link, -1, sizeof(link)); ll sum = 0; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 1; j &lt;= m; ++j) &#123; cin &gt;&gt; v[i][j]; r[i] = max(r[i], v[i][j]); c[j] = max(c[j], v[i][j]); if(v[i][j]) sum += v[i][j] - 1; &#125; &#125; for(int i = 1; i &lt;= n; i++)&#123; if(r[i]) sum -= r[i] - 1; &#125; for(int i = 1; i &lt;= m; i++)&#123; if(c[i]) sum -= c[i] - 1; &#125; for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 1; j &lt;= m; ++j) &#123; if(r[i] == c[j] &amp;&amp; v[i][j])addedge(i, j + n); &#125; &#125; for (int i = 1; i &lt;= n; ++i) &#123; mem(vis); if(r[i] &amp;&amp; dfs(i)) sum += (r[i] - 1); &#125; cout &lt;&lt; sum &lt;&lt; '\n'; return 0;&#125;]]></content>
      <categories>
        <category>二分图</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[The 13th Chinese Northeast Collegiate Programming Contest-D(Master of Data Structure)]]></title>
    <url>%2F2019%2F10%2F03%2FThe-13th-Chinese-Northeast-Collegiate-Programming-Contest-D-Master-of-Data-Structure%2F</url>
    <content type="text"><![CDATA[链接：https://codeforces.com/gym/102220/problem/D思路：点只有4000个，考虑把这些关键点拉出来建虚树，然后在上面暴力更新即可。注意两个关键点中间的信息我们可以存在深度较大的那个点上面，维护一下点的个数以及值，然后对于每个操作直接在虚树上暴力跑即可（注意这个题虚树的top就要设为0了）。代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef double db;typedef pair&lt;int, int&gt; pii;typedef vector&lt;int&gt; vi;typedef vector&lt;ll&gt; vl;typedef vector&lt;pii&gt; vp;const int inf = 1e9;const ll INF = 1e18;const db eps = 1e-10;#define fi first#define se second#define pb push_back#define eb emplace_back#define ep emplace#define mem(a) memset(a, 0, sizeof(a))#define copy(a, b) memcpy(a, b, sizeof(b))#define PA cout &lt;&lt; "pass\n"#define lowbit(x) (x &amp; -x)#define all(x) x.begin(), x.end()#define TM cout &lt;&lt; db(clock()) / CLOCKS_PER_SEC &lt;&lt; '\n'const int maxn = 5e5 + 233;vi G[maxn];int f[maxn][20], sta[maxn], n, T, m, top, dfn[maxn], dfs_clock, d[maxn], par[maxn], val[maxn];pii w[maxn];void dfs(int u, int fa)&#123; dfn[u] = ++dfs_clock; f[u][0] = fa; for (int i = 1; i &lt; 20; ++i) &#123; f[u][i] = f[f[u][i - 1]][i - 1]; &#125; d[u] = d[fa] + 1; for(auto &amp;v : G[u])&#123; if(v == fa) continue; dfs(v, u); &#125;&#125;int lca(int u, int v)&#123; if(d[u] &gt; d[v]) swap(u, v); for(int i = 19; i &gt;= 0; i--)&#123; if(d[f[v][i]] &gt;= d[u]) v = f[v][i]; &#125; if(u == v) return u; for(int i = 19; i &gt;= 0; i--)&#123; if(f[u][i] != f[v][i]) u = f[u][i], v = f[v][i]; &#125; return f[u][0];&#125;void add(int u, int v)&#123; if(d[u] &gt; d[v]) swap(u, v); par[v] = u; w[v] = pii(d[v] - d[u] - 1, 0); val[v] = 0;&#125;void insert(int u)&#123; if(top == 1) &#123; sta[++top] = u; return; &#125; int lc = lca(sta[top], u); if(lc == sta[top])&#123; sta[++top] = u; return; &#125; while(top &gt; 1 &amp;&amp; dfn[sta[top - 1]] &gt;= dfn[lc])&#123; add(sta[top - 1], sta[top]); top--; &#125; if(lc != sta[top])&#123; add(lc, sta[top]); sta[top] = lc; &#125; sta[++top] = u;&#125;struct ask&#123; int op, u, v, k;&#125;q[3000];bool cmp(int x, int y)&#123; return dfn[x] &lt; dfn[y];&#125;vi t;ll res, mn, mx;void update(int op, int u, int k, bool ok)&#123; if(op == 1)&#123; val[u] += k; if(ok) w[u].se += k; &#125; if(op == 2)&#123; val[u] ^= k; if(ok) w[u].se ^= k; &#125; if(op == 3)&#123; if(val[u] &gt;= k) val[u] -= k; if(ok &amp;&amp; w[u].se &gt;= k) w[u].se -= k; &#125; if(op == 4)&#123; res += val[u]; if(ok) res += 1ll * w[u].fi * w[u].se; &#125; if(op == 5)&#123; res ^= val[u]; if(ok &amp;&amp; w[u].fi % 2) res ^= w[u].se; &#125; if(op == 6)&#123; mx = max(mx, (ll)val[u]); mn = min(mn, (ll)val[u]); if(ok &amp;&amp; w[u].fi) mx = max(mx, (ll)w[u].se), mn = min(mn, (ll)w[u].se); res = mx - mn; &#125; if(op == 7)&#123; mn = min(mn, abs((ll)val[u] - k)); if(ok &amp;&amp; w[u].fi) mn = min(mn, abs((ll)w[u].se - k)); res = mn; &#125;&#125;void solve(int op, int u, int v, int k)&#123; res = 0, mn = INF, mx = 0; while(u != v)&#123; if(d[u] &lt; d[v]) swap(u, v); update(op, u, k, 1); u = par[u]; &#125; update(op, u, k, 0); if(op &gt;= 4) cout &lt;&lt; res &lt;&lt; '\n';&#125;int main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); cin &gt;&gt; T; while(T--)&#123; cin &gt;&gt; n &gt;&gt; m; t.clear(); for (int i = 1; i &lt;= n; ++i) &#123; G[i].clear(); par[i] = 0; &#125; top = 1; sta[top] = 0; dfs_clock = 0; for (int i = 1; i &lt; n; ++i) &#123; int u, v; cin &gt;&gt; u &gt;&gt; v; G[u].eb(v); G[v].eb(u); &#125; for (int i = 1; i &lt;= m; ++i) &#123; cin &gt;&gt; q[i].op &gt;&gt; q[i].u &gt;&gt; q[i].v; if(q[i].op &lt;= 3 || q[i].op == 7) cin &gt;&gt; q[i].k; t.eb(q[i].u), t.eb(q[i].v); &#125; dfs(1, 0); sort(all(t), cmp); for(auto &amp;it : t) insert(it); while(top &gt; 1)&#123; add(sta[top - 1], sta[top]); top--; &#125; for(int i = 1; i &lt;= m; i++)&#123; solve(q[i].op, q[i].u, q[i].v, q[i].k); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>虚树</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[luogu-P2495 [SDOI2011](消耗战)]]></title>
    <url>%2F2019%2F10%2F03%2Fluogu-P2495-SDOI2011-%E6%B6%88%E8%80%97%E6%88%98%2F</url>
    <content type="text"><![CDATA[链接：https://www.luogu.org/problem/P2495思路：虚树板子题。。 虚树概念虚树感觉在一定程度上就是树上的离散化？我们只用提出需要操作的关键点，然后建一棵新树，在上面进行操作即可。这样复杂度就可以变为操作点的个数了 建树考虑虚树中的关键点：操作点本身以及他们两两间的lca，可以证明这个点数不会超过操作点的2倍。建树需要按照dfs序建立，然后依次插入各个节点，同时维护一个栈。每次加的时候如下操作：1、看栈的大小，如果只有一个点我们加入并返回。2、找到需要加入点和栈顶点的lca，如果lca等于栈顶说明在一条链上，我们把该点加入栈中即可。3、否则比较栈顶的前面一个元素，与lca比较dfs序，如果比lca的dfs序大，说明该次加入的点不在该链上，我们弹出栈顶，并连边。4、如果lca跟栈顶元素不同，则lca入栈，连边。5、该点入栈。 虚树一些细节2操作中，一般来说是需要把点加入栈中的，但某些题目，如本题，我们发现如果有一条链上的关键点，只需要离根节点最近的那个就行了，因为那个被割断后面必然被割断，所以本题中不用再在2操作中把点加入栈中。 本题建出虚树后，考虑维护原树中每个点到根节点路径上的最小边长度，直接在虚树上树形dp即可。代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef double db;typedef pair&lt;int, int&gt; pii;typedef vector&lt;int&gt; vi;typedef vector&lt;ll&gt; vl;typedef vector&lt;pii&gt; vp;const int inf = 1e9;const ll INF = 1e18;const db eps = 1e-10;#define fi first#define se second#define pb push_back#define eb emplace_back#define ep emplace#define mem(a) memset(a, 0, sizeof(a))#define copy(a, b) memcpy(a, b, sizeof(b))#define PA cout &lt;&lt; "pass\n"#define lowbit(x) (x &amp; -x)#define all(x) x.begin(), x.end()#define TM cout &lt;&lt; db(clock()) / CLOCKS_PER_SEC &lt;&lt; '\n'const int maxn = 3e5 + 233;vi g[maxn];vp G[maxn];int d[maxn], f[maxn][20], ord[maxn], dfn[maxn], dfs_clock, sta[maxn], top, n, m;ll mn[maxn];void dfs(int u, int fa)&#123; dfn[u] = ++dfs_clock; d[u] = d[fa] + 1; f[u][0] = fa; for(int i = 1; i &lt; 20; i++) f[u][i] = f[f[u][i - 1]][i - 1]; for(auto &amp;it : G[u])&#123; int v = it.fi, w = it.se; if(v == fa) continue; mn[v] = min(mn[u], (ll)w); dfs(v, u); &#125;&#125;int lca(int u, int v)&#123; if(d[u] &gt; d[v]) swap(u, v); for(int i = 19; i &gt;= 0; i--)&#123; if(d[f[v][i]] &gt;= d[u]) v = f[v][i]; &#125; if(u == v) return u; for(int i = 19; i &gt;= 0; i--)&#123; if(f[u][i] != f[v][i]) u = f[u][i], v = f[v][i]; &#125; return f[u][0];&#125;void insert(int u)&#123; if(top == 1)&#123; sta[++top] = u; return; &#125; int lc = lca(u, sta[top]); if(lc == sta[top]) return; while(top &gt; 1 &amp;&amp; dfn[lc] &lt;= dfn[sta[top - 1]])&#123; g[sta[top - 1]].eb(sta[top]); top--; &#125; if(lc != sta[top])&#123; g[lc].eb(sta[top]); sta[top] = lc; &#125; sta[++top] = u;&#125;bool cmp(int x, int y)&#123; return dfn[x] &lt; dfn[y];&#125;ll solve(int u)&#123; if(g[u].size() == 0) return mn[u]; ll res = 0; for(auto &amp;v : g[u])&#123; res += solve(v); &#125; g[u].clear(); return min(res, mn[u]);&#125;int main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); cin &gt;&gt; n; for (int i = 1; i &lt; n; ++i) &#123; int u, v, w; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; G[u].eb(v, w); G[v].eb(u, w); &#125; mn[1] = INF; dfs(1, 0); cin &gt;&gt; m; while(m--)&#123; int len; cin &gt;&gt; len; for(int j = 0; j &lt; len; j++) &#123; cin &gt;&gt; ord[j]; &#125; sort(ord, ord + len, cmp); top = 0; sta[++top] = 1; for(int j = 0; j &lt; len; j++) insert(ord[j]); while(top &gt; 0)&#123; g[sta[top - 1]].eb(sta[top]); top--; &#125; cout &lt;&lt; solve(1) &lt;&lt; '\n'; &#125; return 0;&#125;]]></content>
      <categories>
        <category>虚树</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Round 589 (Div. 2)-E(Another Filling the Grid)]]></title>
    <url>%2F2019%2F10%2F01%2FCodeforces-Round-589-Div-2-E-Another-Filling-the-Grid%2F</url>
    <content type="text"><![CDATA[链接：https://codeforces.com/contest/1228/problem/E思路：比赛前一天做了一个基本一模一样的二项式反演题，实属笑了。。考虑f[i][j]表示至少有i行最小值不为1，有j列最小值不为1，那么方案数我们可以求出来等于: f[i][j] = C_n^i * C_n^j * k^{n * n - (i + j) * n + i * j} * (k - 1)^{(i + j) * n - i * j}令g[i][j]表示恰好有i行最小值不为1，有j列最小值不为1，根绝二项式反演我们有： f[a][b] = \sum_{i = a}^n\sum_{j = b}^n C_i^a * C_j^b * g[i][j]那么根据二项式反演推到二维我们可以得知： g[a][b] = \sum_{i = a}^n\sum_{j = b}^n (-1)^{i + j - a - b} * C_i^a * C_j^b * f[i][j]带入得到本题的解，复杂度O(n^2logn)，预处理后可以变成O(n^2)如果想进一步优化，我们考虑里面那一层求和，看作二项式展开，我们把它合并回去，就可以得到O(nlogn)，这里不再细推。代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef double db;typedef pair&lt;int, int&gt; pii;typedef vector&lt;int&gt; vi;typedef vector&lt;ll&gt; vl;typedef vector&lt;pii&gt; vp;const int inf = 1e9;const ll INF = 1e18;const db eps = 1e-10;#define fi first#define se second#define pb push_back#define eb emplace_back#define ep emplace#define mem(a) memset(a, 0, sizeof(a))#define copy(a, b) memcpy(a, b, sizeof(b))#define PA cout &lt;&lt; "pass\n"#define lowbit(x) (x &amp; -x)#define all(x) x.begin(), x.end()#define TM cout &lt;&lt; db(clock()) / CLOCKS_PER_SEC &lt;&lt; '\n'int n, k;const int mod = 1e9 + 7;int dp[3030][3030];int C[3010][3010];void add(int &amp;x, int y)&#123; x += y; if(x &gt;= mod) x -= mod;&#125;void sub(int &amp;x, int y)&#123; x -= y; if(x &lt; 0) x += mod;&#125;int pow_mod(int q, int w)&#123; int ret = 1; while(w)&#123; if(w &amp; 1) ret = 1ll * ret * q % mod; q = 1ll * q * q % mod; w &gt;&gt;= 1; &#125; return ret;&#125;int main()&#123; C[0][0] = 1; for(int i = 1; i &lt;= 3000; i++)&#123; C[i][0] = 1; for(int j = 1; j &lt;= i; j++)&#123; add(C[i][j], C[i - 1][j]); add(C[i][j], C[i - 1][j - 1]); &#125; &#125; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); cin &gt;&gt; n &gt;&gt; k; for(int i = 0; i &lt;= n; i++)&#123; for(int j = 0; j &lt;= n; j++)&#123; dp[i][j] = 1ll * C[n][i] * C[n][j] % mod * pow_mod(k - 1, i * n + j * n - i * j) % mod * pow_mod(k, n * n - i * n - j * n + i * j) % mod; &#125; &#125; int res = 0; for(int i = 0; i &lt;= n; i++)&#123; for(int j = 0; j &lt;= n; j++)&#123; if((i + j) &amp; 1) sub(res, dp[i][j]); else add(res, dp[i][j]); &#125; &#125; cout &lt;&lt; res &lt;&lt; '\n'; return 0;&#125;]]></content>
      <categories>
        <category>二项式反演</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[loj-6503.「雅礼集训 2018 Day4」Magic]]></title>
    <url>%2F2019%2F09%2F28%2Floj-6503-%E3%80%8C%E9%9B%85%E7%A4%BC%E9%9B%86%E8%AE%AD-2018-Day4%E3%80%8DMagic%2F</url>
    <content type="text"><![CDATA[链接：https://loj.ac/problem/6503思路：设f(i)表示至少有i对的方案数，g(i)表示恰好i对方案数，可以得到 f(k) = \sum_{i = k}^n C_i^k * g(i)根据二项式反演: g(k) = \sum_{i = k}^n (-1)^{i - k} C_i^k * f(i)那么接下来考虑怎么求f(i)，这个其实挺不容易求的，因为各个球之间是不区别的。这里就要用到一个技巧，即先让相同颜色球之间有别区别，最后再处以(数量)！即可。那么我们可以想到，如果某种颜色有a个球，要b个对子，我们就是先放a - b个球上去，然后剩下b个球这些球里面插，每插一个数下一次就会多一个插的方案，那么对于b的方案数即为\frac{(a - 1)!}{(a - b - 1)!}，那么不同颜色的球之间相当于求一个卷积，用上一个题的启发式ntt即可，后面的方法都完全一样了。。代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef double db;typedef pair&lt;int, int&gt; pii;typedef vector&lt;int&gt; vi;typedef vector&lt;ll&gt; vl;typedef vector&lt;pii&gt; vp;const int inf = 1e9;const ll INF = 1e18;#define fi first#define se second#define pb push_back#define eb emplace_back#define ep emplace#define mem(a) memset(a, 0, sizeof(a))#define copy(a, b) memcpy(a, b, sizeof(b))#define PA cout &lt;&lt; "pass\n"#define lowbit(x) (x &amp; -x)#define all(x) x.begin(), x.end()#define TM cout &lt;&lt; db(clock() / CLOCKS_PER_SEC) &lt;&lt; '\n'const int mod = 998244353;const int maxn = 3e5 + 233;const int inv2 = (mod + 1) &gt;&gt; 1;int pow_mod(ll q, ll w)&#123; int ret = 1; while(w)&#123; if(w &amp; 1) ret = (ll)ret * q % mod; q = q * q % mod; w &gt;&gt;= 1; &#125; return ret;&#125;int add(int x, int y)&#123; x += y; if(x &gt;= mod) x -= mod; return x;&#125;int sub(int x, int y)&#123; x -= y; if(x &lt; 0) x += mod; return x;&#125;namespace Polynomial&#123; int c[maxn]; int rev[maxn]; int x[maxn], y[maxn]; int inv[maxn]; int f[maxn], g[maxn]; int lnb[maxn]; int getlen(int x)&#123; int len = 1; while(len &lt;= x) len &lt;&lt;= 1; return len; &#125; void ntt(int *a, int len, int on) &#123; int cnt = 0; while((1 &lt;&lt; cnt) &lt; len) ++cnt; for (int i = 0; i &lt; len; ++i) &#123; rev[i] = (rev[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; (cnt - 1)); if (i &lt; rev[i])swap(a[i], a[rev[i]]); &#125; for (int h = 1; h &lt; len; h &lt;&lt;= 1) &#123; int wn = pow_mod(3, (mod - 1) / (h &lt;&lt; 1)); for (int j = 0; j &lt; len; j += (h &lt;&lt; 1)) &#123; int w = 1; for (int k = j; k &lt; j + h; k++) &#123; int u = a[k] % mod; int t = 1ll * w * a[k + h] % mod; a[k] = add(u, t); a[k + h] = sub(u, t); w = 1ll * w * wn % mod; &#125; &#125; &#125; if (on == -1) &#123; for (int i = 1; i &lt; len / 2; i++) swap(a[i], a[len - i]); int inv = pow_mod(len, mod - 2); for (int i = 0; i &lt; len; i++) a[i] = (ll)a[i] * inv % mod; &#125; &#125; void mul(int *a, int *b, int *c, int n, int m)&#123; int len = getlen(n + m); for (int i = 0; i &lt;= n; ++i) &#123; x[i] = a[i]; &#125; for (int i = 0; i &lt;= m; ++i) &#123; y[i] = b[i]; &#125; ntt(x, len, 1), ntt(y, len, 1); for (int i = 0; i &lt; len; ++i) &#123; c[i] = (ll)x[i] * y[i] % mod; x[i] = y[i] = 0; &#125; ntt(c, len, -1); &#125;&#125;using namespace Polynomial;int n, m, k;int fac[maxn], facinv[maxn];struct node&#123; vector&lt;int&gt; r; node()&#123; r.clear(); &#125; node(vector&lt;int&gt; t)&#123; r = t; &#125; bool operator &lt;(const node &amp;x) const&#123; return r.size() &gt; x.r.size(); &#125;&#125;;priority_queue&lt;node&gt; q;int a[maxn], b[maxn];int C(int x, int y)&#123; if(x &lt; y) return 0; return 1ll * fac[x] * facinv[y] % mod * facinv[x - y] % mod;&#125;int main() &#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); fac[0] = facinv[0] = 1; for(int i = 1; i &lt; maxn; i++) fac[i] = 1ll * fac[i - 1] * i % mod; facinv[maxn - 1] = pow_mod(fac[maxn - 1], mod - 2); for(int i = maxn - 2; i; i--) facinv[i] = 1ll * facinv[i + 1] * (i + 1) % mod; cin &gt;&gt; m &gt;&gt; n &gt;&gt; k; //cout &lt;&lt; fac[10] &lt;&lt; ' ' &lt;&lt; C(10, 2) &lt;&lt; '\n'; int all = 1; for(int i = 1; i &lt;= m; i++)&#123; vector&lt;int&gt; tmp; int len; cin &gt;&gt; len; all = 1ll * all * pow_mod(fac[len], mod - 2) % mod; for(int j = 0; j &lt; len; j++)&#123; tmp.eb(1ll * C(len, j) * fac[len - 1] % mod * facinv[len - j - 1] % mod); &#125; q.ep(tmp); &#125; for(int i = 1; i &lt; m; i++)&#123; vi t1 = q.top().r; q.pop(); vi t2 = q.top().r; q.pop(); for(int i = 0; i &lt; t1.size(); i++) a[i] = t1[i]; for(int i = 0; i &lt; t2.size(); i++) b[i] = t2[i]; mul(a, b, c, t1.size() - 1, t2.size() - 1); vi tmp; for(int i = 0; i &lt; t1.size() + t2.size() - 1; i++) tmp.eb(c[i]); q.ep(tmp); &#125; vi t = q.top().r; q.pop(); for(int i = 0; i &lt; t.size(); i++) t[i] = 1ll * t[i] * fac[n - i] % mod * all % mod; for(int i = t.size(); i &lt;= n; i++) t.eb(0); int f = 1; int res = 0; for(int i = k; i &lt;= n; i++)&#123; res = (res + 1ll * f * C(i, k) * t[i] % mod + mod) % mod; f = -f; &#125; cout &lt;&lt; res &lt;&lt; '\n'; return 0;&#125;]]></content>
      <categories>
        <category>二项式反演</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2017-CCPC-HangZhou-G(Marriage)]]></title>
    <url>%2F2019%2F09%2F28%2F2017-CCPC-HangZhou-G-Marriage%2F</url>
    <content type="text"><![CDATA[链接：http://acm.hdu.edu.cn/showproblem.php?pid=6270思路：学了一天二项式反演总算感觉入门了？其实二项式反演感觉跟容斥原理非常类似 二项式反演概念反演即有两个函数f, g，如果知道其中一个函数和两个之间的关系，我们可以反演出另一个函数。通常二项式反演有如下两个形式：（其实网上的形式都是0 - n，但这个更广泛，因为你可以把其他不用地方的值定义为0就行了）1、f_n = \sum_{i = s}^t(-1)^i * C_t^i * g_i \Longleftrightarrow g_n = \sum_{i = s}^t (-1)^i * C_t^i * f_i2、f_n = \sum_{i = s}^t C_t^i * g_i \Longleftrightarrow g_n = \sum_{i = s}^t (-1)^{t - i} * C_t^i * f_i 二项式反演套路与充斥原理套路一样，一般来说我们直接算恰好k个的方案数不容易算出，但大于等于/小于等于k个的方案比较容易通过组合数/dp求出的时候，我们通过求出前缀/后缀和f，然后利用二项式反演得出恰好为k的答案g 一些例子1、错位排列错位排列是一个经典的容斥原理问题，但也是一个经典的二项式反演。我们设f(i)为最多错位排列i个的方案数，容易得出f(i) = i!，令g(i)为恰好错位排列i个的方案数，我们可以得到： f(k) = \sum_{i = 0}^kC_k^i * g(i)根据二项式反演我们可以得出： g(k) = \sum_{i = 0}^k (-1)^{k - i} * C_k^i * f(i) = \sum_{i = 0}^k (-1)^{k - i} * C_k^i * i!考虑枚举k - i: g(k) = \sum_{i = 0}^k(-1)^i\frac{k!}{i!} = k!\sum_{i = 0}^k\frac{(-1)^i}{i!}2、球染色问题问题：n个球，k种颜色，求满足相邻颜色不同，每种颜色至少出现一次的方案数。设f(i)为至少用了i种颜色且满足相邻不同色的方案数，g(i)为用了i种颜色且满足相邻不同色的方案数，那么有： f(p) = \sum_{i = p}^{k}C_i^p * g(i)根据二项式反演： g(p) = \sum_{i = p}^{k}(-1)^{i - p} * C_i^p * f(i)容易得出f(i) = i * (i - 1)^{n - 1}那么得到： g(p) = \sum_{i = p}^{k}(-1)^{i - p} * C_i^p * i * (i - 1) ^ {n - 1}本题在本题中，其实就是错位排列的推广版，我们考虑每个家庭内的近亲结婚方案，用f(i)表示至少有k对近亲结婚，g(i)表示恰好有k对近亲结婚，我们可以得到： f(k) = \sum_{i = k}^nC_i^k * g(i)根据二项式反演： g(k) = \sum_{i = k}^n(-1)^{i - k} * C_i^k * f(i)(注意代码里因为所有的C_n^0 = 1，所以省略了。。)考虑不同家庭直接方案组合是一个卷积的形式，ntt即可。但最坏可能要卷积很多次，我们考虑按哈夫曼树的形式来卷积，即每次取两个长度最短的来卷积，这样证明过复杂度是O(nlog^2n)的。或者分治ntt？（并不会。。）代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef double db;typedef pair&lt;int, int&gt; pii;typedef vector&lt;int&gt; vi;typedef vector&lt;ll&gt; vl;typedef vector&lt;pii&gt; vp;const int inf = 1e9;const ll INF = 1e18;#define fi first#define se second#define pb push_back#define eb emplace_back#define ep emplace#define mem(a) memset(a, 0, sizeof(a))#define copy(a, b) memcpy(a, b, sizeof(b))#define PA cout &lt;&lt; "pass\n"#define lowbit(x) (x &amp; -x)#define all(x) x.begin(), x.end()#define TM cout &lt;&lt; db(clock() / CLOCKS_PER_SEC) &lt;&lt; '\n'const int mod = 998244353;const int maxn = 3e5 + 233;const int inv2 = (mod + 1) &gt;&gt; 1;int pow_mod(ll q, ll w)&#123; int ret = 1; while(w)&#123; if(w &amp; 1) ret = (ll)ret * q % mod; q = q * q % mod; w &gt;&gt;= 1; &#125; return ret;&#125;int add(int x, int y)&#123; x += y; if(x &gt;= mod) x -= mod; return x;&#125;int sub(int x, int y)&#123; x -= y; if(x &lt; 0) x += mod; return x;&#125;namespace Polynomial&#123; int c[maxn]; int rev[maxn]; int x[maxn], y[maxn]; int inv[maxn]; int f[maxn], g[maxn]; int getlen(int x)&#123; int len = 1; while(len &lt;= x) len &lt;&lt;= 1; return len; &#125; void ntt(int *a, int len, int on) &#123; int cnt = 0; while((1 &lt;&lt; cnt) &lt; len) ++cnt; for (int i = 0; i &lt; len; ++i) &#123; rev[i] = (rev[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; (cnt - 1)); if (i &lt; rev[i])swap(a[i], a[rev[i]]); &#125; for (int h = 1; h &lt; len; h &lt;&lt;= 1) &#123; int wn = pow_mod(3, (mod - 1) / (h &lt;&lt; 1)); for (int j = 0; j &lt; len; j += (h &lt;&lt; 1)) &#123; int w = 1; for (int k = j; k &lt; j + h; k++) &#123; int u = a[k] % mod; int t = 1ll * w * a[k + h] % mod; a[k] = add(u, t); a[k + h] = sub(u, t); w = 1ll * w * wn % mod; &#125; &#125; &#125; if (on == -1) &#123; for (int i = 1; i &lt; len / 2; i++) swap(a[i], a[len - i]); int inv = pow_mod(len, mod - 2); for (int i = 0; i &lt; len; i++) a[i] = (ll)a[i] * inv % mod; &#125; &#125; void mul(int *a, int *b, int *c, int n, int m)&#123; int len = getlen(n + m); for (int i = 0; i &lt;= n; ++i) &#123; x[i] = a[i]; &#125; for (int i = 0; i &lt;= m; ++i) &#123; y[i] = b[i]; &#125; ntt(x, len, 1), ntt(y, len, 1); for (int i = 0; i &lt; len; ++i) &#123; c[i] = (ll)x[i] * y[i] % mod; x[i] = y[i] = 0; &#125; ntt(c, len, -1); &#125;&#125;using namespace Polynomial;int T, n;struct node&#123; vector&lt;int&gt; r; node()&#123; r.clear(); &#125; node(vector&lt;int&gt; x)&#123; r = x; &#125; bool operator &lt;(const node &amp;x) const&#123; return r.size() &gt; x.r.size(); &#125;&#125;;priority_queue&lt;node&gt; q;int fac[maxn], facinv[maxn];int a[maxn], b[maxn];int C(int x, int y)&#123; if(x &lt; y) return 0; return 1ll * fac[x] * facinv[y] % mod * facinv[x - y] % mod;&#125;int main() &#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); fac[0] = facinv[0] = 1; for(int i = 1; i &lt; maxn; i++) fac[i] = 1ll * fac[i - 1] * i % mod; facinv[maxn - 1] = pow_mod(fac[maxn - 1], mod - 2); for(int i = maxn - 2; i &gt;= 1; i--) facinv[i] = 1ll * facinv[i + 1] * (i + 1) % mod; cin &gt;&gt; T; while(T--)&#123; cin &gt;&gt; n; while(!q.empty()) q.pop(); int sum = 0; for (int i = 1; i &lt;= n; ++i) &#123; int x, y; cin &gt;&gt; x &gt;&gt; y; sum += x; vector&lt;int&gt; tmp; for(int j = 0; j &lt;= min(x, y); j++)&#123; tmp.push_back(1ll * C(x, j) * C(y, j) % mod * fac[j] % mod); &#125; q.push(node&#123;tmp&#125;); &#125; for(int i = 1; i &lt; n; i++)&#123; vi t1 = q.top().r; q.pop(); vi t2 = q.top().r; q.pop(); for(int i = 0; i &lt; t1.size(); i++) a[i] = t1[i]; for(int i = 0; i &lt; t2.size(); i++) b[i] = t2[i]; mul(a, b, c, t1.size() - 1, t2.size() - 1); vi tmp; for(int i = 0; i &lt;= t1.size() + t2.size() - 2; i++) tmp.eb(c[i]); q.push(node&#123;tmp&#125;); &#125; int res = 0; int f = 1; vi t = q.top().r; for(int i = 0; i &lt; t.size(); i++)&#123; res = (res + 1ll * f * t[i] % mod * fac[sum - i] % mod + mod) % mod; f = -f; &#125; cout &lt;&lt; res &lt;&lt; '\n'; &#125; return 0;&#125;]]></content>
      <categories>
        <category>二项式反演</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2017-CCPC-HangZhou-K(Master of Sequence)]]></title>
    <url>%2F2019%2F09%2F28%2F2017-CCPC-HangZhou-K-Master-of-Sequence%2F</url>
    <content type="text"><![CDATA[链接：http://acm.hdu.edu.cn/showproblem.php?pid=6274思路：一个对于整除题目很有启发性的题目：即把它分为整除部分和余数部分。考虑a最多1000，我们把每个数分为对a的整数部分和余数部分，那么对于询问3，我们二分一个t，可以得到他对每一个a的整数部分和余数部分，那么我们对于所有b维护一下他对所有a的余数个数的前缀和，这样我们在O(1)时间内可以查到某个t对于某个a需要减多少1。所以对于询问1和2我们暴力修改维护的前缀和，对于询问3，我们二分一个t，O(1000)内即可算出它的S答案。（这个题bit做询问3确实很容易T）代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef double db;typedef pair&lt;int, int&gt; pii;typedef vector&lt;int&gt; vi;typedef vector&lt;ll&gt; vl;typedef vector&lt;pii&gt; vp;const int inf = 1e9;const ll INF = 1e18;const db eps = 1e-10;#define fi first#define se second#define pb push_back#define eb emplace_back#define ep emplace#define mem(a) memset(a, 0, sizeof(a))#define copy(a, b) memcpy(a, b, sizeof(b))#define PA cout &lt;&lt; "pass\n"#define lowbit(x) (x &amp; -x)#define all(x) x.begin(), x.end()#define TM cout &lt;&lt; db(clock()) / CLOCKS_PER_SEC &lt;&lt; '\n'const int maxn = 1e5 + 233;int n, m, T;ll c[1010][1010], sum[1010];int cnt[1010];int a[maxn], b[maxn];inline int read() &#123; int X = 0, w = 0; char ch = 0; while (!isdigit(ch)) &#123; w |= ch == '-'; ch = getchar(); &#125; while (isdigit(ch)) X = (X &lt;&lt; 3) + (X &lt;&lt; 1) + (ch ^ 48), ch = getchar(); return w ? -X : X;&#125;inline void write(ll x) &#123; if (x &lt; 0) putchar('-'), x = -x; if (x &gt; 9) write(x / 10); putchar(x % 10 + '0');&#125;int main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); T = read(); while(T--)&#123; n = read(), m = read(); mem(c); mem(sum); mem(cnt); for (int i = 1; i &lt;= n; ++i) &#123; a[i] = read(); cnt[a[i]]++; &#125; for (int i = 1; i &lt;= n; ++i) &#123; b[i] = read(); sum[a[i]] += b[i] / a[i]; c[a[i]][b[i] % a[i]]++; &#125; for(int i = 1; i &lt;= 1000; i++)&#123; for(int j = 1000 - 1; j &gt;= 0; j--)&#123; c[i][j] += c[i][j + 1]; &#125; &#125; while(m--)&#123; int op, x, y; op = read(); x = read(); if(op == 1)&#123; y = read(); sum[a[x]] -= b[x] / a[x]; sum[y] += b[x] / y; for(int i = 0; i &lt;= b[x] % a[x]; i++) c[a[x]][i]--; for(int i = 0; i &lt;= b[x] % y; i++) c[y][i]++; cnt[a[x]]--, cnt[y]++; a[x] = y; &#125; if(op == 2)&#123; y = read(); sum[a[x]] -= b[x] / a[x]; sum[a[x]] += y / a[x]; for(int i = 0; i &lt;= b[x] % a[x]; i++) c[a[x]][i]--; for(int i = 0; i &lt;= y % a[x]; i++) c[a[x]][i]++; b[x] = y; &#125; if(op == 3)&#123; ll lb = 0, ub = 1e14, ans = 1e14; while(ub &gt;= lb)&#123; ll mid = ub + lb &gt;&gt; 1; ll tmp = 0; for(int i = 1; i &lt;= 1000; i++)&#123; tmp += mid / i * cnt[i]; tmp -= c[i][mid % i + 1]; tmp -= sum[i]; &#125; if(tmp &gt;= x) ub = mid - 1, ans = mid; else lb = mid + 1; &#125; write(ans); puts(""); &#125; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>二分</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2017-CCPC-HangZhou-H(Master of Connected Component)]]></title>
    <url>%2F2019%2F09%2F28%2F2017-CCPC-HangZhou-H-Master-of-Connected-Component%2F</url>
    <content type="text"><![CDATA[链接：http://acm.hdu.edu.cn/showproblem.php?pid=6271思路：第一反应是把第一棵树作为莫队的l，第二棵树作为莫队的r，然后在莫队上维护左右两个可撤销并查集，后来发现不太对。。。其实只需要把树当成序列就行了，即第一棵树按树的深度就行分块，提出关键点，第一棵树上不是关键点的点找最近的关键点祖先点，把询问放到那个点去。然后我们dfs第一棵树，到一个关键点后我们dfs一遍第二棵树，暴力处理掉所有这个关键点上的询问。由于第一棵树上每个点到最近关键点的距离不超过\sqrt(n)，所以每个点处理的复杂度不超过\sqrt(n)，宗的复杂度为O(n\sqrt(n)logn)代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef double db;typedef pair&lt;int, int&gt; pii;typedef vector&lt;int&gt; vi;typedef vector&lt;ll&gt; vl;typedef vector&lt;pii&gt; vp;const int inf = 1e9;const ll INF = 1e18;const db eps = 1e-10;#define fi first#define se second#define pb push_back#define eb emplace_back#define ep emplace#define mem(a) memset(a, 0, sizeof(a))#define copy(a, b) memcpy(a, b, sizeof(b))#define PA cout &lt;&lt; "pass\n"#define lowbit(x) (x &amp; -x)#define all(x) x.begin(), x.end()#define TM cout &lt;&lt; db(clock()) / CLOCKS_PER_SEC &lt;&lt; '\n'const int maxn = 1e4 + 233;int n, m, sz, T;vi g1[maxn], g2[maxn];int rk[maxn];int f[maxn];int bel[maxn];vi a;stack&lt;tuple&lt;int, int, int&gt; &gt; s;int cnt;pii p[2][maxn];int res[maxn];int par[maxn];int t;int find(int u)&#123; return u == f[u] ? u : find(f[u]);&#125;void dfs1(int u, int fa, int dep)&#123; par[u] = fa; if(dep % sz == 0)&#123; a.eb(u); bel[u] = u; &#125; else bel[u] = a.back(); for(auto &amp;v : g1[u])&#123; if(v == fa) continue; dfs1(v, u, dep + 1); &#125;&#125;bool add(int u, int v)&#123; int fx = find(u), fy = find(v); if(fx == fy) return false; if(rk[fx] &lt; rk[fy]) swap(fx, fy); f[fy] = fx; s.ep(fx, fy, rk[fx]); rk[fx] = max(rk[fx], rk[fy] + 1); cnt++; return true;&#125;void del()&#123; tuple&lt;int, int, int&gt; tmp = s.top(); s.pop(); f[get&lt;1&gt;(tmp)] = get&lt;1&gt;(tmp); rk[get&lt;0&gt;(tmp)] = get&lt;2&gt;(tmp); cnt--;&#125;void getans(int o, int u, int fa)&#123; bool ok = add(p[0][u].fi, p[0][u].se); if(u == fa) &#123; res[o] = m - cnt; if(ok) del(); return; &#125; getans(o, par[u], fa); if(ok) del();&#125;void dfs2(int u, int fa, int now)&#123; bool ok = add(p[1][u].fi, p[1][u].se); if(bel[u] == now)&#123; getans(u, u, now); &#125; for(auto &amp;v : g2[u])&#123; if(v == fa) continue; dfs2(v, u, now); &#125; if(ok) del();&#125;void solve(int u, int fa)&#123; bool ok = add(p[0][u].fi, p[0][u].se); if(t &lt; a.size() &amp;&amp; u == a[t])&#123; dfs2(1, 0, a[t]); t++; &#125; for(auto &amp;v : g1[u])&#123; if(v == fa) continue; solve(v, u); &#125; if(ok) del();&#125;void init()&#123; for (int i = 1; i &lt;= n; ++i) &#123; g1[i].clear(); g2[i].clear(); &#125; while(!s.empty()) s.pop(); a.clear(); t = 0; for (int i = 1; i &lt;= m; ++i) &#123; f[i] = i, rk[i] = 1; &#125;&#125;int main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); cin &gt;&gt; T; while(T--)&#123; cin &gt;&gt; n &gt;&gt; m; init(); sz = sqrt(n); for (int i = 1; i &lt;= n; ++i) &#123; cin &gt;&gt; p[0][i].fi &gt;&gt; p[0][i].se; &#125; for(int i = 1; i &lt; n; i++)&#123; int u, v; cin &gt;&gt; u &gt;&gt; v; g1[u].eb(v); g1[v].eb(u); &#125; for (int i = 1; i &lt;= n; ++i) &#123; cin &gt;&gt; p[1][i].fi &gt;&gt; p[1][i].se; &#125; for(int i = 1; i &lt; n; i++)&#123; int u, v; cin &gt;&gt; u &gt;&gt; v; g2[u].eb(v); g2[v].eb(u); &#125; dfs1(1, 0, 0); solve(1, 0); for(int i = 1; i &lt;= n; i++) cout &lt;&lt; res[i] &lt;&lt; '\n'; &#125; return 0;&#125;]]></content>
      <categories>
        <category>分块</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2017-CCPC-HangZhou-L(Mod, Xor and Everything)]]></title>
    <url>%2F2019%2F09%2F27%2F2017-CCPC-HangZhou-L-Mod-Xor-and-Everything%2F</url>
    <content type="text"><![CDATA[链接：http://acm.hdu.edu.cn/showproblem.php?pid=6275思路：这个题实在是卡常过于严重，，失去了这个题本身的意义。。这题涉及了两个比较常见的套路：1、n\ mod \ i = n - \lfloor\frac{n}{i}\rfloor * i2、x_1 \oplus x_2 \oplus x_3 \cdots \oplus x_n = \sum_{i = 1} ^ {2^i]]></content>
      <categories>
        <category>类欧</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2017-CCPC-HangZhou-E(Master of Subgraph)]]></title>
    <url>%2F2019%2F09%2F27%2F2017-CCPC-HangZhou-E-Master-of-Subgraph%2F</url>
    <content type="text"><![CDATA[链接：http://acm.hdu.edu.cn/showproblem.php?pid=6268思路：lls vp的时候给我说了个O(nm)，结果后来发现跟省赛的链合并想混了，链合并可以树形背包做到O(nm)，但这是两个背包合并普通做法就只能O(nm)了，所以我们只能考虑让链和背包合并，这时候就是点分治的作用域了。考虑每次处理某一个重心(必须选)及其子树，那么到子树内一个点更新一次背包，这样复杂度O(nmlogn)，但这样不太能通过，我们考虑这个背包是01背包，可以用bitset来优化，每次进去直接用移位运算更新背包，这样复杂度为O(nlogn\frac{m}{w})，就能通过了。代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef double db;typedef pair&lt;int, int&gt; pii;typedef vector&lt;int&gt; vi;typedef vector&lt;ll&gt; vl;typedef vector&lt;pii&gt; vp;const int inf = 1e9;const ll INF = 1e18;const db eps = 1e-10;#define fi first#define se second#define pb push_back#define eb emplace_back#define ep emplace#define mem(a) memset(a, 0, sizeof(a))#define copy(a, b) memcpy(a, b, sizeof(b))#define PA cout &lt;&lt; "pass\n"#define lowbit(x) (x &amp; -x)#define all(x) x.begin(), x.end()#define TM cout &lt;&lt; db(clock()) / CLOCKS_PER_SEC &lt;&lt; '\n'const int maxn = 3010;bitset&lt;100010&gt; mp[maxn], res;int n, m, T;vi G[maxn];bool vis[maxn];int w[maxn], son[maxn], rt, sz[maxn], size;void init()&#123; rt = 0; son[0] = 1e9; for(int i = 1; i &lt;= n; i++) G[i].clear(), vis[i] = 0; res.reset();&#125;void getroot(int u, int f)&#123; son[u] = 0; sz[u] = 1; for(auto &amp;v : G[u])&#123; if(v == f || vis[v]) continue; getroot(v, u); sz[u] += sz[v]; son[u] = max(son[u], sz[v]); &#125; son[u] = max(son[u], size - sz[u]); if(son[u] &lt; son[rt]) rt = u;&#125;void solve(int u, int f)&#123; mp[u] &lt;&lt;= w[u]; for(auto &amp;v : G[u])&#123; if(v == f || vis[v]) continue; mp[v] = mp[u]; solve(v, u); mp[u] |= mp[v]; &#125;&#125;void dfs(int u)&#123; vis[u] = 1; mp[u] = 1; solve(u, 0); res |= mp[u]; for(auto &amp;v : G[u])&#123; if(vis[v]) continue; size = sz[v]; rt = 0; getroot(v, 0); dfs(rt); &#125;&#125;int main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); cin &gt;&gt; T; while(T--)&#123; cin &gt;&gt; n &gt;&gt; m; init(); for (int i = 1; i &lt; n; ++i) &#123; int u, v; cin &gt;&gt; u &gt;&gt; v; G[u].eb(v); G[v].eb(u); &#125; for (int i = 1; i &lt;= n; ++i) &#123; cin &gt;&gt; w[i]; &#125; getroot(1, 0); dfs(rt); for(int i = 1; i &lt;= m; i++) cout &lt;&lt; res[i]; cout &lt;&lt; '\n'; &#125; return 0;&#125;]]></content>
      <categories>
        <category>点分治</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Round 588 (Div. 2)-E(Kamil and Making a Stream)]]></title>
    <url>%2F2019%2F09%2F24%2FCodeforces-Round-588-Div-2-E-Kamil-and-Making-a-Stream%2F</url>
    <content type="text"><![CDATA[链接：https://codeforces.com/contest/1230/problem/E思路：有一个比较重要的结论，gcd在一段连续的序列中最多变化log次。我的做法是在树上倍增，维护向上倍增的gcd，从一个点开始倍增找到gcd变化的点，跳过去，中间一段的值都是一样的一起统计，这样复杂度O(nlognlog10^{12})其实有个更简单的做法，因为一段只有log个变化，就是有log个不同的取值，直接用map维护每个点开始向上的gcd可能取值，只有log个，直接从父节点更新下来统计答案即可。倍增1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef double db;typedef pair&lt;int, int&gt; pii;typedef vector&lt;int&gt; vi;typedef vector&lt;ll&gt; vl;typedef vector&lt;pii&gt; vp;const int inf = 1e9;const ll INF = 1e18;const db eps = 1e-10;#define fi first#define se second#define pb push_back#define eb emplace_back#define ep emplace#define mem(a) memset(a, 0, sizeof(a))#define copy(a, b) memcpy(a, b, sizeof(b))#define PA cout &lt;&lt; "pass\n"#define lowbit(x) (x &amp; -x)#define all(x) x.begin(), x.end()#define TM cout &lt;&lt; db(clock()) / CLOCKS_PER_SEC &lt;&lt; '\n'const int maxn = 1e5 + 233;int f[maxn][20];ll g[maxn][20];ll x[maxn];vi G[maxn];int dep[maxn];int n;const int mod = 1e9 + 7;void dfs(int u, int fa)&#123; dep[u] = dep[fa] + 1; g[u][0] = __gcd(x[u], x[fa]); f[u][0] = fa; for(int i = 1; i &lt; 20; i++) g[u][i] = __gcd(g[u][i - 1], g[f[u][i - 1]][i - 1]), f[u][i] = f[f[u][i - 1]][i - 1]; for(auto &amp;v : G[u])&#123; if(v == fa) continue; dfs(v, u); &#125;&#125;int main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); cin &gt;&gt; n; for (int i = 1; i &lt;= n; ++i) &#123; cin &gt;&gt; x[i]; &#125; for (int i = 1; i &lt; n; ++i) &#123; int u, v; cin &gt;&gt; u &gt;&gt; v; G[u].eb(v); G[v].eb(u); &#125; dfs(1, 0); ll res = 0; for(int i = 1; i &lt;= n; i++)&#123; int p = i; ll now = x[p]; while(p)&#123; int t = p; for(int i = 19; i &gt;= 0; i--)&#123; if(__gcd(now, g[p][i]) == now) p = f[p][i]; &#125; p = f[p][0]; res = (res + now % mod * (dep[t] - dep[p])) % mod; now = __gcd(now, x[p]); &#125; &#125; cout &lt;&lt; res &lt;&lt; '\n'; return 0;&#125; 更简单的做法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef double db;typedef pair&lt;int, int&gt; pii;typedef vector&lt;int&gt; vi;typedef vector&lt;ll&gt; vl;typedef vector&lt;pii&gt; vp;const int inf = 1e9;const ll INF = 1e18;const db eps = 1e-10;#define fi first#define se second#define pb push_back#define eb emplace_back#define ep emplace#define mem(a) memset(a, 0, sizeof(a))#define copy(a, b) memcpy(a, b, sizeof(b))#define PA cout &lt;&lt; "pass\n"#define lowbit(x) (x &amp; -x)#define all(x) x.begin(), x.end()#define TM cout &lt;&lt; db(clock()) / CLOCKS_PER_SEC &lt;&lt; '\n'const int maxn = 1e5 + 233;vi G[maxn];map&lt;ll, ll&gt; mp[maxn];ll v[maxn];int n;ll res;const int mod = 1e9 + 7;void dfs(int u, int fa)&#123; for(auto &amp;it : mp[fa])&#123; mp[u][__gcd(it.fi, v[u])] += it.se; res = (res + __gcd(it.fi, v[u]) * it.se) % mod; &#125; mp[u][v[u]]++; res = (res + v[u]) % mod; for(auto &amp;v : G[u])&#123; if(v == fa) continue; dfs(v, u); &#125;&#125;int main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); cin &gt;&gt; n; for (int i = 1; i &lt;= n; ++i) &#123; cin &gt;&gt; v[i]; &#125; for (int i = 1; i &lt; n; ++i) &#123; int u, v; cin &gt;&gt; u &gt;&gt; v; G[u].eb(v); G[v].eb(u); &#125; dfs(1, 0); cout &lt;&lt; res &lt;&lt; '\n'; return 0;&#125;]]></content>
      <categories>
        <category>思维</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Educational Codeforces Round 73 (Rated for Div.2)-F(Choose a Square)]]></title>
    <url>%2F2019%2F09%2F24%2FEducational-Codeforces-Round-73-Rated-for-Div-2-F-Choose-a-Square%2F</url>
    <content type="text"><![CDATA[链接：https://codeforces.com/contest/1221/problem/F思路：由于是在y = x上的正方形，我们可以考虑把所有点都放到直线的下方，对结果不会造成影响。接下来我们考虑以某一个x坐标i为结束，那么我们要在前面中找到一个j，使得sum[i] - sum[j - 1] - i + j的值最大。发现可以把i和j分开，那么我们在线段树上每一个点维护一个(后缀和 - j)即可，每次先更新最大值，然后找到这个i上所有要加入的点，线段树上对每个点区间加更新即可。代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef double db;typedef pair&lt;ll, ll&gt; pii;typedef vector&lt;int&gt; vi;typedef vector&lt;ll&gt; vl;typedef vector&lt;pii&gt; vp;const int inf = 1e9;const ll INF = 1e18;const db eps = 1e-10;#define fi first#define se second#define pb push_back#define eb emplace_back#define ep emplace#define mem(a) memset(a, 0, sizeof(a))#define copy(a, b) memcpy(a, b, sizeof(b))#define PA cout &lt;&lt; "pass\n"#define lowbit(x) (x &amp; -x)#define all(x) x.begin(), x.end()#define TM cout &lt;&lt; db(clock()) / CLOCKS_PER_SEC &lt;&lt; '\n'vi px, py;const int maxn = 1e6 + 233;pii mx[maxn &lt;&lt; 2];ll tag[maxn &lt;&lt; 2];void pushup(int o)&#123; mx[o] = max(mx[o &lt;&lt; 1], mx[o &lt;&lt; 1 | 1]);&#125;void pushdown(int o)&#123; if(tag[o])&#123; mx[o &lt;&lt; 1].fi += tag[o]; mx[o &lt;&lt; 1 | 1].fi += tag[o]; tag[o &lt;&lt; 1] += tag[o]; tag[o &lt;&lt; 1 | 1] += tag[o]; tag[o] = 0; &#125;&#125;void build(int o, int l, int r)&#123; tag[o] = 0; if(l == r)&#123; mx[o] = pii(py[l], l); return; &#125; int mid = l + r &gt;&gt; 1; build(o &lt;&lt; 1, l, mid); build(o &lt;&lt; 1 | 1, mid + 1, r); pushup(o);&#125;void update(int o, int tl, int tr, int l, int r, int v)&#123; if(l &gt; tr || tl &gt; r) return; if(l &lt;= tl &amp;&amp; tr &lt;= r) &#123; mx[o].fi += v; tag[o] += v; return; &#125; pushdown(o); int mid = tl + tr &gt;&gt; 1; update(o &lt;&lt; 1, tl, mid, l, r, v); update(o &lt;&lt; 1 | 1, mid + 1, tr, l, r, v); pushup(o);&#125;pii query(int o, int tl, int tr, int l, int r)&#123; if(l &gt; tr || tl &gt; r) return pii(-INF, -INF); if(l &lt;= tl &amp;&amp; tr &lt;= r) return mx[o]; pushdown(o); int mid = tl + tr &gt;&gt; 1; return max(query(o &lt;&lt; 1, tl, mid, l, r), query(o &lt;&lt; 1 | 1 , mid + 1, tr, l, r));&#125;vp G[maxn];int n;int x[maxn], y[maxn], z[maxn];int pl, pr;int main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); scanf("%d", &amp;n); for (int i = 1; i &lt;= n; ++i) &#123; scanf("%d %d %d", &amp;x[i], &amp;y[i], &amp;z[i]); if(x[i] &lt; y[i]) swap(x[i], y[i]); py.eb(y[i]); py.eb(x[i]); px.eb(x[i]); &#125; py.eb(-1); px.eb(-1); sort(all(py)); sort(all(px)); px.resize(unique(all(px)) - px.begin()); py.resize(unique(all(py)) - py.begin()); for (int i = 1; i &lt;= n; ++i) &#123; int t1 = lower_bound(all(px), x[i]) - px.begin(); int t2 = lower_bound(all(py), y[i]) - py.begin(); G[t1].eb(t2, z[i]); &#125; build(1, 1, py.size() - 1); ll res = 0; for (int i = 1; i &lt; px.size(); ++i) &#123; for(int j = 0; j &lt; G[i].size(); j++)&#123; pii t = G[i][j]; update(1, 1, py.size() - 1, 1, t.fi, t.se); &#125; int t = lower_bound(all(py), px[i]) - py.begin(); pii now = query(1, 1, py.size() - 1, 1, t); if(res &lt; now.fi - px[i])&#123; res = now.fi - px[i]; pl = py[now.se]; pr = px[i]; &#125; &#125; if(res == 0) printf("0\n1000000001 1000000001 1000000001 1000000001\n"); else printf("%lld\n%d %d %d %d\n", res, pl, pl, pr, pr); return 0;&#125;]]></content>
      <categories>
        <category>线段树</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2015 ACM-ICPC Asia Regional Contest Shanghai Site-E(Expection-of-String)]]></title>
    <url>%2F2019%2F09%2F24%2F2015%20ACM-ICPC%20Asia%20Regional%20Contest%20Shanghai%20Site-E(Expection-of-String)%2F</url>
    <content type="text"><![CDATA[链接：http://acm.hdu.edu.cn/showproblem.php?pid=5576思路：实在是没想到能把按位考虑做到这么淋漓尽致。考虑到k次操作后，没办法存下最终两个数的状态，但是我们按位考虑，每次只考虑一个三元组(a, b, c)，然后对他们进行数位dp，当且仅当k次交换后b位置位答案为ac，否则为0。这样我们可以求出k次操作所有在a c两个位置为数字，b为乘号的方案数，再根据位置乘一个10的幂，最后把所有贡献加起来即可。代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef double db;typedef pair&lt;int, int&gt; pii;typedef vector&lt;int&gt; vi;typedef vector&lt;ll&gt; vl;typedef vector&lt;pii&gt; vp;const int inf = 1e9;const ll INF = 1e18;const db eps = 1e-10;#define fi first#define se second#define pb push_back#define eb emplace_back#define ep emplace#define mem(a) memset(a, 0, sizeof(a))#define copy(a, b) memcpy(a, b, sizeof(b))#define PA cout &lt;&lt; "pass\n"#define lowbit(x) (x &amp; -x)#define all(x) x.begin(), x.end()#define TM cout &lt;&lt; db(clock()) / CLOCKS_PER_SEC &lt;&lt; '\n'char s[100];int n, k, T;const int mod = 1e9 + 7;int dp[55][15][15][15];int cnt[15];int t[100];ll fac[60];void add(int &amp;x, int y)&#123; x += y; if(x &gt;= mod) x -= mod;&#125;int dfs(int pos, int a, int b, int c)&#123; if(dp[pos][a][b][c] != -1) return dp[pos][a][b][c]; if(pos == k)&#123; if(b == 10) return dp[pos][a][b][c] = a * c; return dp[pos][a][b][c] = 0; &#125; int res = 0; add(res, dfs(pos + 1, b, a, c)); add(res, dfs(pos + 1, a, c, b)); add(res, dfs(pos + 1, c, b, a)); add(res, 1ll * (n - 3) * (n - 4) / 2 * dfs(pos + 1, a, b, c) % mod); int num[15]; copy(num, cnt); num[a]--, num[b]--, num[c]--; for(int i = 0; i &lt;= 10; i++)&#123; add(res, 1ll * num[i] * dfs(pos + 1, i, b, c) % mod); add(res, 1ll * num[i] * dfs(pos + 1, a, i, c) % mod); add(res, 1ll * num[i] * dfs(pos + 1, a, b, i) % mod); &#125; return dp[pos][a][b][c] = res;&#125;int main()&#123; scanf("%d", &amp;T); int kase = 0; fac[0] = 1; for(int i = 1; i &lt; 60; i++) fac[i] = fac[i - 1] * 10 % mod; while(T--)&#123; scanf("%d %s", &amp;k, s + 1); n = strlen(s + 1); memset(dp, -1, sizeof(dp)); mem(cnt); for(int i = 1; i &lt;= n; i++)&#123; if(s[i] == '*') t[i] = 10; else t[i] = s[i] - '0'; cnt[t[i]]++; &#125; int res = 0; for(int i = 1; i &lt;= n; i++)&#123; for(int j = i + 1; j &lt;= n; j++)&#123; for(int p = j + 1; p &lt;= n; p++)&#123; add(res, 1ll * fac[j - i - 1] * dfs(0, t[i], t[j], t[p]) % mod * fac[n - p] % mod); &#125; &#125; &#125; printf("Case #%d: %d\n", ++kase, res); &#125; return 0;&#125;]]></content>
      <categories>
        <category>数位dp</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2015 ACM-ICPC Asia Regional Contest Shanghai Site-I(Infinity-Point-Sets)]]></title>
    <url>%2F2019%2F09%2F23%2F2015%20ACM-ICPC%20Asia%20Regional%20Contest%20Shanghai%20Site-I(Infinity-Point-Sets)%2F</url>
    <content type="text"><![CDATA[链接：http://acm.hdu.edu.cn/showproblem.php?pid=5581思路：通过画图观察发现，四个点以下都是可以的，我们只用考察五个点及其以上的情况。发现最坏的情况是一条线加上两侧各一个点，再多就不行了。那么我们需要统计的就是：1、三点共线及以上 + 两侧各一个点。2、四点共线及以上 + 非线上任意一点。3、五点共线。为了不重复，我们考虑枚举每个点后，只处理在他上方的（y值相等必须x大于），但我们仍然需要对所以处理，因为外面选点是对于所有点而言的。这样总的情况上不会重复计算，但是这样可能出线下图额外算重的情况:我们只需要在上半部分旋转的时候统计一下直线两个方向分别的点数，然后组合数去重以下即可。代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef double db;typedef pair&lt;int, int&gt; pii;typedef vector&lt;int&gt; vi;typedef vector&lt;ll&gt; vl;typedef vector&lt;pii&gt; vp;const int inf = 1e9;const ll INF = 1e18;const db eps = 1e-10;#define fi first#define se second#define pb push_back#define eb emplace_back#define ep emplace#define mem(a) memset(a, 0, sizeof(a))#define copy(a, b) memcpy(a, b, sizeof(b))#define PA cout &lt;&lt; "pass\n"#define lowbit(x) (x &amp; -x)#define all(x) x.begin(), x.end()#define TM cout &lt;&lt; db(clock()) / CLOCKS_PER_SEC &lt;&lt; '\n'int dcmp(db x) &#123; return x&lt;-eps?-1:x&gt;eps;&#125;typedef struct P &#123; db x, y; P(db x = 0, db y = 0) : x(x), y(y) &#123;&#125; P operator+(P r)&#123;return P(x+r.x,y+r.y);&#125; P operator-(P r)&#123;return P(x-r.x,y-r.y);&#125; P operator*(db r)&#123;return P(x*r,y*r);&#125; P operator/(db r)&#123;return P(x/r,y/r);&#125; bool operator&lt;(const P &amp;r)const&#123;return x&lt;r.x||(x==r.x&amp;&amp;y&lt;r.y);&#125; bool operator==(const P &amp;r)const&#123;return dcmp(x-r.x)==0&amp;&amp;dcmp(y-r.y)==0;&#125; bool upper()&#123;return y &gt; 0 || (y == 0 &amp;&amp; x &gt; 0);&#125; void read()&#123; scanf("%lf %lf", &amp;x, &amp;y); &#125; void print()&#123; printf("%.2f %.2f\n", x, y);&#125;&#125;V;db Cross(V A, V B) &#123; return A.x*B.y - A.y*B.x; &#125;bool cmp(P a, P b)&#123; return Cross(a, b) &gt; 0;&#125;bool cmp2(P a, P b)&#123; if(a.upper() != b.upper()) return a.upper() &gt; b.upper(); return Cross(a, b) &gt; 0;&#125;db Dot(V A, V B) &#123; return A.x*B.x + A.y*B.y; &#125;int T, n;const int maxn = 2e3 + 233;P r[maxn];P tmp[maxn], tmp2[maxn];const int mod = 1e9 + 7;int c[maxn][maxn];int pow_mod(int q, int w)&#123; int ret = 1; while(w)&#123; if(w &amp; 1) ret = (ll) ret * q % mod; q = (ll) q * q % mod; w &gt;&gt;= 1; &#125; return ret;&#125;int main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int kase = 0; c[0][0] = 1; for(int i = 1; i &lt;= 1000; i++)&#123; c[i][0] = 1; for(int j = 1; j &lt;= i; j++) c[i][j] = (c[i - 1][j - 1] + c[i - 1][j]) % mod; &#125; cin &gt;&gt; T; while(T--)&#123; cin &gt;&gt; n; for (int i = 1; i &lt;= n; ++i) &#123; cin &gt;&gt; r[i].x &gt;&gt; r[i].y; &#125; ll res = 0; for(int i = 1; i &lt;= n; i++)&#123; int len = 0; int len2 = 0; for(int j = 1; j &lt;= n; j++)&#123; if(i == j) continue; tmp2[++len2] = r[j] - r[i]; if((r[j].y &gt; r[i].y) || (r[j].y == r[i].y &amp;&amp; r[j].x &gt; r[i].x)) tmp[++len] = r[j] - r[i]; &#125; sort(tmp2 + 1, tmp2 + len2 + 1, cmp2); sort(tmp + 1, tmp + len + 1, cmp); int now = 1; int pre = 0; for(int j = len2 + 1; j &lt;= 2 * len2; j++) tmp2[j] = tmp[j - len2]; int k = 1, j = 1; vector&lt;int&gt; d; int sum = 0; while(now &lt;= len)&#123; int cnt = 1; while(j &lt;= len2 &amp;&amp; dcmp(Cross(tmp2[j], tmp[now])) != 0) j++; int t = j; while(j + 1 &lt;= len2 &amp;&amp; dcmp(Cross(tmp2[j], tmp2[j + 1])) == 0 &amp;&amp; dcmp(Dot(tmp2[j], tmp2[j + 1])) &gt; 0) j++; if(k &lt;= j) k = j + 1; while(k &lt; t + len2 &amp;&amp; dcmp(Cross(tmp2[t], tmp2[k])) &gt; 0) k++; int p = k; while(k &lt; t + len2 &amp;&amp; dcmp(Cross(tmp2[t], tmp2[k])) == 0 &amp;&amp; dcmp(Dot(tmp2[t], tmp2[k])) &lt; 0) k++; while(now + 1 &lt;= len &amp;&amp; dcmp(Cross(tmp[now], tmp[now + 1])) == 0) cnt++, now++; d.push_back(1ll * (j - t + 1) * (k - p) % mod); sum = (sum + 1ll * (j - t + 1) * (k - p) % mod); if(cnt &gt;= 2) res = (res + (1ll * pow_mod(2, cnt) - c[cnt][0] - c[cnt][1] + 2 * mod) % mod * (t + len2 - k) % mod * (p - j - 1) % mod) % mod; if(cnt &gt;= 3) res = (res + (1ll * pow_mod(2, cnt) - c[cnt][0] - c[cnt][1] - c[cnt][2]) % mod * (t + len2 - k + p - j - 1) % mod + mod) % mod; if(cnt &gt;= 4) res = (res + (1ll * pow_mod(2, cnt) - c[cnt][0] - c[cnt][1] - c[cnt][2] - c[cnt][3]) % mod + mod) % mod; now++; pre += cnt; &#125; int ans = 0; for(j = 0; j &lt; d.size(); j++)&#123; ans = (ans + 1ll * (sum - d[j] + mod) * d[j]) % mod; &#125; ans = (ll)ans * pow_mod(2, mod - 2) % mod; res = (res - ans + mod) % mod; &#125; res = (res + c[n][1] + c[n][2] + c[n][3] + c[n][4]) % mod; cout &lt;&lt; "Case #" &lt;&lt; ++kase &lt;&lt; ": " &lt;&lt; res &lt;&lt; '\n'; &#125; return 0;&#125;]]></content>
      <categories>
        <category>计算几何</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2015 ACM-ICPC World Finals-J(Tile Cutting)]]></title>
    <url>%2F2019%2F09%2F19%2F2015-ACM-ICPC-World-Finals-J-Tile-Cutting%2F</url>
    <content type="text"><![CDATA[链接：https://codeforces.com/gym/101239/attachments思路：感觉这个题一开始看到很容易没思路，然后就容易放弃。仔细分析观察后发现并不难。首先我们假设四个角的两种三角形边长分别为(a, b)和(c, d)(a + c = x, b + d = y)，那么我们发现中间的面积等于(a + c) * (b + d) - ac - bd = ad + bc = res，发现ad和bc是同种方案数，我们可以通过枚举因子在O(nlogn)处理出来，对于res的方案数，就是求所有\sum(方案数ad) * (方案数bc) (ad + bc = res)，发现这不就是xy方案数的多项式跟自己做一次卷积吗，然后求x^{res}的系数就好了。区间最大值就随便拿什么维护一下就好了吧，这里用的st表。。。代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126#include&lt;bits/stdc++.h&gt;using namespace std; typedef long long ll;typedef double db;typedef pair&lt;int, int&gt; pii;typedef vector&lt;int&gt; vi;typedef vector&lt;ll&gt; vl;typedef vector&lt;pii&gt; vp;const int inf = 1e9;const ll INF = 1e18;const db eps = 1e-10; #define fi first#define se second#define pb push_back#define eb emplace_back#define ep emplace#define mem(a) memset(a, 0, sizeof(a))#define copy(a, b) memcpy(a, b, sizeof(b))#define PA cout &lt;&lt; "pass\n"#define lowbit(x) (x &amp; -x)#define all(x) x.begin(), x.end()#define TM cout &lt;&lt; db(clock()) / CLOCKS_PER_SEC &lt;&lt; '\n' const int maxn = 2e6 + 233; const db pi = acos(-1);int n, m;ll c[maxn];int rev[maxn]; struct cp &#123; db x, y; inline cp(db a = 0, db b = 0) : x(a), y(b) &#123;&#125; inline cp operator+(const cp &amp;r) const &#123; return cp(x + r.x, y + r.y); &#125; inline cp operator-(const cp &amp;r) const &#123; return cp(x - r.x, y - r.y); &#125; inline cp operator*(const cp &amp;r) const &#123; return cp(x * r.x - y * r.y, x * r.y + y * r.x); &#125; inline cp conj() &#123; return cp(x, -y); &#125;&#125;a[maxn], b[maxn]; void fft(cp *a, int n, int f) &#123; int i, j, k; for (i = j = 0; i &lt; n; ++i) &#123; if (i &lt; rev[i]) swap(a[i], a[rev[i]]); for (k = n &gt;&gt; 1; (j ^= k) &lt; k; k &gt;&gt;= 1); &#125; for (i = 1; i &lt; n; i &lt;&lt;= 1) &#123; cp wn(cos(pi / i), f * sin(pi / i)); for (j = 0; j &lt; n; j += i &lt;&lt; 1) &#123; cp w(1, 0); for (k = 0; k &lt; i; ++k, w = w * wn) &#123; cp x = a[j + k], y = w * a[i + j + k]; a[j + k] = x + y; a[i + j + k] = x - y; &#125; &#125; &#125; if (f == -1) for (i = 0; i &lt; n; ++i) a[i].x /= n;&#125; void solve() &#123; int i, j, k; for (k = 1; k &lt;= m + n; k &lt;&lt;= 1); j = __builtin_ctz(k) - 1; for (i = 0; i &lt; k; i++)rev[i] = rev[i &gt;&gt; 1] &gt;&gt; 1 | ((i &amp; 1) &lt;&lt; j); fft(a, k, 1); cp Q(0, -0.25); for (i = 0, j; i &lt; k; ++i) j = (k - i) &amp; (k - 1), b[i] = (a[i] * a[i] - (a[j] * a[j]).conj()) * Q; fft(b, k, -1); for (i = 0; i &lt;= n + m; ++i) &#123; c[i] = ll(b[i].x + 0.2); &#125;&#125; ll d[maxn][25]; int MAX(int x, int y)&#123; if(c[x] &lt; c[y]) return y; return x;&#125; void RMQ_init() &#123; for (int i = 1; i &lt;= n; i++)d[i][0] = i; for (int j = 1; (1 &lt;&lt; j) &lt;= n; j++) for (int i = 1; i + (1 &lt;&lt; j) - 1 &lt;= n; i++) d[i][j] = MAX(d[i][j - 1], d[i + (1 &lt;&lt; (j - 1))][j - 1]);&#125; int RMQ(int l,int r) &#123; if (l &gt; r)swap(l, r); int k = 0; while (1 &lt;&lt; (k + 1) &lt;= r - l + 1)k++; return MAX(d[l][k], d[r - (1 &lt;&lt; k) + 1][k]);&#125; int T, l, r; int main()&#123; n = m = 500000; for(int i = 1; i &lt;= 500000; i++)&#123; for(int j = 1; i * j &lt;= 500000; j++)&#123; a[i * j].x++; &#125; &#125; for (int i = 0; i &lt;= 500000; ++i) &#123; a[i].y = a[i].x; &#125; solve(); RMQ_init(); cin &gt;&gt; T; while(T--)&#123; cin &gt;&gt; l &gt;&gt; r; cout &lt;&lt; RMQ(l, r) &lt;&lt; ' ' &lt;&lt; c[RMQ(l, r)] &lt;&lt; '\n'; &#125; return 0;&#125;]]></content>
      <categories>
        <category>FFT</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2015 ACM-ICPC World Finals-I(Ship Traffic)]]></title>
    <url>%2F2019%2F09%2F19%2F2015-ACM-ICPC-World-Finals-I-Ship-Traffic%2F</url>
    <content type="text"><![CDATA[链接：https://codeforces.com/gym/101239/attachments思路：对于我方船的出发时间为基准时间，考虑每个船都对应了时间数轴上一段区间不可行，我们把这些时间点以及它前后增加eps点（用以区分区间）拉出来离散化，然后对于某个航道的船按顺序排序，然后两船之间可能存在一段区间是可行的，我们把它在数轴上差分一下，最后找到所有数轴上和 = 航道数的区间，求最大连续的就是答案（注意可能船贯穿两侧，所以有一侧一定是无效的，可以直接舍去）。代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include&lt;bits/stdc++.h&gt;using namespace std; typedef long long ll;typedef double db;typedef pair&lt;int, int&gt; pii;typedef vector&lt;int&gt; vi;typedef vector&lt;ll&gt; vl;typedef vector&lt;pii&gt; vp;const int inf = 1e9;const ll INF = 1e18;const db eps = 1e-10; #define fi first#define se second#define pb push_back#define eb emplace_back#define ep emplace#define mem(a) memset(a, 0, sizeof(a))#define copy(a, b) memcpy(a, b, sizeof(b))#define PA cout &lt;&lt; "pass\n"#define lowbit(x) (x &amp; -x)#define all(x) x.begin(), x.end()#define TM cout &lt;&lt; db(clock()) / CLOCKS_PER_SEC &lt;&lt; '\n' int n;db w, u, v, t1, t2;const int maxn = 6e5 + 233;typedef pair&lt;db, db&gt; pdd;vector&lt;pdd&gt; a[maxn];vector&lt;db&gt; pos;int sum[maxn]; int main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); cout &lt;&lt; fixed &lt;&lt; setprecision(10); cin &gt;&gt; n &gt;&gt; w &gt;&gt; u &gt;&gt; v &gt;&gt; t1 &gt;&gt; t2; for (int i = 1; i &lt;= n; ++i) &#123; string s; cin &gt;&gt; s; int len; cin &gt;&gt; len; for(int j = 1; j &lt;= len; j++)&#123; pdd t; cin &gt;&gt; t.fi &gt;&gt; t.se; if(t.se &lt; 0 &amp;&amp; s[0] == 'W') continue; if(t.se &gt; 0 &amp;&amp; s[0] == 'E') continue; if(t.se &lt; 0) t.se = -t.se; db tl = 1.0 * t.se / u - 1.0 * i * w / v; db tr = 1.0 * (t.se + t.fi) / u - 1.0 * (i - 1) * w / v; a[i].eb(tl, tr); pos.eb(tr); pos.eb(tl); pos.eb(tr + 0.005); pos.eb(tr - 0.005); pos.eb(tl - 0.005); pos.eb(tl + 0.005); &#125; a[i].eb(inf, inf); a[i].eb(-inf, -inf); sort(a[i].begin(), a[i].end()); &#125; pos.eb(t1), pos.eb(t2); pos.eb(inf), pos.eb(-inf); sort(all(pos)); pos.resize(unique(all(pos)) - pos.begin()); for (int i = 1; i &lt;= n; ++i) &#123; for(int j = 1; j &lt; a[i].size(); j++)&#123; int l = lower_bound(all(pos), a[i][j - 1].se) - pos.begin(); int r = lower_bound(all(pos), a[i][j].fi) - pos.begin(); if(l &gt; r) continue; sum[l]++; sum[r + 1]--; &#125; &#125; for(int i = 1; i &lt; pos.size(); i++)&#123; sum[i] += sum[i - 1]; &#125; int s = lower_bound(all(pos), t1) - pos.begin(); int t = lower_bound(all(pos), t2) - pos.begin(); db res = 0; db now = 0; for(int i = s + 1; i &lt;= t; i++)&#123; if(sum[i] == n &amp;&amp; sum[i - 1] == n) now += pos[i] - pos[i - 1]; else now = 0; res = max(res, now); &#125; cout &lt;&lt; res &lt;&lt; '\n'; return 0;&#125;]]></content>
      <categories>
        <category>差分</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Round 585 (Div. 2)-E(Marbles)]]></title>
    <url>%2F2019%2F09%2F17%2FCodeforces-Round-585-Div-2-E-Marbles%2F</url>
    <content type="text"><![CDATA[链接：https://codeforces.com/contest/1215/problem/E思路：一开始想了个错误的结论，以为只要确定每个块走到每个点开始的步数总数，最后除2就是答案，后来发现不对，有可能有些操作右移多，有些左移多，会造成额外的代价。其实我们考虑，如果知道了之前放过哪些数字了，那么就知道下一位从哪里开始，那么枚举下一个移动的是哪个数字，然后他需要移动的步数只跟还有哪些没有移动过有关，换句话说，我们只需要预处理出每个数字全部移动到另外一个数字之前需要多少步（忽略中间其他数字的影响），所以我们只用在根据没移动过的点进行统计当前需要多少步，加入贡献即可。代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef double db;typedef pair&lt;int, int&gt; pii;typedef vector&lt;int&gt; vi;typedef vector&lt;ll&gt; vl;typedef vector&lt;pii&gt; vp;const int inf = 1e9;const ll INF = 1e18;const db eps = 1e-10;#define fi first#define se second#define pb push_back#define eb emplace_back#define ep emplace#define mem(a) memset(a, 0, sizeof(a))#define copy(a, b) memcpy(a, b, sizeof(b))#define PA cout &lt;&lt; "pass\n"#define lowbit(x) (x &amp; -x)#define all(x) x.begin(), x.end()#define TM cout &lt;&lt; db(clock()) / CLOCKS_PER_SEC &lt;&lt; '\n'll dp[1 &lt;&lt; 22];int cnt[25];int n;const int maxn = 4e5 + 233;int a[maxn];ll sum[25][25];int main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); cin &gt;&gt; n; for (int i = 1; i &lt;= n; ++i) &#123; cin &gt;&gt; a[i]; cnt[a[i]]++; for(int j = 1; j &lt;= 20; j++) &#123; if(a[i] != j) sum[a[i]][j] += cnt[j]; &#125; &#125; for(int i = 0; i &lt; (1 &lt;&lt; 21); i++)&#123; dp[i] = INF; &#125; dp[0] = 0; for(int i = 0; i &lt; (1 &lt;&lt; 21); i++)&#123; for(int j = 0; j &lt; 21; j++)&#123; if(i &gt;&gt; j &amp; 1) continue; ll tmp = 0; for(int k = 0; k &lt; 21; k++)&#123; if(i &gt;&gt; k &amp; 1) continue; tmp += sum[j][k]; &#125; dp[i | (1 &lt;&lt; j)] = min(dp[i | (1 &lt;&lt; j)], dp[i] + tmp); &#125; &#125; cout &lt;&lt; dp[(1 &lt;&lt; 21) - 1] &lt;&lt; '\n'; return 0;&#125;]]></content>
      <categories>
        <category>状压dp</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[The Preliminary Contest for ICPC Asia Nanjing 2019-E(K Sum)]]></title>
    <url>%2F2019%2F09%2F13%2FThe-Preliminary-Contest-for-ICPC-Asia-Nanjing-2019-E-K-Sum%2F</url>
    <content type="text"><![CDATA[链接：https://nanti.jisuanke.com/t/41302思路：令f_n(k) = \sum_{l_1 = 1}^n\sum_{l_2 = 1}^n\cdots\sum_{l_k = 1}^n(gcd(l_1, l_2, \cdots, l_k))^2，求\sum_{i = 2}^kf_n(i) mod (1e9 + 7)我们先来推一推公式: f_n(k) = \sum_{l_1 = 1}^n\sum_{l_2 = 1}^n\cdots\sum_{l_k = 1}^n(gcd(l_1, l_2, \cdots, l_k))^2考虑枚举gcd: f_n(k) = \sum_{i = 1}^n\sum_{l_1 = 1}^n\sum_{l_2 = 1}^n\cdots\sum_{l_k = 1}^ni^2[gcd(l_1, l_2, \cdots, l_k) == i]转换一下： f_n(k) = \sum_{i = 1}^n\sum_{l_1 = 1}^{\lfloor\frac{n}{i}\rfloor}\sum_{l_2 = 1}^{\lfloor\frac{n}{i}\rfloor}\cdots\sum_{l_k = 1}^{\lfloor\frac{n}{i}\rfloor}i^2[gcd(l_1, l_2, \cdots, l_k) == 1]来一波莫比乌斯反演： f_n(k) = \sum_{i = 1}^n\sum_{d = 1}^n\mu(d)i^2\lfloor\frac{n}{id}\rfloor^k考虑枚举T = id: f_n(k) = \sum_{T = 1}^n\lfloor\frac{n}{T}\rfloor^k\sum_{d | T}d^2\mu(\frac{T}{d})那么对于\sum_{i = 2}^kf_n(i)有： \sum_{i = 2}^kf_n(i) = \sum_{i = 2}^k\sum_{T = 1}^n\lfloor\frac{n}{T}\rfloor^i\sum_{d | T}d^2\mu(\frac{T}{d})交换次序： \sum_{i = 2}^kf_n(i) = \sum_{T = 1}^n\sum_{i = 2}^k\lfloor\frac{n}{T}\rfloor^i\sum_{d | T}d^2\mu(\frac{T}{d})我们令h(T) = \sum_{d | T}d^2 \mu(\frac{T}{d})我们发现这个函数等于id^2 * \mu考虑杜教筛，给他卷积上一个I，我们知道\mu * I = e，id^2 * e = id^2前面部分我们用数论分块，中间部分是一个等比数列求和，因为k比较大，当k不等于1时我们欧拉降幂算，k = 1时直接算（所以读入的时候要记录一下k mod 1e9 + 7和mod 1e9 + 6的值），后面部分杜教筛即可。代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef double db;typedef pair&lt;int, int&gt; pii;typedef vector&lt;int&gt; vi;typedef vector&lt;ll&gt; vl;typedef vector&lt;pii&gt; vp;const int inf = 1e9;const ll INF = 1e18;const db eps = 1e-10;#define fi first#define se second#define pb push_back#define eb emplace_back#define ep emplace#define mem(a) memset(a, 0, sizeof(a))#define copy(a, b) memcpy(a, b, sizeof(b))#define PA cout &lt;&lt; "pass\n"#define lowbit(x) (x &amp; -x)#define all(x) x.begin(), x.end()#define TM cout &lt;&lt; db(clock()) / CLOCKS_PER_SEC &lt;&lt; '\n'const int maxn = 1e6 + 233;const int mod = 1e9 + 7;const int inv6 = (mod + 1) / 6;vi prime;bool vis[maxn];int mu[maxn];int sum[maxn];void add(int &amp;x, int y)&#123; x += y; if(x &gt;= mod) x -= mod;&#125;void sub(int &amp;x, int y)&#123; x -= y; if(x &lt; 0) x += mod;&#125;struct HASH &#123; static const int mod = 1635947; int hs[mod], head[mod], nxt[mod], id[mod], top; void init()&#123; memset(head, -1, sizeof(head)); top = 1; &#125;; void insert(int x, int y) &#123; int k = x % mod; hs[top] = x, id[top] = y, nxt[top] = head[k], head[k] = top++; &#125; int find(int x) &#123; int k = x % mod; for (int i = head[k]; i != -1; i = nxt[i]) if (hs[i] == x) return id[i]; return -1; &#125;&#125;mp;void init()&#123; mu[1] = 1; for(int i = 2; i &lt; maxn; i++)&#123; if(!vis[i]) prime.eb(i), mu[i] = -1; for(int j = 0; j &lt; prime.size() &amp;&amp; i * prime[j] &lt; maxn; j++)&#123; vis[i * prime[j]] = 1; if(i % prime[j] == 0) break; mu[i * prime[j]] = -mu[i]; &#125; &#125; for (int i = 1; i &lt; maxn; ++i) &#123; for(int j = 1; j * i &lt; maxn; j++)&#123; add(sum[i * j], ((1ll * i * i * mu[j]) % mod + mod) % mod); &#125; &#125; for (int i = 1; i &lt; maxn; ++i) &#123; add(sum[i], sum[i - 1]); &#125;&#125;int T;int getans(int x)&#123; if(x &lt; maxn) return sum[x]; int t = mp.find(x); if(t != -1) return t; int ret = 1ll * x * (x + 1) % mod * (2 * x + 1) % mod * inv6 % mod; for(int l = 2, r; l &lt;= x; l = r + 1)&#123; r = x / (x / l); sub(ret, 1ll * (r - l + 1) * getans(x / l) % mod); &#125; mp.insert(x, ret); return ret;&#125;int pow_mod(int q, int w)&#123; int ret = 1; while(w)&#123; if(w &amp; 1) ret = (ll)ret * q % mod; q = (ll)q * q % mod; w &gt;&gt;= 1; &#125; return ret;&#125;int n, m, t;string s;int main()&#123; init(); mp.init(); cin &gt;&gt; T; while(T--)&#123; cin &gt;&gt; n &gt;&gt; s; m = 0; t = 0; for(int i = 0; i &lt; s.size(); i++)&#123; m = (1ll * m * 10 + s[i] - '0') % (mod - 1); t = (1ll * t * 10 + s[i] - '0') % mod; &#125; int res = 0; for(int l = 1, r; l &lt;= n; l = r + 1)&#123; r = n / (n / l); if(n / l == 1)&#123; add(res, 1ll * (t - 1 + mod) * (getans(r) - getans(l - 1) + mod) % mod); &#125; else&#123; add(res, 1ll * (pow_mod(n / l, 2) - pow_mod(n / l, m + 1) + mod) * (getans(r) - getans(l - 1) + mod) % mod * pow_mod(1 - n / l + mod, mod - 2) % mod); &#125; &#125; cout &lt;&lt; res &lt;&lt; '\n'; &#125; return 0;&#125;]]></content>
      <categories>
        <category>杜教筛</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[The Preliminary Contest for ICPC Asia Nanjing 2019-I(Washing clothes)]]></title>
    <url>%2F2019%2F09%2F13%2FThe-Preliminary-Contest-for-ICPC-Asia-Nanjing-2019-I-Washing-clothes%2F</url>
    <content type="text"><![CDATA[链接：https://nanti.jisuanke.com/t/41306思路：首先要观察出几个性质：1、最终答案一定可以将人分为两部分，使得前一半用手洗，后一半用机洗，且答案最后一个手洗结束时间和机洗结束时间之间的最大值。2、随着x增大，这个分界点会向前。3、我们将每个人机洗时间的结束时间表示为t_i + (n - i + 1) * x，那么最终机洗结束时间就为这些当中的最大值，这些我们可以看作二维平面上的直线，他们构成了一个凸包。4、随着x增大，最大值取点会靠后。综上，我写的时候采取的是在凸包上二分，从后往前扫，每次找到那个机洗和人洗的分界点，然后把直线加入凸包中，找到分界点后我们在凸包上二分，找到最优点，再判断前一个分界点对应的结束时间，取其中小的一个更新答案即可。 我们来推一下凸包上斜率优化的式子： res = max(t_i + (n - i + 1) * x) (1 \leq i \leq n)假设有个j点取到最大值，同时存在其他点k： t_j - t_k - (j - k) * x \geq 0有： x \leq \frac{t_j - t_k}{j - k} (j > k)x \geq \frac{t_j - t_k}{j - k} (j < k)维护这个凸包，在上面二分找到答案即可。代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef double db;typedef pair&lt;int, int&gt; pii;typedef vector&lt;int&gt; vi;typedef vector&lt;ll&gt; vl;typedef vector&lt;pii&gt; vp;const int inf = 1e9;const ll INF = 1e18;const db eps = 1e-10;#define fi first#define se second#define pb push_back#define eb emplace_back#define ep emplace#define mem(a) memset(a, 0, sizeof(a))#define copy(a, b) memcpy(a, b, sizeof(b))#define PA cout &lt;&lt; "pass\n"#define lowbit(x) (x &amp; -x)#define all(x) x.begin(), x.end()#define TM cout &lt;&lt; db(clock()) / CLOCKS_PER_SEC &lt;&lt; '\n'const int maxn = 1e6 + 233;ll t[maxn];int n ,y, head, tail, Q[maxn];ll res[maxn];ll up(int x, int y)&#123; return t[y] - t[x];&#125;ll down(int x, int y)&#123; return y - x;&#125;int get(int x)&#123; if(head == tail) return head; int lb = head + 1, ub = tail, ans = head + 1; while(ub &gt;= lb)&#123; int mid = lb + ub &gt;&gt; 1; if(up(Q[mid - 1], Q[mid]) &gt;= -down(Q[mid - 1], Q[mid]) * x) lb = mid + 1, ans = mid; else ub = mid - 1; &#125; return ans;&#125;int main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); while(cin &gt;&gt; n &gt;&gt; y) &#123; head = 1, tail = 1; for (int i = 1; i &lt;= n; ++i) &#123; cin &gt;&gt; t[i]; &#125; sort(t + 1, t + n + 1, greater&lt;ll&gt;()); int pos = 0; ll pre = 0; for (int i = y; i; i--) &#123; int tmp = get(i); //找到机洗和人洗的分界点 while (pos &lt; n &amp;&amp; t[pos + 1] + y &gt;= 1ll * Q[tmp] * i + t[Q[tmp]]) &#123; tmp = get(i); pre = 1ll * Q[tmp] * i + t[Q[tmp]]; pos++; while (head &lt; tail &amp;&amp; up(Q[tail], pos) * down(Q[tail - 1], Q[tail]) &gt;= up(Q[tail - 1], Q[tail]) * down(Q[tail], pos)) tail--; Q[++tail] = pos; //更新凸包上的答案 tmp = get(i); &#125; tmp = get(i); res[i] = 1ll * Q[tmp] * i + t[Q[tmp]]; if (pos &lt; n) res[i] = max(res[i], t[pos + 1] + y); res[i] = min(res[i], max(pre, t[pos] + y)); &#125; for (int i = 1; i &lt;= y; ++i) &#123; cout &lt;&lt; res[i] &lt;&lt; (i == y ? '\n' : ' '); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>斜率优化dp</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Round 225 (Div. 1)-E(Vowels)]]></title>
    <url>%2F2019%2F09%2F03%2FCodeforces-Round-225-Div-1-E-Vowels%2F</url>
    <content type="text"><![CDATA[链接：https://codeforces.com/contest/383/problem/E思路：字符一共24种，那么就有2^{24}种可能的元音子集，考虑对于每一个单词并更新子集，这里需要用到容斥。有x个元素的状态的个数 = 有1个 - 有2个 + 有3个…. + (-1)^{x - 1}，那么我们可以用sosdp来计算这个前缀和，最后统计一下答案即可。代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef double db;typedef pair&lt;int, int&gt; pii;typedef vector&lt;int&gt; vi;typedef vector&lt;ll&gt; vl;typedef vector&lt;pii&gt; vp;const int inf = 1e9;const ll INF = 1e18;const db eps = 1e-10;#define fi first#define se second#define pb push_back#define eb emplace_back#define ep emplace#define mem(a) memset(a, 0, sizeof(a))#define copy(a, b) memcpy(a, b, sizeof(b))#define PA cout &lt;&lt; "pass\n"#define lowbit(x) (x &amp; -x)#define all(x) x.begin(), x.end()#define TM cout &lt;&lt; db(clock()) / CLOCKS_PER_SEC &lt;&lt; '\n'const int maxn = 1 &lt;&lt; 24;int f[maxn], a[maxn], n;char s[20];int main() &#123; scanf("%d", &amp;n); for (int i = 1; i &lt;= n; ++i) &#123; scanf("%s", s); int p = 0; for (int j = 0; j &lt; 3; j++) p |= 1 &lt;&lt; (s[j] - 'a'); for (int j = p; j; j = (j - 1) &amp; p) &#123; if (__builtin_popcount(j) &amp; 1) a[j]++; else a[j]--; &#125; &#125; for (int i = 0; i &lt; (1 &lt;&lt; 24); i++) f[i] = a[i]; for (int j = 0; j &lt; 24; j++) &#123; for (int i = 0; i &lt; (1 &lt;&lt; 24); i++) &#123; if (i &gt;&gt; j &amp; 1) f[i] += f[i ^ (1 &lt;&lt; j)]; &#125; &#125; int res = 0; for (int i = 0; i &lt; (1 &lt;&lt; 24); i++) res ^= 1ll * f[i] * f[i]; printf("%d\n", res); return 0;&#125;]]></content>
      <categories>
        <category>状压dp</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Manthan, Codefest 19 (open for everyone, rated, Div. 1 + Div. 2)-F(Bits And Pieces)]]></title>
    <url>%2F2019%2F09%2F03%2FManthan-Codefest-19-open-for-everyone-rated-Div-1-Div-2-F-Bits-And-Pieces%2F</url>
    <content type="text"><![CDATA[链接：https://codeforces.com/contest/1208/problem/F思路：考虑如果我们枚举a_i，如果按位枚举，我们需要知道前面是否存在两个数的&amp;运算等于某个数，这个可以用sosdp来做。只是这个sosdp不是一开始就递推出来的，而是动态插数的，一个数如果被更新了两次就可以不用再更新了（它的子集也一定被更新了两次及以上）。接下来我们从大到小按位取，如果a_i存在这一位，那么我们记入答案，否则我们看sosdp的这个mask是否被两个数更新过，如果是我们贪心的把它取出来，然后mask往上转移，否则继续枚举，最后更新答案，并且把当前位置插入sosdp中即可。代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef double db;typedef pair&lt;int, int&gt; pii;typedef vector&lt;int&gt; vi;typedef vector&lt;ll&gt; vl;typedef vector&lt;pii&gt; vp;const int inf = 1e9;const ll INF = 1e18;const db eps = 1e-10;#define fi first#define se second#define pb push_back#define eb emplace_back#define ep emplace#define mem(a) memset(a, 0, sizeof(a))#define copy(a, b) memcpy(a, b, sizeof(b))#define PA cout &lt;&lt; "pass\n"#define lowbit(x) (x &amp; -x)#define all(x) x.begin(), x.end()#define TM cout &lt;&lt; db(clock()) / CLOCKS_PER_SEC &lt;&lt; '\n'const int maxn = 2e6 + 233;int f[maxn], a[maxn], n;void update(int x, int k)&#123; if(k &gt; 20) return; if(f[x] &gt; 1) return; if(k == 20) f[x]++; update(x, k + 1); if(x &gt;&gt; k &amp; 1) update(x ^ (1 &lt;&lt; k), k);&#125;int main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); cin &gt;&gt; n; for (int i = 1; i &lt;= n; ++i) &#123; cin &gt;&gt; a[i]; &#125; int res = 0; for (int i = n; i &gt;= 1; --i) &#123; int ans = 0, t = 0; for(int j = 20; j &gt;= 0; --j)&#123; if(a[i] &gt;&gt; j &amp; 1) ans |= 1 &lt;&lt; j; else if(f[t | (1 &lt;&lt; j)] &gt; 1) ans |= 1 &lt;&lt; j, t |= 1 &lt;&lt; j; &#125; update(a[i], 0); if(i &lt;= n - 2) res = max(res, ans); &#125; cout &lt;&lt; res &lt;&lt; '\n'; return 0;&#125;]]></content>
      <categories>
        <category>状压dp</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[The Preliminary Contest for ICPC Asia Nanjing 2019-D(Robots)]]></title>
    <url>%2F2019%2F09%2F01%2FThe-Preliminary-Contest-for-ICPC-Asia-Nanjing-2019-D-Robots%2F</url>
    <content type="text"><![CDATA[链接：https://nanti.jisuanke.com/t/41301思路：考虑一个基础问题，DAG从s到t期望步数计算。直到今天我才知道这种期望是要倒着算，正着算看起来式子是对的，但是有问题：概率和不等于1，转移没法解释。倒着的话，我们每次从某个点沿着反向边转移，我们发现所有点转移过来的概率和为1，就能解释得通了。写成式子就是： dp[u] = \frac{1}{out[u] + 1}dp[u] + \sum_{(u, v)\subseteq E}\frac{1}{out[u] + 1}dp[v] + 1移过去可以得到递推式，我们就可以倒着递推出起点到终点的期望了。那么本题是求代价，考虑先求期望步数，一个点的代价其实就是它的期望步数，那么代价的g函数递推就是： g[u] = \frac{1}{out[u] + 1}g[u] + \sum_{(u, v)\subseteq E}\frac{1}{out[u] + 1}g[v] + f[u]类比着倒着拓扑序做就可以了。代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef double db;typedef pair&lt;int, int&gt; pii;typedef vector&lt;int&gt; vi;typedef vector&lt;ll&gt; vl;typedef vector&lt;pii&gt; vp;const int inf = 1e9;const ll INF = 1e18;const db eps = 1e-10;#define fi first#define se second#define pb push_back#define eb emplace_back#define ep emplace#define mem(a) memset(a, 0, sizeof(a))#define copy(a, b) memcpy(a, b, sizeof(b))#define PA cout &lt;&lt; "pass\n"#define lowbit(x) (x &amp; -x)#define all(x) x.begin(), x.end()#define TM cout &lt;&lt; db(clock()) / CLOCKS_PER_SEC &lt;&lt; '\n'const int maxn = 1e5 + 233;vi G[maxn], RG[maxn];db f[maxn], g[maxn];int cnt[maxn], tmp[maxn];int T, n, m;int main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); cin &gt;&gt; T; while(T--)&#123; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; ++i) &#123; G[i].clear(); RG[i].clear(); &#125; mem(f), mem(g), mem(cnt); for (int i = 1; i &lt;= m; ++i) &#123; int u, v; cin &gt;&gt; u &gt;&gt; v; G[u].eb(v); RG[v].eb(u); cnt[u]++; &#125; copy(tmp, cnt); queue&lt;int&gt; q; q.ep(n); while(!q.empty())&#123; int u = q.front(); q.pop(); if(u != n) f[u] += 1.0 * (G[u].size() + 1) / G[u].size(); for(int i = 0; i &lt; RG[u].size(); i++)&#123; int v = RG[u][i]; tmp[v]--; if(!tmp[v]) q.ep(v); f[v] += 1.0 / G[v].size() * f[u]; &#125; &#125; cout &lt;&lt; fixed &lt;&lt; setprecision(2); while(!q.empty()) q.pop(); q.ep(n); copy(tmp, cnt); while(!q.empty())&#123; int u = q.front(); q.pop(); if(u != n) g[u] += 1.0 * f[u] * (G[u].size() + 1) / G[u].size(); for(int i = 0; i &lt; RG[u].size(); i++)&#123; int v = RG[u][i]; tmp[v]--; if(!tmp[v]) q.ep(v); g[v] += 1.0 / G[v].size() * g[u]; &#125; &#125; cout &lt;&lt; g[1] &lt;&lt; '\n'; &#125; return 0;&#125;]]></content>
      <categories>
        <category>基础dp</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Round 112 (Div. 2)-E(Compatible Numbers)]]></title>
    <url>%2F2019%2F08%2F31%2FCodeforces-Round-112-Div-2-E-Compatible-Numbers%2F</url>
    <content type="text"><![CDATA[链接：https://codeforces.com/contest/165/problem/E思路：cf教程链接：https://codeforces.com/blog/entry/45223 SOS dp概念SOS dp用来解决形如 F[mask] = \sum_{i \subseteq mask} x其中x可以是常数，也可以是跟i有关的函数。我们发现F维护的是一个状态及其对应的所有子集，这个通常也被成为高位前缀和。 SOS dp求解考虑这个可以通过状压dp，也叫sosdp来求，考虑枚举一位，然后从小到大枚举状态，如果该状态存在该位，那么加上去掉这一位的状态（已经枚举过），这样我们求出来的就是mask状态对应的子集的和，也就是F函数。有些题可能是需要F[mask]表示包含mask的所有所有状态的后缀和，换一下前缀和方向就变成后缀和了。 SOS dp细节1、注意第一维一定是先枚举位数，因为每次更新是按照位的顺序更新的。看cf上那张图会更清楚。2、初始化F的时候就是对应的i = mask时的x的值 考虑本题，要求对于每个i，是否存在j使得a_i \& a_j = 0。考虑SOS dp求解，如果a_i \& a_j = 0，那么a_j取反一定包含a_i，那么我们考虑对解维护SOS dp，即一个解向所有包含它的状态更新，初始化所有mask = -1，a_i取反对应的状态为a_i，然后用SOS dp更新所有答案，最后只用查询每个a_i取反后是否有解即可。代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;bits/stdc++.h&gt;using namespace std; typedef long long ll;typedef double db;typedef pair&lt;int, int&gt; pii;typedef vector&lt;int&gt; vi;typedef vector&lt;ll&gt; vl;typedef vector&lt;pii&gt; vp;const int inf = 1e9;const ll INF = 1e18;const db eps = 1e-10; #define fi first#define se second#define pb push_back#define eb emplace_back#define ep emplace#define mem(a) memset(a, 0, sizeof(a))#define copy(a, b) memcpy(a, b, sizeof(b))#define PA cout &lt;&lt; "pass\n"#define lowbit(x) (x &amp; -x)#define all(x) x.begin(), x.end()#define TM cout &lt;&lt; db(clock()) / CLOCKS_PER_SEC &lt;&lt; '\n' const int maxn = 5e6 + 233;int a[maxn], n, f[maxn]; void update(int x, int k, int y)&#123; if(k &gt; 21) return; if(f[x] != -1) return; if(k == 21) f[x] = y; update(x, k + 1, y); if(x &gt;&gt; k &amp; 1) update(x ^ (1 &lt;&lt; k), k, y);&#125; int main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); cin &gt;&gt; n; for (int i = 1; i &lt;= n; ++i) &#123; cin &gt;&gt; a[i]; &#125; memset(f, -1, sizeof(f)); for (int i = 1; i &lt;= n; ++i) &#123; int x = (~a[i]) &amp; ((1 &lt;&lt; 22) - 1); update(x, 0, a[i]); &#125; for (int i = 1; i &lt;= n; ++i) &#123; cout &lt;&lt; f[a[i]] &lt;&lt; (i == n ? '\n' : ' '); &#125; return 0;&#125;]]></content>
      <categories>
        <category>状压dp</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2019 Multi-University Training Contest 10-D(Play Games with Rounddog)]]></title>
    <url>%2F2019%2F08%2F25%2F2019-Multi-University-Training-Contest-10-D-Play-Games-with-Rounddog%2F</url>
    <content type="text"><![CDATA[链接：http://acm.hdu.edu.cn/showproblem.php?pid=6704思路：考虑葫芦选的，一定是SAM的fail树某个点对应子树中点的，如果葫芦想赢，那么必须选出来的不能出现子集的异或和为0，换句话说他们都必须线性无关，那就是线性基了。考虑在有解的情况下我们要答案最大，我们考虑按w的大小向SAM的fail树上更新线性基，一直从该点沿着边更新到根节点。考虑复杂度，因为一个点最多被更新58次，更新一次代价58，所以这部分复杂度O(nlognlogn)。这样保证大的先更新，最后出来的总和一定是最大的，然后询问我们只用倍增找到那个串在SAM上对应的节点，查询其最大综合即可。代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef double db;typedef pair&lt;int, int&gt; pii;typedef vector&lt;int&gt; vi;typedef vector&lt;ll&gt; vl;typedef vector&lt;pii&gt; vp;const int inf = 1e9;const ll INF = 1e18;const db eps = 1e-10;#define fi first#define se second#define pb push_back#define eb emplace_back#define ep emplace#define mem(a) memset(a, 0, sizeof(a))#define copy(a, b) memcpy(a, b, sizeof(b))#define PA cout &lt;&lt; "pass\n"#define lowbit(x) (x &amp; -x)#define all(x) x.begin(), x.end()#define TM cout &lt;&lt; db(clock()) / CLOCKS_PER_SEC &lt;&lt; '\n'#define sigma_size 28const int maxn = 1e5 + 5;const int mod = 1e9 + 7;char s[maxn];typedef long long ll;int t[maxn];struct SAM &#123; int len[maxn * 2]; //最长子串的长度(该节点字串数量=len[x]-len[f[x]]) int f[maxn * 2]; //后缀链接(最短串前部减少一个字符所到达的状态) int cnt[maxn * 2]; //被后缀连接的数 int ch[maxn * 2][sigma_size]; //状态转移(尾部加一个字符的下一个状态)(图) int idx; //节点编号 int last; //最后节点 int epos[maxn * 2]; // enpos数（该状态子串出现数量） int pos[maxn * 2]; void init() &#123; //初始化 last = idx = 1; //1表示root起始点 空集 f[1] = len[1] = 0; memset(ch, 0, sizeof(ch)); mem(f); mem(cnt); mem(len); mem(epos); mem(pos); &#125;//SAM建图 void add(int c, int id) &#123; //插入字符，为字符ascll码值 int x = ++idx; //创建一个新节点x; len[x] = len[last] + 1; // 长度等于最后一个节点+1 epos[x] = 1; //接受节点子串除后缀连接还需加一 pos[x] = id; t[id] = x; int p; //第一个有C转移的节点; for (p = last; p &amp;&amp; !ch[p][c]; p = f[p])ch[p][c] = x;//沿着后缀连接 将所有没有字符c转移的节点直接指向新节点 if (!p)f[x] = 1, cnt[1]++; //全部都没有c的转移 直接将新节点后缀连接到起点 else &#123; int q = ch[p][c]; //p通过c转移到的节点 if (len[p] + 1 == len[q]) //pq是连续的 f[x] = q, cnt[q]++; //将新节点后缀连接指向q即可,q节点的被后缀连接数+1 else &#123; int nq = ++idx; //不连续 需要复制一份q节点 len[nq] = len[p] + 1; //令nq与p连续 f[nq] = f[q]; //因后面link[q]改变此处不加cnt memcpy(ch[nq], ch[q], sizeof(ch[q])); //复制q的信息给nq for (; p &amp;&amp; ch[p][c] == q; p = f[p]) ch[p][c] = nq; //沿着后缀连接 将所有通过c转移为q的改为nq f[q] = f[x] = nq; //将x和q后缀连接改为nq cnt[nq] += 2; // nq增加两个后缀连接 &#125; &#125; last = x; //更新最后处理的节点 &#125;&#125;sol;int root[maxn &lt;&lt; 6], ls[maxn &lt;&lt; 6], rs[maxn &lt;&lt; 6], sum[maxn &lt;&lt; 6];int _o;int T, n, q;vi G[maxn * 2];int f[maxn * 2][30];int in[maxn * 2], out[maxn * 2], cnt;void init()&#123; mem(root); mem(ls); mem(rs); mem(sum); mem(f); cnt = 0; _o = 0; for (int i = 1; i &lt;= 2 * n; ++i) &#123; G[i].clear(); &#125;&#125;void update(int pre, int &amp;o, int l, int r, int p, int v)&#123; o = ++_o; ls[o] = ls[pre], rs[o] = rs[pre], sum[o] = sum[pre] + v; if(l == r) return; int mid = l + r &gt;&gt; 1; if(p &lt;= mid) update(ls[pre], ls[o], l, mid, p, v); else update(rs[pre], rs[o], mid + 1, r, p, v);&#125;int query(int pre, int now, int l, int r, int k)&#123; int mid = l + r &gt;&gt; 1, x = sum[ls[now]] - sum[ls[pre]]; if(l == r) return l; if(x &gt;= k) return query(ls[pre], ls[now], l, mid, k); return query(rs[pre], rs[now], mid + 1, r, k - x);&#125;void dfs(int u)&#123; in[u] = ++cnt; update(root[cnt - 1], root[cnt], 1, n + 1, sol.pos[u], 1); for (int i = 1; i &lt;= 20; ++i) &#123; f[u][i] = f[f[u][i - 1]][i - 1]; &#125; for(auto &amp;v : G[u])&#123; dfs(v); &#125; out[u] = cnt;&#125;int main()&#123; scanf("%d", &amp;T); while(T--)&#123; scanf("%d %d %s", &amp;n, &amp;q, s + 1); sol.init(); init(); for (int i = 1; i &lt;= n; ++i) &#123; sol.add(s[i] - 'a', i); &#125; for (int i = 1; i &lt;= sol.idx; ++i) &#123; if(!sol.pos[i]) sol.pos[i] = n + 1; &#125; for (int i = 2; i &lt;= sol.idx; ++i) &#123; G[sol.f[i]].eb(i); f[i][0] = sol.f[i]; &#125; dfs(1); while(q--)&#123; int l, r, k; scanf("%d %d %d", &amp;l, &amp;r, &amp;k); int p = t[r]; for(int i = 20; i &gt;= 0; i--)&#123; int x = f[p][i]; if(sol.len[x] &gt;= r - l + 1) p = x; &#125; int res = query(root[in[p] - 1], root[out[p]], 1, n + 1, k); if(res == n + 1) res = -1; else res -= r - l; printf("%d\n", res); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>后缀自动机</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2019 Multi-University Training Contest 10-G(Closest Pair of Segments)]]></title>
    <url>%2F2019%2F08%2F25%2F2019-Multi-University-Training-Contest-10-G-Closest-Pair-of-Segments%2F</url>
    <content type="text"><![CDATA[链接：http://acm.hdu.edu.cn/showproblem.php?pid=6697思路：二分是比较容易想到的一个思路，二分后的判断不太容易想到，首先发现二分后线段将会变成一个类似椭圆的东西（但上面是直线），我们需要维护这些类椭圆是否存在交点。考虑按x进行排序，维护一个y轴的扫描线，那么每次加入一个点只需判断跟上下两个线段是否相交，删除一个点只用判断上下它上下两个线段是否相交即可。我们用该x点在其他线段对应的y给线段排序即可。复杂度O(nlognlogn)。代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef double db;typedef pair&lt;int, int&gt; pii;typedef vector&lt;int&gt; vi;typedef vector&lt;ll&gt; vl;typedef vector&lt;pii&gt; vp;typedef pair&lt;db, db&gt; pdd;const int inf = 1e9;const ll INF = 1e18;const db eps = 1e-9;#define fi first#define se second#define pb push_back#define eb emplace_back#define ep emplace#define mem(a) memset(a, 0, sizeof(a))#define copy(a, b) memcpy(a, b, sizeof(b))#define PA cout &lt;&lt; "pass\n"#define lowbit(x) (x &amp; -x)#define all(x) x.begin(), x.end()#define TM cout &lt;&lt; db(clock()) / CLOCKS_PER_SEC &lt;&lt; '\n'int dcmp(db x)&#123; return x &lt; -eps ? -1 : x &gt; eps;&#125;const int maxn = 2e4 + 233;pdd a[maxn], b[maxn];int n;int T;typedef pair&lt;db, int&gt; pdi;vector&lt;pdi&gt; r;db Cross(pdd a, pdd b)&#123; return a.fi * b.se - a.se * b.fi;&#125;db Dot(pdd a, pdd b)&#123; return a.fi * b.fi + a.se * b.se;&#125;db Length(pdd a)&#123; return sqrt(Dot(a, a));&#125;db DistanceToSegmentS(pdd p, pdd A, pdd B) &#123; if (dcmp(A.fi - B.fi) == 0 &amp;&amp; dcmp(A.se - B.se) == 0) return Length(pdd(p.fi - A.fi, p.se - A.se)); pdd v1 = pdd(B.fi - A.fi, B.se - A.se), v2 = pdd(p.fi - A.fi, p.se - A.se), v3 = pdd(p.fi - B.fi, p.se - B.se); if (dcmp(Dot(v1, v2)) &lt; 0) return Length(v2); else if (dcmp(Dot(v1, v3)) &gt; 0) return Length(v3); else return fabs(Cross(v1, v2)) / Length(v1);&#125;db ok(int p1, int p2)&#123; db x = DistanceToSegmentS(a[p1], a[p2], b[p2]); x = min(x, DistanceToSegmentS(b[p1], a[p2], b[p2])); x = min(x, DistanceToSegmentS(a[p2], a[p1], b[p1])); x = min(x, DistanceToSegmentS(b[p2], a[p1], b[p1])); return x;&#125;pdd c[maxn], d[maxn];db tmp = 0;db get(int x)&#123; if(dcmp(c[x].fi - d[x].fi) == 0) return (c[x].se + d[x].se) / 2; return (d[x].se - c[x].se) / (d[x].fi - c[x].fi) * (tmp - c[x].fi) + c[x].se;&#125;struct Com&#123; bool operator() (const int &amp;a,const int &amp;b) &#123; return a != b ? get(a) &lt; get(b) : false; &#125;&#125;;set&lt;int, Com&gt; s;bool check(db l)&#123; r.clear(); for (int i = 1; i &lt;= n; ++i) &#123; c[i] = pdd&#123;a[i].fi - l / 2, a[i].se&#125;; d[i] = pdd&#123;b[i].fi + l / 2, b[i].se&#125;; r.eb(a[i].fi - l / 2, -i); r.eb(b[i].fi + l / 2, i); &#125; sort(all(r)); for(int i = 0; i &lt; r.size(); i++)&#123; tmp = r[i].fi; if(r[i].se &gt; 0) &#123; s.erase(r[i].se); auto t = s.lower_bound(r[i].se); if(t != s.begin() &amp;&amp; t != s.end())&#123; auto pre = t--; if(ok((*t), (*pre)) &lt; l + eps) return true; &#125; continue; &#125; r[i].se = -r[i].se; auto t = s.lower_bound(r[i].se); if(t != s.end() &amp;&amp; ok((*t), r[i].se) &lt; l + eps) return true; if(t != s.begin() &amp;&amp; ok(r[i].se, (*--t)) &lt; l + eps) return true; s.ep(r[i].se); &#125; return false;&#125;int main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); cin &gt;&gt; T; while(T--)&#123; cin &gt;&gt; n; for (int i = 1; i &lt;= n; ++i) &#123; cin &gt;&gt; a[i].fi &gt;&gt; a[i].se &gt;&gt; b[i].fi &gt;&gt; b[i].se; if(a[i] &gt; b[i]) swap(a[i], b[i]); &#125; cout &lt;&lt; fixed &lt;&lt; setprecision(10); db ub = 1e12, lb = 0; while((ub - lb) / max(1.0, lb) &gt; eps)&#123; s.clear(); db mid = lb + (ub - lb) / 2; if(check(mid)) ub = mid; else lb = mid; &#125; cout &lt;&lt; (ub + lb) / 2 &lt;&lt; '\n'; &#125; return 0;&#125;]]></content>
      <categories>
        <category>计算几何</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2019中国大学生程序设计竞赛（CCPC)-网络选拔赛-C(K-th occurrence)]]></title>
    <url>%2F2019%2F08%2F25%2F2019%E4%B8%AD%E5%9B%BD%E5%A4%A7%E5%AD%A6%E7%94%9F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AB%9E%E8%B5%9B%EF%BC%88CCPC-%E7%BD%91%E7%BB%9C%E9%80%89%E6%8B%94%E8%B5%9B-C-K-th-occurrence%2F</url>
    <content type="text"><![CDATA[链接：http://acm.hdu.edu.cn/showproblem.php?pid=6704思路：求一个字符串第k次出现的位置。考虑SA上，一个字符串连续出现的一定是高度数组上的一段，那么就是求这一段里面第k大的下标，只需要对sa建一个主席树就可以了（注意可以多建一个节点表示不存在，就不用特判了）。找这段区间在高度数组上前后二分即可。如果是SAM，一个串对应一个节点，那么它所有出现位置一定都位于它的子树内，那么相当于求子树静态第k大，我们只用对SAM的fail树dfs序建可持久化线段树即可。注意不属于后缀节点的值全部标记为n + 1，表示不存在，同时复制节点不复制原节点的权值，保证树上只有一个唯一的节点对应后缀节点。代码：SA：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef double db;typedef pair&lt;int, int&gt; pii;typedef vector&lt;int&gt; vi;typedef vector&lt;ll&gt; vl;typedef vector&lt;pii&gt; vp;const int inf = 1e9;const ll INF = 1e18;#define fi first#define se second#define pb push_back#define eb emplace_back#define ep emplace#define mem(a) memset(a, 0, sizeof(a))#define copy(a, b) memcpy(a, b, sizeof(b))#define PA cout &lt;&lt; "pass\n"#define lowbit(x) (x &amp; -x)#define all(x) x.begin(), x.end()#define TM cout &lt;&lt; db(clock()) / CLOCKS_PER_SEC &lt;&lt; '\n'#define F(x) ((x) / 3 + ((x) % 3 == 1 ? 0 : tb))#define G(x) ((x) &lt; tb ? (x) * 3 + 1 : ((x) - tb) * 3 + 2)using namespace std;const int maxn = 100005;int wa[maxn], wb[maxn], wc[maxn], wv[maxn], sa[3 * maxn];int r[maxn], h[maxn], s[3 * maxn];int n, T, q;int root[maxn &lt;&lt; 5], ls[maxn &lt;&lt; 5], rs[maxn &lt;&lt; 5], sum[maxn &lt;&lt; 5];int idx;char ch[maxn];void init()&#123; mem(root); mem(ls); mem(rs); mem(sum); idx = 0;&#125;int c0(int *s, int a, int b) &#123; return s[a] == s[b] &amp;&amp; s[a + 1] == s[b + 1] &amp;&amp; s[a + 2] == s[b + 2];&#125;int c12(int k, int *s, int a, int b) &#123; if (k == 2) return s[a] &lt; s[b] || s[a] == s[b] &amp;&amp; c12(1, s, a + 1, b + 1); return s[a] &lt; s[b] || s[a] == s[b] &amp;&amp; wv[a + 1] &lt; wv[b + 1];&#125;void sort(int *s, int *a, int *b, int n, int m) &#123; for (int i = 0; i &lt; n; i++) wv[i] = s[a[i]]; for (int i = 0; i &lt; m; i++) wc[i] = 0; for (int i = 0; i &lt; n; i++) wc[wv[i]]++; for (int i = 1; i &lt; m; i++) wc[i] += wc[i - 1]; for (int i = n - 1; i &gt;= 0; i--) b[--wc[wv[i]]] = a[i];&#125;void dc3(int *s, int *sa, int n, int m) &#123; int i, j, *sn = s + n, *san = sa + n, ta = 0, tb = (n + 1) / 3, tbc = 0, p; s[n] = s[n + 1] = 0; for (i = 0; i &lt; n; i++) if (i % 3 != 0) wa[tbc++] = i; sort(s + 2, wa, wb, tbc, m); sort(s + 1, wb, wa, tbc, m); sort(s, wa, wb, tbc, m); for (p = 1, sn[F(wb[0])] = 0, i = 1; i &lt; tbc; i++) sn[F(wb[i])] = c0(s, wb[i - 1], wb[i]) ? p - 1 : p++; if (p &lt; tbc) dc3(sn, san, tbc, p); else for (i = 0; i &lt; tbc; i++) san[sn[i]] = i; for (i = 0; i &lt; tbc; i++) if (san[i] &lt; tb) wb[ta++] = san[i] * 3; if (n % 3 == 1) wb[ta++] = n - 1; sort(s, wb, wa, ta, m); for (i = 0; i &lt; tbc; i++) wv[wb[i] = G(san[i])] = i; for (i = 0, j = 0, p = 0; i &lt; ta &amp;&amp; j &lt; tbc; p++) sa[p] = c12(wb[j] % 3, s, wa[i], wb[j]) ? wa[i++] : wb[j++]; for (; i &lt; ta; p++) sa[p] = wa[i++]; for (; j &lt; tbc; p++) sa[p] = wb[j++];&#125;void getheight() &#123; int i, j, k = 0; for (i = 1; i &lt;= n; i++) r[sa[i]] = i; for (i = 0; i &lt; n; h[r[i++]] = k) for (k ? k-- : 0, j = sa[r[i] - 1]; s[i + k] == s[j + k]; k++);&#125;void build(int &amp;o, int l, int r)&#123; o = ++idx; if(l == r) return; int mid = l + r &gt;&gt; 1; build(ls[o], l, mid); build(rs[o], mid + 1, r);&#125;void update(int pre, int &amp;o, int l, int r, int p, int v)&#123; o = ++idx; ls[o] = ls[pre], rs[o] = rs[pre], sum[o] = sum[pre] + v; if(l == r) return; int mid = l + r &gt;&gt; 1; if(p &lt;= mid) update(ls[pre], ls[o], l, mid, p, v); else update(rs[pre], rs[o], mid + 1, r, p, v);&#125;int query(int pre, int now, int l, int r, int k)&#123; int mid = l + r &gt;&gt; 1, x = sum[ls[now]] - sum[ls[pre]]; if(l == r) &#123; if(sum[now] - sum[pre] &gt; 0) return l; return -1; &#125; if(x &gt;= k) return query(ls[pre], ls[now], l, mid, k); return query(rs[pre], rs[now], mid + 1, r, k - x);&#125;int d[maxn][100];void RMQ_init() &#123; for (int i = 1; i &lt;= n; i++)d[i][0] = h[i]; for (int j = 1; (1 &lt;&lt; j) &lt;= n; j++) for (int i = 0; i + (1 &lt;&lt; j) - 1 &lt;= n; i++) d[i][j] = min(d[i][j - 1], d[i + (1 &lt;&lt; (j - 1))][j - 1]);&#125;int RMQ(int l,int r) &#123; if (l &gt; r)swap(l, r); int k = 0; while (1 &lt;&lt; (k + 1) &lt;= r - l + 1)k++; return min(d[l][k], d[r - (1 &lt;&lt; k) + 1][k]);&#125;int query(int pl, int pr)&#123; if(pl &gt; pr) swap(pl, pr); if(pl == pr) return n - sa[pl]; return RMQ(pl + 1, pr);&#125;int main()&#123; scanf("%d", &amp;T); while(T--)&#123; init(); scanf("%d %d", &amp;n, &amp;q); scanf("%s", ch); for(int i = 0; i &lt; n; i++) s[i] = ch[i] - 'a' + 1; s[n] = 0; dc3(s, sa, n + 1, 30); getheight(); RMQ_init(); for (int i = 1; i &lt;= n; ++i) &#123; update(root[i - 1], root[i], 1, n, sa[i] + 1, 1); &#125; while(q--)&#123; int l, len, k; scanf("%d %d %d", &amp;l, &amp;len, &amp;k); len -= l - 1; l = r[l - 1]; int lb = 1, ub = l, pl = 1; while(ub &gt;= lb)&#123; int mid = ub + lb &gt;&gt; 1; if(query(mid, l) &gt;= len) pl = mid, ub = mid - 1; else lb = mid + 1; &#125; lb = l, ub = n; int pr = 1; while(ub &gt;= lb)&#123; int mid = ub + lb &gt;&gt; 1; if(query(l, mid) &gt;= len) pr = mid, lb = mid + 1; else ub = mid - 1; &#125; printf("%d\n", query(root[pl - 1], root[pr], 1, n, k)); &#125; &#125; return 0;&#125; SAM:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef double db;typedef pair&lt;int, int&gt; pii;typedef vector&lt;int&gt; vi;typedef vector&lt;ll&gt; vl;typedef vector&lt;pii&gt; vp;const int inf = 1e9;const ll INF = 1e18;const db eps = 1e-10;#define fi first#define se second#define pb push_back#define eb emplace_back#define ep emplace#define mem(a) memset(a, 0, sizeof(a))#define copy(a, b) memcpy(a, b, sizeof(b))#define PA cout &lt;&lt; "pass\n"#define lowbit(x) (x &amp; -x)#define all(x) x.begin(), x.end()#define TM cout &lt;&lt; db(clock()) / CLOCKS_PER_SEC &lt;&lt; '\n'#define sigma_size 28const int maxn = 1e5 + 5;const int mod = 1e9 + 7;char s[maxn];typedef long long ll;int t[maxn];struct SAM &#123; int len[maxn * 2]; //最长子串的长度(该节点字串数量=len[x]-len[f[x]]) int f[maxn * 2]; //后缀链接(最短串前部减少一个字符所到达的状态) int cnt[maxn * 2]; //被后缀连接的数 int ch[maxn * 2][sigma_size]; //状态转移(尾部加一个字符的下一个状态)(图) int idx; //节点编号 int last; //最后节点 int epos[maxn * 2]; // enpos数（该状态子串出现数量） int pos[maxn * 2]; void init() &#123; //初始化 last = idx = 1; //1表示root起始点 空集 f[1] = len[1] = 0; memset(ch, 0, sizeof(ch)); mem(f); mem(cnt); mem(len); mem(epos); mem(pos); &#125;//SAM建图 void add(int c, int id) &#123; //插入字符，为字符ascll码值 int x = ++idx; //创建一个新节点x; len[x] = len[last] + 1; // 长度等于最后一个节点+1 epos[x] = 1; //接受节点子串除后缀连接还需加一 pos[x] = id; t[id] = x; int p; //第一个有C转移的节点; for (p = last; p &amp;&amp; !ch[p][c]; p = f[p])ch[p][c] = x;//沿着后缀连接 将所有没有字符c转移的节点直接指向新节点 if (!p)f[x] = 1, cnt[1]++; //全部都没有c的转移 直接将新节点后缀连接到起点 else &#123; int q = ch[p][c]; //p通过c转移到的节点 if (len[p] + 1 == len[q]) //pq是连续的 f[x] = q, cnt[q]++; //将新节点后缀连接指向q即可,q节点的被后缀连接数+1 else &#123; int nq = ++idx; //不连续 需要复制一份q节点 len[nq] = len[p] + 1; //令nq与p连续 f[nq] = f[q]; //因后面link[q]改变此处不加cnt memcpy(ch[nq], ch[q], sizeof(ch[q])); //复制q的信息给nq for (; p &amp;&amp; ch[p][c] == q; p = f[p]) ch[p][c] = nq; //沿着后缀连接 将所有通过c转移为q的改为nq f[q] = f[x] = nq; //将x和q后缀连接改为nq cnt[nq] += 2; // nq增加两个后缀连接 &#125; &#125; last = x; //更新最后处理的节点 &#125;&#125;sol;int root[maxn &lt;&lt; 6], ls[maxn &lt;&lt; 6], rs[maxn &lt;&lt; 6], sum[maxn &lt;&lt; 6];int _o;int T, n, q;vi G[maxn * 2];int f[maxn * 2][30];int in[maxn * 2], out[maxn * 2], cnt;void init()&#123; mem(root); mem(ls); mem(rs); mem(sum); mem(f); cnt = 0; _o = 0; for (int i = 1; i &lt;= 2 * n; ++i) &#123; G[i].clear(); &#125;&#125;void update(int pre, int &amp;o, int l, int r, int p, int v)&#123; o = ++_o; ls[o] = ls[pre], rs[o] = rs[pre], sum[o] = sum[pre] + v; if(l == r) return; int mid = l + r &gt;&gt; 1; if(p &lt;= mid) update(ls[pre], ls[o], l, mid, p, v); else update(rs[pre], rs[o], mid + 1, r, p, v);&#125;int query(int pre, int now, int l, int r, int k)&#123; int mid = l + r &gt;&gt; 1, x = sum[ls[now]] - sum[ls[pre]]; if(l == r) return l; if(x &gt;= k) return query(ls[pre], ls[now], l, mid, k); return query(rs[pre], rs[now], mid + 1, r, k - x);&#125;void dfs(int u)&#123; in[u] = ++cnt; update(root[cnt - 1], root[cnt], 1, n + 1, sol.pos[u], 1); for (int i = 1; i &lt;= 20; ++i) &#123; f[u][i] = f[f[u][i - 1]][i - 1]; &#125; for(auto &amp;v : G[u])&#123; dfs(v); &#125; out[u] = cnt;&#125;int main()&#123; scanf("%d", &amp;T); while(T--)&#123; scanf("%d %d %s", &amp;n, &amp;q, s + 1); sol.init(); init(); for (int i = 1; i &lt;= n; ++i) &#123; sol.add(s[i] - 'a', i); &#125; for (int i = 1; i &lt;= sol.idx; ++i) &#123; if(!sol.pos[i]) sol.pos[i] = n + 1; &#125; for (int i = 2; i &lt;= sol.idx; ++i) &#123; G[sol.f[i]].eb(i); f[i][0] = sol.f[i]; &#125; dfs(1); //cout &lt;&lt; sol.ch[sol.ch[1][0]][0] &lt;&lt; '\n'; while(q--)&#123; int l, r, k; scanf("%d %d %d", &amp;l, &amp;r, &amp;k); int p = t[r]; for(int i = 20; i &gt;= 0; i--)&#123; int x = f[p][i]; if(sol.len[x] &gt;= r - l + 1) p = x; &#125; int res = query(root[in[p] - 1], root[out[p]], 1, n + 1, k); if(res == n + 1) res = -1; else res -= r - l; printf("%d\n", res); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>后缀数组</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2019 Multi-University Training Contest 8-E(Acesrc and String Theory)]]></title>
    <url>%2F2019%2F08%2F25%2F2019-Multi-University-Training-Contest-8-E-Acesrc-and-String-Theory%2F</url>
    <content type="text"><![CDATA[链接：http://acm.hdu.edu.cn/showproblem.php?pid=6661思路：求是某个子串k次重复的子串有多少个。考虑这种免不了要枚举循环节。当循环节确定后，我们枚举某一个起点x，然后看它与x + len的lcp是否能出现k次，如果能我们可以前后拓展，这样整个sa数组就被分为了几段，每一段里面任意连续k * len长度的串都满足条件，这样我们对于每一段都可以统计贡献，所以我们需要正着反着都做一次SA，然后找到一段len向前后能拓展的最大长度，然后统计答案，之后跳到最右端开始新的一段。由于每次跳至少为len，根据调和级数可以知道复杂度最坏为O(nlogn)代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef double db;typedef pair&lt;int, int&gt; pii;typedef vector&lt;int&gt; vi;typedef vector&lt;ll&gt; vl;typedef vector&lt;pii&gt; vp;const int inf = 1e9;const ll INF = 1e18;const db eps = 1e-10;#define fi first#define se second#define pb push_back#define eb emplace_back#define ep emplace#define mem(a) memset(a, 0, sizeof(a))#define copy(a, b) memcpy(a, b, sizeof(b))#define PA cout &lt;&lt; "pass\n"#define lowbit(x) (x &amp; -x)#define all(x) x.begin(), x.end()#define TM cout &lt;&lt; db(clock()) / CLOCKS_PER_SEC &lt;&lt; '\n'#define F(x) ((x) / 3 + ((x) % 3 == 1 ? 0 : tb))#define G(x) ((x) &lt; tb ? (x) * 3 + 1 : ((x) - tb) * 3 + 2)const int maxn = 400005;int n, T;char s[maxn];struct Suffix_Array&#123; int wa[maxn], wb[maxn], wc[maxn], wv[maxn], sa[3 * maxn]; int r[maxn], h[maxn], s[3 * maxn]; int d[maxn][40]; int c0(int *s, int a, int b) &#123; return s[a] == s[b] &amp;&amp; s[a + 1] == s[b + 1] &amp;&amp; s[a + 2] == s[b + 2]; &#125; int c12(int k, int *s, int a, int b) &#123; if (k == 2) return s[a] &lt; s[b] || s[a] == s[b] &amp;&amp; c12(1, s, a + 1, b + 1); return s[a] &lt; s[b] || s[a] == s[b] &amp;&amp; wv[a + 1] &lt; wv[b + 1]; &#125; void sort(int *s, int *a, int *b, int n, int m) &#123; for (int i = 0; i &lt; n; i++) wv[i] = s[a[i]]; for (int i = 0; i &lt; m; i++) wc[i] = 0; for (int i = 0; i &lt; n; i++) wc[wv[i]]++; for (int i = 1; i &lt; m; i++) wc[i] += wc[i - 1]; for (int i = n - 1; i &gt;= 0; i--) b[--wc[wv[i]]] = a[i]; &#125; void dc3(int *s, int *sa, int n, int m) &#123; int i, j, *sn = s + n, *san = sa + n, ta = 0, tb = (n + 1) / 3, tbc = 0, p; s[n] = s[n + 1] = 0; for (i = 0; i &lt; n; i++) if (i % 3 != 0) wa[tbc++] = i; sort(s + 2, wa, wb, tbc, m); sort(s + 1, wb, wa, tbc, m); sort(s, wa, wb, tbc, m); for (p = 1, sn[F(wb[0])] = 0, i = 1; i &lt; tbc; i++) sn[F(wb[i])] = c0(s, wb[i - 1], wb[i]) ? p - 1 : p++; if (p &lt; tbc) dc3(sn, san, tbc, p); else for (i = 0; i &lt; tbc; i++) san[sn[i]] = i; for (i = 0; i &lt; tbc; i++) if (san[i] &lt; tb) wb[ta++] = san[i] * 3; if (n % 3 == 1) wb[ta++] = n - 1; sort(s, wb, wa, ta, m); for (i = 0; i &lt; tbc; i++) wv[wb[i] = G(san[i])] = i; for (i = 0, j = 0, p = 0; i &lt; ta &amp;&amp; j &lt; tbc; p++) sa[p] = c12(wb[j] % 3, s, wa[i], wb[j]) ? wa[i++] : wb[j++]; for (; i &lt; ta; p++) sa[p] = wa[i++]; for (; j &lt; tbc; p++) sa[p] = wb[j++]; &#125; void getheight() &#123; int i, j, k = 0; for (i = 1; i &lt;= n; i++) r[sa[i]] = i; for (i = 0; i &lt; n; h[r[i++]] = k) for (k ? k-- : 0, j = sa[r[i] - 1]; s[i + k] == s[j + k]; k++); &#125; void RMQ_init() &#123; for (int i = 1; i &lt;= n; i++)d[i][0] = h[i]; for (int j = 1; (1 &lt;&lt; j) &lt;= n; j++) for (int i = 0; i + (1 &lt;&lt; j) - 1 &lt;= n; i++) d[i][j] = min(d[i][j - 1], d[i + (1 &lt;&lt; (j - 1))][j - 1]); &#125; int RMQ(int l, int r) &#123; if (l &gt; r)swap(l, r); int k = 0; while (1 &lt;&lt; (k + 1) &lt;= r - l + 1)k++; return min(d[l][k], d[r - (1 &lt;&lt; k) + 1][k]); &#125; int query(int L, int R)&#123; L = r[L], R = r[R]; if(L &gt; R) swap(L, R); if(L == R) return n - sa[L]; return RMQ(L + 1, R); &#125;&#125;L, R;int k;int solve(int pl, int pr, int len)&#123; int lt = L.query(pl, pr + 1);; int rt = R.query(n - 1 - pr, n - pl); pl -= rt; pr += lt; return max(0, pr - pl + 1 - k * len + 1);&#125;int main()&#123; scanf("%d", &amp;T); while(T--)&#123; scanf("%d %s", &amp;k, s); n = strlen(s); if(k == 1)&#123; printf("%lld\n", 1ll * n * (n + 1) / 2); continue; &#125; for(int i = 0; i &lt; n; i++) L.s[i] = s[i] - 'a' + 1, R.s[n - 1 - i] = s[i] - 'a' + 1; L.s[n] = R.s[n] = 0; L.dc3(L.s, L.sa, n + 1, 30); L.getheight(); L.RMQ_init(); R.dc3(R.s, R.sa, n + 1, 30); R.getheight(); R.RMQ_init(); ll res = 0; for(int len = 1; len &lt;= n; len++)&#123; int last = 0; while(last + len &lt; n)&#123; res += solve(last, last + len - 1, len); last += L.query(last, last + len) + len; &#125; &#125; printf("%lld\n", res); &#125; return 0;&#125;]]></content>
      <categories>
        <category>后缀数组</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2019牛客暑期多校训练营(第十场)-J(Wood Processing)]]></title>
    <url>%2F2019%2F08%2F18%2F2019%E7%89%9B%E5%AE%A2%E6%9A%91%E6%9C%9F%E5%A4%9A%E6%A0%A1%E8%AE%AD%E7%BB%83%E8%90%A5-%E7%AC%AC%E5%8D%81%E5%9C%BA-J-Wood-Processing%2F</url>
    <content type="text"><![CDATA[链接：https://ac.nowcoder.com/acm/contest/890/J思路：以为简单套套wqs二分就行了，结果出了一堆问题，才发现是自己wqs二分完全没学懂，这里会再细致梳理一下。 wqs二分概念对于形如题目有限制选k个物品，或者至多至少选k个物品且我们证明出必定选满k个为最优的限制的题目，就可以运用wqs二分来解决。常规dp必须要将选多少个作为一维状态来记录，wqs二分可以感性理解：我们给每一次操作增加一个代价，然后去掉选k个的限制，显然代价和选的个数具有单调性关系，我们就利用这个单调性关系，二分代价，从而找到刚好选k个物品的答案，这样dp就可以降维。 wqs二分理论假设没有选k个限制时，我们发现选的个数和答案是一个凸函数，我们考虑二分一个代价，然后加到总的答案里，我们发现图像会变成一个单峰函数，我们找到最值，再把选的代价还原回去，即可知道二分大了还是小了，根据方向更新答案（后面会说）。求最大值的话就是一个上凸函数，最小值就是一个下凸函数。图示就是一个上凸函数求最大值，考虑二分一个斜率（代价），这时候所有点当中，会有一个点使得这条直线的截距最大，如果这个点刚好是在k处取的，那么这个截距就是我们要求的选k个时候的答案。我们可以根据二分后dp结束后最优值与k的大小关系，来更新斜率的大小，从而最后把斜率卡在选k的位置，得到最后要求的答案。注意wqs二分的上下界是[-n max, n max] wqs一个非常重要且很容易让人忽视的细节有一个很关键的问题，就是有没有可能这个斜率不是整数，即当斜率为x的时候最值在k - 1，当斜率为x + 1的时候最值在k + 1。我们想一想，出现这种情况，一定代表着你k - 1或者k + 1时也可以取到k处的答案（即凸函数在这几个点是共线的，要多思考一下这个问题），那么我们也可以用k - 1或者k + 1的答案来更新，因为它们是共线的所以没有影响。但问题来了，到底什么时候更新呢？也就是说多点共线的时候，我们要强制保证我们取的答案必须是左端点或者右端点，如果在中间，你就不知道什么时候更新才是正确答案。如果在左端点，我们就在小于等于k的时候更新，如果在右端点，我们就在大于等于k的时候更新。因为我们知道，最后一定会取到那条直线上。当你强制规定一条直线取左右端点时，它一定会取到，且跟它共线的其他点不会取到，且只会在小于等于/大于等于k的时候更新，这样一定可以保证最后答案是正确的？那么怎么保证一定在左端点或者右端点呢？这个就需要你在排序/dp的时候下功夫了。比如国家集训队tree那道题，可能出现选多个白边代价在一条直线上的情况，这样一定是有一些白边和黑边代价一样造成的，我们排序时权值相等就先选白边，这样就强制到了右端点，那么就大于等于的时候更新。 还有就是这个题，因为是wqs二分套了斜率优化，我们考虑如果强制左端点，那么斜率优化的时候要保证转移的步数是最小的，也就是当斜率相同时必须要取最前面的点。好像看似一定会取到最前面的点，其实不然，考虑后面加点进去的时候，如果斜率相同一定要pop掉。因为斜率相同，说明有三点共线，说明中间那个点无论如何不可能时唯一的最优决策点，它前面那个点一定不会比他权值差且步数也不会比它多，如果这个时候不pop，后面可能会有一个斜率过大，把所有的折线都pop掉，只留下一个点，就可能是这个不可能成为唯一最优的决策点，事实上应该从这个斜率最前面的点转移过来是最优的（因为步数可能会更少，是因为没点了才被迫留下最后一个点），所以我们必须把斜率相同的也pop掉才对，斜率严格大于时才pop前面。（不建议这么写，非常容易想不清楚就出错了）当然这种其实强制右端点更简单，那么斜率优化我们要保证转移的步数是最大的，也就是斜率相同我们尽量取后面的点，那从前面pop时斜率相同我们pop，后面就无所谓了反正一定会到最后一个点。 还有南京那个题也就能解释怎么更新了，如果二分栈比较的时候你是按最大步数优先，外面就大于等于的时候更新，否则就小于等于的时候更新即可。代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef __int128 LL;typedef double db;typedef pair&lt;int, int&gt; pii;typedef vector&lt;int&gt; vi;typedef vector&lt;ll&gt; vl;typedef vector&lt;pii&gt; vp;const int inf = 1e9;const ll INF = 1e18;#define fi first#define se second#define pb push_back#define eb emplace_back#define ep emplace#define mem(a) memset(a, 0, sizeof(a))#define copy(a, b) memcpy(a, b, sizeof(b))#define PA cout &lt;&lt; "pass\n"#define lowbit(x) (x &amp; -x)#define all(x) x.begin(), x.end()#define TM cout &lt;&lt; db(clock() / CLOCKS_PER_SEC) &lt;&lt; '\n'const int maxn = 5050;ll dp[maxn];int cnt[maxn];pii a[maxn];int n, k;int head, tail;int Q[maxn];ll sum[maxn], w[maxn];ll up(int x, int y)&#123; return sum[x] - w[x] * a[x + 1].fi - dp[x] + dp[y] - sum[y] + w[y] * a[y + 1].fi;&#125;ll down(int x, int y)&#123; return a[y + 1].fi - a[x + 1].fi;&#125;bool solve(ll x)&#123; head = 1, tail = 1; Q[1] = 0; for(int i = 1; i &lt;= n; i++)&#123; while(head &lt; tail &amp;&amp; (LL)up(Q[head], Q[head + 1]) &lt; (LL)down(Q[head], Q[head + 1]) * w[i]) head++; int now = Q[head]; dp[i] = dp[now] + (sum[i] - sum[now]) - (w[i] - w[now]) * a[now + 1].fi + x; cnt[i] = cnt[now] + 1; while(head &lt; tail &amp;&amp; (LL)up(Q[tail - 1], Q[tail]) * down(Q[tail], i) &gt;= (LL)up(Q[tail], i) * down(Q[tail - 1], Q[tail])) tail--; Q[++tail] = i; &#125; return cnt[n] &lt;= k;&#125;int main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); cin &gt;&gt; n &gt;&gt; k; for (int i = 1; i &lt;= n; ++i) &#123; cin &gt;&gt; a[i].se &gt;&gt; a[i].fi; &#125; sort(a + 1, a + n + 1); for (int i = 1; i &lt;= n; ++i) &#123; sum[i] = sum[i - 1] + 1ll * a[i].fi * a[i].se; w[i] = w[i - 1] + a[i].se; &#125; ll lb = -1e18, ub = 1e18, ans = 0; while(ub &gt;= lb)&#123; ll mid = ub + lb &gt;&gt; 1; if(solve(mid))&#123; ub = mid - 1; ans = dp[n] - 1ll * mid * k; &#125; else lb = mid + 1; &#125; cout &lt;&lt; ans &lt;&lt; '\n'; return 0;&#125;]]></content>
      <categories>
        <category>wqs二分</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2019牛客暑期多校训练营(第九场)-I(KM and M)]]></title>
    <url>%2F2019%2F08%2F16%2F2019%E7%89%9B%E5%AE%A2%E6%9A%91%E6%9C%9F%E5%A4%9A%E6%A0%A1%E8%AE%AD%E7%BB%83%E8%90%A5-%E7%AC%AC%E4%B9%9D%E5%9C%BA-I-KM-and-M%2F</url>
    <content type="text"><![CDATA[链接：https://ac.nowcoder.com/acm/contest/889/I思路：按位考虑贡献，那么如果M的这一位为1，我们考虑有多少K使得KM的这一位也为1，也就是求\sum_{i = 1}^N[\frac{KM}{2^x} \% 2 == 1]，这个明显是类欧的问题，而判奇偶又有着一个经典套路，我们把判断奇偶转化为一个差值，即: \sum_{i = 1}^N \frac{KM}{2^x} - \lfloor\frac{KM}{2^{x + 1}}\rfloor * 2发现变成了两个类欧的经典问题，统计出来个数的贡献后乘以该位的值，最后求和就是答案了。代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include&lt;bits/stdc++.h&gt;using namespace std;typedef __int128 LL;typedef long long ll;typedef double db;typedef pair&lt;int, int&gt; pii;typedef vector&lt;int&gt; vi;typedef vector&lt;ll&gt; vl;typedef vector&lt;pii&gt; vp;const int inf = 1e9;const LL INF = 1e18;#define fi first#define se second#define pb push_back#define eb emplace_back#define ep emplace#define mem(a) memset(a, 0, sizeof(a))#define copy(a, b) memcpy(a, b, sizeof(b))#define PA cout &lt;&lt; "pass\n"#define lowbit(x) (x &amp; -x)#define all(x) x.begin(), x.end()#define TM cout &lt;&lt; db(clock() / CLOCKS_PER_SEC) &lt;&lt; '\n'//1e9 + 7////const int mod = 1e9 + 7;const int inv2 = 500000004;const int inv6 = 166666668;struct node &#123; LL f, g, h;&#125;;node solve(LL a, LL b, LL c, LL n) &#123; node ans, tmp; if (a == 0) &#123; ans.f = (n + 1) * (b / c) % mod; ans.g = (b / c) * n % mod * (n + 1) % mod * inv2 % mod; ans.h = (n + 1) * (b / c) % mod * (b / c) % mod; return ans; &#125; if (a &gt;= c || b &gt;= c) &#123; tmp = solve(a % c, b % c, c, n); ans.f = (tmp.f + (a / c) * n % mod * (n + 1) % mod * inv2 % mod + (b / c) * (n + 1) % mod) % mod; ans.g = (tmp.g + (a / c) * n % mod * (n + 1) % mod * (2 * n + 1) % mod * inv6 % mod + (b / c) * n % mod * (n + 1) % mod * inv2 % mod) % mod; ans.h = ((a / c) * (a / c) % mod * n % mod * (n + 1) % mod * (2 * n + 1) % mod * inv6 % mod + (b / c) * (b / c) % mod * (n + 1) % mod + (a / c) * (b / c) % mod * n % mod * (n + 1) % mod + tmp.h + 2 * (a / c) % mod * tmp.g % mod + 2 * (b / c) % mod * tmp.f % mod) % mod; return ans; &#125; LL m = (a * n + b) / c; tmp = solve(c, c - b - 1, a, m - 1); ans.f = ((n * (m % mod) % mod - tmp.f) % mod + mod) % mod; ans.g = ((n * (n + 1) % mod * (m % mod) % mod - tmp.f - tmp.h) % mod + mod) * inv2 % mod; ans.h = ((n * (m % mod) % mod * ((m + 1) % mod) % mod - 2 * tmp.g - 2 * tmp.f - ans.f) % mod + mod) % mod; return ans;&#125;ll n, m;int main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); cin &gt;&gt; n &gt;&gt; m; ll res = 0; for (int i = 0; i &lt; 40; ++i) &#123; if((m &gt;&gt; i) &amp; 1)&#123; node t1 = solve(m, 0, 1ll &lt;&lt; i, n); node t2 = solve(m, 0, 2ll &lt;&lt; i, n); res = (res + (t1.f - 2 * t2.f + 2ll * mod) % mod * ((1ll &lt;&lt; i) % mod)) % mod; &#125; &#125; cout &lt;&lt; res &lt;&lt; '\n'; return 0;&#125;]]></content>
      <categories>
        <category>类欧</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[bzoj-3817(Sum)]]></title>
    <url>%2F2019%2F08%2F16%2Fbzoj-3817-Sum%2F</url>
    <content type="text"><![CDATA[链接：https://www.lydsy.com/JudgeOnline/problem.php?id=3817思路：类欧几里得 无理数类欧我们先来看一个简单的问题：求\sum_{i = 0}^ndi，其中d是一个无理数。没法写成分数形式，好像我们就没法用代数形式推导了。。我们考虑先观察一下无理数有哪些性质：我们发现，如果我们用几何意义来解释，那么一定不会有整点在直线上，而有理数是会有整点存在于整点上的。我们考虑d &gt; 1的情况： \sum_{i = 1}^ndi = \sum_{i = 0}^n\lfloor\ d\rfloor i + (d - \lfloor d\rfloor)i = \lfloor d\rfloor \frac{n(n + 1)}{2} + \sum_{i = 1}^n(d - \lfloor d\rfloor)i我们很愉快的发现后面是个子问题，可以递归去做。几何解释就是如下，黑色部分是现在计算的，白色是递归去做的考虑 d &lt;= 1的情况：考虑将上图白色部分逆时针旋转90度，然后再关于y轴对称：这时候两个对称，我们只用总的矩形 - 黑色部分就是白色部分，因为无理数直线上没有整数点的性质，我们用总的减黑色的，发现黑色又是d &gt; 1的情况，也可以递归去做了 回到本题，我们先把式子化简一下，我们假设x = \sqrt(r)原来问题就变成了:\sum_{d = 1}^n(-1)^{\lfloor dx \rfloor}我们发现取值只与dx的奇偶性有关，我们考虑可以写为：\sum_{d = 1}^n 1 - 2[dx \% 2 == 1]下面是类欧里面比较经典常用的变换，即我们可以将是否为奇数的判断是改写成： \sum_{d = 1}^n 1 - 2(dx - \lfloor\frac{dx}{2}\rfloor *2)这样我们最终要求的就是: n + \sum_{d = 1}^n 4 * \lfloor\frac{dx}{2}\rfloor - 2dx如果r不是平方数，那么它的根号就是无理数，我们采用无理数的类欧，否则要吗特判要吗用有理数类欧进行解决。 注意本题如果直接带着无理数搞精度可能不够，我们需要利用根号的性质，用三个变量a, b, c，表示d，初始的时候a = 1, b = 0, c = 1。然后考虑取倒数，原来我们的形式为k = \frac{ax + b}{c}，倒过来后变为k = \frac{c}{ax + b}，我们把它凑成对应的形式：\frac{acx - bc}{a^2x^2 - b^2}，那么新的a = ac，新的b = -bc，新的c = a^2x^2 - b^2。这样基本不会损失精度。代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef double db;typedef pair&lt;int, int&gt; pii;typedef vector&lt;int&gt; vi;typedef vector&lt;ll&gt; vl;typedef vector&lt;pii&gt; vp;const int inf = 1e9;const ll INF = 1e18;#define fi first#define se second#define pb push_back#define eb emplace_back#define ep emplace#define mem(a) memset(a, 0, sizeof(a))#define copy(a, b) memcpy(a, b, sizeof(b))#define PA cout &lt;&lt; "pass\n"#define lowbit(x) (x &amp; -x)#define all(x) x.begin(), x.end()#define TM cout &lt;&lt; db(clock() / CLOCKS_PER_SEC) &lt;&lt; '\n'll r;db x;ll n;ll cal(ll a, ll b, ll c, ll n)&#123; if(!n) return 0; ll g = __gcd(a, __gcd(b, c)); a /= g, b /= g, c /= g; ll k = (a * x + b) / c; if(!k) &#123; ll tmp = (a * x + b) / c * n; return tmp * n - cal(a * c, -b * c, a * a * r - b * b, tmp); &#125; return k * n * (n + 1) / 2 + cal(a, b - c * k, c, n);&#125;ll f(ll a, ll b, ll c, ll n)&#123; if(!a) return (n + 1) * (b / c); ll g = __gcd(a, __gcd(b, c)); a /= g, b /= g, c /= g; if(a &gt;= c || b &gt;= c)&#123; return (n + 1) * n / 2 * (a / c) + (n + 1) * (b / c) + f(a % c, b % c, c, n); &#125; ll m = (a * n + b) / c; return n * m - f(c, c - b - 1, a, m - 1);&#125;int T;int main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); cin &gt;&gt; T; while(T--)&#123; cin &gt;&gt; n &gt;&gt; r; x = sqrt(1.0 * r); int t = x; if(1ll * t * t == r)&#123; cout &lt;&lt; n + 4 * f(r, 0, 2, n) - 2 * f(r, 0, 1, n) &lt;&lt; '\n'; &#125; else &#123; cout &lt;&lt; n + 4 * cal(1, 0, 2, n) - 2 * cal(1, 0, 1, n) &lt;&lt; '\n'; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>类欧</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[luogu-P5170(类欧几里得算法)]]></title>
    <url>%2F2019%2F08%2F16%2Fluogu-P5170-%E7%B1%BB%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[链接：https://www.luogu.org/problem/P5170思路：类欧几里得问题 类欧几里得f = \sum_{i = 0}^n\lfloor\frac{ai + b}{c}\rfloorg = \sum_{i = 0}^n\lfloor\frac{ai + b}{c}\rfloor^2h = \sum_{i = 0}^ni\lfloor\frac{ai + b}{c}\rfloor类欧就是解决这三个问题。 证明与推导https://blog.csdn.net/WorldWide_D/article/details/54730588本文不详细证明 结论令m = \lfloor\frac{an + b}{c}\rfloor f(a, b, c, n) = f(a \% c, b \% c, c, n) + \frac{n(n + 1)}{2}\lfloor\frac{a}{c}\rfloor + (n + 1)\lfloor\frac{b}{c}\rfloor (a >= c \ ||\ b >= c)f(a, b, c, n) = nm - f(c, c - b - 1, a, m - 1) (a < c \ \&\& \ b < c)g(a, b, c, n) = g(a \%c, b \%c, c, n) + \frac{n(n + 1)(2n + 1)}{6}\lfloor\frac{a}{c}\rfloor + \frac{n(n + 1)}{2}\lfloor\frac{b}{c}\rfloor(a >= c \ ||\ b >= c)g(a, b, c, n) = \frac{nm(n + 1) - f(c, c - b - 1, a, m - 1) - h(c, c - b - 1, a, m - 1)}{2}(a < c \ \&\& \ b < c)h(a, b, c, d) = h(a \%c, b \%c, c, n) + \frac{n(n + 1)(2n + 1)}{6}\lfloor\frac{a}{c}^2\rfloor + (n + 1)\lfloor\frac{b}{c}\rfloor^2 \\ + 2\lfloor\frac{b}{c}\rfloor f(a \%c, b \%c, c, n) + 2\lfloor\frac{a}{c}\rfloor g(a \%c, b \%c, c, n) + \lfloor\frac{a}{c}\rfloor\lfloor\frac{b}{c}\rfloor n(n + 1) (a >= c \ ||\ b >= c)h(a, b, c, d) = m(m + 1)n - 2g(c, c - b - 1, a, m - 1) - 2f(c, c - b - 1, a, m - 1) - f(a, b, c, n)注意事项类欧在斜率是有理数和无理数的做法是不同的，因为无理数不能表示成分数形式的形式，且直线上不存在整点，所以有理数的类欧问题不能用无理数解决，无理数的类欧问题也不能用有理数解决。 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef double db;typedef pair&lt;int, int&gt; pii;typedef vector&lt;int&gt; vi;typedef vector&lt;ll&gt; vl;typedef vector&lt;pii&gt; vp;const int inf = 1e9;const ll INF = 1e18;#define fi first#define se second#define pb push_back#define eb emplace_back#define ep emplace#define mem(a) memset(a, 0, sizeof(a))#define copy(a, b) memcpy(a, b, sizeof(b))#define PA cout &lt;&lt; "pass\n"#define lowbit(x) (x &amp; -x)#define all(x) x.begin(), x.end()#define TM cout &lt;&lt; db(clock() / CLOCKS_PER_SEC) &lt;&lt; '\n'const int mod = 998244353;const int inv2 = 499122177;const int inv6 = 166374059;struct node &#123; ll f, g, h;&#125;;node solve(ll a, ll b, ll c, ll n) &#123; node ans, tmp; if (a == 0) &#123; ans.f = (n + 1) * (b / c) % mod; ans.g = (b / c) * n % mod * (n + 1) % mod * inv2 % mod; ans.h = (n + 1) * (b / c) % mod * (b / c) % mod; return ans; &#125; if (a &gt;= c || b &gt;= c) &#123; tmp = solve(a % c, b % c, c, n); ans.f = (tmp.f + (a / c) * n % mod * (n + 1) % mod * inv2 % mod + (b / c) * (n + 1) % mod) % mod; ans.g = (tmp.g + (a / c) * n % mod * (n + 1) % mod * (2 * n + 1) % mod * inv6 % mod + (b / c) * n % mod * (n + 1) % mod * inv2 % mod) % mod; ans.h = ((a / c) * (a / c) % mod * n % mod * (n + 1) % mod * (2 * n + 1) % mod * inv6 % mod + (b / c) * (b / c) % mod * (n + 1) % mod + (a / c) * (b / c) % mod * n % mod * (n + 1) % mod + tmp.h + 2 * (a / c) % mod * tmp.g % mod + 2 * (b / c) % mod * tmp.f % mod) % mod; return ans; &#125; ll m = (a * n + b) / c; tmp = solve(c, c - b - 1, a, m - 1); ans.f = ((n * (m % mod) % mod - tmp.f) % mod + mod) % mod; ans.g = ((n * (n + 1) % mod * (m % mod) % mod - tmp.f - tmp.h) % mod + mod) * inv2 % mod; ans.h = ((n * (m % mod) % mod * ((m + 1) % mod) % mod - 2 * tmp.g - 2 * tmp.f - ans.f) % mod + mod) % mod; return ans;&#125;int T, n, a, b, c;int main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); cin &gt;&gt; T; while(T--)&#123; cin &gt;&gt; n &gt;&gt; a &gt;&gt; b &gt;&gt; c; node ans = solve(a, b, c, n); cout &lt;&lt; ans.f &lt;&lt; ' ' &lt;&lt; ans.h &lt;&lt; ' ' &lt;&lt; ans.g &lt;&lt; '\n'; &#125; return 0;&#125;]]></content>
      <categories>
        <category>类欧</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2019牛客暑期多校训练营(第八场)-F(Flower Dance)]]></title>
    <url>%2F2019%2F08%2F13%2F2019%E7%89%9B%E5%AE%A2%E6%9A%91%E6%9C%9F%E5%A4%9A%E6%A0%A1%E8%AE%AD%E7%BB%83%E8%90%A5-%E7%AC%AC%E5%85%AB%E5%9C%BA-F-Flower-Dance%2F</url>
    <content type="text"><![CDATA[链接：https://ac.nowcoder.com/acm/contest/888/F思路：好像一直不太能写对这种极角排序后统计数量的题目？这个题我们从反面考虑，枚举一个点后，我们找不合法的另外三个点有哪些情况，很明显：四点能构成凸包，三点共线，四点共线。考虑四点构成凸包，我们定了一个点，那么跟它相连的有两条边，所以我们只用定一侧进行选择就可以（假设是左侧）。剩下两种情况也好处理，所以方法就出来了，我们枚举一个点，然后极角排序，枚举一个向量，先找出跟这个向量方向相同的向量，假设$p_1$条。然后找到在它左侧的向量数目，假设$p_2$条。三点共线数目就是\frac{p_1 * (p_1 - 1)}{2} * p_2，四点共线就是\frac{p_1 * (p_1 - 1) * (p_1 - 2)}{6}，凸包就是\frac{p_2 * (p_2 - 1)}{2} * p_1。但发现还有算少的，四点共线，还有可能有点在另一侧，我们再单独扣掉就好了。注意旋转时候的边界判断，叉积的大于/小于 和等于最好分开写，因为等于需要和内积一起使用来判断，不然可能出现转过了的情况。代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef double db;typedef pair&lt;int, int&gt; pii;typedef vector&lt;int&gt; vi;typedef vector&lt;ll&gt; vl;typedef vector&lt;pii&gt; vp;const int inf = 1e9;const ll INF = 1e18;#define fi first#define se second#define pb push_back#define eb emplace_back#define ep emplace#define mem(a) memset(a, 0, sizeof(a))#define copy(a, b) memcpy(a, b, sizeof(b))#define PA cout &lt;&lt; "pass\n"#define lowbit(x) (x &amp; -x)#define all(x) x.begin(), x.end()#define TM db(clock() / CLOCKS_PER_SEC)typedef struct P&#123; ll x, y; P(ll x = 0, ll y = 0): x(x), y(y)&#123;&#125; P operator +(const P &amp;r) const&#123; return P(x + r.x, y + r.y); &#125; P operator -(const P &amp;r) const&#123; return P(x - r.x, y - r.y); &#125; P operator *(const ll r) const&#123; return P(x * r, y * r); &#125; P operator /(const ll r) const&#123; assert(r != 0); return P(x / r, y / r); &#125; bool upper()&#123;return y &gt; 0 || (y == 0 &amp;&amp; x &gt; 0);&#125;&#125;V;ll Cross(V a, V b)&#123; return a.x * b.y - a.y * b.x;&#125;ll Dot(V a, V b)&#123; return a.x * b.x + a.y * b.y;&#125;bool cmp(P a, P b) &#123; if(a.upper() != b.upper()) return a.upper() &gt; b.upper(); return Cross(a, b) &gt; 0;&#125;const int maxn = 2010;P r[maxn];int n;ll res;P t[maxn];void solve(int x)&#123; int cnt = 0; for (int i = 1; i &lt;= n; ++i) &#123; if(i == x) continue; t[++cnt] = r[i]; &#125; map&lt;pii, int&gt; mp; for (int i = 1; i &lt;= cnt; ++i) &#123; t[i] = t[i] - r[x]; int g = abs(__gcd(t[i].x, t[i].y)); mp[pii(t[i].x / g, t[i].y / g)]++; &#125; for(auto &amp;it : mp)&#123; res += 1ll * it.se * (it.se - 1) / 2 * mp[pii(-it.fi.fi, -it.fi.se)]; &#125; sort(t + 1, t + cnt + 1, cmp); for (int i = cnt + 1; i &lt;= 2 * cnt; ++i) &#123; t[i] = t[i - cnt]; &#125; res += 1ll * cnt * (cnt - 1) * (cnt - 2) / 6; for (int i = 1, j, k = 1; i &lt;= cnt; i = j) &#123; j = i; while(j &lt;= cnt &amp;&amp; Cross(t[j], t[i]) == 0 &amp;&amp; Dot(t[i], t[j]) &gt; 0) j++; int p = j - i; res -= 1ll * p * (p - 1) * (p - 2) / 6; while(k &lt; i + cnt &amp;&amp; Cross(t[i], t[k]) &gt;= 0) k++; int pp = k - j; res -= 1ll * p * (pp - 1) * pp / 2; res -= 1ll * p * (p - 1) * pp / 2; &#125;&#125;int main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); cin &gt;&gt; n; for (int i = 1; i &lt;= n; ++i) &#123; cin &gt;&gt; r[i].x &gt;&gt; r[i].y; &#125; for (int i = 1; i &lt;= n; ++i) &#123; solve(i); &#125; cout &lt;&lt; res &lt;&lt; '\n'; return 0;&#125;]]></content>
      <categories>
        <category>计算几何</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2019牛客暑期多校训练营(第八场)-I(Inner World)]]></title>
    <url>%2F2019%2F08%2F13%2F2019%E7%89%9B%E5%AE%A2%E6%9A%91%E6%9C%9F%E5%A4%9A%E6%A0%A1%E8%AE%AD%E7%BB%83%E8%90%A5-%E7%AC%AC%E5%85%AB%E5%9C%BA-I-Inner-World%2F</url>
    <content type="text"><![CDATA[链接：https://ac.nowcoder.com/acm/contest/888/I思路：大概是这段时间来做的最妙的一个题了吧？问题有很多约束，从而产生了很多性质，需要慢慢挖掘。首先每个点只会被加一次，那么意味着这些加的点其实可以构成一棵树。其次是所有点加完后才询问，也就是这是一个静态的问题。每次询问的是[l, r]的树中有多少子节点，我们换一个看法，因为每个点只会被加一次，我们把这些加入操作构成一棵树，每个点有一个区间[l, r]，那么产生贡献的点一定在这个树询问点的子树内，也就是子树内每一个点与[l, r]区间求交，再把大小计入贡献。这个时候最妙的来了，我们可以把这个构成的树的dfs序看作一维，把区间看作第二维，那么考虑进行dfs，并且按照每个点对应的[l, r]进行加点。假设询问点是u，我们在x1进入点u，x2点离开u点，那么我们要求的总和，在二维矩阵里是不是对应的就是(x1, l), (x2, r)这个矩阵。二维矩阵我们知道可以用容斥算，但很明显空间不够我们开二维，我们思考一下，假设我们把矩阵大小写成如下形式：[(x2, r), (1, l)] - [(x1, r), (1, l)]，即写为前缀和相减，我们惊奇的发现，我们可以维护一棵线段树，线段树上维护第二维，我们把所有询问记录到对应点上，进去的时候算一下公式后面的x1部分，然后更新，进入子树更新，出来的时候就刚好是x2状态，再算一下前面的贡献，二者之差就是这个点询问的答案了，这也非常巧妙的就甩掉了第一维。代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef double db;typedef pair&lt;int, int&gt; pii;typedef vector&lt;int&gt; vi;typedef vector&lt;ll&gt; vl;typedef vector&lt;pii&gt; vp;const int inf = 1e9;const ll INF = 1e18;#define fi first#define se second#define pb push_back#define eb emplace_back#define ep emplace#define mem(a) memset(a, 0, sizeof(a))#define copy(a, b) memcpy(a, b, sizeof(b))#define PA cout &lt;&lt; "pass\n"#define lowbit(x) (x &amp; -x)#define all(x) x.begin(), x.end()#define TM db(clock() / CLOCKS_PER_SEC)const int maxn = 3e5 + 233;int n, m, q;ll sum[maxn &lt;&lt; 2];int tag[maxn &lt;&lt; 2];void pushup(int o)&#123; sum[o] = sum[o &lt;&lt; 1] + sum[o &lt;&lt; 1 | 1];&#125;void pushdown(int o, int m)&#123; if(tag[o])&#123; tag[o &lt;&lt; 1] += tag[o]; tag[o &lt;&lt; 1 | 1] += tag[o]; sum[o &lt;&lt; 1] += 1ll * tag[o] * (m - (m &gt;&gt; 1)); sum[o &lt;&lt; 1 | 1] += 1ll * tag[o] * (m &gt;&gt; 1); tag[o] = 0; &#125;&#125;void update(int o, int tl, int tr, int l, int r, int v)&#123; if(l &gt; tr || tl &gt; r) return; if(l &lt;= tl &amp;&amp; tr &lt;= r)&#123; tag[o] += v; sum[o] += 1ll * v * (tr - tl + 1); return; &#125; pushdown(o, tr - tl + 1); int mid = tl + tr &gt;&gt; 1; update(o &lt;&lt; 1, tl, mid, l, r, v); update(o &lt;&lt; 1 | 1, mid + 1, tr, l, r, v); pushup(o);&#125;ll query(int o, int tl, int tr, int l, int r)&#123; if(l &gt; tr || tl &gt; r) return 0; if(l &lt;= tl &amp;&amp; tr &lt;= r) return sum[o]; pushdown(o, tr - tl + 1); int mid = tl + tr &gt;&gt; 1; return query(o &lt;&lt; 1, tl, mid, l, r) + query(o &lt;&lt; 1 | 1, mid + 1, tr, l, r);&#125;int l[maxn], r[maxn];vp in[maxn], out[maxn];vi G[maxn];vi ask[maxn];ll res[maxn];void dfs(int u)&#123; for(int i = 0; i &lt; in[u].size(); i++)&#123; res[ask[u][i]] = -query(1, 1, n, in[u][i].fi, in[u][i].se); &#125; if(l[u] &amp;&amp; r[u]) update(1, 1, n, l[u], r[u], 1); for(auto &amp;v : G[u])&#123; dfs(v); &#125; for(int i = 0; i &lt; out[u].size(); i++)&#123; res[ask[u][i]] += query(1, 1, n, out[u][i].fi, out[u][i].se); &#125;&#125;int main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= m; ++i) &#123; int u, v, x, y; cin &gt;&gt; u &gt;&gt; v &gt;&gt; x &gt;&gt; y; G[u].eb(v); l[v] = x, r[v] = y; &#125; l[1] = 1, r[1] = n; cin &gt;&gt; q; for (int i = 1; i &lt;= q; ++i) &#123; int x, y, z; cin &gt;&gt; x &gt;&gt; y &gt;&gt; z; ask[x].eb(i); in[x].eb(y, z); out[x].eb(y, z); &#125; dfs(1); for (int i = 1; i &lt;= q; ++i) &#123; cout &lt;&lt; res[i] &lt;&lt; '\n'; &#125; return 0;&#125;]]></content>
      <categories>
        <category>线段树</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2019牛客暑期多校训练营(第八场)-D(Distance)]]></title>
    <url>%2F2019%2F08%2F13%2F2019%E7%89%9B%E5%AE%A2%E6%9A%91%E6%9C%9F%E5%A4%9A%E6%A0%A1%E8%AE%AD%E7%BB%83%E8%90%A5-%E7%AC%AC%E5%85%AB%E5%9C%BA-D-Distance%2F</url>
    <content type="text"><![CDATA[链接：https://ac.nowcoder.com/acm/contest/888/D思路：这个题说着是bfs，其实里面分块思想特别经典。考虑nmh总的是1e5，也就是说做一次bfs复杂度的上界是1e5，如果我们分块来做，也可以叫定期重构，即隔一段时间重新进行一次暴力bfs，期间插入的点我们都暴力访问。我们考虑复杂度，假设重构周期为T，那么总的复杂度就是O(Tnmh + \frac{qnmh}{E})，我们发现T = \sqrt(nmh)时总复杂度最小。代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef double db;typedef pair&lt;int, int&gt; pii;typedef vector&lt;int&gt; vi;typedef vector&lt;ll&gt; vl;typedef vector&lt;pii&gt; vp;const int inf = 1e9;const ll INF = 1e18;#define fi first#define se second#define pb push_back#define eb emplace_back#define ep emplace#define mem(a) memset(a, 0, sizeof(a))#define copy(a, b) memcpy(a, b, sizeof(b))#define PA cout &lt;&lt; "pass\n"#define lowbit(x) (x &amp; -x)#define all(x) x.begin(), x.end()#define TM db(clock() / CLOCKS_PER_SEC)const int maxn = 1e5 + 233;int n, m, h, q;int d[maxn];int get(int x, int y, int z)&#123; return (x - 1) * m * h + (y - 1) * h + z;&#125;struct node&#123; int x, y, z;&#125;;vector&lt;node&gt; t;int sz;int dx[6] = &#123;1, -1, 0, 0, 0, 0&#125;;int dy[6] = &#123;0, 0, 1, -1, 0, 0&#125;;int dz[6] = &#123;0, 0, 0, 0, 1, -1&#125;;bool in(int x, int y, int z)&#123; return x &gt;= 1 &amp;&amp; x &lt;= n &amp;&amp; y &gt;= 1 &amp;&amp; y &lt;= m &amp;&amp; z &gt;= 1 &amp;&amp; z &lt;= h;&#125;void bfs()&#123; queue&lt;node&gt; q; for (int i = 0; i &lt; t.size(); ++i) &#123; d[get(t[i].x, t[i].y, t[i].z)] = 0; q.push(t[i]); &#125; while(!q.empty())&#123; int x = q.front().x; int y = q.front().y; int z = q.front().z; q.pop(); for (int i = 0; i &lt; 6; ++i) &#123; int nx = x + dx[i]; int ny = y + dy[i]; int nz = z + dz[i]; if(!in(nx, ny, nz)) continue; if(d[get(nx, ny, nz)] &lt;= d[get(x, y, z)] + 1) continue; d[get(nx, ny, nz)] = d[get(x, y, z)] + 1; q.push(node&#123;nx, ny, nz&#125;); &#125; &#125;&#125;int main()&#123;#ifndef ONLINE_JUDGE freopen("in.txt", "r", stdin); freopen("out.txt", "w", stdout);#else#endif ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); cin &gt;&gt; n &gt;&gt; m &gt;&gt; h &gt;&gt; q; sz = sqrt(1ll * n * m * h); for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 1; j &lt;= m; ++j) &#123; for (int k = 1; k &lt;= h; ++k) &#123; d[get(i, j, k)] = inf; &#125; &#125; &#125; for (int i = 1; i &lt;= q; ++i) &#123; int op, x, y, z; cin &gt;&gt; op &gt;&gt; x &gt;&gt; y &gt;&gt; z; if(op == 1) t.push_back(node&#123;x, y, z&#125;); else&#123; int res = d[get(x, y, z)]; for(int j = 0; j &lt; t.size(); j++)&#123; res = min(res, abs(t[j].x - x) + abs(t[j].y - y) + abs(t[j].z - z)); &#125; cout &lt;&lt; res &lt;&lt; '\n'; &#125; if(i % sz == 0)&#123; bfs(); t.clear(); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>bfs</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[bzoj-3223(文艺平衡树)]]></title>
    <url>%2F2019%2F08%2F12%2Fbzoj-3223-%E6%96%87%E8%89%BA%E5%B9%B3%E8%A1%A1%E6%A0%91%2F</url>
    <content type="text"><![CDATA[链接：https://www.lydsy.com/JudgeOnline/problem.php?id=3223思路：splay一个非常经典的题目，考虑按照中序遍历建立splay树，假设需要翻转区间[l, r]，我们把l - 1放根上，然后把r + 1放到根的右儿子，这样r + 1的左子树的中序遍历就是区间[l, r]，考虑中序遍历的性质，翻转是不是就是对于每个节点都把它的左右子树交换了一下？这样我们就可以模仿线段树的下传标记一样，在树上打翻转标记下传即可。最后我们只用dfs遍历这个splay树，按照中序遍历的顺序输出答案即可。代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234#include&lt;bits/stdc++.h&gt;using namespace std; typedef long long ll;typedef double db;typedef pair&lt;int, int&gt; pii;typedef vector&lt;int&gt; vi;typedef vector&lt;ll&gt; vl;typedef vector&lt;pii&gt; vp;const int inf = 1e9;const ll INF = 1e18; #define fi first#define se second#define pb push_back#define eb emplace_back#define ep emplace#define mem(a) memset(a, 0, sizeof(a))#define copy(a, b) memcpy(a, b, sizeof(b))#define PA cout &lt;&lt; "pass\n"#define lowbit(x) (x &amp; -x)#define all(x) x.begin(), x.end() inline int read()&#123; int s=0,w=1; char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')w=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9') s=s*10+ch-'0',ch=getchar(); return s*w;&#125; const int maxn = 1e5 + 233;int f[maxn], cnt[maxn], ch[maxn][2], sz[maxn], val[maxn], tag[maxn], idx, rt, n, m;int v[maxn]; void clear(int x)&#123; f[x] = cnt[x] = ch[x][0] = ch[x][1] = sz[x] = val[x] = 0;&#125; bool get(int x)&#123; return ch[f[x]][1] == x;&#125; void pushup(int x)&#123; sz[x] = sz[ch[x][0]] + sz[ch[x][1]] + 1;&#125; void pushdown(int x)&#123; if(x &amp;&amp; tag[x])&#123; tag[ch[x][0]] ^= 1; tag[ch[x][1]] ^= 1; swap(ch[x][0], ch[x][1]); tag[x] = 0; &#125;&#125; void rotate(int x)&#123; int fa = f[x], gf = f[fa], o = get(x); pushdown(fa), pushdown(x); ch[fa][o] = ch[x][o ^ 1]; f[ch[fa][o]] = fa; ch[x][o ^ 1] = fa, f[fa] = x; f[x] = gf; if(gf) ch[gf][ch[gf][1] == fa] = x; pushup(fa); pushup(x);&#125; void splay(int x, int e = 0)&#123; for(int fa; (fa = f[x]) != e; rotate(x))&#123; if(f[fa] != e) rotate(get(x) == get(fa) ? fa : x); &#125; if(!e) rt = x;&#125; void insert(int x)&#123; if(!rt)&#123; idx++; val[idx] = x; rt = idx; cnt[idx] = sz[idx] = 1; f[idx] = ch[idx][0] = ch[idx][1] = 0; return; &#125; int now = rt, fa = 0; while(1)&#123; if(x == val[now])&#123; cnt[now]++; pushup(now); pushup(fa); splay(now); return; &#125; fa = now; now = ch[now][val[now] &lt; x]; if(!now)&#123; idx++; sz[idx] = cnt[idx] = 1; ch[idx][0] = ch[idx][1] = 0; ch[fa][x &gt; val[fa]] = idx; f[idx] = fa; val[idx] = x; pushup(fa); splay(idx); return; &#125; &#125;&#125; int rnk(int x)&#123; int now = rt; while(1)&#123; pushdown(now); if(x &lt;= sz[ch[now][0]]) now = ch[now][0]; else&#123; x -= sz[ch[now][0]] + 1; if(!x)&#123; return now; &#125; now = ch[now][1]; &#125; &#125;&#125; int kth(int x)&#123; int now = rt; while(1)&#123; if(ch[now][0] &amp;&amp; x &lt;= sz[ch[now][0]]) now = ch[now][0]; else&#123; if(x &lt;= sz[ch[now][0]] + cnt[now]) return val[now]; x -= sz[ch[now][0]] + cnt[now], now = ch[now][1]; &#125; &#125;&#125; int pre()&#123; int now = ch[rt][0]; while(ch[now][1]) now = ch[now][1]; return now;&#125; int next()&#123; int now = ch[rt][1]; while(ch[now][0]) now = ch[now][0]; return now;&#125; void del(int x)&#123; rnk(x); if(cnt[rt] &gt; 1)&#123; cnt[rt]--; pushup(rt); return; &#125; if(!ch[rt][0] &amp;&amp; !ch[rt][1])&#123; clear(rt); rt = 0; return; &#125; if(!ch[rt][0])&#123; int t = rt; rt = ch[rt][1]; f[rt] = 0; clear(t); return; &#125; else if(!ch[rt][1])&#123; int t = rt; rt = ch[rt][0]; f[rt] = 0; clear(t); return; &#125; int t = rt; int p = pre(); splay(p); ch[rt][1] = ch[t][1]; f[ch[t][1]] = rt; clear(t); pushup(rt);&#125; int build(int fa, int l, int r)&#123; if(l &gt; r) return 0; int mid = l + r &gt;&gt; 1; int now = ++idx; val[now] = v[mid], f[now] = fa, tag[now] = 0; ch[now][0] = build(now, l, mid - 1); ch[now][1] = build(now, mid + 1, r); pushup(now); return now;&#125; void turn(int l, int r)&#123; l = rnk(l); r = rnk(r + 2); splay(l, 0); splay(r, l); pushdown(rt); tag[ch[ch[rt][1]][0]] ^= 1;&#125; inline void write(int x) &#123; if (x &lt; 0) putchar('-'), x = -x; if (x &gt; 9) write(x / 10); putchar(x % 10 + '0');&#125; void dfs(int x)&#123; pushdown(x); if(ch[x][0]) dfs(ch[x][0]); if(val[x] != -inf &amp;&amp; val[x] != inf) write(val[x]), putchar(' '); if(ch[x][1]) dfs(ch[x][1]);&#125; int main()&#123; n = read(); m = read(); for (int i = 1; i &lt;= n; ++i) &#123; v[i + 1] = i; &#125; v[1] = -inf; v[n + 2] = inf; rt = build(0, 1, n + 2); for (int i = 1; i &lt;= m; ++i) &#123; int x, y; x = read(), y = read(); turn(x, y); &#125; dfs(rt); return 0;&#125;]]></content>
      <categories>
        <category>splay</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[bzoj-3224(普通平衡树)]]></title>
    <url>%2F2019%2F08%2F12%2Fbzoj-3224-%E6%99%AE%E9%80%9A%E5%B9%B3%E8%A1%A1%E6%A0%91%2F</url>
    <content type="text"><![CDATA[链接：https://www.lydsy.com/JudgeOnline/problem.php?id=3224思路：想最初萌新入坑的时候看wf，那时候好像jls就是在敲一个splay？然后对从此觉得splay是非常高深的东西。。。最近初看，发现能懂一部分原理，这篇文章写的挺不错的。后面还会继续仔细看：https://blog.csdn.net/a_comme_amour/article/details/79382104然后放一个模板题在这里。代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183#include&lt;bits/stdc++.h&gt;using namespace std; typedef long long ll;typedef double db;typedef pair&lt;int, int&gt; pii;typedef vector&lt;int&gt; vi;typedef vector&lt;ll&gt; vl;typedef vector&lt;pii&gt; vp;const int inf = 1e9;const ll INF = 1e18; #define fi first#define se second#define pb push_back#define eb emplace_back#define ep emplace#define mem(a) memset(a, 0, sizeof(a))#define copy(a, b) memcpy(a, b, sizeof(b))#define PA cout &lt;&lt; "pass\n"#define lowbit(x) (x &amp; -x)#define all(x) x.begin(), x.end() const int maxn = 1e5 + 233;int f[maxn], cnt[maxn], ch[maxn][2], sz[maxn], val[maxn], tag[maxn], idx, rt, n; void clear(int x)&#123; f[x] = cnt[x] = ch[x][0] = ch[x][1] = sz[x] = val[x] = 0;&#125; bool get(int x)&#123; return ch[f[x]][1] == x;&#125; void pushup(int x)&#123; if(x)&#123; sz[x] = cnt[x]; if(ch[x][0]) sz[x] += sz[ch[x][0]]; if(ch[x][1]) sz[x] += sz[ch[x][1]]; &#125;&#125; void rotate(int x)&#123; int fa = f[x], gf = f[fa], o = get(x); ch[fa][o] = ch[x][o ^ 1]; f[ch[fa][o]] = fa; ch[x][o ^ 1] = fa, f[fa] = x; f[x] = gf; if(gf) ch[gf][ch[gf][1] == fa] = x; pushup(fa); pushup(x);&#125; void splay(int x, int e = 0)&#123; for(int fa; (fa = f[x]) != e; rotate(x))&#123; if(f[fa] != e) rotate(get(x) == get(fa) ? fa : x); &#125; if(!e) rt = x;&#125; void insert(int x)&#123; if(!rt)&#123; idx++; val[idx] = x; rt = idx; cnt[idx] = sz[idx] = 1; f[idx] = ch[idx][0] = ch[idx][1] = 0; return; &#125; int now = rt, fa = 0; while(1)&#123; if(x == val[now])&#123; cnt[now]++; pushup(now); pushup(fa); splay(now); return; &#125; fa = now; now = ch[now][val[now] &lt; x]; if(!now)&#123; idx++; sz[idx] = cnt[idx] = 1; ch[idx][0] = ch[idx][1] = 0; ch[fa][x &gt; val[fa]] = idx; f[idx] = fa; val[idx] = x; pushup(fa); splay(idx); return; &#125; &#125;&#125; int rnk(int x)&#123; int now = rt, ans = 0; while(1)&#123; if(x &lt; val[now]) now = ch[now][0]; else&#123; ans += sz[ch[now][0]]; if(x == val[now])&#123; splay(now); return ans + 1; &#125; ans += cnt[now]; now = ch[now][1]; &#125; &#125;&#125; int kth(int x)&#123; int now = rt; while(1)&#123; if(ch[now][0] &amp;&amp; x &lt;= sz[ch[now][0]]) now = ch[now][0]; else&#123; if(x &lt;= sz[ch[now][0]] + cnt[now]) return val[now]; x -= sz[ch[now][0]] + cnt[now], now = ch[now][1]; &#125; &#125;&#125; int pre()&#123; int now = ch[rt][0]; while(ch[now][1]) now = ch[now][1]; return now;&#125; int next()&#123; int now = ch[rt][1]; while(ch[now][0]) now = ch[now][0]; return now;&#125; void del(int x)&#123; rnk(x); if(cnt[rt] &gt; 1)&#123; cnt[rt]--; pushup(rt); return; &#125; if(!ch[rt][0] &amp;&amp; !ch[rt][1])&#123; clear(rt); rt = 0; return; &#125; if(!ch[rt][0])&#123; int t = rt; rt = ch[rt][1]; f[rt] = 0; clear(t); return; &#125; else if(!ch[rt][1])&#123; int t = rt; rt = ch[rt][0]; f[rt] = 0; clear(t); return; &#125; int t = rt; int p = pre(); splay(p); ch[rt][1] = ch[t][1]; f[ch[t][1]] = rt; clear(t); pushup(rt);&#125; int main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); cin &gt;&gt; n; for (int i = 1; i &lt;= n; ++i) &#123; int op, k; cin &gt;&gt; op &gt;&gt; k; if(op == 1) insert(k); if(op == 2)del(k); if(op == 3)cout &lt;&lt; rnk(k) &lt;&lt; '\n'; if(op == 4) cout &lt;&lt; kth(k) &lt;&lt; '\n'; if(op == 5) insert(k), cout &lt;&lt; val[pre()] &lt;&lt; '\n', del(k); if(op == 6) insert(k), cout &lt;&lt; val[next()] &lt;&lt; '\n', del(k); &#125; return 0;&#125;]]></content>
      <categories>
        <category>splay</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[bzoj-4025(二分图)]]></title>
    <url>%2F2019%2F08%2F12%2Fbzoj-4025-%E4%BA%8C%E5%88%86%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[链接：https://www.lydsy.com/JudgeOnline/problem.php?id=4025思路：和上一个题基本一样啊，不过多了一个二分图的判断，二分图就是没有奇环的图，考虑还是用并查集维护，出现奇环必然是两个点已经在同一个集合内了，我们考虑维护一个带权并查集，只用判断二者到根节点距离就可以判断出当前这次合并时候为产生奇环。有一个需要注意的地方是，并查集维护的不能是到根节点的距离。因为在线段树上分治时有撤销并查集的操作，这时候某一个点会断开成为根节点，这样子树内的点就遗失了它到它父亲点的距离的信息（因为之前的信息就作废了没有任何价值，又得不出新的情况下的距离）。所以我们按秩合并的时候维护的是它到它父亲节点的距离，到根节点的距离我们只用像找根节点那样再跳一次统计即可。这样即使撤销也不会遗失子树内的信息，可以重新统计出到新根节点的距离。代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116#include&lt;bits/stdc++.h&gt;using namespace std; typedef long long ll;typedef double db;typedef pair&lt;int, int&gt; pii;typedef vector&lt;int&gt; vi;typedef vector&lt;ll&gt; vl;typedef vector&lt;pii&gt; vp;const int inf = 1e9;const ll INF = 1e18; #define fi first#define se second#define pb push_back#define eb push_back#define ep emplace#define mem(a) memset(a, 0, sizeof(a))#define copy(a, b) memcpy(a, b, sizeof(b))#define PA cout &lt;&lt; "pass\n"#define lowbit(x) (x &amp; -x)#define all(x) x.begin(), x.end() int n, m, t;const int maxn = 1e5 + 233;int f[maxn], rk[maxn], d[maxn];vp tree[maxn &lt;&lt; 2], sta[maxn &lt;&lt; 2];vi s[maxn &lt;&lt; 2];bool ans[maxn]; int find(int x)&#123; return x == f[x] ? x : find(f[x]);&#125; int getdis(int x)&#123; return x == f[x] ? 0 : d[x] ^ getdis(f[x]);&#125; bool merge(int o, int u, int v)&#123; if(u == v) return false; int fx = find(u); int fy = find(v); if(fx == fy)&#123; if(getdis(u) ^ getdis(v)) return true; return false; &#125; if(rk[fx] &lt;= rk[fy]) swap(fx, fy); sta[o].eb(pii(fx, fy)), s[o].eb(rk[fx]); f[fy] = fx, rk[fx] = max(rk[fx], rk[fy] + 1); d[fy] = getdis(u) ^ getdis(v) ^ 1; return true;&#125; void del(int o)&#123; while(!sta[o].empty()) &#123; pii t = sta[o].back(); f[t.fi] = t.fi, f[t.se] = t.se; d[t.se] = 0; rk[t.fi] = s[o].back(); sta[o].pop_back(), s[o].pop_back(); &#125;&#125; void update(int o, int tl, int tr, int l, int r, int u, int v)&#123; if(tl &gt; r || l &gt; tr) return; if(l &lt;= tl &amp;&amp; tr &lt;= r) &#123; tree[o].eb(pii(u, v)); return; &#125; int mid = tl + tr &gt;&gt; 1; update(o &lt;&lt; 1, tl, mid, l, r, u, v); update(o &lt;&lt; 1 | 1, mid + 1, tr, l, r, u, v);&#125; void dfs(int o, int l, int r)&#123; for(int i = 0; i &lt; tree[o].size(); i++)&#123; if(!merge(o, tree[o][i].fi, tree[o][i].se))&#123; del(o); return; &#125; &#125; if(l == r)&#123; ans[l] = true; del(o); return; &#125; int mid = l + r &gt;&gt; 1; dfs(o &lt;&lt; 1, l, mid); dfs(o &lt;&lt; 1 | 1, mid + 1, r); del(o);&#125; void print(bool x)&#123; if(x) cout &lt;&lt; "Yes\n"; else cout &lt;&lt; "No\n";&#125; int main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); cin &gt;&gt; n &gt;&gt; m &gt;&gt; t; for (int i = 1; i &lt;= n; ++i) &#123; f[i] = i, d[i] = 0, rk[i] = 1; &#125; for (int i = 1; i &lt;= m; ++i) &#123; int a, b, c, d; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d; c++; if(c &gt; d) continue; update(1, 1, t, c, d, a, b); &#125; dfs(1, 1, t); for (int i = 1; i &lt;= t; ++i) &#123; print(ans[i]); &#125; return 0;&#125;]]></content>
      <categories>
        <category>线段树分治</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2019牛客暑期多校训练营(第八场)-E(Explorer)]]></title>
    <url>%2F2019%2F08%2F12%2F2019%E7%89%9B%E5%AE%A2%E6%9A%91%E6%9C%9F%E5%A4%9A%E6%A0%A1%E8%AE%AD%E7%BB%83%E8%90%A5-%E7%AC%AC%E5%85%AB%E5%9C%BA-E-Explorer%2F</url>
    <content type="text"><![CDATA[链接：https://ac.nowcoder.com/acm/contest/888/E思路：咕咕咕了两天，研究线段树分治（ddc好像喜欢叫它时间分治），发现也是个很神奇的东西。 线段树分治什么是线段树分治呢？考虑有些问题，某些范围可以看作是时间的限制，即在一个时间段内这个操作有效。同时这种操作一边比较容易但一边比较难（比如并查集合并容易，但分离就很难），但撤销前一个操作比较简单的时候（并查集撤销前一个操作比较简单）。我们就可以把所有的这些操作放在以时间（可能对应题目中不同的背景）为坐标的线段树下。考虑把这些操作放到线段树对应的区间里，然后我们按照线段树的dfs序进行处理，每次进去的时候把这个区间对应的操作加进去，然后根据题目进行某些统计，dfs完后出来的时候利用栈的性质把这些操作撤销掉。这样就避免了那些比较复杂的反面操作，从而做法变得非常优雅。 考虑本题，每一条边对应一个[l, r]区间的人数，那么我们可以把人数看成线段树的下标（时间），把这些边插入到线段树中，考虑在dfs时维护一个并查集，到每个根节点后，check一下1和n是否在同一个集合中即可，然后出来的时候撤销之前的并查集合并操作即可。为了满足撤销操作，我们并查集需要按秩合并，那么这个题就没了。代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#include&lt;bits/stdc++.h&gt;using namespace std; typedef long long ll;typedef double db;typedef pair&lt;int, int&gt; pii;typedef vector&lt;int&gt; vi;typedef vector&lt;ll&gt; vl;typedef vector&lt;pii&gt; vp;const int inf = 1e9;const ll INF = 1e18; #define fi first#define se second#define pb push_back#define eb emplace_back#define ep emplace#define mem(a) memset(a, 0, sizeof(a))#define copy(a, b) memcpy(a, b, sizeof(b))#define PA cout &lt;&lt; "pass\n"#define lowbit(x) (x &amp; -x)#define all(x) x.begin(), x.end() vi pos;const int maxn = 1e5 + 233;vp tree[maxn &lt;&lt; 3], sta[maxn &lt;&lt; 3];int f[maxn];stack&lt;int&gt; s[maxn &lt;&lt; 3];int rk[maxn], n, m;ll res; struct node&#123; int u, v, l, r;&#125;a[maxn]; int find(int x)&#123; return x == f[x] ? x : find(f[x]);&#125; void merge(int o, int u, int v)&#123; int fx = find(u); int fy = find(v); if(fx == fy) return; if(rk[fx] &lt;= rk[fy]) swap(fx, fy); s[o].ep(rk[fx]); sta[o].eb(fx, fy); f[fy] = fx, rk[fx] = max(rk[fx], rk[fy] + 1);&#125; void del(int o)&#123; pii t = sta[o].back(); f[t.fi] = t.fi, f[t.se] = t.se; rk[t.fi] = s[o].top();&#125; void update(int o, int tl, int tr, int l, int r, int u, int v)&#123; if(l &gt; tr || tl &gt; r) return; if(l &lt;= tl &amp;&amp; tr &lt;= r) &#123; tree[o].eb(u, v); return; &#125; int mid = tl + tr &gt;&gt; 1; update(o &lt;&lt; 1, tl, mid, l, r, u, v); update(o &lt;&lt; 1 | 1, mid + 1, tr, l, r, u, v);&#125; void dfs(int o, int l, int r)&#123; for(int i = 0; i &lt; tree[o].size(); i++)&#123; merge(o, tree[o][i].fi, tree[o][i].se); &#125; if(l == r)&#123; if(find(1) == find(n)) res += pos[l + 1] - pos[l]; while(!sta[o].empty()) del(o), sta[o].pop_back(), s[o].pop(); tree[o].clear(); return; &#125; int mid = l + r &gt;&gt; 1; dfs(o &lt;&lt; 1, l, mid); dfs(o &lt;&lt; 1 | 1, mid + 1, r); while(!sta[o].empty()) del(o), sta[o].pop_back(), s[o].pop(); tree[o].clear();&#125; int main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); cin &gt;&gt; n &gt;&gt; m; pos.eb(0); for (int i = 1; i &lt;= n; ++i) &#123; f[i] = i; &#125; for (int i = 1; i &lt;= m; ++i) &#123; cin &gt;&gt; a[i].u &gt;&gt; a[i].v &gt;&gt; a[i].l &gt;&gt; a[i].r; a[i].r++; pos.eb(a[i].r); pos.eb(a[i].l); &#125; sort(all(pos)); pos.resize(unique(all(pos)) - pos.begin()); for (int i = 1; i &lt;= m; ++i) &#123; int l = lower_bound(all(pos), a[i].l) - pos.begin(); int r = lower_bound(all(pos), a[i].r) - pos.begin() - 1; update(1, 1, pos.size() - 2, l, r, a[i].u, a[i].v); &#125; dfs(1, 1, pos.size() - 2); cout &lt;&lt; res &lt;&lt; '\n'; return 0;&#125;]]></content>
      <categories>
        <category>线段树分治</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2019牛客暑期多校训练营(第八场)-J(Just Jump)]]></title>
    <url>%2F2019%2F08%2F10%2F2019%E7%89%9B%E5%AE%A2%E6%9A%91%E6%9C%9F%E5%A4%9A%E6%A0%A1%E8%AE%AD%E7%BB%83%E8%90%A5-%E7%AC%AC%E5%85%AB%E5%9C%BA-J-Just-Jump%2F</url>
    <content type="text"><![CDATA[链接：https://ac.nowcoder.com/acm/contest/888/J思路：当时给ddc说的方法是对的，后来试了试发现真的是对的，但当时脑残了不会求把n分为某些数相加，每个数都必须大于等于d的方案数，后来发现直接前缀和dp优化就行了。。。。考虑我们先dp求出没有攻击限制的方案数，然后再减去不合法的。难点就在于不合法的不能减多了或者减少了，我们必须要确定一个计数状态，即每一种方案只会在某一个点上被计数，这也就不会重复。那么很容易想到如果我们枚举第一个被攻击的位置，那么后面是一个方案数的子问题，我们前面dp已经求过了，前面也是一个子问题，但是因为它是第一个点，所以前面还要减去从其它已经踩雷的地方转移过来的状态。我们令dp[i]表示第i个点是第一次被攻击的方案，那么在他前面的我们都求过了，转移过来又是一个之前求过的子问题。那么我们对于每一个点算出前面的总方案，再减去从前面已经作为第一次被攻击的点转移过来的方案，剩下的就是它第一次被攻击的方案，再乘以后面的转移方案数，就是以它为第一次被攻击点的不合法的方案数，在总方案中扣去所有点有限制点作为第一次被攻击点的不合法方案，就是最后的合法方案。考虑正确性：每一个不合法的点只会在第一次被攻击的时候计数一次，且第一次被攻击的每个点的方案扣去了前面不合法的转移，所以是正确的。 注意不要再计算组合数的时候爆掉了。。代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef double db;typedef pair&lt;int, int&gt; pii;typedef vector&lt;int&gt; vi;typedef vector&lt;ll&gt; vl;typedef vector&lt;pii&gt; vp;const int inf = 1e9;const ll INF = 1e18;#define fi first#define se second#define pb push_back#define eb emplace_back#define ep emplace#define mem(a) memset(a, 0, sizeof(a))#define copy(a, b) memcpy(a, b, sizeof(b))#define PA cout &lt;&lt; "pass\n"#define lowbit(x) (x &amp; -x)const int mod = 998244353;const int maxn = 1e7 + 233;ll fac[maxn + 100], inv[maxn + 100];int d, l, m;ll pow_mod(ll q, ll w)&#123; ll ret = 1; while(w)&#123; if(w &amp; 1) ret = ret * q % mod; q = q * q % mod; w &gt;&gt;= 1; &#125; return ret;&#125;ll cal(ll x, ll y)&#123; if(x &lt; 0 || y &lt; 0) return 0; if(x &lt; y) return 0; return fac[x] * inv[y] % mod * inv[x - y] % mod;&#125;pii a[3030];ll sum[maxn];ll dp[3030];ll f[maxn];int main() &#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); cin &gt;&gt; l &gt;&gt; d &gt;&gt; m; fac[0] = inv[0] = 1; inv[1] = 1; for (int i = 1; i &lt; maxn; ++i) &#123; fac[i] = fac[i - 1] * i % mod; &#125; inv[maxn - 1] = pow_mod(fac[maxn - 1], mod - 2); for (int i = maxn - 2; i &gt;= 2; i--) inv[i] = (inv[i + 1] * (i + 1)) % mod; f[0] = 1; sum[0] = 1; for (int i = 1; i &lt; d; ++i) &#123; sum[i] = 1; &#125; for (int i = d; i &lt;= l; ++i) &#123; f[i] = sum[i - d]; sum[i] = (sum[i - 1] + f[i]) % mod; &#125; for (int i = 1; i &lt;= m; ++i) &#123; cin &gt;&gt; a[i].fi &gt;&gt; a[i].se; &#125; sort(a + 1, a + m + 1); ll res = f[l]; //总方案 for (int i = 1; i &lt;= m; ++i) &#123; dp[i] = cal(a[i].se - 1ll * a[i].fi * (d - 1) - 1, a[i].fi - 1); //以它作为结尾的总方案 for (int j = 1; j &lt; i; j++) &#123; dp[i] = ((dp[i] - dp[j] * cal(a[i].se - a[j].se - 1ll * (a[i].fi - a[j].fi) * (d - 1) - 1, a[i].fi - a[j].fi - 1)) % mod + mod) % mod; //扣掉之前经过不合法点的方案，剩下的就是不经过前面不合法点到达它的方案，也就是它作为第一次被攻击点的方案 &#125; res = ((res - dp[i] * f[l - a[i].se]) % mod + mod) % mod; //总方案扣掉以该点为第一次被攻击点的不合法方案 &#125; cout &lt;&lt; res &lt;&lt; '\n'; return 0;&#125;]]></content>
      <categories>
        <category>计数dp</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2019 Multi-University Training Contest 6-F(Faraway)]]></title>
    <url>%2F2019%2F08%2F09%2F2019-Multi-University-Training-Contest-6-F-Faraway%2F</url>
    <content type="text"><![CDATA[链接：http://acm.hdu.edu.cn/showproblem.php?pid=6639思路：不知道放在什么标签下了。。这个题给人的感觉就是数据范围贼小，但却不知道怎么下手。。。其实这个题有个结论，就是把曼哈顿距离展开后，n个横纵坐标不相同的点会把平面分为$(n + 1)^2$份。我们发现模数很小，它们的lcm = 60，其实这个题就是分区域，然后暴力枚举横纵坐标对于60的余数，然后暴力check一下看是否可行，如果可行的话统计区域数量。注意为了不重复统计，我们考虑只统计右上边界，左下边界不统计。那么我们可以在给x，y下界设为-1，方便统计。以及我对于求l - r内模一个数等于t的个数居然懵了，不知道怎么求。。。最后是先把两个端点转到60的倍数上，然后强行判断的，感觉有点失了智了。。。。代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef double db;typedef pair&lt;int, int&gt; pii;typedef vector&lt;int&gt; vi;typedef vector&lt;ll&gt; vl;typedef vector&lt;pii&gt; vp;const int inf = 1e9;const ll INF = 1e18;#define fi first#define se second#define pb push_back#define eb emplace_back#define ep emplace#define mem(a) memset(a, 0, sizeof(a))#define PA puts("pass")#define lowbit(x) (x &amp; -x)int T;int n, m;struct node&#123; int x, y, k, t;&#125;a[30];vi posx, posy;bool check(int x, int y, int ma, int mb)&#123; for(int i = 1; i &lt;= n; i++)&#123; if(posx[x] &lt; a[i].x &amp;&amp; posy[y] &lt; a[i].y)&#123; if(((60 + a[i].x % 60 - ma) + (60 + a[i].y % 60 - mb)) % a[i].k == a[i].t) continue; return false; &#125; if(posx[x] &lt; a[i].x &amp;&amp; posy[y] &gt;= a[i].y)&#123; if((60 + a[i].x % 60 - ma + mb - a[i].y % 60 + 60) % a[i].k == a[i].t) continue; return false; &#125; if(posx[x] &gt;= a[i].x &amp;&amp; posy[y] &lt; a[i].y)&#123; if((60 + ma - a[i].x % 60 + 60 + a[i].y % 60 - mb) % a[i].k == a[i].t) continue; return false; &#125; if(posx[x] &gt;= a[i].x &amp;&amp; posy[y] &gt;= a[i].y)&#123; if((60 + ma - a[i].x % 60 + 60 + mb - a[i].y % 60) % a[i].k == a[i].t) continue; return false; &#125; &#125; return true;&#125;int get(int l, int r, int k)&#123; if(l &gt; r) return 0; int l1 = l - 1 &lt; k ? 0 : (l - 1 - k) / 60 + 1; int r1 = r &lt; k ? 0 : (r - k) / 60 + 1; return r1 - l1;&#125;int main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); cin &gt;&gt; T; while(T--)&#123; cin &gt;&gt; n &gt;&gt; m; posx.clear(); posy.clear(); posx.eb(-1), posy.eb(-1); for (int i = 1; i &lt;= n; ++i) &#123; cin &gt;&gt; a[i].x &gt;&gt; a[i].y &gt;&gt; a[i].k &gt;&gt; a[i].t; posx.eb(a[i].x); posy.eb(a[i].y); &#125; posx.eb(m); posy.eb(m); sort(posx.begin(), posx.end()); sort(posy.begin(), posy.end()); ll res = 0; for (int i = 0; i &lt; posx.size() - 1; ++i) &#123; for (int j = 0; j &lt; posy.size() - 1; ++j) &#123; for (int k = 0; k &lt; 60; ++k) &#123; for (int l = 0; l &lt; 60; ++l) &#123; if(!check(i, j, k, l)) continue; int l1 = posx[i] + 1; int r1 = posx[i + 1]; int l2 = posy[j] + 1; int r2 = posy[j + 1]; res += 1ll * get(l1, r1, k) * get(l2, r2, l); &#125; &#125; &#125; &#125; cout &lt;&lt; res &lt;&lt; '\n'; &#125; return 0;&#125;]]></content>
      <categories>
        <category>思维</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[VK Cup 2015 - Round 2 (unofficial online mirror, Div. 1 only)-F(Encoding)]]></title>
    <url>%2F2019%2F08%2F09%2FVK-Cup-2015-Round-2-unofficial-online-mirror-Div-1-only-F-Encoding%2F</url>
    <content type="text"><![CDATA[链接：https://codeforces.com/contest/533/problem/F思路：一开始想的kmp，但是可以有多组替换，所有kmp好像没法做。。。。考虑对两个串的26个字母分别变为01串，即如果为字符x该位为1，否则为0，然后做hash。我们对于一次匹配，找到26个串在某个i开头的后面第一次出现的位置，然后看t对应位置出现的是什么字符，然后把二者的hash串比较一下，如果不等则不行，否则建立对应关系，如果最终对应关系唯一，那么这个开头就是可以的，复杂度$O(26n)$代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include&lt;bits/stdc++.h&gt;using namespace std; typedef long long ll;typedef double db;typedef pair&lt;int, int&gt; pii;typedef vector&lt;int&gt; vi;typedef vector&lt;ll&gt; vl;typedef vector&lt;pii&gt; vp;const int inf = 1e9;const ll INF = 1e18; #define fi first#define se second#define pb push_back#define eb emplace_back#define ep emplace#define mem(a) memset(a, 0, sizeof(a))#define PA puts("pass")#define lowbit(x) (x &amp; -x) const int base = 233;const int mod = 1e9 + 7 ;const int maxn = 2e5 + 233;ll bin[maxn], h[2][26][maxn];char s[maxn];char t[maxn];int head[26];vi pos[26];int n, m;int vis[26]; void init()&#123; bin[0] = 1; for(int i = 1; i &lt; maxn; i++) bin[i] = bin[i - 1] * base % mod; for(int i = 1; i &lt;= n; i++)&#123; for(int j = 0; j &lt; 26; j++)&#123; h[0][j][i] = (h[0][j][i - 1] * base + (s[i] - 'a' == j)) % mod; &#125; &#125; for (int i = 1; i &lt;= m; ++i) &#123; for (int j = 0; j &lt; 26; ++j) &#123; h[1][j][i] = (h[1][j][i - 1] * base + (t[i] - 'a' == j)) % mod; &#125; &#125; for(int i = 1; i &lt;= n; i++) pos[s[i] - 'a'].eb(i);&#125; ll get(int o, int p, int l, int r)&#123; return ((h[o][p][r] - h[o][p][l - 1] * bin[r - l + 1]) % mod + mod) % mod;&#125; bool check(int x, int y)&#123; if(vis[x] == -1 &amp;&amp; vis[y] == -1) return false; if(vis[x] == y &amp;&amp; vis[y] == x) return false; return true;&#125; int main()&#123; scanf("%d %d %s %s", &amp;n, &amp;m, s + 1, t + 1); init(); vi ans; for(int i = 1; i + m - 1 &lt;= n; i++)&#123; bool f = true; memset(vis, -1, sizeof(vis)); for(int j = 0; j &lt; 26; j++)&#123; while(head[j] &lt; pos[j].size() &amp;&amp; pos[j][head[j]] &lt; i) head[j]++; if(head[j] &gt;= pos[j].size() || (head[j] &lt; pos[j].size() &amp;&amp; pos[j][head[j]] &gt;= i + m)) continue; int z = pos[j][head[j]] - i + 1; ll t1 = get(0, j, i, i + m - 1); ll t2 = get(1, t[z] - 'a', 1, m); if(t1 != t2 || check(j, t[z] - 'a')) &#123; f = false; break; &#125; vis[t[z] - 'a'] = j; vis[j] = t[z] - 'a'; &#125; if(f) ans.eb(i); &#125; cout &lt;&lt; ans.size() &lt;&lt; '\n'; for (int i = 0; i &lt; ans.size(); ++i) &#123; cout &lt;&lt; ans[i] &lt;&lt; (i == ans.size() - 1 ? '\n' : ' '); &#125; return 0;&#125;]]></content>
      <categories>
        <category>hash</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[bzoj-4326(运输计划)]]></title>
    <url>%2F2019%2F08%2F09%2Fbzoj-4326-%E8%BF%90%E8%BE%93%E8%AE%A1%E5%88%92%2F</url>
    <content type="text"><![CDATA[链接：https://www.lydsy.com/JudgeOnline/problem.php?id=4326思路：树上差分题目。 树上差分序列上差分是非常简单的东西，考虑差分用到树上，一般问题是对u, v上的路径加减同一个数，这个跟序列上非常类似，分为两种。1、路径上的点差分：如果是对点差分，假设操作是 + 1，我们需要在点u, v上+1，在他们的lca处-1，在他们lca的father再减1，最后dfs合并，保证路径上都加到了。2、路径上的边差分：边的话我们还是得转移到点上：即点x代表的路径是x到x的father的那条边，这样我们需要点u, v上+1，在他们的lca处-2，最后dfs合并即可。 本题就是一个树上差分的应用，有一定思维难度。首先发现时间具有单调性，即更长的时间结果不会更差，这个就可以二分。考虑二分一个时间后，如果某条路径比这个值短或者相等，说明无论怎么样都可行，我们不用管它，否则我们将它放到树上进行边差分，并且维护一个最大值。最后放到树上的肯定都是大于二分值—即必须要删边才能满足的，假设一共加了x条路径，我们只用看某一个边出现次数是否等于x并且加入的最长路经 - 这条路径 &lt;= 二分值，如果存在就满足，否则不满足。这一点不太容易想到。代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143#include&lt;bits/stdc++.h&gt;using namespace std; typedef long long ll;typedef double db;typedef pair&lt;int, int&gt; pii;typedef vector&lt;int&gt; vi;typedef vector&lt;ll&gt; vl;typedef vector&lt;pii&gt; vp;const int inf = 1e9;const ll INF = 1e18; #define fi first#define se second#define pb push_back#define eb push_back#define ep emplace#define mem(a) memset(a, 0, sizeof(a))#define copy(a, b) memcpy(a, b, sizeof(b))#define PA cout &lt;&lt; "pass\n"#define lowbit(x) (x &amp; -x) inline int read() &#123; int s = 0, w = 1; char ch = getchar(); while (ch &lt; '0' || ch &gt; '9') &#123; if (ch == '-')w = -1; ch = getchar(); &#125; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') s = s * 10 + ch - '0', ch = getchar(); return s * w;&#125; const int maxn = 3e5 + 233;int u[maxn], v[maxn];int n, m; int f[maxn][21];int len[maxn];int d[maxn], cnt[maxn];int id[maxn], lc[maxn];int dep[maxn]; struct edge&#123; int from, to, dist;&#125;;vector&lt;edge&gt; edges;vi G[maxn]; void addedge(int from, int to, int dist)&#123; edges.pb(edge&#123;from, to, dist&#125;); G[from].eb(edges.size() - 1);&#125; void dfs(int u, int fa)&#123; f[u][0] = fa; dep[u] = dep[fa] + 1; for (int i = 1; i &lt;= 20; ++i) &#123; f[u][i] = f[f[u][i - 1]][i - 1]; &#125; for(int i = 0; i &lt; G[u].size(); i++)&#123; edge &amp;e = edges[G[u][i]]; if(e.to == fa) continue; d[e.to] = d[u] + e.dist; id[e.to] = G[u][i]; dfs(e.to, u); &#125;&#125; int lca(int u, int v)&#123; if(dep[u] &gt; dep[v]) swap(u, v); for(int i = 20; i &gt;= 0; i--)&#123; if(dep[u] &lt;= dep[f[v][i]]) v = f[v][i]; &#125; if(u == v) return u; for(int i = 20; i &gt;= 0; i--)&#123; if(f[u][i] != f[v][i]) u = f[u][i], v = f[v][i]; &#125; return f[u][0];&#125; void getans(int u, int fa)&#123; for (int i = 0; i &lt; G[u].size(); ++i) &#123; edge &amp;e = edges[G[u][i]]; if (e.to == fa) continue; getans(e.to, u); cnt[u] += cnt[e.to]; &#125;&#125; bool check(int t)&#123; int mx = 0; int p = 0; for (int i = 1; i &lt;= m; ++i) &#123; if(len[i] &lt;= t) continue; mx = max(mx, len[i]); cnt[u[i]]++, cnt[v[i]]++, cnt[lc[i]] -= 2; p++; &#125; if(mx &lt;= t) return true; getans(n, 0); bool f = false; for (int i = 1; i &lt;= n; ++i) &#123; if(cnt[i] == p &amp;&amp; mx - edges[id[i]].dist &lt;= t) f = true; cnt[i] = 0; &#125; return f;&#125; int main()&#123; n = read(); m = read(); int lb = 0, ub = 0, ans = 0; for (int i = 1; i &lt; n; ++i) &#123; int x, y, z; cin &gt;&gt; x &gt;&gt; y &gt;&gt; z; addedge(x, y, z); addedge(y, x, z); lb = max(lb, z); &#125; dfs(n, 0); for (int i = 1; i &lt;= m; ++i) &#123; u[i] = read(), v[i] = read(); lc[i] = lca(u[i], v[i]); len[i] = d[u[i]] + d[v[i]] - 2 * d[lc[i]]; ub = max(ub, len[i]); &#125; lb = ans = ub - lb; while(ub &gt;= lb)&#123; int mid = ub + lb &gt;&gt; 1; if(check(mid))&#123; ans = mid; ub = mid - 1; &#125; else lb = mid + 1; &#125; cout &lt;&lt; ans &lt;&lt; '\n'; return 0;&#125;]]></content>
      <categories>
        <category>差分</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2019 Multi-University Training Contest 6-B(Nonsense Time)]]></title>
    <url>%2F2019%2F08%2F08%2F2019-Multi-University-Training-Contest-6-B-Nonsense-Time%2F</url>
    <content type="text"><![CDATA[链接：http://acm.hdu.edu.cn/showproblem.php?pid=6635思路：这个题有一个结论，一个随机序列的LIS期望是O(\sqrt(n))的，那么我们考虑每次加入一个数，我们要check序列的LIS是否增长，这个没办法快速check。那我们考虑倒过来，如果是删除一个数，如果删的数不在LIS中，那么肯定不影响。如果在的话，因为期望是O(\sqrt(n))，所以我们考虑重新再求一个LIS。这样期望复杂度是O(n\sqrt(n)logn)。代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef double db;typedef pair&lt;int, int&gt; pii;typedef vector&lt;int&gt; vi;typedef vector&lt;ll&gt; vl;typedef vector&lt;pii&gt; vp;const int inf = 1e9;const ll INF = 1e18;#define fi first#define se second#define pb push_back#define eb emplace_back#define ep emplace#define mem(a) memset(a, 0, sizeof(a))#define PA puts("pass")#define lowbit(x) (x &amp; -x)const int maxn = 5e4 + 233;int a[maxn], b[maxn];bool vis[maxn];bool ok[maxn];int T, n;int f[maxn];int g[maxn], ans;void solve()&#123; ans = 0; mem(ok); for (int i = 1; i &lt;= n; ++i) &#123; g[i] = inf; &#125; for (int i = 1; i &lt;= n; ++i) &#123; if(vis[i]) continue; int k = lower_bound(g + 1, g + n + 1, a[i]) - g; f[i] = k; g[k] = a[i]; ans = max(ans, f[i]); &#125; int t = ans; int pre = 1e9; for(int i = n; i; i--)&#123; if(vis[i]) continue; if(f[i] == t &amp;&amp; a[i] &lt; pre) t--, ok[i] = 1, pre = a[i]; &#125;&#125;void clear()&#123; mem(vis);&#125;int main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); cin &gt;&gt; T; while(T--)&#123; cin &gt;&gt; n; clear(); for (int i = 1; i &lt;= n; ++i) &#123; cin &gt;&gt; a[i]; &#125; for (int i = 1; i &lt;= n; ++i) &#123; cin &gt;&gt; b[i]; &#125; vi res; solve(); for(int i = n; i; i--)&#123; res.eb(ans); vis[b[i]] = 1; if(!ok[b[i]]) continue; else solve(); &#125; for(int i = res.size() - 1; i &gt;= 0; i--)&#123; cout &lt;&lt; res[i] &lt;&lt; (!i ? '\n' : ' '); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>基础dp</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[bzoj-5317(部落战争)]]></title>
    <url>%2F2019%2F08%2F08%2Fbzoj-5317-%E9%83%A8%E8%90%BD%E6%88%98%E4%BA%89%2F</url>
    <content type="text"><![CDATA[链接：https://www.lydsy.com/JudgeOnline/problem.php?id=5317思路：闵可夫斯基和。 闵可夫斯基和概念给定点集A，点集B，闵可夫斯基和求的是点集C，其中点C是A，B中任取一点相加。 闵可夫斯基和求法https://www.cnblogs.com/xzyxzy/p/10229921.html可以看这里，就是按照两个凸包的所有向量排序，然后依次连接起来，就得到两个凸包的闵可夫斯基和了。 本题考虑求的是点集B + 向量v与A是否有交，即v = A - B，后面是一个闵可夫斯基和的形式。我们将B取反，然后把A凸包和B凸包求一个闵可夫斯基和。如果原来有交，那么v向量一定在二者的闵可夫斯基和图形的凸包中，只用判断点是否在凸包内就行了。代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef double db;typedef pair&lt;int, int&gt; pii;typedef vector&lt;int&gt; vi;typedef vector&lt;ll&gt; vl;typedef vector&lt;pii&gt; vp;const int inf = 1e9;const ll INF = 1e18;#define fi first#define se second#define pb push_back#define eb emplace_back#define ep emplace#define mem(a) memset(a, 0, sizeof(a))#define PA puts("pass")#define lowbit(x) (x &amp; -x)#include&lt;bits/stdc++.h&gt;using namespace std;typedef double db;const db eps = 1e-10;const db pi = acos(-1);int dcmp(db x) &#123; return x&lt;-eps?-1:x&gt;eps;&#125;typedef struct P &#123; db x, y; P(db x = 0, db y = 0) : x(x), y(y) &#123;&#125; P operator+(P r)&#123;return P(x+r.x,y+r.y);&#125; P operator-(P r)&#123;return P(x-r.x,y-r.y);&#125; P operator*(db r)&#123;return P(x*r,y*r);&#125; P operator/(db r)&#123;return P(x/r,y/r);&#125; bool operator&lt;(const P &amp;r)const&#123;return x&lt;r.x||(x==r.x&amp;&amp;y&lt;r.y);&#125; bool operator==(const P &amp;r)const&#123;return dcmp(x-r.x)==0&amp;&amp;dcmp(y-r.y)==0;&#125; void read()&#123; scanf("%lf %lf", &amp;x, &amp;y); &#125; void print()&#123; printf("%.2f %.2f\n", x, y);&#125;&#125;V;db Cross(V A, V B) &#123; return A.x*B.y - A.y*B.x; &#125;//凸包/**************************************************************** 输入点数组p， 个数为p， 输出点数组ch。 返回凸包顶点数* 不希望凸包的边上有输入点，把两个&lt;= 改成 &lt;* 高精度要求时建议用dcmp比较* 输入点不能有重复点。函数执行完以后输入点的顺序被破坏****************************************************************/int ConvexHull(P *p, int n, P* ch) &#123; sort(p, p + n); //先比较x坐标，再比较y坐标 int m = 0; for(int i = 0; i &lt; n; i++) &#123; while(m &gt; 1 &amp;&amp; Cross(ch[m-1] - ch[m-2], p[i] - ch[m-2]) &lt;= 0) m--; ch[m++] = p[i]; &#125; int k = m; for(int i = n - 2; i &gt;= 0; i--) &#123; while(m &gt; k &amp;&amp; Cross(ch[m-1] - ch[m-2], p[i] - ch[m-2]) &lt;= 0) m--; ch[m++] = p[i]; &#125; if(n &gt; 1) m--; return m;&#125;bool inConvexHull(P *ch, int m, P a) &#123; if (dcmp(Cross(ch[1] - ch[0], a - ch[0])) &lt; 0) return false; if (dcmp(Cross(ch[m - 1] - ch[0], a - ch[0])) &gt; 0) return false; int l = 2, r = m - 1; int ans = 1; while (r &gt;= l) &#123; int mid = l + r &gt;&gt; 1; if (dcmp(Cross(ch[mid] - ch[0], a - ch[0])) &lt;= 0) &#123; r = mid - 1; ans = mid; &#125; else l = mid + 1; &#125; if (dcmp(Cross(ch[ans - 1] - ch[ans], a - ch[ans])) &gt; 0) return false; return true;&#125;int Minkowski(P *ch1, P *ch2, P *ch3, int n, int m)&#123; vector&lt;P&gt; c1(n), c2(m); for(int i = 0; i &lt; n - 1; i++) c1[i] = ch1[i + 1] - ch1[i]; c1[n - 1] = ch1[0] - ch1[n - 1]; for(int i = 0; i &lt; m - 1; i++) c2[i] = ch2[i + 1] - ch2[i]; c2[m - 1] = ch2[0] - ch2[m - 1]; int i = 0, j = 0; int k = 0; ch3[k++] = ch1[i] + ch2[j]; while(i &lt; n &amp;&amp; j &lt; m) ch3[k++] = ch3[k - 1] + (dcmp(Cross(c1[i], c2[j])) &gt;= 0 ? c1[i++] : c2[j++]); while(i &lt; n) ch3[k++] = ch3[k - 1] + c1[i++]; while(j &lt; m) ch3[k++] = ch3[k - 1] + c2[j++]; return k;&#125;int n, m, q;const int maxn = 1e5 + 233;P a[maxn], b[maxn], ch1[maxn], ch2[maxn], ch3[maxn], ch4[maxn], tmp;int main() &#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); cin &gt;&gt; n &gt;&gt; m &gt;&gt; q; for (int i = 0; i &lt; n; ++i) &#123; cin &gt;&gt; a[i].x &gt;&gt; a[i].y; &#125; for (int i = 0; i &lt; m; ++i) &#123; cin &gt;&gt; b[i].x &gt;&gt; b[i].y; b[i] = P(-b[i].x, -b[i].y); &#125; n = ConvexHull(a, n, ch1); m = ConvexHull(b, m, ch2); int k = Minkowski(ch1, ch2, ch3, n, m); k = ConvexHull(ch3, k, ch4); while (q--) &#123; cin &gt;&gt; tmp.x &gt;&gt; tmp.y; cout &lt;&lt; inConvexHull(ch4, k, tmp) &lt;&lt; '\n'; &#125; return 0;&#125;]]></content>
      <categories>
        <category>计算几何</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2019牛客暑期多校训练营(第七场)-E(Find the median)]]></title>
    <url>%2F2019%2F08%2F08%2F2019%E7%89%9B%E5%AE%A2%E6%9A%91%E6%9C%9F%E5%A4%9A%E6%A0%A1%E8%AE%AD%E7%BB%83%E8%90%A5-%E7%AC%AC%E4%B8%83%E5%9C%BA-E-Find-the-median%2F</url>
    <content type="text"><![CDATA[链接：https://ac.nowcoder.com/acm/contest/887/E思路：线段树有点卡内存，考虑离线搞，把所有点以及它们右边那个点都拿去离散化。右边那个点用来存区间。所以线段树每个点其实代表一段区间，我们考虑需要维护区间长度，区间出现数的次数，那么单个出现次数可以由二者运算得出。然后每次更新都是在区间的一段上面更新，查询我们直接在线段树上二分走下去就行了。代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef double db;typedef pair&lt;int, int&gt; pii;typedef vector&lt;int&gt; vi;typedef vector&lt;ll&gt; vl;typedef vector&lt;pii&gt; vp;const int inf = 1e9;const ll INF = 1e18;#define fi first#define se second#define pb push_back#define eb emplace_back#define ep emplace#define mem(a) memset(a, 0, sizeof(a))#define PA puts("pass")#define lowbit(x) (x &amp; -x)const int maxn = 1200000 + 233;int len[maxn &lt;&lt; 2], tag[maxn &lt;&lt; 2];ll cnt[maxn &lt;&lt; 2];vi pos;void pushup(int o)&#123; cnt[o] = cnt[o &lt;&lt; 1] + cnt[o &lt;&lt; 1 | 1]; len[o] = len[o &lt;&lt; 1] + len[o &lt;&lt; 1 | 1];&#125;void pushdown(int o)&#123; if(tag[o])&#123; tag[o &lt;&lt; 1] += tag[o]; tag[o &lt;&lt; 1 | 1] += tag[o]; cnt[o &lt;&lt; 1] += 1ll * tag[o] * len[o &lt;&lt; 1]; cnt[o &lt;&lt; 1 | 1] += 1ll * tag[o] * len[o &lt;&lt; 1 | 1]; tag[o] = 0; &#125;&#125;void build(int o, int l, int r)&#123; tag[o] = cnt[o] = len[o] = 0; if(l == r)&#123; if(l == pos.size()) len[o] = 1; else len[o] = pos[l + 1] - pos[l]; return; &#125; int mid = l + r &gt;&gt; 1; build(o &lt;&lt; 1, l, mid); build(o &lt;&lt; 1 | 1, mid + 1, r); pushup(o);&#125;void update(int o, int tl, int tr, int l, int r)&#123; if(l &gt; tr || tl &gt; r) return; if(l &lt;= tl &amp;&amp; tr &lt;= r)&#123; tag[o] += 1; cnt[o] += len[o]; return; &#125; pushdown(o); int mid = tl + tr &gt;&gt; 1; update(o &lt;&lt; 1, tl, mid, l, r); update(o &lt;&lt; 1 | 1, mid + 1, tr, l, r); pushup(o);&#125;int query(int o, int tl, int tr, int l, int r, ll k)&#123; if(tl == tr)&#123; ll t = cnt[o] / len[o]; if(!t) return pos[tl]; return pos[tl] + (k - 1) / t; &#125; pushdown(o); int mid = tl + tr &gt;&gt; 1; if(cnt[o &lt;&lt; 1] &gt;= k) return query(o &lt;&lt; 1, tl, mid, l, r, k); return query(o &lt;&lt; 1 | 1, mid + 1, tr, l, r, k - cnt[o &lt;&lt; 1]);&#125;int n;int x[400005], y[400005], a[2], b[2], c[2], m[2];int main() &#123;#ifndef ONLINE_JUDGE freopen("in.txt", "r", stdin);#else#endif ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); cin &gt;&gt; n; pos.eb(0); cin &gt;&gt; x[1] &gt;&gt; x[2] &gt;&gt; a[0] &gt;&gt; b[0] &gt;&gt; c[0] &gt;&gt; m[0]; cin &gt;&gt; y[1] &gt;&gt; y[2] &gt;&gt; a[1] &gt;&gt; b[1] &gt;&gt; c[1] &gt;&gt; m[1]; for (int i = 3; i &lt;= n; i++) &#123; x[i] = (1ll * a[0] * x[i - 1] + 1ll * b[0] * x[i - 2] + c[0]) % m[0]; y[i] = (1ll * a[1] * y[i - 1] + 1ll * b[1] * y[i - 2] + c[1]) % m[1]; &#125; for(int i = 1; i &lt;= n; i++)&#123; int l = min(x[i], y[i]) + 1; int r = max(x[i], y[i]) + 1; pos.eb(l); pos.eb(l + 1); pos.eb(r); pos.eb(r + 1); &#125; sort(pos.begin(), pos.end()); pos.resize(unique(pos.begin(), pos.end()) - pos.begin()); pos.pop_back(); build(1, 1, pos.size() - 1); ll sum = 0; for(int i = 1; i &lt;= n; i++)&#123; int l = min(x[i], y[i]) + 1; int r = max(x[i], y[i]) + 1; sum += r - l + 1; l = lower_bound(pos.begin(), pos.end(), l) - pos.begin(); r = lower_bound(pos.begin(), pos.end(), r) - pos.begin(); update(1, 1, pos.size() - 1, l, r); cout &lt;&lt; query(1, 1, pos.size() - 1, 1, pos.size() - 1, (sum + 1) / 2) &lt;&lt; '\n'; &#125; return 0;&#125;]]></content>
      <categories>
        <category>线段树</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2019 Multi-University Training Contest 6-E(Snowy Smile)]]></title>
    <url>%2F2019%2F08%2F07%2F2019-Multi-University-Training-Contest-6-E-Snowy-Smile%2F</url>
    <content type="text"><![CDATA[链接：http://acm.hdu.edu.cn/showproblem.php?pid=6638思路：一年前做过这种线段树，不过实在是没想起来。。加上今天身体不算太舒服。。。考虑如果一个序列上，我们求一个最大的连续子段和，可以贪心O(n)做到。如果单点修改，我们可以考虑线段树维护几个值：sum(区间和)，mx(最大连续子段和)，lsum(左端点开始的最大连续子段和)，rsum(右端点开始的最大连续子段和)，然后合并就非常简单：区间和就相加，最大连续子段和来自左右区间的mx，或者左区间的rsum + 右区间的lsum，左端点开始的最大连续子段和要吗是左边的lsum，要吗是左区间sum + 右区间lsum，右端点开始的最大连续子段和同理。然后我们考虑枚举左端点(如果有一堆点x坐标相同，枚举第一个就行，后面都跳过)，按x顺序依次加点进去，一次加一段x坐标相等的点，这时相当于固定了右端点，然后在y轴上做待修改的最大连续子段和即可。代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef double db;typedef pair&lt;int, int&gt; pii;typedef vector&lt;int&gt; vi;typedef vector&lt;ll&gt; vl;typedef vector&lt;pii&gt; vp;const int inf = 1e9;const ll INF = 1e18;#define fi first#define se second#define pb push_back#define eb emplace_back#define ep emplace#define mem(a) memset(a, 0, sizeof(a))#define PA puts("pass")#define lowbit(x) (x &amp; -x)const int maxn = 2010;int n;vi pos;ll mx[maxn &lt;&lt; 2], sum[maxn &lt;&lt; 2], lsum[maxn &lt;&lt; 2], rsum[maxn &lt;&lt; 2];void pushup(int o)&#123; mx[o] = max(mx[o &lt;&lt; 1], max(mx[o &lt;&lt; 1 | 1], rsum[o &lt;&lt; 1] + lsum[o &lt;&lt; 1 | 1])); sum[o] = sum[o &lt;&lt; 1] + sum[o &lt;&lt; 1 | 1]; lsum[o] = max(lsum[o &lt;&lt; 1], sum[o &lt;&lt; 1] + lsum[o &lt;&lt; 1 | 1]); rsum[o] = max(rsum[o &lt;&lt; 1 | 1], sum[o &lt;&lt; 1 | 1] + rsum[o &lt;&lt; 1]);&#125;void build(int o, int l, int r)&#123; if(l == r)&#123; mx[o] = sum[o] = lsum[o] = rsum[o] = 0; return; &#125; int mid = l + r &gt;&gt; 1; build(o &lt;&lt; 1, l, mid); build(o &lt;&lt; 1 | 1, mid + 1, r); pushup(o);&#125;void update(int o, int tl, int tr, int l, int r, ll v)&#123; if(l &gt; tr || tl &gt; r) return; if(l &lt;= tl &amp;&amp; tr &lt;= r)&#123; mx[o] += v; sum[o] += v; lsum[o] += v; rsum[o] += v; return; &#125; int mid = tl + tr &gt;&gt; 1; update(o &lt;&lt; 1, tl, mid, l, r, v); update(o &lt;&lt; 1 | 1, mid + 1, tr, l, r, v); pushup(o);&#125;int T;struct node&#123; int x, y, w; bool operator&lt;(const node &amp;r) const&#123; return x &lt; r.x || (x == r.x &amp;&amp; y &lt; r.y); &#125;&#125;a[maxn];ll mn[maxn];int main()&#123;#ifndef ONLINE_JUDGE freopen("in.txt", "r", stdin);#else#endif ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); cin &gt;&gt; T; while(T--)&#123; cin &gt;&gt; n; pos.clear(); for (int i = 1; i &lt;= n; ++i) &#123; cin &gt;&gt; a[i].x &gt;&gt; a[i].y &gt;&gt; a[i].w; pos.eb(a[i].y); &#125; sort(pos.begin(), pos.end()); sort(a + 1, a + n + 1); pos.resize(unique(pos.begin(), pos.end()) - pos.begin()); for (int i = 1; i &lt;= n; ++i) &#123; a[i].y = lower_bound(pos.begin(), pos.end(), a[i].y) - pos.begin() + 1; &#125; ll res = 0; for(int i = 1; i &lt;= n; i++)&#123; if(a[i].x == a[i - 1].x) continue; build(1, 1, pos.size()); for(int j = i; j &lt;= n; j++)&#123; if(j &gt; 1 &amp;&amp; a[j].x &gt; a[j - 1].x) res = max(res, mx[1]); update(1, 1, pos.size(), a[j].y, a[j].y, a[j].w); &#125; res = max(res, mx[1]); &#125; cout &lt;&lt; res &lt;&lt; '\n'; &#125; return 0;&#125;]]></content>
      <categories>
        <category>线段树</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[ABBYY Cup 3.0-G3(Good Substrings)]]></title>
    <url>%2F2019%2F08%2F06%2FABBYY-Cup-3-0-G3-Good-Substrings%2F</url>
    <content type="text"><![CDATA[链接：https://codeforces.com/contest/316/problem/G3思路：一开始想的是原串建立SAM，然后拿各个串去跑SAM，在节点给出贡献，最后沿着fail树统计贡献即可。但是发现一个问题，就是假设跑到了某个点，那么它fail树上的祖先一定是它的子串，它们都应该贡献++，但是当前这个点怎么办？因为一个点是包含了多个串，你怎么知道是从哪个串开始的呢？究其原因是我们子串状态划分的不够细，就会出现这个问题。正解是建立广义后缀自动机，建立的时候标记一下每个点是哪个串的贡献，然后沿fail树统计出现次数。然后我们对于每一个状态进行check，这个状态只要是原串出现过并且满足其他统计串的区间条件即可。复杂度O(m * (S + \sum T))代码:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102#include&lt;bits/stdc++.h&gt;#define sigma_size 28using namespace std;const int maxn = 5e5 + 50010;const int mod = 1e9 + 7;typedef long long ll;int len[maxn * 2];int f[maxn * 2]; int cnt[maxn * 2]; int ch[maxn * 2][sigma_size]; int idx; int last; int epos[maxn * 2];char s[maxn];int res[maxn * 2][20]; void init() &#123; last = idx = 1; f[1] = len[1] = 0; memset(ch[1], 0, sizeof(ch[1]));&#125; void add(int c, int id) &#123; int x = ++idx; len[x] = len[last] + 1; epos[x] = 1; res[x][id]++; int p; for (p = last; p &amp;&amp; !ch[p][c]; p = f[p])ch[p][c] = x; if (!p)f[x] = 1, cnt[1]++; else &#123; int q = ch[p][c]; if (len[p] + 1 == len[q]) f[x] = q, cnt[q]++; else &#123; int nq = ++idx; len[nq] = len[p] + 1; f[nq] = f[q]; memcpy(ch[nq], ch[q], sizeof(ch[q])); for (; p &amp;&amp; ch[p][c] == q; p = f[p]) ch[p][c] = nq; f[q] = f[x] = nq; cnt[nq] += 2; &#125; &#125; last = x; &#125; int n; void getpos() &#123; queue&lt;int&gt; q; for (int i = 1; i &lt;= idx; i++) if (!cnt[i])q.push(i); while (!q.empty()) &#123; int x = q.front(); q.pop(); epos[f[x]] += epos[x]; for(int i = 0; i &lt;= n; i++)&#123; res[f[x]][i] += res[x][i]; &#125; if (--cnt[f[x]] == 0)q.push(f[x]); &#125;&#125; typedef pair&lt;int, int&gt; pii;pii a[20];#define fi first#define se second ll ans; int main() &#123; scanf("%s", s + 1); n = strlen(s + 1); init(); for (int i = 1; i &lt;= n; ++i) &#123; add(s[i] - 'a', 0); &#125; scanf("%d", &amp;n); for (int i = 1; i &lt;= n; ++i) &#123; scanf("%s %d %d", s + 1, &amp;a[i].fi, &amp;a[i].se); last = 1; for(int j = 1, t = strlen(s + 1); j &lt;= t; j++)&#123; add(s[j] - 'a', i); &#125; &#125; getpos(); for (int i = 2; i &lt;= idx; ++i) &#123; int p = len[i] - len[f[i]]; if(res[i][0] == 0) p = 0; for (int j = 1; j &lt;= n; ++j) &#123; if(res[i][j] &gt;= a[j].fi &amp;&amp; res[i][j] &lt;= a[j].se) continue; p = 0; break; &#125; ans += p; &#125; printf("%lld\n", ans); return 0;&#125;]]></content>
      <categories>
        <category>后缀自动机</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2019 Multi-University Training Contest 5-H(line symmetric)]]></title>
    <url>%2F2019%2F08%2F06%2F2019-Multi-University-Training-Contest-5-H-line-symmetric%2F</url>
    <content type="text"><![CDATA[链接：http://acm.hdu.edu.cn/showproblem.php?pid=6631思路：场上写的时候考虑的是枚举对称轴是点点，边边还是点边，然后发现对称轴还可以旋转非常不好写。。事实上可以考虑枚举对称轴，发现一定是相邻两个点或者隔了一个点的两个点，这样我们只用看对称轴几个条件：1、两端点数差不能大于2。 2、需要更改的位置数不能大于1。 3、如果点在对称轴上也需要更改。 4、不能有互相穿过对称轴的情况，不然交叉配对后有点相交，不再是简单多边形。 这个题主要是细节比较多。。。wa点也很多。。。。不太好写。代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef double db;typedef pair&lt;int, int&gt; pii;typedef vector&lt;int&gt; vi;typedef vector&lt;ll&gt; vl;typedef vector&lt;pii&gt; vp;const int inf = 1e9;const ll INF = 1e18;#define fi first#define se second#define pb push_back#define eb emplace_back#define mem(a) memset(a, 0, sizeof(a))#define PA puts("pass")#define lowbit(x) (x &amp; -x)const db eps = 1e-10;const db pi = acos(-1);int dcmp(db x) &#123; return x&lt;-eps?-1:x&gt;eps;&#125;db myacos(db x)&#123; if(x&lt;-1) x = -1; if(x&gt;1) x = 1; return acos(x);&#125;db myasin(db x)&#123; if(x&lt;-1) x = -1; if(x&gt;1) x = 1; return asin(x);&#125;db mysqrt(db x)&#123; return x&lt;0?0:sqrt(x);&#125;typedef struct P &#123; db x, y; P(db x = 0, db y = 0) : x(x), y(y) &#123;&#125; P operator+(P r)&#123;return P(x+r.x,y+r.y);&#125; P operator-(P r)&#123;return P(x-r.x,y-r.y);&#125; P operator*(db r)&#123;return P(x*r,y*r);&#125; P operator/(db r)&#123;return P(x/r,y/r);&#125; bool operator&lt;(const P &amp;r)const&#123;return x&lt;r.x||(x==r.x&amp;&amp;y&lt;r.y);&#125; bool operator==(const P &amp;r)const&#123;return dcmp(x-r.x)==0&amp;&amp;dcmp(y-r.y)==0;&#125; void read()&#123; scanf("%lf %lf", &amp;x, &amp;y); &#125; void print()&#123; printf("%.2f %.2f\n", x, y);&#125;&#125;V;//向量点积db Dot(V A, V B) &#123; return A.x*B.x + A.y*B.y; &#125;db Cross(V A, V B) &#123; return A.x*B.y - A.y*B.x; &#125;bool SegmentProperIntersection(P a1, P a2, P b1, P b2) &#123; db c1 = Cross(a2-a1, b1-a1), c2 = Cross(a2-a1, b2-a1); db c3 = Cross(b2-b1, a1-b1), c4 = Cross(b2-b1, a2-b1); return dcmp(c1)*dcmp(c2) &lt; 0 &amp;&amp; dcmp(c3)*dcmp(c4) &lt; 0;&#125;bool OnSegment(P p, P a1, P a2) &#123; return dcmp(Cross(a1-p, a2-p)) == 0 &amp;&amp; dcmp((Dot(a1-p, a2-p)) &lt; 0);&#125;const int maxn = 2010;P a[maxn];int T, n;V Rotate(V A, db rad) &#123; return V(A.x*cos(rad)-A.y*sin(rad), A.x*sin(rad)+A.y*cos(rad));&#125;void print(bool x)&#123; if(x) cout &lt;&lt; "Y\n"; else cout &lt;&lt; "N\n";&#125;V now;P t;bool check(int s, int e1, int e2)&#123; V o = Rotate(now, pi / 2); int t1 = 0, t2 = 0, t3 = 0, t4 = 0, t5 = 0; for(int i = (s + n - 1) % n; i != e1; i = (i + n - 1) % n)&#123; int x = dcmp(Cross(a[i] - t, o)); if(x == 0) t5++; else if(x &gt; 0) t1++; else t2++; &#125; for(int i = (s + 1) % n; i != e2; i = (i + 1) % n)&#123; int x = dcmp(Cross(a[i] - t, o)); if(x == 0) t5++; else if(x &gt; 0) t3++; else t4++; &#125; int res = min(t1 + t4, t2 + t3) + t5; if(res &lt;= 1 )return true; return false;&#125;bool solve1()&#123; for (int i = 0; i &lt; n; ++i) &#123; int l = i, r = (i + 1) % n; now = a[r] - a[l]; t = (a[r] + a[l]) / 2; int res = 0; l = (l + n - 1) % n; r = (r + 1) % n; while(l != r)&#123; if(dcmp(Dot((a[r] + a[l]) / 2 - t, now)) != 0 || dcmp(Cross(a[r] - a[l], now)) != 0)&#123; res++; &#125; r = (r + 1) % n; l = (l - 1 + n) % n; &#125; if(!check(i, l, l)) continue; if(dcmp(Dot(a[l] - t, now)) != 0)&#123; res++; &#125; if(res &lt;= 1) &#123; return true; &#125; &#125; for (int i = 0; i &lt; n; ++i) &#123; int l = (i - 1 + n) % n, r = (i + 1) % n; now = a[r] - a[l]; t = (a[r] + a[l]) / 2; int res = 0; int len = 0; l = (l + n - 1) % n; r = (r + 1) % n; while(len &lt; n / 2 - 1)&#123; len++; if(dcmp(Dot((a[r] + a[l]) / 2 - t, now)) != 0 || dcmp(Cross(a[r] - a[l], now)) != 0)&#123; res++; &#125; r = (r + 1) % n; l = (l - 1 + n) % n; &#125; if(!check(i, l, r)) continue; if(dcmp(Dot(a[i] - t, now)) != 0)&#123; res++; &#125; if(res &lt;= 1) &#123; return true; &#125; &#125; return false;&#125;bool solve2()&#123; for (int i = 0; i &lt; n; ++i) &#123; int l = i, r = (i + 1) % n; now = a[r] - a[l]; t = (a[r] + a[l]) / 2; int res = 0; int len = 0; l = (l + n - 1) % n; r = (r + 1) % n; while(len &lt; n / 2 - 1)&#123; len++; if(dcmp(Dot((a[r] + a[l]) / 2 - t, now)) != 0 || dcmp(Cross(a[r] - a[l], now)) != 0)&#123; res++; &#125; r = (r + 1) % n; l = (l - 1 + n) % n; &#125; if(!check(i, l, r)) continue; if(res &lt;= 1) &#123; return true; &#125; &#125; for (int i = 0; i &lt; n; ++i) &#123; int l = (i - 1 + n) % n, r = (i + 1) % n; now = a[r] - a[l]; t = (a[r] + a[l]) / 2; int res = 0; l = (l - 1 + n) % n; r = (r + 1) % n; while(l != r)&#123; if(dcmp(Dot((a[r] + a[l]) / 2 - t, now)) != 0 || dcmp(Cross(a[r] - a[l], now)) != 0)&#123; res++; &#125; r = (r + 1) % n; l = (l - 1 + n) % n; &#125; if(!check(i, l, l)) continue; if(dcmp(Dot(a[i] - t, now)) != 0)&#123; res++; &#125; if(dcmp(Dot(a[l] - t, now)) != 0) res++; if(res &lt;= 1) &#123; return true; &#125; &#125; return false;&#125;int main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); cin &gt;&gt; T; while(T--)&#123; cin &gt;&gt; n; for (int i = 0; i &lt; n; ++i) &#123; cin &gt;&gt; a[i].x &gt;&gt; a[i].y; &#125; if(n &lt;= 4)&#123; print(1); continue; &#125; if(n % 2) print(solve1()); else print(solve2()); &#125; return 0;&#125;]]></content>
      <categories>
        <category>计算几何</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2019 Multi-University Training Contest 5-A(fraction)]]></title>
    <url>%2F2019%2F08%2F06%2F2019-Multi-University-Training-Contest-5-A-fraction%2F</url>
    <content type="text"><![CDATA[链接：http://acm.hdu.edu.cn/showproblem.php?pid=6624思路：题目求最小的b使得存在a &lt; b满足a \equiv bx\ mod\ p考虑换个形式写：a = bx - cp可以得到0 < bx - cp < b得到： \frac{p}{x} < \frac{b}{c} < \frac{p}{x - 1}这个问题可以用辗转相除法解决。我们考虑先比较\lfloor\frac{p}{x}\rfloor和\lfloor\frac{p}{x - 1}\rfloor的值，如果不等，我们令b = \lfloor\frac{p}{x}\rfloor + 1，c = 1，即可得到最小的c。否则我们考虑同时减去一个t = \lfloor\frac{p}{x}\rfloor，变为两个真分数了，再把它倒过来，可以得到: \frac{x - 1}{p - t * (x - 1)} < \frac{c}{b - t * c} < \frac{p}{p - t * (x - 1)}我们可以递归解决即可。考虑这样得到的是最小的吗，答案是一定的，假设上一次答案是最小的，根据等式传递即可得到这次答案也是最小的。代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef double db;typedef pair&lt;int, int&gt; pii;typedef vector&lt;int&gt; vi;typedef vector&lt;ll&gt; vl;typedef vector&lt;pii&gt; vp;const int inf = 1e9;const ll INF = 1e18;#define fi first#define se second#define pb push_back#define eb emplace_back#define mem(a) memset(a, 0, sizeof(a))#define PA puts("pass")#define lowbit(x) (x &amp; -x)int T;ll x, p;void solve(ll a, ll b, ll c, ll d, ll &amp;x, ll &amp;y)&#123; ll t1 = a / b; ll t2 = c / d; if(t1 != t2)&#123; x = t1 + 1; y = 1; return; &#125; solve(d, c - t1 * d, b, a - t1 * b, x, y); ll t = y + t1 * x; y = x; x = t;&#125;int main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); cin &gt;&gt; T; while(T--)&#123; cin &gt;&gt; p &gt;&gt; x; ll b, c; solve(p, x, p, x - 1, b, c); ll a = b * x - c * p; ll g = __gcd(a, b); cout &lt;&lt; a / g &lt;&lt; "/" &lt;&lt; b / g &lt;&lt; '\n'; &#125; return 0;&#125;]]></content>
      <categories>
        <category>数论</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[bzoj-2806(Cheat)]]></title>
    <url>%2F2019%2F08%2F04%2Fbzoj-2806-Cheat%2F</url>
    <content type="text"><![CDATA[链接：https://www.lydsy.com/JudgeOnline/problem.php?id=2806思路：明显要二分L值，不然后面都没法做。。考虑二分L值后，如何check。考虑枚举到一个点i，此时到达自动机上u结点，此时匹配的最长后缀串长为x，那么我们考虑当前dp[i]是从哪个j转移过来的，很明显j的范围是[i - x, i - L] (x &gt;= L)，考虑i往后移动，i - x的值是单调不减的（i稳定 + 1，x每次最多 + 1而且还可能因为找不到匹配而变小）， i - L的值也是稳定单调递增，这就变成了一个滑窗，可以用单调队列优化dp解决了。注意单调队列中在i时只放入i - x极以前的位置，保证单调队列中的值在队首check后都是合法可以转移到i点的值。然后还有就是注意求当前匹配的最长后缀的写法。代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108#include&lt;bits/stdc++.h&gt;#define sigma_size 2using namespace std;const int maxn = 1100000 + 233;const int mod = 1e9 + 7;typedef long long ll;int len[maxn * 2]; //最长子串的长度(该节点字串数量=len[x]-len[f[x]])int f[maxn * 2]; //后缀链接(最短串前部减少一个字符所到达的状态)int cnt[maxn * 2]; //被后缀连接的数int ch[maxn * 2][sigma_size]; //状态转移(尾部加一个字符的下一个状态)(图)int idx; //节点编号int last; //最后节点ll epos[maxn * 2]; // enpos数（该状态子串出现数量）char s[maxn];int n, m;int dp[maxn * 2];int head, tail, Q[maxn];void init() &#123; //初始化 last = idx = 1; //1表示root起始点 空集 f[1] = len[1] = 0; memset(ch[1], 0, sizeof(ch[1]));&#125;//SAM建图void add(int c) &#123; //插入字符，为字符ascll码值 int x = ++idx; //创建一个新节点x; len[x] = len[last] + 1; // 长度等于最后一个节点+1 epos[x] = 1; //接受节点子串除后缀连接还需加一 int p; //第一个有C转移的节点; for (p = last; p &amp;&amp; !ch[p][c]; p = f[p])ch[p][c] = x;//沿着后缀连接 将所有没有字符c转移的节点直接指向新节点 if (!p)f[x] = 1, cnt[1]++; //全部都没有c的转移 直接将新节点后缀连接到起点 else &#123; int q = ch[p][c]; //p通过c转移到的节点 if (len[p] + 1 == len[q]) //pq是连续的 f[x] = q, cnt[q]++; //将新节点后缀连接指向q即可,q节点的被后缀连接数+1 else &#123; int nq = ++idx; //不连续 需要复制一份q节点 len[nq] = len[p] + 1; //令nq与p连续 f[nq] = f[q]; //因后面link[q]改变此处不加cnt memcpy(ch[nq], ch[q], sizeof(ch[q])); //复制q的信息给nq for (; p &amp;&amp; ch[p][c] == q; p = f[p]) ch[p][c] = nq; //沿着后缀连接 将所有通过c转移为q的改为nq f[q] = f[x] = nq; //将x和q后缀连接改为nq cnt[nq] += 2; // nq增加两个后缀连接 &#125; &#125; last = x; //更新最后处理的节点&#125;int t;bool check(int x) &#123; int p = 1, sz = 0; head = 1, tail = 0; for (int i = 1; i &lt;= t; ++i) &#123; int c = s[i] - '0'; if(ch[p][c])&#123; sz++, p = ch[p][c]; &#125; else &#123; while (p &amp;&amp; !ch[p][c]) p = f[p]; if (!p) p = 1, sz = 0; else sz = len[p] + 1, p = ch[p][c]; &#125; dp[i] = dp[i - 1]; if(sz &gt;= x) dp[i] = max(dp[i], sz); int z = i - x; if(z &gt;= 0) &#123; while (head &lt;= tail &amp;&amp; dp[Q[tail]] - Q[tail] &lt;= dp[z] - z) tail--; Q[++tail] = z; &#125; while(head &lt;= tail &amp;&amp; i - Q[head] &gt; sz) head++; if(head &lt;= tail) dp[i] = max(dp[i], dp[Q[head]] - Q[head] + i); &#125; int tmp = dp[t]; for (int i = 1; i &lt;= t; ++i) &#123; dp[i] = 0; &#125; return tmp * 10 &gt;= t * 9;&#125;int main() &#123; scanf("%d %d", &amp;n, &amp;m); init(); for (int i = 1; i &lt;= m; ++i) &#123; scanf("%s", s + 1); last = 1; for (int j = 1, t = strlen(s + 1); j &lt;= t; ++j) &#123; add(s[j] - '0'); &#125; &#125; for(int i = 1; i &lt;= n; i++)&#123; scanf("%s", s + 1); t = strlen(s + 1); int lb = 1, ub = t, ans = 0; while(ub &gt;= lb)&#123; int mid = ub + lb &gt;&gt; 1; if(check(mid))&#123; ans = mid; lb = mid + 1; &#125; else ub = mid - 1; &#125; printf("%d\n", ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>后缀自动机</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[The 2019 ACM-ICPC China Shannxi Provincial Programming Contest-B(Product)]]></title>
    <url>%2F2019%2F08%2F04%2FThe-2019-ACM-ICPC-China-Shannxi-Provincial-Programming-Contest-B-Product%2F</url>
    <content type="text"><![CDATA[链接：https://nanti.jisuanke.com/t/39269思路：考虑把东西全部拿到指数上面去，然后用欧拉降幂，令mod = p - 1，那么指数部分就变为了: \sum_{i = 1}^n\sum_{j = 1}^n\sum_{k = 1}^ngcd(i, j)[k|gcd(i, j)]枚举gcd(i, j): \sum_{t = 1}^ntd(t)\sum_{i = 1}^{\lfloor\frac{n}{t}\rfloor}\sum_{j = 1}^{\lfloor\frac{n}{t}\rfloor}[gcd(i, j) == 1]后面是非常典型的套路，用欧拉函数前缀和去凑: \sum_{t = 1}^ntd(t) * (2 * \sum_{i = 1}^{\lfloor\frac{n}{d}\rfloor}\phi(i) - 1)考虑前面分块，后面欧拉函数前缀和我们可以用杜教筛解决，关键是求区间的$td(t)$。既然直接不太好求，我们考虑一下它的前缀和形式： f(n) = \sum_{i = 1}^nid(i) = \sum_{i = 1}^ni\sum_{j|i}1考虑枚举j: \sum_{j = 1}^nj\sum_{i = 1}^{\lfloor\frac{n}{j}\rfloor}i = \sum_{j = 1}^nj * \frac{(1 + \lfloor\frac{n}{j}\rfloor)\lfloor\frac{n}{j}\rfloor}{2}发现它的前缀和也可以数论分块做，但是两个数论分块套在一起复杂度爆了。我们仔细观察发现，里面的数论分块和外面的数论分块的分块值是完全一样的，换句话说它们要用的是共同的2 * \sqrt(n)个点处的值，所以我们考虑里面记忆化搜索，这样总的数论分块的复杂度就变为了O(\sqrt(n))。对于欧拉函数的杜教筛部分也是一样，杜教筛只会用到那$2 * \sqrt(n)$处点的值，所以整个分块中杜教筛的复杂度仍然是O(n^\frac{2}{3})注意上面的是模的phi(p) = p - 1，可能不存在逆元，所以不要直接就乱取逆元。。。。代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef double db;typedef pair&lt;int, int&gt; pii;typedef vector&lt;int&gt; vi;typedef vector&lt;ll&gt; vl;typedef vector&lt;pii&gt; vp;const int inf = 1e9;const ll INF = 1e18;#define fi first#define se second#define pb push_back#define eb emplace_back#define mem(a) memset(a, 0, sizeof(a))#define PA puts("pass")#define lowbit(x) (x &amp; -x)const int maxn = 3e6 + 233;vi prime;bool vis[maxn];int phi[maxn];int d[maxn];int n, m;int mod;int pow_mod(int q, int w, int mod)&#123; int ret = 1; while(w)&#123; if(w &amp; 1) ret = ll(ret) * q % mod; q = (ll) q * q % mod; w &gt;&gt;= 1; &#125; return ret;&#125;void add(int &amp;x, int y)&#123; x += y; if(x &gt;= mod) x -= mod;&#125;void sub(int &amp;x, int y)&#123; x -= y; if(x &lt; 0) x += mod;&#125;struct HASH &#123; static const int mod = 1226959; int hs[mod], head[mod], nxt[mod], id[mod], top; void init()&#123; memset(head, -1, sizeof(head)); top = 1; &#125;; void insert(ll x, int y) &#123; int k = x % mod; hs[top] = x, id[top] = y, nxt[top] = head[k], head[k] = top++; &#125; int find(int x) &#123; int k = x % mod; for (int i = head[k]; i != -1; i = nxt[i]) if (hs[i] == x) return id[i]; return -1; &#125;&#125;mp1, mp2;void init()&#123; phi[1] = 1, d[1] = 1; for(int i = 2; i &lt; maxn; i++)&#123; if(!vis[i]) prime.eb(i), phi[i] = i - 1, d[i] = 2; for(int j = 0; j &lt; prime.size() &amp;&amp; i * prime[j] &lt; maxn; j++)&#123; vis[i * prime[j]] = 1; if(i % prime[j] == 0)&#123; phi[i * prime[j]] = phi[i] * prime[j]; int num = 1, p = i; while(p % prime[j] == 0) p /= prime[j], num++; d[i * prime[j]] = d[i] / num * (num + 1); break; &#125; phi[i * prime[j]] = phi[i] * phi[prime[j]]; d[i * prime[j]] = d[i] * 2; &#125; &#125; for (int i = 1; i &lt; maxn; ++i) &#123; d[i] = 1ll * d[i] * i % mod; add(d[i], d[i - 1]); add(phi[i], phi[i - 1]); &#125;&#125;int getphi(int x)&#123; if(x &lt; maxn) return phi[x]; int t = mp1.find(x); if(t != -1) return t; int res = 1ll * x * (x + 1) / 2 % mod; for(int l = 2, r; l &lt;= x; l = r + 1)&#123; r = x / (x / l); sub(res, 1ll * (r - l + 1) * getphi(x / l) % mod); &#125; mp1.insert(x, res); return res;&#125;int cal(int l, int r)&#123; return 1ll * (r + l) * (r - l + 1) / 2 % mod;&#125;int getnum(int x)&#123; if(x &lt; maxn)return d[x]; int t = mp2.find(x); if(t != -1) return t; int res = 0; for(int l = 1, r; l &lt;= x; l = r + 1)&#123; r = x / (x / l); add(res, 1ll * cal(l, r) * cal(1, x / l) % mod); &#125; mp2.insert(x, res); return res;&#125;int main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); mp1.init(), mp2.init(); cin &gt;&gt; n &gt;&gt; m &gt;&gt; mod; mod--; init(); int res = 0; for(int l = 1, r; l &lt;= n; l = r + 1)&#123; r = n / (n / l); add(res, 1ll * (((ll)getnum(r) - getnum(l - 1)) % mod + mod) % mod * ((2ll * getphi(n / l) + mod - 1) % mod) % mod); &#125; cout &lt;&lt; pow_mod(m, res, mod + 1) &lt;&lt; '\n'; return 0;&#125;]]></content>
      <categories>
        <category>杜教筛</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2019牛客暑期多校训练营(第六场)-C(Palindrome Mouse)]]></title>
    <url>%2F2019%2F08%2F03%2F2019%E7%89%9B%E5%AE%A2%E6%9A%91%E6%9C%9F%E5%A4%9A%E6%A0%A1%E8%AE%AD%E7%BB%83%E8%90%A5-%E7%AC%AC%E5%85%AD%E5%9C%BA-C-Palindrome-Mouse%2F</url>
    <content type="text"><![CDATA[链接：https://ac.nowcoder.com/acm/contest/886/C思路：又对回文自动机有了更进一步的认识。。。。考虑对于回文树上的每一个点统计它的子回文串，我们考虑这些串一定是出现在它及它之前的后缀点的fail树上的（每个回文子串必定是某个后缀点的后缀回文子串），所以我们沿着一路下来，经过的每个点沿着fail树暴力标记，对于某个点的答案贡献就是它所标记的节点数量和。首先第一点：我们如果在fail树上遇到一个点标记过了，那么就停止。这个很好证明，因为之前来过这个点，那它更高的地方一定都被标记了。第二点：每次暴力跳最多不会超过两步。考虑我们每次移动后，新增加的串必定是以该点为结尾的回文串，我们先跳一步，跳到一个它的最长回文后缀的位置，这个点有可能没被计算过（只有结束点在中心点右边的位置的才算过，如果该长度小于之前一半对称过去就在中心点的左边，就可能没有计算过），这没关系，我们考虑再跳一步，它又是一个最长的回文后缀，这时候再在父亲的回文串上对称一下，它就变成了父亲的某个回文前缀，我们利用对称关系，一定可以找到起始点结束点都在中心点右边的该回文子串，这个串一定被统计过了。所以总体复杂度O(n)。如果还不太懂可以看看这里： https://www.cnblogs.com/1625--H/p/11296121.html 感谢原博主代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef double db;typedef pair&lt;int, int&gt; pii;typedef vector&lt;int&gt; vi;typedef vector&lt;ll&gt; vl;typedef vector&lt;pii&gt; vp;const int inf = 1e9;const ll INF = 1e18;#define fi first#define se second#define pb push_back#define eb emplace_back#define mem(a) memset(a, 0, sizeof(a))#define PA puts("pass")#define lowbit(x) (x &amp; -x)const int maxnode = 1e5 + 100;const int sigma_size = 26;int ch[maxnode][sigma_size];int f[maxnode];int cnt[maxnode]; // 节点i表示的回文串在S中出现的次数（建树时求出的不是完全的，count()加上子节点以后才是正确的）int num[maxnode]; //以节点i回文串的末尾字符结尾的但不包含本条路径上的回文串的数目。(也就是fail指针路径的深度)int len[maxnode]; //节点i的回文串的长度int s[maxnode]; //表示第i次添加的字符int last; //指向最新添加的回文结点bool vis[maxnode];int n;int p; //节点个数（节点从2开始）char str[maxnode];void clear()&#123; mem(f); mem(ch); mem(num); mem(len); mem(cnt); mem(vis); mem(s);&#125;int newnode(int w) &#123; for(int i = 0; i &lt; sigma_size; i++)ch[p][i] = 0; cnt[p] = 0; num[p] = 0; len[p] = w; return p++;&#125;void init() &#123; p = 0; newnode(0); newnode(-1); last = 0; n = 0; s[n] = -1; f[0] = 1;&#125;int getfail(int x) &#123; while (s[n - len[x] - 1] != s[n])x = f[x]; return x;&#125;void add(int c) &#123; s[++n] = c; int cur = getfail(last); if (!ch[cur][c]) &#123; int now = newnode(len[cur] + 2); f[now] = ch[getfail(f[cur])][c]; ch[cur][c] = now; num[now] = num[f[now]] + 1; &#125; last = ch[cur][c]; cnt[last]++;&#125;void count()&#123; for(int i = p-1; i &gt;= 0; i--) cnt[f[i]] += cnt[i];&#125;ll res;void dfs(int u, int sum)&#123; vector&lt;int&gt; tmp; int p = u; while(f[p] &gt; 1 &amp;&amp; !vis[f[p]])&#123; p = f[p]; vis[p] = 1; tmp.eb(p); sum++; &#125; res += sum; if(u &gt; 1) &#123; tmp.eb(u); sum++; vis[u] = 1; &#125; for(int i = 0; i &lt; 26; i++)&#123; if(ch[u][i]) dfs(ch[u][i], sum); &#125; for(auto &amp;it : tmp) vis[it] = 0;&#125;int T;int main()&#123; scanf("%d", &amp;T); int kase = 0; while(T--)&#123; scanf("%s", str + 1); clear(); init(); int t = strlen(str + 1); for(int i = 1; i &lt;= t; i++) add(str[i] - 'a'); res = 0; dfs(0, 0); dfs(1, 0); printf("Case #%d: %lld\n", ++kase, res); &#125; return 0;&#125;]]></content>
      <categories>
        <category>回文自动机</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[bzoj-4916(神犇和蒟蒻)]]></title>
    <url>%2F2019%2F08%2F03%2Fbzoj-4916-%E7%A5%9E%E7%8A%87%E5%92%8C%E8%92%9F%E8%92%BB%2F</url>
    <content type="text"><![CDATA[链接：https://www.lydsy.com/JudgeOnline/problem.php?id=4916思路：求第一个就不说了，恒为1。第二个考虑化简：\sum_{i = 1}^n\phi(i^2)由于是积性函数，并且根据欧拉函数的性质，i中的质因子一定在$\phi(i)$中计算过了，所以可以得到:\sum_{i = 1}^n\ i * \phi(i)我们把这个函数尝试跟$I$做狄利克雷卷积：f * I = \sum_{d|i}d * \phi(d) * \frac{i}{d} = i ^ 2发现特别好算，于是套用杜教筛：S(n) = i ^ 2 - \sum_{i = 2} ^ niS(\lfloor\frac{n}{i}\rfloor)代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include&lt;bits/stdc++.h&gt;using namespace std; typedef long long ll;typedef double db;typedef pair&lt;int, int&gt; pii;typedef vector&lt;int&gt; vi;typedef vector&lt;ll&gt; vl;typedef vector&lt;pii&gt; vp;const int inf = 1e9;const ll INF = 1e18; #define fi first#define se second#define pb push_back#define eb emplace_back#define mem(a) memset(a, 0, sizeof(a))#define PA puts("pass")#define lowbit(x) (x &amp; -x)const int mod = 1e9 + 7;const int maxn = 3e6;const int inv = 166666668;vi prime;bool vis[maxn];int phi[maxn]; void add(int &amp;x, int y)&#123; x += y; if(x &gt;= mod) x -= mod;&#125; void sub(int &amp;x, int y)&#123; x -= y; if(x &lt; 0) x += mod;&#125; void init()&#123; phi[1] = 1; for(int i = 2; i &lt; maxn; i++)&#123; if(!vis[i]) prime.pb(i), phi[i] = i - 1; for(int j = 0; j &lt; prime.size() &amp;&amp; i * prime[j] &lt; maxn; j++)&#123; vis[i * prime[j]] = 1; if(i % prime[j] == 0)&#123; phi[i * prime[j]] = phi[i] * prime[j]; break; &#125; phi[i * prime[j]] = phi[i] * phi[prime[j]]; &#125; &#125; for (int i = 1; i &lt; maxn; ++i) &#123; add(phi[i],(1ll * (i - 1) * phi[i] + phi[i - 1]) % mod); &#125;&#125; struct HASH &#123; static const int mod = 12000005; int hs[mod], head[mod], nxt[mod], id[mod], top; void init()&#123; memset(head, -1, sizeof(head)); top = 1; &#125;; void insert(int x, int y) &#123; int k = x % mod; hs[top] = x, id[top] = y, nxt[top] = head[k], head[k] = top++; &#125; int find(int x) &#123; int k = x % mod; for (int i = head[k]; i != -1; i = nxt[i]) if (hs[i] == x) return id[i]; return -1; &#125;&#125;mp;int n; int getans(int x)&#123; if(x &lt; maxn) return phi[x]; int t = mp.find(x); if(t != -1) return t; int res = 1ll * x * (x + 1) % mod * (2 * x + 1) % mod * inv % mod; for(int l = 2, r; l &lt;= x; l = r + 1)&#123; r = x / (x / l); sub(res, 1ll * (r - l + 1) * (r + l) / 2 % mod * getans(x / l) % mod); &#125; mp.insert(x, res); return res;&#125;int main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); init(); cin &gt;&gt; n; mp.init(); cout &lt;&lt; 1 &lt;&lt; '\n' &lt;&lt; getans(n) &lt;&lt; '\n'; return 0;&#125;]]></content>
      <categories>
        <category>杜教筛</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[CCPC-Wannafly Winter Camp Day3-F(小清新数论)]]></title>
    <url>%2F2019%2F08%2F02%2FCCPC-Wannafly-Winter-Camp-Day3-F-%E5%B0%8F%E6%B8%85%E6%96%B0%E6%95%B0%E8%AE%BA%2F</url>
    <content type="text"><![CDATA[链接：https://www.cometoj.com/contest/14/problem/F?problem_id=208思路：二话不说，先直接走一波公式。我们要求 \sum_{i = 1}^n\sum_{j = 1}^n\mu(gcd(i, j))枚举gcd(i, j): \sum_{d = 1}^n\mu(d)\sum_{i = 1}^{\lfloor\frac{n}{d}\rfloor}\sum_{j = 1}^{\lfloor\frac{n}{d}\rfloor}[gcd(i, j) == 1]令 f(n) = \sum_{i = 1}^{n}\sum_{j = 1}^{n}[gcd(i, j) == 1]考虑凑成欧拉函数的前缀和形式: f(n) = 2 * \sum_{i = 1}^n\sum_{j = 1}^i - 1我们知道欧拉函数可以用杜教筛求出来，那么原式就变为了： \sum_{d = 1}^n\mu(d)f(\lfloor\frac{n}{d}\rfloor)我们发现可以整除分块，两个莫比乌斯函数也可以用杜教筛来求解，总的复杂度为O(\sqrt(n) + n^{\frac{2}{3}})代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef double db;typedef pair&lt;int, int&gt; pii;typedef vector&lt;int&gt; vi;typedef vector&lt;ll&gt; vl;typedef vector&lt;pii&gt; vp;const int inf = 1e9;const ll INF = 1e18;#define fi first#define se second#define pb push_back#define eb emplace_back#define mem(a) memset(a, 0, sizeof(a))#define PA puts("pass")#define lowbit(x) (x &amp; -x)const int maxn = 5e6 + 5;ll n;unordered_map&lt;ll, int&gt; ansphi, ansmu;int phi[maxn];vi prime;bool vis[maxn];int mu[maxn];const int mod = 998244353;void add(int &amp;x, int y)&#123; x += y; if(x &gt;= mod) x -= mod;&#125;void sub(int &amp;x, int y)&#123; x -= y; if(x &lt; 0) x += mod;&#125;void init()&#123; mu[1] = phi[1] = 1; for(int i = 2; i &lt; maxn; i++)&#123; if(!vis[i]) prime.eb(i), phi[i] = i - 1, mu[i] = -1; for (int j = 0; j &lt; prime.size() &amp;&amp; i * prime[j] &lt; maxn; ++j) &#123; vis[i * prime[j]] = 1; if(i % prime[j] == 0)&#123; phi[i * prime[j]] = phi[i] * prime[j]; break; &#125; phi[i * prime[j]] = phi[i] * phi[prime[j]]; mu[i * prime[j]] = -mu[i]; &#125; &#125; for (int i = 1; i &lt; maxn; ++i) &#123; add(phi[i], phi[i - 1]); &#125; for(int i = 1; i &lt; maxn; i++)&#123; mu[i] += mu[i - 1]; if(mu[i] &gt;= mod) mu[i] -= mod; if(mu[i] &lt; 0) mu[i] += mod; &#125;&#125;int getmu(ll x)&#123; if(x &lt; maxn) return mu[x]; if(ansmu[x]) return ansmu[x]; int ret = 1; for(ll l = 2, r; l &lt;= x; l = r + 1)&#123; r = x / (x / l); sub(ret, (r - l + 1) % mod * getmu(x / l) % mod); &#125; return ansmu[x] = ret;&#125;int getphi(ll x)&#123; if(x &lt; maxn) return phi[x]; if(ansphi[x]) return ansphi[x]; int ret = 0; for(ll l = 2, r; l &lt;= x; l = r + 1)&#123; r = x / (x / l); sub(ret, (r - l + 1) % mod * getphi(x / l) % mod); &#125; add(ret, 1ll * (x + 1) % mod * x % mod * (mod + 1 &gt;&gt; 1) % mod); return ansphi[x] = ret;&#125;int main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); init(); cin &gt;&gt; n; int res = 0; for(ll l = 1, r; l &lt;= n; l = r + 1)&#123; r = n / (n / l); int tmp = getphi(n / l); add(tmp, tmp); sub(tmp, 1); add(res, 1ll * (getmu(r) - getmu(l - 1) + mod) % mod * tmp % mod); &#125; cout &lt;&lt; res &lt;&lt; '\n'; return 0;&#125;]]></content>
      <categories>
        <category>杜教筛</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[luogu-P4213(杜教筛)]]></title>
    <url>%2F2019%2F08%2F02%2Fluogu-P4213-%E6%9D%9C%E6%95%99%E7%AD%9B%2F</url>
    <content type="text"><![CDATA[链接：https://www.luogu.org/problem/P4213思路： 狄利克雷卷积两个积性函数的狄利克雷卷积为(f*g)(i) = \sum_{d|n}f(d)\cdot g(\frac{d}{n})给出几个常见的狄利克雷卷积：1、\mu\ * I = \epsilon2、\phi\ * I = id(n)（一个数的因子的欧拉函数和等于这个数本身，可以用归纳法证明）3、id\ * \mu = \phi(n) 杜教筛概念杜教筛用来解决一系列积性函数的前缀和问题，例如本题中的$\sum_{i = 1}^n\phi(i)$以及$\sum_{i = 1}^n\mu(i)$，考虑n比较小的时候我们可以线性筛解决。但n例如到$10^{10}$的时候，线性筛就没法解决了，这个时候就需要上杜教筛了。考虑$S(n) = \sum_{i = 1}^nf(i)$我们两边分别用一个g走一个狄利克雷卷积:$\sum_{i = 1}^n f * g = \sum_{i = 1}^n\sum_{d|n}f(d)\cdot g(\frac{n}{d})$ = $\sum_{d = 1}^ng(d)\sum_{i = 1}^{\lfloor\frac{n}{d}\rfloor}f(i)$ = $\sum_{d = 1}^ng(d)S(\lfloor\frac{n}{d}\rfloor)$考虑把第一项提出去，得到如下： g(1)S(n) = \sum_{i = 1}^n(f * g)(i) - \sum_{i = 2}^ng(i)S(\lfloor\frac{n}{i}\rfloor)如果f和g的狄利克雷卷积很好算，g的值也很好算，那么这个问题就可以递归记忆化搜索，可以证明复杂度为$O(n ^ {\frac{3}{4}})$。如果我们预处理一些项，再记忆化搜索，可以证明当预处理为$O(n ^ {\frac{2}{3}})$的时候，复杂度为$O(n ^ {\frac{2}{3}})$。对于本题，我们发现对于$\mu$函数和$\phi$函数，我们g都选择$I$函数，都变得非常好算，问题就解决了。注意能不开long long的地方就不开long long，还要注意一般n都是10次方级别，所以小心爆long long注意分块的时候r初始化。。。。代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef double db;typedef pair&lt;int, int&gt; pii;typedef vector&lt;int&gt; vi;typedef vector&lt;ll&gt; vl;typedef vector&lt;pii&gt; vp;const int inf = 1e9;const ll INF = 1e18;#define fi first#define se second#define pb push_back#define eb emplace_back#define mem(a) memset(a, 0, sizeof(a))#define PA puts("pass")#define lowbit(x) (x &amp; -x)const int maxn = 3e6 + 233;vi prime;bool vis[maxn];ll mu[maxn], phi[maxn];ll n;struct HASH &#123; static const int mod = 1635947; int hs[mod], head[mod], nxt[mod], top; ll id[mod]; void init()&#123; memset(head, -1, sizeof(head)); top = 1; &#125;; void insert(int x, ll y) &#123; int k = x % mod; hs[top] = x, id[top] = y, nxt[top] = head[k], head[k] = top++; &#125; ll find(int x) &#123; int k = x % mod; for (int i = head[k]; i != -1; i = nxt[i]) if (hs[i] == x) return id[i]; return -1; &#125;&#125;dpmu, dpphi;void init()&#123; mu[1] = phi[1] = 1; for(int i = 2; i &lt; maxn; i++)&#123; if(!vis[i]) prime.eb(i), mu[i] = -1, phi[i] = i - 1; for (int j = 0; j &lt; prime.size() &amp;&amp; i * prime[j] &lt; maxn; ++j) &#123; vis[i * prime[j]] = 1; if(i % prime[j] == 0) &#123; phi[i * prime[j]] = phi[i] * prime[j]; break; &#125; mu[i * prime[j]] = -mu[i]; phi[i * prime[j]] = phi[i] * phi[prime[j]]; &#125; &#125; for (int i = 1; i &lt; maxn; ++i) &#123; mu[i] += mu[i - 1], phi[i] += phi[i - 1]; &#125;&#125;ll getmu(int x)&#123; if(x &lt; maxn) return mu[x]; ll t = dpmu.find(x); if(t != -1) return t; ll ret = 1; for(int l = 2, r = 2; l &lt;= x &amp;&amp; r &lt; 2147483647; l = r + 1)&#123; r = x / (x / l); ret -= (r - l + 1) * getmu(x / l); &#125; dpmu.insert(x, ret); return ret;&#125;ll getphi(int x)&#123; if(x &lt; maxn) return phi[x]; ll t = dpphi.find(x); if(t != -1) return t; ll ret = 0; for(int l = 2, r = 2; l &lt;= x &amp; r &lt; 2147483647; l = r + 1)&#123; r = x / (x / l); ret -= (r - l + 1) * getphi(x / l); &#125; dpphi.insert(x, 1ull * x * ((ll)x + 1) / 2 + ret); return 1ull * x * ((ll)x + 1) / 2 + ret;&#125;int T;int main()&#123; //freopen("in.txt", "r", stdin); ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); init(); cin &gt;&gt; T; while(T--) &#123; dpmu.init(); dpphi.init(); cin &gt;&gt; n; cout &lt;&lt; getphi(n) &lt;&lt; ' ' &lt;&lt; getmu(n) &lt;&lt; '\n'; &#125; return 0;&#125;]]></content>
      <categories>
        <category>杜教筛</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2019牛客暑期多校训练营(第五场)-E(independent set 1)]]></title>
    <url>%2F2019%2F08%2F02%2F2019%E7%89%9B%E5%AE%A2%E6%9A%91%E6%9C%9F%E5%A4%9A%E6%A0%A1%E8%AE%AD%E7%BB%83%E8%90%A5-%E7%AC%AC%E4%BA%94%E5%9C%BA-E-independent-set-1%2F</url>
    <content type="text"><![CDATA[链接：https://ac.nowcoder.com/acm/contest/885/E思路：开始觉得不太可做啊，结果是没看n的范围。。。这范围明显可以状压dp，考虑dp[i]表示状态为i的最大独立集是多少。我们考虑枚举到一个i，他一定是由一个子状态转移过来的，我们不妨枚举最低位的点，那么转移过来的状态有两种：选它或者不选它，不选它的话我们就找到去掉它的状态，这个肯定已经在之前处理过了。如果选它我们就找到不包含跟它有边的点的最大的状态，转移过来即可。最后取二者最大值就是当前状态的答案，最后把所有状态加起来就是最终答案了。注意本题卡空间，一个状态的答案不会超过n，所以我们开个char就可以卡过去了。代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef double db;typedef pair&lt;int, int&gt; pii;typedef vector&lt;int&gt; vi;typedef vector&lt;ll&gt; vl;typedef vector&lt;pii&gt; vp;const int inf = 1e9;const ll INF = 1e18;typedef unsigned char uc;#define fi first#define se second#define pb push_back#define eb emplace_back#define mem(a) memset(a, 0, sizeof(a))#define PA puts("pass")#define lowbit(x) (x &amp; -x)uc dp[1 &lt;&lt; 26];int mp[30];int n, m;int get(int x)&#123; int tmp = -1; while(x)&#123; tmp++; x &gt;&gt;= 1; &#125; return tmp;&#125;int main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; n; ++i) &#123; mp[i] |= 1 &lt;&lt; i; &#125; for (int i = 1; i &lt;= m; ++i) &#123; int u, v; cin &gt;&gt; u &gt;&gt; v; mp[u] |= 1 &lt;&lt; v; mp[v] |= 1 &lt;&lt; u; &#125; int res = 0; for (int i = 1; i &lt; (1 &lt;&lt; n); ++i) &#123; dp[i] = max(dp[i ^ lowbit(i)], uc(dp[i &amp; (~mp[get(lowbit(i))])] + 1)); res += dp[i]; &#125; cout &lt;&lt; res &lt;&lt; '\n'; return 0;&#125;]]></content>
      <categories>
        <category>基础dp</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2019牛客暑期多校训练营(第五场)-C(generator 2)]]></title>
    <url>%2F2019%2F08%2F02%2F2019%E7%89%9B%E5%AE%A2%E6%9A%91%E6%9C%9F%E5%A4%9A%E6%A0%A1%E8%AE%AD%E7%BB%83%E8%90%A5-%E7%AC%AC%E4%BA%94%E5%9C%BA-C-generator-2%2F</url>
    <content type="text"><![CDATA[链接：https://ac.nowcoder.com/acm/contest/885/C思路：感觉是一个复习场啊，那就再来写写bsgs的东西吧，以前就只过了一个模板。 bsgs概念bsgs是解决形如$a^x \equiv b (mod c)，求一个最小的x$的问题，通过鸽巢原理我们可以知道，当a，p互质的时候，答案一定在p以内 bsgs算法我们不可能每次都枚举x，试想一下如果生活中我们从一堆东西中找我们需要的东西，我们怎么找？一个比较好的方法是把东西先分成几等分，每一份的数量最好可以让我们一眼就找到，这样你一眼搜索的效率就比一件一件高太多了。 bsgs也是这个思想，我们先算出一部分的值作为底，假设我们算出的底为0-m，剩下如果存在一个数y在0-p内满足上式，他一定可以写成 a^{i*m - j} \equiv b \ (mod\ c)其中m就是我们的底，j是一个0 - (m - 1)内的数，我们就是枚举i，然后对于这些基底我们全都放到一个hash表内，这样每次查询是否出现过就可以做到O(1)了，注意对于同模，我们取较大的那个下标，因为后面求答案是减，所以减去最大的就是最小的答案。考虑复杂度，假设基底大小为m，p的大小为n，那么总复杂度就是$O(m + \frac{n}{m})$，如果是一次处理的话，我们由均值不等式得到，基底大小取$\sqrt(n)$的时候复杂度最小。 回到这个题，我们先来推一推公式：已知$x_i = ax_{i - 1} + b$考虑构造我们可以得到：$x_i + t = a(x_{i - 1} + t)$解得$t = \frac{b}{a - 1}$，其中$a \neq 1 并且 a \neq 0$得到通项公式：$x_n = a^n(x_0 + t) - t$将t, v带入并化简：$a^n \equiv((a - 1)v + b) * ((a - 1)x_0 + b)^{-1}$就变成了一个bsgs的问题。但很容易就直接上了，然后T掉。观察这个题，只有v是询问中变化的。这时候就不要死板的觉得bsgs的底一定要选$\sqrt(p)$了，我们来算一算。假设基底选的大小为m考虑bs部分的复杂度为$O(m)$，gs部分的复杂度为$O(\frac{pq}{m})$，这样总复杂度为$O(m + \frac{pq}{m})$，这样根据均值不等式可以看出m选$\sqrt(pq)$的时候最好，其实本题直接选$\frac{p}{1000}$作为基底就好了。当然本题还要特判一下a等于0和1的情况，讨论一下就可以得出答案，在这里不再赘述了。建议手写hash表哦，发现unorder_map比手写还是慢个5-6倍。代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef double db;typedef pair&lt;int, int&gt; pii;typedef vector&lt;int&gt; vi;typedef vector&lt;ll&gt; vl;typedef vector&lt;pii&gt; vp;const int inf = 1e9;const ll INF = 1e18;#define fi first#define se second#define pb push_back#define eb emplace_back#define mem(a) memset(a, 0, sizeof(a))#define PA puts("pass")#define lowbit(x) (x &amp; -x)ll pow_mod(ll q, ll w, ll mod)&#123; ll ret = 1; while(w)&#123; if(w &amp; 1) ret = ret * q % mod; q = q * q % mod; w &gt;&gt;= 1; &#125; return ret;&#125;struct HASH &#123; static const int mod = 12000005; int hs[mod], head[mod], nxt[mod], id[mod], top; void init()&#123; memset(head, -1, sizeof(head)); top = 1; &#125;; void insert(ll x, int y) &#123; int k = x % mod; hs[top] = x, id[top] = y, nxt[top] = head[k], head[k] = top++; &#125; int find(int x) &#123; int k = x % mod; for (int i = head[k]; i != -1; i = nxt[i]) if (hs[i] == x) return id[i]; return -1; &#125;&#125;mp;ll n;int x0, a, b, p, q, t, v;int bsgs(ll a, ll b, ll c)&#123; // a ^ x = b (mod c) if(b == 1) return 0; if(a == 0 &amp;&amp; b != 0) return -1; int tmp; int y = tmp = pow_mod(a, t, c); int inv = pow_mod(b, p - 2, p); for(int i = 1; i &lt;= 1000; i++)&#123; int p = mp.find(1ll * inv * tmp % c); if(p != -1) return t * i - p; tmp = (ll)tmp * y % c; &#125; return -1;&#125;int T;int main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); cin &gt;&gt; T; while(T--) &#123; mp.init(); cin &gt;&gt; n &gt;&gt; x0 &gt;&gt; a &gt;&gt; b &gt;&gt; p; t = p / 1000 + 1; ll tmp = 1; for (int i = 0; i &lt; t; ++i) &#123; mp.insert(tmp, i); tmp = tmp * a % p; &#125; cin &gt;&gt; q; while (q--) &#123; cin &gt;&gt; v; if(a == 0)&#123; if(v == x0) cout &lt;&lt; "0\n"; else if(v == b) cout &lt;&lt; "1\n"; else cout &lt;&lt; "-1\n"; continue; &#125; if(a == 1)&#123; if(!b) cout &lt;&lt; "-1\n"; else&#123; ll t = ((v - x0) * pow_mod(b, p - 2, p) % p + p) % p; if(t &gt;= n) t = -1; cout &lt;&lt; t &lt;&lt; '\n'; &#125; continue; &#125; int res = bsgs(a, (1ll * (a - 1) * v + b) % p * pow_mod((1ll * x0 * (a - 1) + b) % p, p - 2, p) % p, p); if(res &gt;= n) res = -1; cout &lt;&lt; res &lt;&lt; '\n'; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>bsgs</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2019牛客暑期多校训练营(第五场)-F(maximum clique 1)]]></title>
    <url>%2F2019%2F08%2F01%2F2019%E7%89%9B%E5%AE%A2%E6%9A%91%E6%9C%9F%E5%A4%9A%E6%A0%A1%E8%AE%AD%E7%BB%83%E8%90%A5-%E7%AC%AC%E4%BA%94%E5%9C%BA-F-maximum-clique-1%2F</url>
    <content type="text"><![CDATA[链接：https://ac.nowcoder.com/acm/contest/885/F思路：怎么就没想到是二分图呢，怎么就没想到是二分图呢，怎么就没想到是二分图呢？借着这个机会来复习一下二分图最大匹配，最小点覆盖和最大独立集。 概念1、二分图最大匹配：指二分图最大的匹配对数，每个点只能匹配最多一次。2、二分图最小点覆盖：求一个数目最小的点集，使得每一条边连的两点都至少有一个点在点集内。3、二分图的最大独立集：求一个数目最多的点集，使得任意两个点之间都没有边相连。 定理（不加证明）1、最大匹配数 = 最小点覆盖数2、最大独立集数 = 点数 - 最小点覆盖数 = 点数 - 最大匹配数 求解可以用匈牙利或者网络流算法，跑出最大匹配数。如果需要求最小点覆盖方案，或者最大独立集方案，采取如下方式：我们从右边没有匹配的点开始出发，沿着匹配边 - 非匹配边 - 匹配点一直走，直到走不动为止，把路上的点都标记，这样左边集合中标记的点和右边集合中没有标记的点就构成了一个最小点覆盖集。考虑对于左边集合中标记的点和右边集合没标记的点，都是匹配点，这个点集就可以覆盖所有的边。为什么？考虑如果有一条边没有覆盖，那么它必然是左边没标记而右边有标记，说明这两个点都没匹配，这必然不可能，说明这不是最大匹配，出现矛盾！所以所有边都在里面了。除去最小点覆盖的集合外的点，就可以构成最大独立集。 回到本题，考虑想问题的反面，即从那些不能共存的数对中，选一个最大集合，使得他们能共存，这不就是独立集问题吗，主要是要看出这是一个二分图。首先我们得想办法把点集分到两边去，可以按二进制中1的个数来分，为奇的在一边，为偶的在另一边。因为奇和奇之间，一定不会有边，然后跑网络流，按照上述方法标记后，取左边没标记的点和右边有标记的点即可构成最大独立集。代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef double db;typedef pair&lt;int, int&gt; pii;typedef vector&lt;int&gt; vi;typedef vector&lt;ll&gt; vl;typedef vector&lt;pii&gt; vp;const int inf = 1e9;const ll INF = 1e18;#define fi first#define se second#define pb push_back#define eb emplace_back#define mem(a) memset(a, 0, sizeof(a))#define PA puts("pass")#define lowbit(x) (x &amp; -x)int n, m;const int maxn = 5005;struct edge &#123; int from, to, cap, flow;&#125;;int s,t,tot;vector&lt;edge&gt; edges;vector&lt;int&gt; G[maxn];bool vis[maxn];int d[maxn];int cur[maxn];int color[maxn];int a[maxn];void init() &#123; edges.clear(); for (int i = 0; i &lt;= t; i++)G[i].clear();&#125;void addedge(int from,int to,int cap) &#123; edges.push_back(edge&#123;from, to, cap, 0&#125;); edges.push_back(edge&#123;to, from, 0, 0&#125;); tot = edges.size(); G[from].push_back(tot - 2); G[to].push_back(tot - 1);&#125;bool bfs() &#123; memset(vis, 0, sizeof(vis)); queue&lt;int&gt; q; q.push(s); d[s] = 0; vis[s] = 1; while (!q.empty()) &#123; int x = q.front(); q.pop(); for (int i = 0; i &lt; G[x].size(); i++) &#123; edge &amp;e = edges[G[x][i]]; if (!vis[e.to] &amp;&amp; e.cap &gt; e.flow) &#123; vis[e.to] = 1; d[e.to] = d[x] + 1; q.push(e.to); &#125; &#125; &#125; return vis[t];&#125;int dfs(int x,int a) &#123; if (x == t || a == 0)return a; int flow = 0, f; for (int &amp;i = cur[x]; i &lt; G[x].size(); i++) &#123; edge &amp;e = edges[G[x][i]]; if (d[x] + 1 == d[e.to] &amp;&amp; (f = dfs(e.to, min(a, e.cap - e.flow))) &gt; 0) &#123; e.flow += f; edges[G[x][i] ^ 1].flow -= f; flow += f; a -= f; if (a == 0)break; &#125; &#125; return flow;&#125;int maxflow() &#123; int flow = 0; while (bfs()) &#123; memset(cur, 0, sizeof(cur)); flow += dfs(s, inf); &#125; return flow;&#125;int ok[maxn];void dfs1(int u)&#123; ok[u] = 1; for(int i = 0; i &lt; G[u].size(); i++)&#123; edge &amp;e = edges[G[u][i]]; if(e.cap &gt; e.flow &amp;&amp; !ok[e.to]) dfs1(e.to); &#125;&#125;int main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); cin &gt;&gt; n; s = 0, t = n + 1; init(); for (int i = 1; i &lt;= n; ++i) &#123; cin &gt;&gt; a[i]; int cnt = __builtin_popcount(a[i]); if(cnt &amp; 1) addedge(s, i, 1), color[i] = 0; else addedge(i, t, 1), color[i] = 1; &#125; for (int i = 1; i &lt;= n; ++i) &#123; for (int j = i + 1; j &lt;= n; ++j) &#123; int t = a[i] ^ a[j]; if(t == lowbit(t))&#123; if(!color[i])addedge(i, j, 1); else addedge(j, i, 1); &#125; &#125; &#125; int res = n - maxflow(); dfs1(s); vector&lt;int&gt; ans; for (int i = 1; i &lt;= n; ++i) &#123; if ((color[i] ^ ok[i])) ans.eb(a[i]); &#125; cout &lt;&lt; res &lt;&lt; '\n'; for(int i = 0;i &lt; ans.size(); i++)&#123; cout &lt;&lt; ans[i] &lt;&lt; (i == ans.size() - 1 ? '\n' : ' '); &#125; return 0;&#125;]]></content>
      <categories>
        <category>网络流</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[luogu-P2597(灾难)]]></title>
    <url>%2F2019%2F07%2F31%2Fluogu-P2597-%E7%81%BE%E9%9A%BE%2F</url>
    <content type="text"><![CDATA[链接：https://www.luogu.org/problem/P2597思路：这个题其实不太容易能看出来是一个支配树的题，看出来就发现是一个裸题。首先我们发现有一些点是没有入度的，对应实际意义就是它们的生存不需要靠其他生物，那我们考虑加一个超级点，由超级点向这些点连边，代表其实这些点生存是靠超级点。那么如果一个生物能够活下去，从超级点到它必须有一条路径。现在问的是去掉某个点后，其他有多少点不能存活，也就是没有路径，这不就变为了支配树裸题了吗？只需要求它子树大小就行了，子树上的点都必然要依靠这个点。代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef double db;typedef pair&lt;int, int&gt; pii;typedef vector&lt;int&gt; vi;typedef vector&lt;ll&gt; vl;typedef vector&lt;pii&gt; vp;const int inf = 1e9;const ll INF = 1e18;#define fi first#define se second#define pb push_back#define eb emplace_back#define mem(a) memset(a, 0, sizeof(a))#define PA puts("pass")#define lowbit(x) (x &amp; -x)const int maxn = 1e5;vi g[maxn], rg[maxn], G[maxn];int n, deg[maxn], f[maxn][20], d[maxn], ans[maxn];int lca(int u, int v)&#123; if(d[u] &gt; d[v]) swap(u, v); for(int i = 19; i &gt;= 0; i--)&#123; if(d[f[v][i]] &gt;= d[u]) v = f[v][i]; &#125; if(v == u) return u; for(int i = 19; i &gt;= 0; i--)&#123; if(f[u][i] != f[v][i]) u = f[u][i], v = f[v][i]; &#125; return f[u][0];&#125;void getans(int u)&#123; ans[u] = 1; for(auto &amp;v : G[u])&#123; getans(v); ans[u] += ans[v]; &#125;&#125;int main() &#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); cin &gt;&gt; n; for (int i = 1; i &lt;= n; ++i) &#123; int x; while (cin &gt;&gt; x &amp;&amp; x) &#123; g[x].eb(i); rg[i].eb(x); deg[i]++; &#125; &#125; queue&lt;int&gt; q; for (int i = 1; i &lt;= n; ++i) &#123; if (!deg[i]) rg[i].eb(0), q.push(i); &#125; while (!q.empty()) &#123; int u = q.front(); q.pop(); int y = rg[u][0]; for (int i = 1; i &lt; rg[u].size(); i++) &#123; y = lca(y, rg[u][i]); &#125; f[u][0] = y; d[u] = d[y] + 1; G[y].eb(u); for (int i = 1; i &lt; 20; ++i) &#123; f[u][i] = f[f[u][i - 1]][i - 1]; &#125; for (int i = 0; i &lt; g[u].size(); ++i) &#123; int v = g[u][i]; if (!--deg[v]) q.push(v); &#125; &#125; getans(0); for (int i = 1; i &lt;= n; ++i) &#123; cout &lt;&lt; ans[i] - 1 &lt;&lt; '\n'; &#125; return 0;&#125;]]></content>
      <categories>
        <category>支配树</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[luogu-P5180(支配树)]]></title>
    <url>%2F2019%2F07%2F31%2Fluogu-P5180-%E6%94%AF%E9%85%8D%E6%A0%91%2F</url>
    <content type="text"><![CDATA[链接：https://www.luogu.org/problem/P5180思路：有向图支配树裸题，纯粹放一个板子在这里。。。。。具体内容看上一篇，待补。代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef double db;typedef pair&lt;int, int&gt; pii;typedef vector&lt;int&gt; vi;typedef vector&lt;ll&gt; vl;typedef vector&lt;pii&gt; vp;const int inf = 1e9;const ll INF = 1e18;#define fi first#define se second#define pb push_back#define eb emplace_back#define mem(a) memset(a, 0, sizeof(a))#define PA puts("pass")#define lowbit(x) (x &amp; -x)const int maxn = 2e5 + 5;vi g[maxn], rg[maxn], ng[maxn], G[maxn];int n, m;int dfn[maxn], id[maxn], dfs_clock, fa[maxn], f[maxn];int semi[maxn], idom[maxn], mn[maxn], ans[maxn];int find(int x)&#123; if(x == f[x]) return x; int p = find(f[x]); if(dfn[semi[mn[f[x]]]] &lt; dfn[semi[mn[x]]]) mn[x] = mn[f[x]]; return f[x] = p;&#125;void dfs(int u)&#123; dfn[u] = ++dfs_clock, id[dfs_clock] = u; for(auto &amp;v : g[u])&#123; if(dfn[v]) continue; fa[v] = u; dfs(v); &#125;&#125;void tarjan()&#123; for(int i = dfs_clock; i &gt; 1; i--)&#123; int u = id[i]; for(auto &amp;v : rg[u])&#123; if(!dfn[v]) continue; find(v); if(dfn[semi[mn[v]]] &lt; dfn[semi[u]]) semi[u] = semi[mn[v]]; &#125; ng[semi[u]].eb(u); f[u] = fa[u]; u = fa[u]; for(auto &amp;v : ng[u])&#123; find(v); if(semi[mn[v]] == u) idom[v] = u; else idom[v] = mn[v]; &#125; &#125; for(int i = 2; i &lt;= dfs_clock; i++)&#123; int u = id[i]; if(idom[u] != semi[u]) idom[u] = idom[idom[u]]; &#125;&#125;void getans(int u)&#123; ans[u] = 1; for(auto &amp;v : G[u])&#123; getans(v); ans[u] += ans[v]; &#125;&#125;int main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; ++i) &#123; semi[i] = mn[i] = f[i] = i; &#125; for (int i = 1; i &lt;= m; ++i) &#123; int u, v; cin &gt;&gt; u &gt;&gt; v; g[u].eb(v); rg[v].eb(u); &#125; dfs(1); //起点开始 tarjan(); for(int i = 2; i &lt;= n; i++) G[idom[i]].eb(i); //除了起点外都要建图 getans(1); //起点结束 for(int i = 1; i &lt;= n; i++) cout &lt;&lt; ans[i] &lt;&lt; (i == n ? '\n' : ' '); return 0;&#125;]]></content>
      <categories>
        <category>支配树</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2019 Multi-University Training Contest 3-B(Blow up the city)]]></title>
    <url>%2F2019%2F07%2F31%2F2019-Multi-University-Training-Contest-3-B-Blow-up-the-city%2F</url>
    <content type="text"><![CDATA[链接：http://acm.hdu.edu.cn/showproblem.php?pid=6604思路：先着重来介绍一下支配树的性质与构造方法吧，本文不详细做证明。 支配树概念支配树解决的问题是从一个起点出发，如果想要到达y结点必须要经过x结点，我们说x支配y（x是y的必经点）。我们所要根据一张图构建出一棵支配树，使得支配树的根代表起点。对于任意一个点x，他到根这条链上的点都是要达到他的必经点（都是它的支配点），他是他所有子树的支配点。 支配树的构造树树同时也是支配树，只需要求出以起点为根的有根树就行了。 DAG考虑拓扑排序，我们假设当前处理到拓扑序为x的结点，那么拓扑序为1 - (x - 1)之间的点我们都已经处理完了，我们考虑所有跟他相连的点，都肯定之前已经被处理过了，他们在支配树上的LCA一定在该点到根的链上（如果他们的LCA都没了，他们也就全没了，自然不会有后面的），所以我们把该点的父亲设为其他点在支配树上共同的LCA，一直重复，这样支配树就构造好了。 有向图https://blog.csdn.net/litble/article/details/83019578 留一个链接在这里吧，暂时没看太懂，有时间再来补，顺手留一个板子 其他考虑如果有多个起点我们怎么办？我们可以设置一个超级起点，然后向这多个起点连边，最后以这个超级结点为根建立支配树就行了。 回到本题，本题求的是，给你两个点a, b，问有多少点（包括这两个点在内），使得去掉这个点以及它周围的所有边之后，ab两点中至少有一个点不能到达原图中出度为0的点。考虑对于那些出度为0的点，可以看作是起点，我们建立一个超级起点然后建立支配树，对于两点的答案就是他俩的深度和 - lca的深度，就是中间点的数量。 代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef double db;typedef pair&lt;int, int&gt; pii;typedef vector&lt;int&gt; vi;typedef vector&lt;ll&gt; vl;typedef vector&lt;pii&gt; vp;const int inf = 1e9;const ll INF = 1e18;#define fi first#define se second#define pb push_back#define eb emplace_back#define mem(a) memset(a, 0, sizeof(a))#define PA puts("pass")#define lowbit(x) (x &amp; -x)const int maxn = 1e5 + 233;vi g[maxn], rg[maxn];int f[maxn][20], d[maxn], deg[maxn];int T, n, m;void clear()&#123; for (int i = 0; i &lt;= n; ++i) &#123; g[i].clear(); rg[i].clear(); deg[i] = 0; mem(f[i]); &#125;&#125;int lca(int u, int v)&#123; if(d[u] &gt; d[v]) swap(u, v); for(int i = 19; i &gt;= 0; i--)&#123; if(d[f[v][i]] &gt;= d[u]) v = f[v][i]; &#125; if(u == v) return u; for(int i = 19; i &gt;= 0; i--)&#123; if(f[u][i] != f[v][i]) u = f[u][i], v = f[v][i]; &#125; return f[u][0];&#125;int main()&#123; #ifndef ONLINE_JUDGE freopen("in.txt", "r", stdin); #else #endif ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); cin &gt;&gt; T; while(T--)&#123; cin &gt;&gt; n &gt;&gt; m; clear(); for (int i = 1; i &lt;= m; ++i) &#123; int u, v; cin &gt;&gt; u &gt;&gt; v; g[v].eb(u); rg[u].eb(v); deg[u]++; &#125; queue&lt;int&gt; q; for (int i = 1; i &lt;= n; ++i) &#123; if(!deg[i]) g[0].eb(i), rg[i].eb(0), q.push(i); &#125; while(!q.empty())&#123; int u = q.front(); q.pop(); int y = rg[u][0]; for (int i = 0; i &lt; rg[u].size(); ++i) &#123; y = lca(y, rg[u][i]); &#125; f[u][0] = y; d[u] = d[y] + 1; for (int j = 1; j &lt;= 19; ++j) &#123; f[u][j] = f[f[u][j - 1]][j - 1]; &#125; for (int i = 0; i &lt; g[u].size(); ++i) &#123; int v = g[u][i]; if(!--deg[v]) q.push(v); &#125; &#125; cin &gt;&gt; m; while(m--)&#123; int u, v; cin &gt;&gt; u &gt;&gt; v; int lc = lca(u, v); cout &lt;&lt; d[u] + d[v] - d[lc] &lt;&lt; '\n'; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>支配树</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2019 Multi-University Training Contest 3-H(Game)]]></title>
    <url>%2F2019%2F07%2F31%2F2019-Multi-University-Training-Contest-3-H-Game%2F</url>
    <content type="text"><![CDATA[链接：http://acm.hdu.edu.cn/showproblem.php?pid=6610思路：考虑一个区间如果是bob赢，那么必须这个区间的异或和为0，我们考虑把异或变为前缀和，也就是统计区间每个数出现了多少次，然后统计答案，显然是一个莫队的问题。但是还有交换操作，考虑交换操作，其实本质就是更改了当前那一个点的异或前缀和，直接上待修改的三维莫队就行了。（注意前缀和需要给0号点增设一个0，这样本身就为0的才能统计到），最后用总的选择数 - bob赢的就是alice赢的代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef double db;typedef vector&lt;int&gt; vi;typedef pair&lt;int, int&gt; pii;typedef vector&lt;pii&gt; vp;typedef vector&lt;ll&gt; vl;#define fi first#define se second#define pb push_back#define eb emplace_back#define lowbit(x) (x &amp; -x)#define PA puts("pass")#define mem(a) memset(a, 0, sizeof(a))int sz;const int maxn = 1e6 + 233;struct node&#123; int l, r, id, p1, p2, t; bool operator &lt;(const node &amp;x) const&#123; return p1 ^ x.p1 ? p1 &lt; x.p1 : (p2 ^ x.p2 ? p2 &lt; x.p2 : (p2 &amp; 1 ? t &lt; x.t : t &gt; x.t)); &#125;&#125;q[maxn];int cnt[2 * maxn], a[maxn];int b[maxn];int n, m;int qcnt, tcnt;ll ans[maxn];int sum[maxn];ll res;void add(int pos)&#123; res -= 1ll * (cnt[sum[pos]] - 1) * cnt[sum[pos]] / 2; cnt[sum[pos]]++; res += 1ll * (cnt[sum[pos]] - 1) * cnt[sum[pos]] / 2;&#125;void del(int pos)&#123; res -= 1ll * (cnt[sum[pos]] - 1) * cnt[sum[pos]] / 2; cnt[sum[pos]]--; res += 1ll * (cnt[sum[pos]] - 1) * cnt[sum[pos]] / 2;&#125;void update(int t, int i)&#123; int x = sum[b[t] - 1] ^ a[b[t] + 1]; if(q[i].l &lt;= b[t] &amp;&amp; b[t] &lt;= q[i].r)&#123; res -= 1ll * (cnt[sum[b[t]]] - 1) * cnt[sum[b[t]]] / 2; cnt[sum[b[t]]]--; res += 1ll * (cnt[sum[b[t]]] - 1) * cnt[sum[b[t]]] / 2; res -= 1ll * (cnt[x] - 1) * cnt[x] / 2; cnt[x]++; res += 1ll * (cnt[x] - 1) * cnt[x] / 2; &#125; swap(a[b[t]], a[b[t] + 1]); sum[b[t]] = x;&#125;int main()&#123; //freopen("in.txt", "r", stdin); ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); while(cin &gt;&gt; n &gt;&gt; m)&#123; qcnt = tcnt = 0; mem(cnt); sz = pow(n, 2.0 / 3); for (int i = 1; i &lt;= n; ++i) &#123; cin &gt;&gt; a[i]; sum[i] = sum[i - 1] ^ a[i]; &#125; for (int i = 1; i &lt;= m; ++i) &#123; int t; cin &gt;&gt; t; if(t == 2) &#123; ++tcnt; cin &gt;&gt; b[tcnt]; &#125; else&#123; ++qcnt; cin &gt;&gt; q[qcnt].l &gt;&gt; q[qcnt].r; q[qcnt].l--; q[qcnt].id = qcnt; q[qcnt].t = tcnt, q[qcnt].p1 = q[qcnt].l / sz, q[qcnt].p2 = q[qcnt].r / sz; &#125; &#125; sort(q + 1, q + qcnt + 1); res = 0; int l = 0, r = -1, t = 0; for (int i = 1; i &lt;= qcnt; ++i) &#123; while(l &lt; q[i].l) del(l++); while(l &gt; q[i].l) add(--l); while(r &lt; q[i].r) add(++r); while(r &gt; q[i].r) del(r--); while(t &lt; q[i].t) update(++t, i); while(t &gt; q[i].t) update(t--, i); ans[q[i].id] = 1ll * (q[i].r - q[i].l + 1) * (q[i].r - q[i].l) / 2 - res; &#125; for (int i = 1; i &lt;= qcnt; ++i) &#123; cout &lt;&lt; ans[i] &lt;&lt; '\n'; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>莫队</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2019 Multi-University Training Contest 3-A(Azshara's deep sea)]]></title>
    <url>%2F2019%2F07%2F31%2F2019-Multi-University-Training-Contest-3-A-Azshara-s-deep-sea%2F</url>
    <content type="text"><![CDATA[链接：http://acm.hdu.edu.cn/showproblem.php?pid=6603思路：我们通过求半段求凸包，判断两点是否能连线，把信息预处理出来。后半段就变成了：在凸包上，给出一些可以连线的两点，任意连线的两条线段不能相交，求最多可以连多少条线段。考虑对于一个区间，如果我们把它端点连了，那么它里面的点就不能和外面的点连了，所以我们每次考虑合并最外面的两个端点，这样问题就变成了区间dp了，dp[l][r]表示区间l-r中，最外面l和r有连线的最大线段数，然后枚举一下断点，合并即可。代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef double db;typedef pair&lt;int, int&gt; pii;typedef vector&lt;int&gt; vi;typedef vector&lt;ll&gt; vl;typedef vector&lt;pii&gt; vp;const int inf = 1e9;const ll INF = 1e18;#define fi first#define se second#define pb push_back#define eb emplace_back#define mem(a) memset(a, 0, sizeof(a))#define PA puts("pass")#define lowbit(x) (x &amp; -x)const db eps = 1e-10;const db pi = acos(-1);int dcmp(db x) &#123; return x&lt;-eps?-1:x&gt;eps;&#125;db myacos(db x)&#123; if(x&lt;-1) x = -1; if(x&gt;1) x = 1; return acos(x);&#125;db myasin(db x)&#123; if(x&lt;-1) x = -1; if(x&gt;1) x = 1; return asin(x);&#125;db mysqrt(db x)&#123; return x&lt;0?0:sqrt(x);&#125;typedef struct P &#123; db x, y; P(db x = 0, db y = 0) : x(x), y(y) &#123;&#125; P operator+(P r)&#123;return P(x+r.x,y+r.y);&#125; P operator-(P r)&#123;return P(x-r.x,y-r.y);&#125; P operator*(db r)&#123;return P(x*r,y*r);&#125; P operator/(db r)&#123;return P(x/r,y/r);&#125; bool operator&lt;(const P &amp;r)const&#123;return x&lt;r.x||(x==r.x&amp;&amp;y&lt;r.y);&#125; bool operator==(const P &amp;r)const&#123;return dcmp(x-r.x)==0&amp;&amp;dcmp(y-r.y)==0;&#125; void read()&#123; scanf("%lf %lf", &amp;x, &amp;y); &#125; void print()&#123; printf("%.2f %.2f\n", x, y);&#125;&#125;V;//向量a的极角db Angle(const V&amp; v) &#123; return atan2(v.y, v.x);&#125;//向量点积db Dot(V A, V B) &#123; return A.x*B.x + A.y*B.y; &#125;//向量长度db Length(V A) &#123; return mysqrt(Dot(A, A)); &#125;//向量叉积db Cross(V A, V B) &#123; return A.x*B.y - A.y*B.x; &#125;//点到直线距离db DistanceToLine(P p, P A, P B) &#123; V v1 = B - A, v2 = p - A; return fabs(Cross(v1, v2) / Length(v1)); //不取绝对值，得到的是有向距离&#125;int ConvexHull(P *p, int n, P* ch) &#123; sort(p, p + n); //先比较x坐标，再比较y坐标 int m = 0; for(int i = 0; i &lt; n; i++) &#123; while(m &gt; 1 &amp;&amp; Cross(ch[m-1] - ch[m-2], p[i] - ch[m-2]) &lt;= 0) m--; ch[m++] = p[i]; &#125; int k = m; for(int i = n - 2; i &gt;= 0; i--) &#123; while(m &gt; k &amp;&amp; Cross(ch[m-1] - ch[m-2], p[i] - ch[m-2]) &lt;= 0) m--; ch[m++] = p[i]; &#125; if(n &gt; 1) m--; return m;&#125;const int maxn = 410;int T, n, m, q;P a[maxn], b[maxn], ch[maxn];int dp[maxn][maxn], mp[maxn][maxn];db r;int main()&#123; #ifndef ONLINE_JUDGE freopen("in.txt", "r", stdin); #else #endif ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); cin &gt;&gt; T; while(T--)&#123; cin &gt;&gt; n &gt;&gt; q &gt;&gt; r; mem(dp); mem(mp); for (int i = 0; i &lt; n; ++i) &#123; cin &gt;&gt; a[i].x &gt;&gt; a[i].y; &#125; for (int i = 1; i &lt;= q; ++i) &#123; cin &gt;&gt; b[i].x &gt;&gt; b[i].y; &#125; m = ConvexHull(a, n, ch); for (int i = 0; i &lt; m; ++i) &#123; for(int j = i + 1; j &lt; m; j++)&#123; if((i + 1) % m == j || (j + 1) % m == i) continue; bool f = true; for(int k = 1; k &lt;= q; k++)&#123; if(dcmp(DistanceToLine(b[k], ch[i], ch[j]) - r) &lt;= 0)&#123; f = false; break; &#125; &#125; if(f) mp[i][j] = mp[j][i] = 1; &#125; &#125; for(int len = 1; len &lt; m; len++)&#123; for(int l = 0; l + len &lt; m; l++)&#123; int r = l + len; for(int k = l + 1; k &lt; r; k++)&#123; dp[l][r] = max(dp[l][r], dp[l][k] + dp[k][r] + mp[l][r]); &#125; &#125; &#125; cout &lt;&lt; dp[0][m - 1] &lt;&lt; '\n'; &#125; return 0;&#125;]]></content>
      <categories>
        <category>计算几何</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2019牛客暑期多校训练营(第四场)-B(xor)]]></title>
    <url>%2F2019%2F07%2F30%2F2019%E7%89%9B%E5%AE%A2%E6%9A%91%E6%9C%9F%E5%A4%9A%E6%A0%A1%E8%AE%AD%E7%BB%83%E8%90%A5-%E7%AC%AC%E5%9B%9B%E5%9C%BA-B-xor%2F</url>
    <content type="text"><![CDATA[链接：https://ac.nowcoder.com/acm/contest/884/B思路：四个线性基题，三个叫xor。。。。我也是服了。求并求交求方案统计都已经出过了，求交的具体看这里https://blog.csdn.net/demon_rieman/article/details/88830846。 不太看得懂，就收个板子吧。求交复杂度是两个log的。代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 50002;int n, m;vector&lt;ll&gt; pos[maxn];struct Linebasis&#123; const static int sz = 33; ll p[sz + 2]; //p是上三角矩阵，b是对角矩阵; Linebasis()&#123; init(); &#125; void init()&#123; memset(p, 0, sizeof(p)); &#125; bool insert(ll x)&#123; for(int i = sz; i &gt;= 0; i--)&#123; if((x &gt;&gt; i) &amp; 1)&#123; if(!p[i])&#123; p[i] = x; break; &#125; x ^= p[i]; &#125; &#125; return x &gt; 0; &#125; bool check(ll x)&#123; for(int i = sz; i &gt;= 0; i--)&#123; if((x &gt;&gt; i) &amp; 1)&#123; if(!p[i])&#123; break; &#125; x ^= p[i]; &#125; &#125; return x &gt; 0; &#125; Linebasis operator |(const Linebasis &amp; r) const&#123; Linebasis res = r; for(int i = 0; i &lt;= sz; i++) &#123; if(p[i]) res.insert(p[i]); &#125; return res; &#125; Linebasis operator &amp;(const Linebasis &amp;r)const &#123; Linebasis all = r, c, d; for (int i = 0; i &lt;= sz; ++i) d.p[i] = 1ll &lt;&lt; i; for (int i = sz; i &gt;= 0; --i) &#123; if(p[i])&#123; ll v = p[i], k = 0; bool can = true; for (int j = sz; j &gt;= 0; --j) &#123; if(v &gt;&gt; j &amp; 1)&#123; if(all.p[j])&#123; v ^= all.p[j]; k ^= d.p[j]; &#125; else&#123; can = false; all.p[j] = v; d.p[j] = k; break; &#125; &#125; &#125; if(can)&#123; v = 0; for (int j = sz; j &gt;= 0; --j) &#123; if(k &gt;&gt; j &amp; 1)&#123; v ^= r.p[j]; &#125; &#125; c.insert(v); &#125; &#125; &#125; return c; &#125; ll querymax(ll x = 0)&#123; ll res = x; for(int i = sz; i &gt;= 0; i--)&#123; if((res ^ p[i]) &gt; res) res ^= p[i]; &#125; return res; &#125; ll querymin()&#123; for(int i = 0; i &lt;= sz; i++)&#123; if(p[i]) return p[i]; &#125; return 0; &#125;&#125;sol[maxn &lt;&lt; 2];void pushup(int o)&#123; sol[o] = sol[o &lt;&lt; 1] &amp; sol[o &lt;&lt; 1 | 1];&#125;void build(int o, int l, int r)&#123; if(l == r)&#123; for (int i = 0; i &lt; pos[l].size(); ++i) &#123; sol[o].insert(pos[l][i]); &#125; return; &#125; int mid = l + r &gt;&gt; 1; build(o &lt;&lt; 1, l, mid); build(o &lt;&lt; 1 | 1, mid + 1, r); pushup(o);&#125;bool query(int o, int tl, int tr, int l, int r, ll v)&#123; if(l &gt; tr || r &lt; tl) return true; if(l &lt;= tl &amp;&amp; tr &lt;= r) return !sol[o].check(v); int mid = tl + tr &gt;&gt; 1; return query(o &lt;&lt; 1, tl, mid, l, r, v) &amp;&amp; query(o &lt;&lt; 1 | 1, mid + 1, tr, l, r, v);&#125;int main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; ++i) &#123; int x; ll v; cin &gt;&gt; x; while(x--)&#123; cin &gt;&gt; v; pos[i].push_back(v); &#125; &#125; build(1, 1, n); while(m--)&#123; int l, r; ll v; cin &gt;&gt; l &gt;&gt; r &gt;&gt; v; if(query(1, 1, n, l, r, v)) cout &lt;&lt; "YES\n"; else cout &lt;&lt; "NO\n"; &#125; return 0;&#125;]]></content>
      <categories>
        <category>线性基</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2019牛客暑期多校训练营(第四场)-I(string)]]></title>
    <url>%2F2019%2F07%2F30%2F2019%E7%89%9B%E5%AE%A2%E6%9A%91%E6%9C%9F%E5%A4%9A%E6%A0%A1%E8%AE%AD%E7%BB%83%E8%90%A5-%E7%AC%AC%E5%9B%9B%E5%9C%BA-I-string%2F</url>
    <content type="text"><![CDATA[链接：https://ac.nowcoder.com/acm/contest/884/I思路：考虑一个串和它的反串只能算一次，可以对原串和反串建议广义后缀自动机，这样一个串和反串就会被算到2次，但还有例外，就是回文串。所以我们再用PAM求一下本质不同回文串的个数，加起来除以2就是答案。代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139#include&lt;bits/stdc++.h&gt;#define sigma_size 28using namespace std;const int maxn = 4e5 + 5;typedef long long ll;char s[maxn];int n;struct SAM &#123; int len[maxn * 2]; //最长子串的长度(该节点字串数量=len[x]-len[f[x]]) int f[maxn * 2]; //后缀链接(最短串前部减少一个字符所到达的状态) int cnt[maxn * 2]; //被后缀连接的数 int ch[maxn * 2][sigma_size]; //状态转移(尾部加一个字符的下一个状态)(图) int idx; //节点编号 int last; //最后节点 ll epos[maxn * 2]; // enpos数（该状态子串出现数量） void init() &#123; //初始化 last = idx = 1; //1表示root起始点 空集 f[1] = len[1] = 0; memset(ch[1], 0, sizeof(ch[1])); &#125;//SAM建图 void add(int c) &#123; //插入字符，为字符ascll码值 int x = ++idx; //创建一个新节点x; len[x] = len[last] + 1; // 长度等于最后一个节点+1 epos[x] = 1; //接受节点子串除后缀连接还需加一 int p; //第一个有C转移的节点; for (p = last; p &amp;&amp; !ch[p][c]; p = f[p])ch[p][c] = x;//沿着后缀连接 将所有没有字符c转移的节点直接指向新节点 if (!p)f[x] = 1, cnt[1]++; //全部都没有c的转移 直接将新节点后缀连接到起点 else &#123; int q = ch[p][c]; //p通过c转移到的节点 if (len[p] + 1 == len[q]) //pq是连续的 f[x] = q, cnt[q]++; //将新节点后缀连接指向q即可,q节点的被后缀连接数+1 else &#123; int nq = ++idx; //不连续 需要复制一份q节点 len[nq] = len[p] + 1; //令nq与p连续 f[nq] = f[q]; //因后面link[q]改变此处不加cnt memcpy(ch[nq], ch[q], sizeof(ch[q])); //复制q的信息给nq for (; p &amp;&amp; ch[p][c] == q; p = f[p]) ch[p][c] = nq; //沿着后缀连接 将所有通过c转移为q的改为nq f[q] = f[x] = nq; //将x和q后缀连接改为nq cnt[nq] += 2; // nq增加两个后缀连接 &#125; &#125; last = x; //更新最后处理的节点 &#125; void getpos() &#123; //求npos数，即该节点字串出现次数 queue&lt;int&gt; q; for (int i = 1; i &lt;= idx; i++) if (!cnt[i])q.push(i); //将所有没被后缀连接指向的节点入队 while (!q.empty()) &#123; int x = q.front(); q.pop(); epos[f[x]] += epos[x]; //子串数量等于所有后缀连接指向该节点的子串数量和+是否为接受节点 if (--cnt[f[x]] == 0)q.push(f[x]); //当所有后缀连接指向该节点的处理完毕后再入队 &#125; &#125;&#125;sam;const int maxnode = maxn;struct PAM&#123; int ch[maxnode][sigma_size]; int f[maxnode]; int cnt[maxnode]; // 节点i表示的回文串在S中出现的次数（建树时求出的不是完全的，count()加上子节点以后才是正确的） int num[maxnode]; //以节点i回文串的末尾字符结尾的但不包含本条路径上的回文串的数目。(也就是fail指针路径的深度) int len[maxnode]; //节点i的回文串的长度 int s[maxnode]; //表示第i次添加的字符 int last; //指向最新添加的回文结点 int n; int p; //节点个数（节点从2开始） int newnode(int w) &#123; for(int i = 0; i &lt; sigma_size; i++)ch[p][i] = 0; cnt[p] = 0; num[p] = 0; len[p] = w; return p++; &#125; void init() &#123; p = 0; newnode(0); newnode(-1); last = 0; n = 0; s[n] = -1; f[0] = 1; &#125; int getfail(int x) &#123; while (s[n - len[x] - 1] != s[n])x = f[x]; return x; &#125; void add(int c) &#123; s[++n] = c; int cur = getfail(last); if (!ch[cur][c]) &#123; int now = newnode(len[cur] + 2); f[now] = ch[getfail(f[cur])][c]; ch[cur][c] = now; num[now] = num[f[now]] + 1; &#125; last = ch[cur][c]; cnt[last]++; &#125; void count()&#123; for(int i = p-1; i &gt;= 0; i--) cnt[f[i]] += cnt[i]; &#125;&#125;pam;int main() &#123; sam.init(); scanf("%s", s + 1); n = strlen(s + 1); for (int i = 1; i &lt;= n; ++i) &#123; sam.add(s[i] - 'a'); &#125; sam.last = 1; pam.init(); for (int i = n; i; --i) &#123; sam.add(s[i] - 'a'); pam.add(s[i] - 'a'); &#125; ll res = 0; for (int i = 1; i &lt;= sam.idx; ++i) &#123; res += sam.len[i] - sam.len[sam.f[i]]; &#125; res += pam.p - 1; printf("%lld\n", res / 2); return 0;&#125;]]></content>
      <categories>
        <category>后缀自动机</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2019 Multi-University Training Contest 2-L(Longest Subarray)]]></title>
    <url>%2F2019%2F07%2F30%2F2019-Multi-University-Training-Contest-2-L-Longest-Subarray%2F</url>
    <content type="text"><![CDATA[链接：http://acm.hdu.edu.cn/showproblem.php?pid=6602思路：场上感觉已经非常接近正解了，可惜当时突然脑子短路没想到怎么找一个数一边第k次出现的位置。。。。事实上数才1e5，直接暴力装vector里就行了。。。我们考虑从左往右扫，当一个端点固定时（假设是右端点），左端点上如果所有数都满足可行条件，那么这个左端点就是合法的，我们考虑出现一个新的左端点，其他C - 1个数如果后面以这个端点作为左端点肯定是可行的（因为暂时还没出现），那么当前这个数出现，我们考虑会使左边哪些端点产生变化。首先是他到上一个出现的位置之间这段区间，本来它没出现前，这些区间作为左端点对这个数来说都是合法的，现在变的不合法了。还有就是如果存在，原来的第k - 1到k这个区间，因为新加入了一个数，它变为了k - k + 1是合法的了，所以我们需要线段树来区间更新。对于一个右端点，我们需要它最左边等于C的左端点位置，区间维护最大值即可。代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef double db;typedef pair&lt;int, int&gt; pii;typedef vector&lt;int&gt; vi;#define fi first#define se second#define pb push_back#define eb emplace_back#define mem(a) memset(a, 0, sizeof(a))#define PA puts("pass")const int maxn = 1e5 + 5;int mx[maxn &lt;&lt; 2], tag[maxn &lt;&lt; 2];int n, c, k;int a[maxn];vi pos[maxn];int cur[maxn];void pushup(int o)&#123; mx[o] = max(mx[o &lt;&lt; 1], mx[o &lt;&lt; 1 | 1]);&#125;void pushdown(int o)&#123; if(tag[o])&#123; mx[o &lt;&lt; 1] += tag[o]; mx[o &lt;&lt; 1 | 1] += tag[o]; tag[o &lt;&lt; 1] += tag[o]; tag[o &lt;&lt; 1 | 1] += tag[o]; tag[o] = 0; &#125;&#125;void build(int o, int l, int r)&#123; tag[o] = mx[o] = 0; if(l == r) return; int mid = l + r &gt;&gt; 1; build(o &lt;&lt; 1, l, mid); build(o &lt;&lt; 1 | 1, mid + 1, r);&#125;void update(int o, int tl, int tr, int l, int r, int v)&#123; if(l &gt; tr || r &lt; tl) return; if(l &lt;= tl &amp;&amp; tr &lt;= r)&#123; mx[o] += v; tag[o] += v; return ; &#125; pushdown(o); int mid = tl + tr &gt;&gt; 1; update(o &lt;&lt; 1, tl, mid, l, r, v); update(o &lt;&lt; 1 | 1, mid + 1, tr, l, r, v); pushup(o);&#125;int query(int o, int tl, int tr, int l, int r)&#123; if(l &gt; tr || r &lt; tl) return -1; if(tl == tr &amp;&amp; tl &gt;= l &amp;&amp; tr &lt;= r) return tl; pushdown(o); int mid = tl + tr &gt;&gt; 1; if(mx[o &lt;&lt; 1] == c) return query(o &lt;&lt; 1, tl, mid, l, r); else if(mx[o &lt;&lt; 1 | 1] == c) return query(o &lt;&lt; 1 | 1, mid + 1, tr, l, r); return -1;&#125;int main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); while(cin &gt;&gt; n &gt;&gt; c &gt;&gt; k)&#123; for (int i = 1; i &lt;= n; ++i) &#123; cin &gt;&gt; a[i]; pos[i].clear(); pos[i].eb(0); &#125; for (int i = 0; i &lt;= c; ++i) &#123; cur[i] = 0; &#125; build(1, 1, n); int res = 0; for (int i = 1; i &lt;= n; ++i) &#123; int x = a[i]; pos[x].eb(i); int p = ++cur[x]; update(1, 1, n, i, i, c - 1); if(pos[x][p] - 1 &gt;= pos[x][p - 1] + 1) update(1, 1, n, pos[x][p - 1] + 1, pos[x][p] - 1, -1); if(p &gt;= k) update(1, 1, n, pos[x][p - k] + 1, pos[x][p - k + 1], 1); int t = query(1, 1, n, 1, i); if(t != -1) res = max(res, i - t + 1); &#125; cout &lt;&lt; res &lt;&lt; '\n'; &#125; return 0;&#125;]]></content>
      <categories>
        <category>线段树</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[The 2018 ACM-ICPC Asia Qingdao Regional Contest-L(Sub-cycle Graph)]]></title>
    <url>%2F2019%2F07%2F28%2FThe-2018-ACM-ICPC-Asia-Qingdao-Regional-Contest-L-Sub-cycle-Graph%2F</url>
    <content type="text"><![CDATA[链接：https://vjudge.net/problem/ZOJ-4069思路：青岛赛站的金牌/出线题，然而会了生成函数后这个题直接变成了铜牌题的水准，刚学完我就试了试，发现很快推出了结果，不太相信又写了写，发现就过了。。。题目要求一个n点m边的图，要求图加上一些边后能变成一个只有n个元素环的图。我们考虑m &gt; n的时候显然答案为0，n = m的时候就是一个n元环的排列方式，也非常好处理，关键是m &lt; n的时候怎么办？m &lt; n的时候，图上一共就会有k = n - m条链，那么其实就是问有k条链的图的方案数，我们考虑一条链如果有p个点，那么它的方案数：p = 0, 方案数为0p = 1, 方案数为1p &gt; 1, 方案数为$\frac{p!}{2}$那么它的生成函数为： f(p) = x + \frac{1}{2}x + \frac{1}{2}x^2 + ... + \frac{1}{2}x^p = \frac{x}{1-x}(1 - \frac{x}{2})那么k条链的生成函数为（因为k条链之间顺序无关，所以需要除以k!）： res = \frac{x^k}{(1-x)^k}(1 - \frac{x}{2})^k\frac{1}{k!}最终我们要求$x^n$的系数，再乘上n!就是答案，考虑二项式展开，因为上面有个稳定的$x^k$的贡献，所以我们只用求后面$x^m$的系数。考虑后面二项式展开： \frac{(1 - \frac{x}{2})^k}{(1-x)^k} = \sum_{s = 0}^{k}C_k^s(-\frac{1}{2})^sx^s\sum_{t = 0}^{\infty}C_{k + t - 1}^{k - 1}x^t最终$x^m$的系数为: \sum_{s = 0}^{k}C_k^s(-\frac{1}{2})^sC_{k + m - s - 1}^{k - 1}最终答案就为： \sum_{s = 0}^{k}C_k^s(-\frac{1}{2})^sC_{k + m - s - 1}^{k - 1}\frac{n!}{k!}就这样，金牌题就没了？？？代码:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef double db;typedef pair&lt;int, int&gt; pii;typedef vector&lt;int&gt; vi;typedef vector&lt;ll&gt; vl;typedef vector&lt;pii&gt; vp;const int inf = 1e9;const ll INF = 1e18;const int mod = 1e9 + 7;const int maxn = 1e5 + 233;#define fi first#define se second#define pb push_back#define eb emplace_back#define mem(a) memset(a, 0, sizeof(a))#define PA puts("pass")#define lowbit(x) (x &amp; -x)ll fac[maxn], inv[maxn];ll c(ll x, ll y)&#123; if(x &lt; y) return 0; return fac[x] * inv[y] % mod * inv[x - y] % mod;&#125;ll pow_mod(ll q, ll w)&#123; ll ret = 1; while(w)&#123; if(w &amp; 1) ret = ret * q % mod; q = q * q % mod; w &gt;&gt;= 1; &#125; return ret;&#125;int T;int n, m;int main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); fac[0] = 1; inv[0] = 1; for(int i = 1; i &lt; maxn; i++) fac[i] = fac[i - 1] * i % mod, inv[i] = pow_mod(fac[i], mod - 2); cin &gt;&gt; T; while(T--)&#123; cin &gt;&gt; n &gt;&gt; m; if(m &gt; n)&#123; cout &lt;&lt; "0\n"; continue; &#125; if(m == n)&#123; cout &lt;&lt; fac[n - 1] * pow_mod(2, mod - 2) % mod &lt;&lt; '\n'; continue; &#125; ll res = 0; int k = n - m; for(int i = 0; i &lt;= min(m, k); i++)&#123; res = (res + pow_mod(mod - 1, i) * c(k, i) % mod * pow_mod(inv[2], i) % mod * c(k + m - i - 1, m - i)) % mod; &#125; cout &lt;&lt; res * fac[n] % mod * inv[k] % mod &lt;&lt; '\n'; &#125; return 0;&#125;]]></content>
      <categories>
        <category>生成函数</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[HDU-1028(Ignatius and the Princess III)]]></title>
    <url>%2F2019%2F07%2F28%2FHDU-1028-Ignatius-and-the-Princess-III%2F</url>
    <content type="text"><![CDATA[链接：http://acm.hdu.edu.cn/showproblem.php?pid=1028思路：下午辛辛苦苦写的东西，结果电脑出问题了全部给我没了？我哭了，那就重新写一个生成函数的介绍吧。 生成函数概论生成函数是通过将序列信息放入幂级数中，通过幂级数的一些运算，从而非常简单的完成一些计数统计问题。本文只讨论最主要的两种生成函数：一般型生成函数、指数型生成函数。 生成函数特点1、形式幂级数不关心x的值2、形式幂级数不关心收敛和发散，即对f(x)的收敛和发散不做要求 一般型生成函数考虑一个序列为{$a_0, a_1, a_2, a_3….a_n$}，那么它的一般型生成函数为： f(x) = a_0 + a_1x + a_2x^2 + a_3x^3 + ... + a_nx^n如果它是一个无穷的序列，那么它的生成函数也可以拓展成无穷项，特别当序列为{1, 1, 1…1}的无穷序列时，我们可以看到它的一般型生成函数为： f(x) = 1 + x + x^2 + x^3 + ... + x^{\infty} = \frac{1}{1 - x}考虑这个题，是一个典型的整数划分问题，我们当然可以用dp去做，但是考虑生成函数的做法，这个题会更加简单。首先划分规定了顺序，即从小到大，然后没有选择次数，我们考虑对于某个整数k，它的生成函数为： f(k) = 1 + x^k + x^{2k} + ... + x^{\infty}对于给定的n，其实只有比他小的生成函数说有用的，那么对于某个整数n，最后划分序列的生成函数为 res = \prod_{i = 1}^n(1 + x^i + x^{2i} + ... + x^n + ... + x^{\infty})其实只有$x^n$以下的项是有用的，最后的答案就是$x^n$的系数，我们只用模拟多项式乘法就可以做完这个题了。 指数型生成函数指数型生成函数跟一般型生成函数比较类似，对于某个序列{$a_0, a_1, a_2…, a_n$}，它的指数型生成函数形式如下： f(x) = a_0 + a_1x + \frac{a_2}{2!}x^2 + ... + \frac{a_n}{n!}x^n我们发现与一般型生成函数相比，指数型生成函数多除了一个阶乘。我们考虑什么地方会出现阶乘—排列，所以指数型生成函数一般用来解决排列计数问题。 一些有趣的性质上面我们提到，序列为{1, 1, 1….., 1}的无穷序列时，它的一般型生成函数为： f(x) = 1 + x + x^2 + x^3 + ... + x^{\infty} = \frac{1}{1 - x}我们考虑一个多项式g(x)与f(x)相乘，根据观察我们发现，结果$x^n$的系数就是对f(x)求一次前缀和。考虑g(x)与f(x)连乘k次，那么就是对g(x)求k次前缀和，我们来看一下$f^k(x)$的生成函数： f^k(x) = \frac{1}{(1 - x) ^ k}通过牛顿二项式展开： \frac{1}{(1 - x) ^ k} = \sum_{i = 0}^{\infty}C_{k + i - 1}^{k - 1}x^i我们发现组合数$\sum_{i = 0}^{\infty}C_{k + i - 1}^{k - 1}$的实际意义就是求k次前缀和（最好记住，有些题目非常有用）。代码：1234567891011121314151617181920212223#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;ll c[130], tmp[130];int n;int main()&#123; while(cin &gt;&gt; n)&#123; for(int i = 0; i &lt;= n; i++) c[i] = 1; for(int i = 2; i &lt;= n; i++)&#123; memcpy(tmp, c, sizeof(c)); memset(c, 0, sizeof(c)); for(int j = 0; j &lt;= n; j += i)&#123; for(int k = 0; k + j &lt;= n; k++)&#123; c[k + j] += tmp[k]; &#125; &#125; &#125; cout &lt;&lt; c[n] &lt;&lt; '\n'; &#125; return 0;&#125;]]></content>
      <categories>
        <category>生成函数</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[The 2019 ICPC China Nanchang National Invitational and International Silk-Road Programming Contest-C(Xyjj’s sequence)]]></title>
    <url>%2F2019%2F07%2F26%2FThe-2019-ICPC-China-Nanchang-National-Invitational-and-International-Silk-Road-Programming-Contest-C-Xyjj%E2%80%99s-sequence%2F</url>
    <content type="text"><![CDATA[链接：https://nanti.jisuanke.com/t/40255思路：前半部分做过一个类似题啊，就是2的无限次幂对p取膜，这个其实跟那个差不多，只不过不是无限次了，所有要判断一下指数大小和当前的phi(mod)之间的大小，确定使用哪个广义欧拉降幂公式。这个可以预处理b的n次指数，如果大于mod了就不处理了，然后判断一下剩下的x和最后一个次数的大小，如果小于则判断b的x指数和当前mod的大小，注意要特判一下b = 1的情况，这样这个题前半部分欧拉降幂的部分就做完了。可能有更简单的处理方法，以后看到了再回来更新。。后半部分简直是个弱智的不行的dp，唯一有点东西的是可能要卡空间，滚动数组滚掉一维就行了。代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e5 + 5;typedef long long ll;const int mod = 1e5 + 3;const int maxm = 5010;bool vis[maxn];vector&lt;int&gt; prime;ll phi[maxn];ll a, b;ll A[maxm], B[maxm];ll dp[2][2][maxm];ll fac[maxn];int cnt;int n;ll pow_mod(ll q, ll w, ll mod)&#123; ll ret = 1; while(w)&#123; if(w &amp; 1) ret = ret * q % mod; q = q * q % mod; w &gt;&gt;= 1; &#125; return ret;&#125;void init()&#123; phi[1] = 1; for(int i = 2; i &lt; maxn; i++)&#123; if(!vis[i])&#123; prime.push_back(i); phi[i] = i - 1; &#125; for(int j = 0; j &lt; prime.size() &amp;&amp; prime[j] * i &lt; maxn; j++)&#123; vis[i * prime[j]] = 1; if(i % prime[j] == 0) &#123; phi[i * prime[j]] = phi[i] * prime[j]; break; &#125; phi[i * prime[j]] = phi[i] * (prime[j] - 1); &#125; &#125;&#125;ll f(ll x, ll p)&#123; //cout &lt;&lt; x &lt;&lt; ' ' &lt;&lt; p &lt;&lt; '\n'; if(!x) return 1; if(p == 1) return 0; ll tmp = f(x - 1, phi[p]); if(b == 1) &#123; if(phi[p] != 1) return pow_mod(b, tmp, p); return pow_mod(b, tmp + phi[p], p); &#125; if(x &gt; cnt || (fac[x] &gt;= phi[p])) return pow_mod(b, tmp + phi[p], p); else return pow_mod(b, tmp, p);&#125;int main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); init(); cin &gt;&gt; a &gt;&gt; b; fac[1] = b; cnt = 1; if(b &gt; 1) &#123; for (int i = 2; i &lt; maxn; i++) &#123; ll ans = 1; for (int j = 0; j &lt; b; j++) &#123; ans *= fac[i - 1]; if (ans &gt; mod) break; &#125; if (ans &gt; mod) break; cnt++; fac[i] = ans; &#125; &#125; else&#123; for (int i = 1; i &lt; maxn; ++i) &#123; fac[i] = 1; &#125; &#125; cin &gt;&gt; n; for(int i = 1; i &lt;= n; i++)&#123; cin &gt;&gt; A[i]; A[i] = pow_mod(a, f(A[i], phi[mod]), mod); &#125; for(int i = 1; i &lt;= n; i++)&#123; cin &gt;&gt; B[i]; B[i] = pow_mod(a, f(B[i], phi[mod]), mod); &#125; int o = 0; for(int i = 0; i &lt; 2 * n; i++)&#123; memset(dp[o ^ 1], 0, sizeof(dp[o ^ 1])); for(int j = 0; j &lt;= n &amp;&amp; j &lt;= i; j++)&#123; if(j + 1 &lt;= n) &#123; dp[o ^ 1][0][j + 1] = max(dp[o ^ 1][0][j + 1], dp[o][0][j] + (A[j] == A[j + 1] ? A[j] : 0)); dp[o ^ 1][0][j + 1] = max(dp[o ^ 1][0][j + 1], dp[o][1][j] + (B[i - j] == A[j + 1] ? A[j + 1] : 0)); &#125; if(i + 1 - j &lt;= n) &#123; dp[o ^ 1][1][j] = max(dp[o ^ 1][1][j], dp[o][0][j] + (A[j] == B[i - j + 1] ? A[j] : 0)); dp[o ^ 1][1][j] = max(dp[o ^ 1][1][j], dp[o][1][j] + (B[i - j] == B[i - j + 1] ? B[i - j] : 0)); &#125; &#125; o ^= 1; &#125; cout &lt;&lt; max(dp[o][0][n], dp[o][1][n]) &lt;&lt; '\n'; return 0;&#125;]]></content>
      <categories>
        <category>同余</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[The 2019 ICPC China Nanchang National Invitational and International Silk-Road Programming Contest-H(Another Sequence)]]></title>
    <url>%2F2019%2F07%2F26%2FThe-2019-ICPC-China-Nanchang-National-Invitational-and-International-Silk-Road-Programming-Contest-H-Another-Sequence%2F</url>
    <content type="text"><![CDATA[链接：https://nanti.jisuanke.com/t/40260思路：当时现场不会fwt啊，，现在才发现会fwt的话这个题好像真的不难。首先前半部分就是一个裸的fwt，求出c数组中每个值的数有多少个，然后后面又是个线段树的套路题，把所有询问的点拉出来离散化，然后线段树维护区间开根号次数，最后查询先找到数在线段树对应的哪个点上，然后暴力开根号即可，如果次数大于6且该数原来不为0的话就是1了，否则暴力开即可。0特判一下。代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 1 &lt;&lt; 19;ll a[maxn], b[maxn], c[maxn];int n, m;vector&lt;ll&gt; pos;ll sum[maxn &lt;&lt; 2], tag[maxn &lt;&lt; 2];ll pre[maxn];void pushup(int o)&#123; sum[o] = sum[o &lt;&lt; 1] + sum[o &lt;&lt; 1 | 1];&#125;void pushdown(int o, int m)&#123; if(tag[o])&#123; sum[o &lt;&lt; 1] += tag[o] * (m - (m &gt;&gt; 1)); sum[o &lt;&lt; 1 | 1] += tag[o] * (m &gt;&gt; 1); tag[o &lt;&lt; 1] += tag[o]; tag[o &lt;&lt; 1 | 1] += tag[o]; tag[o] = 0; &#125;&#125;void build(int o, int l, int r)&#123; tag[o] = 0; if(l == r) &#123; return ; &#125; int mid = l + r &gt;&gt; 1; build(o &lt;&lt; 1, l, mid); build(o &lt;&lt; 1 | 1, mid + 1, r); pushup(o);&#125;void update(int o, int tl, int tr, int l, int r, int v)&#123; if(l &gt; tr || r &lt; tl) return; if(l &lt;= tl &amp;&amp; tr &lt;= r)&#123; tag[o] += v; sum[o] += 1ll * (tr - tl + 1) * v; return; &#125; pushdown(o, tr - tl + 1); int mid = tl + tr &gt;&gt; 1; update(o &lt;&lt; 1, tl, mid, l, r, v); update(o &lt;&lt; 1 | 1, mid + 1, tr, l, r, v); pushup(o);&#125;ll query(int o, int tl, int tr, int l, int r)&#123; if(l &gt; tr || r &lt; tl) return 0; if(l &lt;= tl &amp;&amp; tr &lt;= r) return sum[o]; pushdown(o, tr - tl + 1); int mid = tl + tr &gt;&gt; 1; return query(o &lt;&lt; 1, tl, mid, l, r) + query(o &lt;&lt; 1 | 1, mid + 1, tr, l, r);&#125;void fwt(ll a[], int n) &#123; for (int i = 1; i &lt; n; i &lt;&lt;= 1) &#123; for (int p = i &lt;&lt; 1, j = 0; j &lt; n; j += p) &#123; for (int k = 0; k &lt; i; k++) &#123; int x = a[j + k], y = a[j + k + i]; a[j + k + i] = x + y; &#125; &#125; &#125;&#125;void ufwt(ll a[], int n) &#123; for (int i = 1; i &lt; n; i &lt;&lt;= 1) &#123; for (int p = i &lt;&lt; 1, j = 0; j &lt; n; j += p) &#123; for (int k = 0; k &lt; i; k++) &#123; int x = a[j + k], y = a[j + k + i]; a[j + k + i] = y - x; &#125; &#125; &#125;&#125;void solve(ll a[], ll b[], ll c[])&#123; fwt(a, maxn); fwt(b, maxn); for(int i = 0; i &lt; maxn; i++) c[i] = a[i] * b[i]; ufwt(c, maxn);&#125;typedef pair&lt;ll, ll&gt; pii;pii q[maxn];int main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); cin &gt;&gt; n; for(int i = 0; i &lt; n; i++) &#123; int x; cin &gt;&gt; x; a[x]++; &#125; for(int i = 0; i &lt; n; i++) &#123; int x; cin &gt;&gt; x; b[x]++; &#125; cin &gt;&gt; m; for(int i = 1; i &lt;= m; i++) &#123; cin &gt;&gt; q[i].first &gt;&gt; q[i].second; if(q[i].first) &#123; pos.push_back(q[i].first); pos.push_back(q[i].second); &#125; else&#123; pos.push_back(q[i].second); &#125; &#125; sort(pos.begin(), pos.end()); pos.resize(unique(pos.begin(), pos.end()) - pos.begin()); for(int i = 1; i &lt;= m; i++)&#123; if(q[i].first)&#123; q[i].first = lower_bound(pos.begin(), pos.end(), q[i].first) - pos.begin() + 1; q[i].second = lower_bound(pos.begin(), pos.end(), q[i].second) - pos.begin() + 1; &#125; &#125; solve(a, b, c); build(1, 1, pos.size()); pre[0] = c[0]; for(int i = 1; i &lt; maxn; i++) pre[i] = pre[i - 1] + c[i]; for(int i = 1; i &lt;= m; i++)&#123; if(q[i].first)&#123; update(1, 1, pos.size(), q[i].first, q[i].second, 1); &#125; else&#123; int l = 0, r = 1e5 + 2; int ans = 0; while(r &gt;= l)&#123; int mid = l + r &gt;&gt; 1; if(pre[mid] &gt;= q[i].second)&#123; ans = mid; r = mid - 1; &#125; else l = mid + 1; &#125; q[i].second = lower_bound(pos.begin(), pos.end(), q[i].second) - pos.begin() + 1; ll x = query(1, 1, pos.size(), q[i].second, q[i].second); if(ans == 0)&#123; cout &lt;&lt; "0\n"; &#125; else if(x &gt; 6) cout &lt;&lt; "1\n"; else&#123; while(x)&#123; ans = sqrt(ans); x--; &#125; cout &lt;&lt; ans &lt;&lt; '\n'; &#125; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>FWT</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2019牛客暑期多校训练营(第三场)-D(Big Integer)]]></title>
    <url>%2F2019%2F07%2F26%2F2019%E7%89%9B%E5%AE%A2%E6%9A%91%E6%9C%9F%E5%A4%9A%E6%A0%A1%E8%AE%AD%E7%BB%83%E8%90%A5-%E7%AC%AC%E4%B8%89%E5%9C%BA-D-Big-Integer%2F</url>
    <content type="text"><![CDATA[链接：https://ac.nowcoder.com/acm/contest/883/D思路：前半部分是非常经典的套路，就不多说了。找到最小的x满足后，首先我们要直到，$i^j$必须是x的倍数才能，否则我们可以辗转相减，得到的部分一定在模p意义下为1，这样最后得到的数一定比x小，产生矛盾，所以$i^j$一定是x倍数，这样问题转为了: \sum_{i = 1}^{n}\sum_{j = 1}^{m}[i^{j} \% x == 0]我们首先发现，对于x分解后每种不同的质因数，i至少包含1个，这很容易得出。其次，j很大的时候，i对于所有质因数的下界都是1，即至少取1个数即可。我们考虑固定j，讨论i会有多少贡献，我们发现我们可以i对于每种质因数的一个下界，假设x = $p_1^{a_1}p_2^{a_2}….p_x^{a_x}$，那么下界g = $p_1^{\lceil\frac{a_1}{j}\rceil}p_2^{\lceil\frac{a_2}{j}\rceil}….p_x^{\lceil\frac{a_n}{j}\rceil}$，i的个数就是$\lfloor\frac{n}{g}\rfloor$，那么我们只用枚举前30的j，然后暴力算出贡献，后面的贡献都一样，因为他们的下界都一样。注意几个trick：一个是2，5的时候无解，需要特判，一个是快速幂的时候可能会爆long long，，这个特别不容易发现。。。代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e5 + 233;vector&lt;int&gt; prime;bool vis[maxn];typedef long long ll;typedef __int128 LL;ll n, m, p;typedef pair&lt;ll, ll&gt; pii;vector&lt;pii&gt; sol;ll pow_mod(ll q, ll w, ll mod)&#123; ll ret = 1; while(w)&#123; if(w &amp; 1) ret = (LL)ret * q % mod; q = (LL)q * q % mod; w &gt;&gt;= 1; &#125; return ret;&#125;ll phi(ll x)&#123; ll ans = x; for(int i = 2; 1ll * i * i &lt;= x; i++)&#123; if(x % i == 0) ans -= ans / i; while(x % i == 0) x /= i; &#125; if(x &gt; 1) ans -= ans / x; return ans;&#125;void init()&#123; for(int i = 2; i &lt; maxn; i++)&#123; if(!vis[i]) prime.push_back(i); for(int j = 0; j &lt; prime.size() &amp;&amp; i * prime[j] &lt; maxn; j++)&#123; vis[i * prime[j]] = 1; if(i % prime[j] == 0) break; &#125; &#125;&#125;void clear()&#123; sol.clear();&#125;ll solve(ll x)&#123; for(int i = 2; 1ll * i * i &lt;= x; i++)&#123; if(x % i) continue; int t = 0; while(x % i == 0) t++, x /= i; if(t) sol.push_back(pii(t, i)); &#125; if(x &gt; 1) sol.push_back(pii(1, x)); ll res = 0; for(int i = 1; i &lt;= min(m, 30ll); i++)&#123; ll ans = 1; for(int j = 0; j &lt; sol.size(); j++)&#123; int t = (sol[j].first + i - 1) / i; for(int k = 0; k &lt; t; k++) &#123; ans *= sol[j].second; &#125; &#125; res += n / ans; &#125; ll ans = 1; for(int i = 0; i &lt; sol.size(); i++) &#123; ans *= sol[i].second; &#125; res += (m - min(m, 30ll)) * (n / ans); return res;&#125;int T;int main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); init(); cin &gt;&gt; T; while(T--)&#123; clear(); cin &gt;&gt; p &gt;&gt; n &gt;&gt; m; if(p == 2 || p == 5) &#123; cout &lt;&lt; "0\n"; continue; &#125; p *= 9; ll x = phi(p); ll tmp = 1e18; for(int i = 1; 1ll * i * i &lt;= x; i++)&#123; if(x % i == 0) &#123; if(pow_mod(10, i, p) == 1) tmp = min(tmp, (ll)i); if(pow_mod(10, x / i, p) == 1) tmp = min(tmp, x / i); &#125; &#125; cout &lt;&lt; solve(tmp) &lt;&lt; '\n'; &#125; return 0;&#125;]]></content>
      <categories>
        <category>同余</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2019牛客暑期多校训练营(第三场)-I(Median)]]></title>
    <url>%2F2019%2F07%2F26%2F2019%E7%89%9B%E5%AE%A2%E6%9A%91%E6%9C%9F%E5%A4%9A%E6%A0%A1%E8%AE%AD%E7%BB%83%E8%90%A5-%E7%AC%AC%E4%B8%89%E5%9C%BA-I-Median%2F</url>
    <content type="text"><![CDATA[链接：https://ac.nowcoder.com/acm/contest/883/I思路：这题有一个非常重要的结论，不容易看出来，但是证明却非常简单。就是如果有解，解一定可以只用给出的b数组来组成。证明是显而易见的，如果用了没有出现的，可以上下调整到一个出现的，不影响答案。我们考虑如果从左向右填数字，当i位置数字填完了，b[i - 2]位置就确定了，也就是说b[i - 2]与i，i - 1， i - 2三个位置有关，与其他位置都无关了。这时我们想起以前一个cf题，对子和顺子求最大收益。顺子也是三个一组，这时做法就类似了，我们考虑用dp[i][j][k]表示第i位选它附近三个数字中第j大的，i - 1选了它附近三个第k大的，考虑转移，从dp[i - 1][k][p]中某一个有解的状态转移过来，我们只用记录每个有解状态的前驱，只要dp[n][i][j]中有解，我们就可以沿着前驱把所有的解找出来，注意初始化dp[(1, 2)][x][y]都算有解情况。顺便吐槽一句，一开始找三个数中第k大，扔到vector里面排序，常数居然大了20多倍，一直以为是复杂度出问题了。。。。。还去找了个快读板子。。。。代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e5 + 233;int dp[maxn][3][3];typedef pair&lt;int, int&gt; pii;pii pre[maxn][3][3];int a[maxn];int res[maxn];int n;int T;inline int read() &#123; int s = 0, w = 1; char ch = getchar(); while (ch &lt; '0' || ch &gt; '9') &#123; if (ch == '-')w = -1; ch = getchar(); &#125; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') s = s * 10 + ch - '0', ch = getchar(); return s * w;&#125;int change(int a1, int a2, int a3, int x)&#123; if(a1 &gt; a2) swap(a1, a2); if(a1 &gt; a3) swap(a1, a3); if(a2 &gt; a3) swap(a2, a3); if(!x) return a1; if(x == 1) return a2; return a3;&#125;int get(int pos, int x)&#123; if(pos == 1) return a[1]; if(pos == 2) &#123; if(x &lt;= 1) return a[1]; else return a[2]; &#125; return change(a[pos - 2], a[pos - 1], a[pos], x);&#125;void getans(int x, int y)&#123; for(int i = n; i &gt;= 2; i--)&#123; res[i] = get(i, x); int tx = pre[i][x][y].first; int ty = pre[i][x][y].second; x = tx, y = ty; &#125; printf("%d", get(1, x)); for(int i = 2; i &lt;= n; i++)&#123; printf(" %d", res[i]); &#125; puts("");&#125;int main()&#123; T = read(); for (int i = 1; i &lt;= 2; ++i) &#123; for (int j = 0; j &lt; 3; ++j) &#123; for (int k = 0; k &lt; 3; ++k) &#123; dp[i][j][k] = 1; &#125; &#125; &#125; while(T--) &#123; n = read(); for (int i = 1; i &lt;= n - 2; ++i) &#123; a[i] = read(); &#125; for (int i = 3; i &lt;= n; ++i) &#123; for (int j = 0; j &lt; 3; ++j) &#123; for (int k = 0; k &lt; 3; ++k) &#123; dp[i][j][k] = 0; pre[i][j][k] = pii(0, 0); &#125; &#125; &#125; for (int i = 3; i &lt;= n; ++i) &#123; for (int j = 0; j &lt; 3; ++j) &#123; for (int k = 0; k &lt; 3; ++k) &#123; for (int p = 0; p &lt; 3; ++p) &#123; if(!dp[i - 1][k][p]) continue; int t1 = get(i - 2, p); int t2 = get(i - 1, k); int t3 = get(i, j); if(a[i - 2] == change(t1, t2, t3, 1))&#123; pre[i][j][k] = pii(k, p); dp[i][j][k] = 1; &#125; &#125; &#125; &#125; &#125; bool f = false; for (int i = 0; i &lt; 3; ++i) &#123; for (int j = 0; j &lt; 3; ++j) &#123; if(dp[n][i][j] == 1)&#123; getans(i, j); f = true; break; &#125; &#125; if(f) break; &#125; if(!f)puts("-1"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>基础dp</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2019牛客暑期多校训练营(第三场)-G(Removing Stones)]]></title>
    <url>%2F2019%2F07%2F26%2F2019%E7%89%9B%E5%AE%A2%E6%9A%91%E6%9C%9F%E5%A4%9A%E6%A0%A1%E8%AE%AD%E7%BB%83%E8%90%A5-%E7%AC%AC%E4%B8%89%E5%9C%BA-G-Removing-Stones%2F</url>
    <content type="text"><![CDATA[链接：https://ac.nowcoder.com/acm/contest/883/G思路：场上觉得这个题如果固定左端点，然后右端点似乎并不能二分，因为后面可能出现更大的值。。。然后感觉就gg，如果固定最大值，又不知道怎么处理重复点。。。然后发现用笛卡尔树解决这个题就非常简单。还是笛卡尔树上对应的最大值区间，我们要求固定一个左/右端点情况下，另一边有多少点能够满足条件。首先我们很容易发现，只要最大堆的数量 &lt;= $\lfloor\frac{区间和}{2}\rfloor$，就一定能赢（比较简单的证明）。这样我们就统计另一边有多少点能满足，我们发现这个有单调性，可以二分。对于不跨越这个点的区间，我们递归到两边去做。为了保证复杂度正确，我们应该选择左右区间中较小的那一部分来枚举，然后在另一边二分，这样可以保证枚举的区间上届是$\lfloor\frac{区间长度}{2}\rfloor$，有人证明过这样总的枚举最多是nlogn次。代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 3e5 + 233;int a[maxn], ls[maxn], rs[maxn], l[maxn], r[maxn];int n, rt;typedef long long ll;ll sum[maxn];int T;ll res;void clear()&#123; for (int i = 1; i &lt;= n; ++i) &#123; l[i] = r[i] = ls[i] = rs[i] = 0; &#125; res = 0;&#125;void dfs(int u)&#123; l[u] = r[u] = u; if(ls[u])&#123; dfs(ls[u]); l[u] = l[ls[u]]; &#125; if(rs[u])&#123; dfs(rs[u]); r[u] = r[rs[u]]; &#125;&#125;void build()&#123; stack&lt;int&gt; s; for(int i = 1; i &lt;= n; i++)&#123; int pre = 0; while(!s.empty() &amp;&amp; a[s.top()] &lt; a[i])&#123; pre = s.top(); s.pop(); &#125; if(!s.size()) rt = i; else rs[s.top()] = i; ls[i] = pre; s.push(i); &#125; dfs(rt);&#125;void solve(int x)&#123; int pl = x - l[x] + 1, pr = r[x] - x + 1; // cout &lt;&lt; x &lt;&lt; ' ' &lt;&lt; l[x] &lt;&lt; ' ' &lt;&lt; r[x] &lt;&lt; '\n'; if(pl &lt; pr)&#123; for(int i = l[x]; i &lt;= x; i++)&#123; int lb = x, ub = r[x], ans = r[x] + 1; while(ub &gt;= lb)&#123; int mid = ub + lb &gt;&gt; 1; if((sum[mid] - sum[i - 1]) / 2 &gt;= a[x])&#123; ans = mid; ub = mid - 1; &#125; else lb = mid + 1; &#125; res += r[x] - ans + 1; &#125; &#125; else&#123; for(int i = x; i &lt;= r[x]; i++)&#123; int lb = l[x], ub = x, ans = l[x] - 1; while(ub &gt;= lb)&#123; int mid = ub + lb &gt;&gt; 1; if((sum[i] - sum[mid - 1]) / 2 &gt;= a[x])&#123; ans = mid; lb = mid + 1; &#125; else ub = mid - 1; &#125; res += ans - l[x] + 1; &#125; &#125; if(ls[x]) solve(ls[x]); if(rs[x]) solve(rs[x]);&#125;int main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); cin &gt;&gt; T; while(T--) &#123; cin &gt;&gt; n; clear(); for (int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i], sum[i] = sum[i - 1] + a[i]; build(); solve(rt); cout &lt;&lt; res &lt;&lt; '\n'; &#125; return 0;&#125;]]></content>
      <categories>
        <category>笛卡尔树</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[luogu-P4755(Beautiful Pair)]]></title>
    <url>%2F2019%2F07%2F26%2Fluogu-P4755-Beautiful-Pair%2F</url>
    <content type="text"><![CDATA[链接：https://www.luogu.org/problem/P4755思路：我们把这个问题换一个问题，在以某个点为最大值的合法区间内，有多少对(l, r)满足$a_k$, $a_r$使得$a_l$ * $a_r$ &lt;= 最大值。看到最大值的合法区间，就想到单调栈或者笛卡尔树了。那么我们考虑枚举l，问题又变为了：在以某个点为最大值的合法区间内，固定l，区间[l, 某个点右边第一个比他大的值的下标 - 1]有多少个数 &lt;= $\lfloor\frac{最大值}{a_l}\rfloor$，但这个并不好处理，因为求区间小于等于某个数的值有多少个，是一个主席树的问题，勇的哥哥可以直接冲上去上主席树了。其实我们可以利用树剖中常用的一个思路，我们把这些询问存下来，然后按照值大小排序，把这些点依次加进去，最后询问树状数组上某段区间的值的和就行了。当然这个题还有一种做法，我们其实是统计区间小于等于某个数的数有多少，那么我们可以用r处的 - l-1处的答案，我们在r处询问某个数++， l-1处询问某个数—，那么我们对所有数从左到右加入树状数组，然后把这个点所有询问的贡献统计进去即可得到答案。这是对于跨越某个最大值点的统计，剩下的递归到两边子树中去做即可。代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e5 + 233;int n, rt;typedef long long ll;int a[maxn], ls[maxn], rs[maxn], l[maxn], r[maxn];ll c[maxn];vector&lt;int&gt; pos;typedef pair&lt;int, int&gt; pii;vector&lt;pii&gt; sol[maxn];void dfs(int u)&#123; l[u] = r[u] = u; if(ls[u])&#123; dfs(ls[u]); l[u] = l[ls[u]]; &#125; if(rs[u])&#123; dfs(rs[u]); r[u] = r[rs[u]]; &#125;&#125;void build()&#123; stack&lt;int&gt; s; for(int i = 1; i &lt;= n; i++)&#123; int pre = 0; while(!s.empty() &amp;&amp; a[s.top()] &lt; a[i])&#123; pre = s.top(); s.pop(); &#125; if(!s.size()) rt = i; else rs[s.top()] = i; ls[i] = pre; s.push(i); &#125; dfs(rt);&#125;int lowbit(int x)&#123; return x &amp; -x;&#125;void add(int x, int d)&#123; while(x &lt; maxn)&#123; c[x] += d; x += lowbit(x); &#125;&#125;ll query(int x)&#123; ll ret = 0; while(x)&#123; ret += c[x]; x -= lowbit(x); &#125; return ret;&#125;void solve(int x)&#123; int pl = x - l[x] + 1, pr = r[x] - x + 1; if(pl &lt; pr)&#123; for(int i = l[x]; i &lt;= x; i++)&#123; sol[r[x]].emplace_back(a[x] / a[i], 1); sol[x - 1].emplace_back(a[x] / a[i], -1); &#125; &#125; else&#123; for(int i = x; i &lt;= r[x]; i++)&#123; sol[x].emplace_back(a[x] / a[i], 1); sol[l[x] - 1].emplace_back(a[x] / a[i], -1); &#125; &#125; if(ls[x]) solve(ls[x]); if(rs[x]) solve(rs[x]);&#125;int main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); cin &gt;&gt; n; for(int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i], pos.push_back(a[i]); build(); sort(pos.begin(), pos.end()); pos.resize(unique(pos.begin(), pos.end()) - pos.begin()); solve(rt); ll res = 0; for(int i = 1; i &lt;= n; i++)&#123; int x = lower_bound(pos.begin(), pos.end(), a[i]) - pos.begin() + 1; add(x, 1); for(int j = 0; j &lt; sol[i].size(); j++)&#123; int y = lower_bound(pos.begin(), pos.end(), sol[i][j].first) - pos.begin() + 1; if(sol[i][j].first &lt; pos[y - 1]) y--; res += sol[i][j].second * query(y); &#125; &#125; cout &lt;&lt; res &lt;&lt; '\n'; return 0;&#125;]]></content>
      <categories>
        <category>笛卡尔树</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[HDU-1506(Largest Rectangle in a Histogram)]]></title>
    <url>%2F2019%2F07%2F26%2FHDU-1506-Largest-Rectangle-in-a-Histogram%2F</url>
    <content type="text"><![CDATA[链接：http://acm.hdu.edu.cn/showproblem.php?pid=1506思路：还是用模板题来写介绍性质吧。。。。给个lls的链接，构树方式很清楚了，单调栈好像就能解决一切了，这里不赘述构树方式：https://www.cnblogs.com/LiuRunky/p/Cartesian_Tree.html 笛卡尔树的一些性质：1、以某点为根的子树中，该点的权值最大/最小（取决于需求），它的左子树在原序列都在它前面，它右子树在原序列都在他后面2、一个子树中对应了该点在原系列中用单调栈求出来的左右第一个比它大/小的区间。3、单调栈似乎没法处理因为值相同而带来的统计重复的问题，比如区间有两个相同的最大值，如果按最大值枚举 + 单调栈可能会被统计多次或者漏掉统计，而笛卡尔树不会。在笛卡尔树上都具有偏序关系（即使相等最后也变为一堆相同权值点中只有一个能作为根，所以极大的方便了我们的统计）。4、笛卡尔树一般特别喜欢和分治问题结合。分治我们需要以某个点为中界，对于跨域中界的区间我们暴力统计，剩下的都分到两边递归处理，这跟笛卡尔树具有堆的性质非常吻合，所以某些统计问题就非常适合用笛卡尔树分治，后面会有题目。 回到本题，我们只需要建树，然后确定每个点在笛卡尔树上作为根节点在原序列的左右边界点，更新答案即可。代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e5 + 233;int n, a[maxn], ls[maxn], rs[maxn], l[maxn], r[maxn];int rt;typedef long long ll;void clear()&#123; for(int i = 1; i &lt;= n; i++) ls[i] = rs[i] = l[i] = r[i] = 0;&#125;void dfs(int u)&#123; l[u] = r[u] = u; if(ls[u])&#123; dfs(ls[u]); l[u] = l[ls[u]]; &#125; if(rs[u])&#123; dfs(rs[u]); r[u] = r[rs[u]]; &#125;&#125;void build()&#123; stack&lt;int&gt; s; for(int i = 1; i &lt;= n; i++)&#123; int pre = 0; while(!s.empty() &amp;&amp; a[s.top()] &gt; a[i])&#123; pre = s.top(); s.pop(); &#125; if(!s.size()) rt = i; else rs[s.top()] = i; ls[i] = pre; s.push(i); &#125; dfs(rt);&#125;int main()&#123; while(cin &gt;&gt; n &amp;&amp; n)&#123; for(int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i]; clear(); build(); ll res = 0; for(int i = 1; i &lt;= n; i++) res = max(res, 1ll * (r[i] - l[i] + 1) * a[i]); cout &lt;&lt; res &lt;&lt; '\n'; &#125; return 0;&#125;]]></content>
      <categories>
        <category>笛卡尔树</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2019 Multi-University Training Contest 2-H(Harmonious Army)]]></title>
    <url>%2F2019%2F07%2F25%2F2019-Multi-University-Training-Contest-2-H-Harmonious-Army%2F</url>
    <content type="text"><![CDATA[链接：http://acm.hdu.edu.cn/showproblem.php?pid=6598思路：看到n范围500就感觉是网络流，但不知道最大流怎么建图。其实这个题就说明了最大流和最小割只是在数值上相等，实际上没有其他联系。最小割往往是从实际意义上非常直接的考虑，在本题中，最大流不好做，我们考虑如果我们先把所有的贡献都算入，其中有一些不合法的，我们除去最小的不合法的代价使得它合法，不就是最大值了吗。那么我们可以用割代表不合法的代价，考虑如下建图：假设有一对pair(x, y), 考虑如下建图，如果割(s, u)，表示不选战士阵营，割(u, t)，表示不选法师阵营，我们可以看出，此图中的最小割可能有如下三种：割掉两个A：表示两个人不是战士，都是法师，那么此时我们需要扣除的就是b和c的贡献和，那么得到第一个式子: 2A = b + c割掉两个C：表示两个人不是法师，都是战士，那么此时我们需要扣除的就是a和b的贡献和，那么得到第二个式子： 2C = a + b割掉一个A一个B一个C：表示两个人分别为法师和战士，那么此时我们要扣除的就是a和c的贡献和：那么得到第三个式子： A + B + C = a + c解除ABC后对没对pair建图跑最小割，最后用总贡献 - 最小割即可得到答案。注意本题有可能不能整除，可以放大倍数后跑完再缩小回来。代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104#include&lt;bits/stdc++.h&gt;using namespace std;int n, m;const int maxn = 1000;typedef long long ll;const ll INF = 1e18;struct edge &#123; int from, to; ll cap, flow;&#125;;int s,t,tot;vector&lt;edge&gt; edges;vector&lt;int&gt; G[maxn];bool vis[maxn];int d[maxn];int cur[maxn];void init() &#123; edges.clear(); for (int i = 0; i &lt;= t; i++)G[i].clear();&#125;void addedge(int from,int to,int cap) &#123; edges.push_back(edge&#123;from, to, cap, 0&#125;); edges.push_back(edge&#123;to, from, 0, 0&#125;); tot = edges.size(); G[from].push_back(tot - 2); G[to].push_back(tot - 1);&#125;bool bfs() &#123; memset(vis, 0, sizeof(vis)); queue&lt;int&gt; q; q.push(s); d[s] = 0; vis[s] = 1; while (!q.empty()) &#123; int x = q.front(); q.pop(); for (int i = 0; i &lt; G[x].size(); i++) &#123; edge &amp;e = edges[G[x][i]]; if (!vis[e.to] &amp;&amp; e.cap &gt; e.flow) &#123; vis[e.to] = 1; d[e.to] = d[x] + 1; q.push(e.to); &#125; &#125; &#125; return vis[t];&#125;ll dfs(int x, ll a) &#123; if (x == t || a == 0)return a; ll flow = 0, f; for (int &amp;i = cur[x]; i &lt; G[x].size(); i++) &#123; edge &amp;e = edges[G[x][i]]; if (d[x] + 1 == d[e.to] &amp;&amp; (f = dfs(e.to, min(a, e.cap - e.flow))) &gt; 0) &#123; e.flow += f; edges[G[x][i] ^ 1].flow -= f; flow += f; a -= f; if (a == 0)break; &#125; &#125; return flow;&#125;ll maxflow() &#123; ll flow = 0; while (bfs()) &#123; memset(cur, 0, sizeof(cur)); flow += dfs(s, INF); &#125; return flow;&#125;int main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); while(cin &gt;&gt; n &gt;&gt; m)&#123; s = 0, t = n + 1; init(); ll sum = 0; for(int i = 1; i &lt;= m; i++)&#123; int u, v, a, b, c; cin &gt;&gt; u &gt;&gt; v &gt;&gt; a &gt;&gt; b &gt;&gt; c; a *= 2, b *= 2, c *= 2; sum += a + b + c; addedge(s, u, (a + b) / 2); addedge(s, v, (a + b) / 2); addedge(u, t, (b + c) / 2); addedge(v, t, (b + c) / 2); addedge(u, v, a / 4 + c / 6); addedge(v, u, a / 4 + c / 6); &#125; ll res = maxflow(); cout &lt;&lt; (sum - res) / 2 &lt;&lt; '\n'; &#125; return 0;&#125;]]></content>
      <categories>
        <category>网络流</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2019 Multi-University Training Contest 2-I(I Love Palindrome String)]]></title>
    <url>%2F2019%2F07%2F24%2F2019-Multi-University-Training-Contest-2-I-I-Love-Palindrome-String%2F</url>
    <content type="text"><![CDATA[链接：http://acm.hdu.edu.cn/showproblem.php?pid=6599思路：本质不同的回文串是O(n)的，那么我们用回文树可以统计出每种本质不同的字符串有多少个，剩下的就是判断该字符串是否合法了。 我的方法是插入时顺便记录下每个点对应的其中一个右端点，然后用hash强行判断，这样比较麻烦也容易写错。。。。事实上还有一种方法，考虑回文树上一个点对应的是一个回文串，它的fail树上的父亲是它的最长回文后缀，我们是要删掉一半的字符还要形成回文。如果当前节点回文长度和父亲节点回文长度之差能整除删去的一半字符，我们可以利用回文串的对称性（类似kmp循环节那里的对称）证明出一半的地方是回文串，所以只需要判断如下式子即可： |str - f[str]| 整除 \ \lfloor\frac{|str|}{2}\rfloor被葫芦骗去写了个双模数。。。。代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127#include&lt;bits/stdc++.h&gt;using namespace std;const int maxnode = 6e5 + 100;const int sigma_size = 26;const int base = 13331;const int mod = 1610612741;const int mod2 = 805306457;typedef long long ll;ll h1[2][maxnode], h2[2][maxnode], bin[2][maxnode];typedef pair&lt;ll, ll&gt; pii;int ch[maxnode][sigma_size];int f[maxnode];int cnt[maxnode]; // 节点i表示的回文串在S中出现的次数（建树时求出的不是完全的，count()加上子节点以后才是正确的）int num[maxnode]; //以节点i回文串的末尾字符结尾的但不包含本条路径上的回文串的数目。(也就是fail指针路径的深度)int len[maxnode]; //节点i的回文串的长度int s[maxnode]; //表示第i次添加的字符int last; //指向最新添加的回文结点int n;int p; //节点个数（节点从2开始）int sz;char str[maxnode];ll res[maxnode];int pos[maxnode];int newnode(int w) &#123; for(int i = 0; i &lt; sigma_size; i++)ch[p][i] = 0; cnt[p] = 0; num[p] = 0; len[p] = w; return p++;&#125;void init() &#123; for(int i = 0; i &lt;= p; i++) &#123; memset(ch[i], 0, sizeof(ch[i])), f[i] = 0; cnt[i] = num[i] = len[i] = 0; s[i] = 0; &#125; p = 0; newnode(0); newnode(-1); last = 0; n = 0; s[n] = -1; f[0] = 1; h1[0][0] = 0; h1[1][0] = 0; h2[1][0] = 0; h2[0][0] = 0; sz = strlen(str + 1); for(int i = 1; i &lt;= sz; i++) res[i] = 0; for(int i = 1; i &lt;= sz; i++) &#123; h1[0][i] = (h1[0][i - 1] * base + str[i]) % mod; h1[1][i] = (h1[1][i - 1] * base + str[i]) % mod2; &#125; for(int i = sz; i; i--)&#123; h2[0][sz - i + 1] = (h2[0][sz - i] * base + str[i]) % mod; h2[1][sz - i + 1] = (h2[1][sz - i] * base + str[i]) % mod2; &#125;&#125;pii get(int l, int r, ll *h0, ll *h1)&#123; return pii(((h0[r] - h0[l - 1] * bin[0][r - l + 1]) % mod + mod) % mod, ((h1[r] - h1[l - 1] * bin[1][r - l + 1]) % mod2 + mod2) % mod2);&#125;int getfail(int x) &#123; while (s[n - len[x] - 1] != s[n])x = f[x]; return x;&#125;void add(int c, int id) &#123; s[++n] = c; int cur = getfail(last); if (!ch[cur][c]) &#123; int now = newnode(len[cur] + 2); f[now] = ch[getfail(f[cur])][c]; ch[cur][c] = now; num[now] = num[f[now]] + 1; &#125; last = ch[cur][c]; cnt[last]++; pos[last] = id;&#125;void count() &#123; for (int i = p - 1; i &gt;= 0; i--) cnt[f[i]] += cnt[i];&#125;int main()&#123; bin[0][0] = bin[1][0] = 1; for(int i = 1; i &lt; maxnode; i++) &#123; bin[0][i] = bin[0][i - 1] * base % mod; bin[1][i] = bin[1][i - 1] * base % mod2; &#125; while(~scanf("%s", str + 1))&#123; init(); for(int i = 1; i &lt;= sz; i++) add(str[i] - 'a', i); count(); for(int i = 2; i &lt;= p; i++)&#123; int r = pos[i]; if(len[i] &lt;= 2)&#123; res[len[i]] += cnt[i]; continue; &#125; int cen = r - len[i] / 2; if((len[i] + 1) / 2 % 2)&#123; int pl = cen - (len[i] + 1) / 2 + 1; int mid = cen - (len[i] + 1) / 2 / 2; if(get(pl, mid, h1[0], h1[1]) == get(sz - cen + 1, sz - mid + 1, h2[0], h2[1])) res[len[i]] += cnt[i]; &#125; else&#123; int pl = cen - (len[i] + 1) / 2 + 1; int mid = cen - (len[i] + 1) / 2 / 2; if(get(pl, mid, h1[0], h1[1]) == get(sz - cen + 1, sz - mid, h2[0], h2[1])) &#123; res[len[i]] += cnt[i]; &#125; &#125; &#125; for(int i = 1; i &lt;= sz; i++) printf("%lld%c", res[i], i == sz ? '\n' : ' '); &#125; return 0;&#125;]]></content>
      <categories>
        <category>回文自动机</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2019 Multi-University Training Contest 1-M(Code)]]></title>
    <url>%2F2019%2F07%2F23%2F2019-Multi-University-Training-Contest-1-M-Code%2F</url>
    <content type="text"><![CDATA[链接：http://acm.hdu.edu.cn/showproblem.php?pid=6590思路：考虑一下式子$b + w_1x_{i, 1} + w_2x_{i, 2}$，我们可以看作以x = $x_{i, 1}$, y = $x_{i, 2}$的一条直线，那么等于0的点也是一条直线，等于-1的点必须都在这条直线的下侧，等于1的点必须在上侧。那么原问题变为了给你一堆点，问你能否找到一条直线把1和-1对应的点分开。这样我们就可以考虑如果能分开，那么他们的凸包一定不会相交，那么对这两个点集求其凸包，判断两个凸包是否相交即可。 判断两个凸包是否相交的方法：先判断是否一个完全包含一个，也就判断其中一个凸包的点是否在另一个凸包内，然后再判断是否存在线段相交，顺时针旋转一圈即可。代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173#include&lt;bits/stdc++.h&gt;using namespace std;typedef double db;const db eps = 1e-10;const db pi = acos(-1);int dcmp(db x) &#123; return x&lt;-eps?-1:x&gt;eps;&#125;db myacos(db x)&#123; if(x&lt;-1) x = -1; if(x&gt;1) x = 1; return acos(x);&#125;db myasin(db x)&#123; if(x&lt;-1) x = -1; if(x&gt;1) x = 1; return asin(x);&#125;db mysqrt(db x)&#123; return x&lt;0?0:sqrt(x);&#125;typedef struct P &#123; db x, y; P(db x = 0, db y = 0) : x(x), y(y) &#123;&#125; P operator+(P r)&#123;return P(x+r.x,y+r.y);&#125; P operator-(P r)&#123;return P(x-r.x,y-r.y);&#125; P operator*(db r)&#123;return P(x*r,y*r);&#125; P operator/(db r)&#123;return P(x/r,y/r);&#125; bool operator&lt;(const P &amp;r)const&#123;return x&lt;r.x||(x==r.x&amp;&amp;y&lt;r.y);&#125; bool operator==(const P &amp;r)const&#123;return dcmp(x-r.x)==0&amp;&amp;dcmp(y-r.y)==0;&#125; void read()&#123; scanf("%lf %lf", &amp;x, &amp;y); &#125; void print()&#123; printf("%.2f %.2f\n", x, y);&#125;&#125;V;//向量点积db Dot(V A, V B) &#123; return A.x*B.x + A.y*B.y; &#125;db Cross(V A, V B) &#123; return A.x*B.y - A.y*B.x; &#125;//向量逆时针旋转rad度(弧度)//线段相交判定，交点不在一条线段的端点bool SegmentProperIntersection(P a1, P a2, P b1, P b2) &#123; db c1 = Cross(a2-a1, b1-a1), c2 = Cross(a2-a1, b2-a1); db c3 = Cross(b2-b1, a1-b1), c4 = Cross(b2-b1, a2-b1); return dcmp(c1)*dcmp(c2) &lt; 0 &amp;&amp; dcmp(c3)*dcmp(c4) &lt; 0;&#125;//判断点是否在点段上，不包含端点bool OnSegment(P p, P a1, P a2) &#123; return dcmp(Cross(a1-p, a2-p)) == 0 &amp;&amp; dcmp((Dot(a1-p, a2-p)) &lt; 0);&#125;bool check(P a1, P a2, P b1, P b2)&#123; if(OnSegment(a1, b1, b2)) return true; if(OnSegment(a2, b1, b2)) return true; if(OnSegment(b1, a1, a2)) return true; if(OnSegment(b2, a1, a2)) return true; if(a1 == b1 || a1 == b2) return true; if(a2 == b1 || a2 == b2) return true; return SegmentProperIntersection(a1, a2, b1, b2);&#125;//凸包/**************************************************************** 输入点数组p， 个数为p， 输出点数组ch。 返回凸包顶点数* 不希望凸包的边上有输入点，把两个&lt;= 改成 &lt;* 高精度要求时建议用dcmp比较* 输入点不能有重复点。函数执行完以后输入点的顺序被破坏****************************************************************/int ConvexHull(P *p, int n, P* ch) &#123; sort(p, p + n); //先比较x坐标，再比较y坐标 int m = 0; for(int i = 0; i &lt; n; i++) &#123; while(m &gt; 1 &amp;&amp; Cross(ch[m-1] - ch[m-2], p[i] - ch[m-2]) &lt;= 0) m--; ch[m++] = p[i]; &#125; int k = m; for(int i = n - 2; i &gt;= 0; i--) &#123; while(m &gt; k &amp;&amp; Cross(ch[m-1] - ch[m-2], p[i] - ch[m-2]) &lt;= 0) m--; ch[m++] = p[i]; &#125; if(n &gt; 1) m--; return m;&#125;bool inConvexHull(P *ch, int m, P a) &#123; if(m == 1) return ch[0] == a; if(m == 2) return OnSegment(a, ch[0], ch[1]); if (Cross(ch[1] - ch[0], a - ch[0]) &lt; 0) return false; if (Cross(ch[m - 1] - ch[0], a - ch[0]) &gt; 0) return false; int l = 2, r = m - 1; int ans = 1; while (r &gt;= l) &#123; int mid = l + r &gt;&gt; 1; if (Cross(ch[mid] - ch[0], a - ch[0]) &lt;= 0) &#123; r = mid - 1; ans = mid; &#125; else l = mid + 1; &#125; if (Cross(ch[ans - 1] - ch[ans], a - ch[ans]) &gt; 0) return false; return true;&#125;const int maxn = 110;int cnt1, cnt2, n;P p1[maxn], p2[maxn];P ch1[maxn], ch2[maxn];int m1, m2;int T;int main()&#123; scanf("%d", &amp;T); while(T--)&#123; cnt1 = cnt2 = 0; scanf("%d", &amp;n); for(int i = 1; i &lt;= n; i++)&#123; P tmp; tmp.read(); int y; scanf("%d", &amp;y); if(y == 1) p1[cnt1++] = tmp; else p2[cnt2++] = tmp; &#125; m1 = ConvexHull(p1, cnt1, ch1); m2 = ConvexHull(p2, cnt2, ch2); bool flag = true; for(int i = 1; i &lt; m1; i++)&#123; bool f = true; for(int j = 1; j &lt; m2; j++)&#123; if(check(ch1[i - 1], ch1[i], ch2[j - 1], ch2[j]))&#123; f = false; break; &#125; &#125; if(!f) &#123; flag = false; break; &#125; &#125; for(int i = 0; i &lt; m1; i++)&#123; if(inConvexHull(ch2, m2, ch1[i]))&#123; flag = false; break; &#125; &#125; for(int i = 0; i &lt; m2; i++)&#123; if(inConvexHull(ch1, m1, ch2[i]))&#123; flag = false; break; &#125; &#125; if(flag) puts("Successful!"); else puts("Infinite loop!"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>计算几何</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2019 Multi-University Training Contest 1-F(Typewriter)]]></title>
    <url>%2F2019%2F07%2F23%2F2019-Multi-University-Training-Contest-1-F-Typewriter%2F</url>
    <content type="text"><![CDATA[链接：http://acm.hdu.edu.cn/showproblem.php?pid=6583思路：后缀自动机好题啊。。。。考虑dp[i]表示以i结束的最小花费，那么他可以由两个地方转移：一个是前一个点 + 一个字符的花费，一个是找一个最靠前的位置j，使得子串(j, i)是(1, j - 1)的子串。那么看到这里其实我们该有想法了，我们维护1 - j - 1的一个SAM，在上面找(j - i)子串，如果能找到就可以转移，如果不能找到，我们考虑j一直向后移动，然后把j经过位置的字符都加入自动机中，直到匹配位置，这样j是单调的，总的是线性的。每次加入新字符后，我们把结点沿着fail树向上跳，直到跳到某个状态对应的子串长度刚好大于等于子串(j, i)为止。为什么要这么做呢？首先大于等于保证子串(j, i)是能属于这个状态的，在这个条件下，肯定在fail树上越高越有可能向后转移(越高说明子串对应的后面链接状态越多)。这样我们跳到最高的能满足的位置，看能不能向后转移，不能的话就继续拓展，如果能就转移，并且转移后继续向fail树上跳，以方便下一个点尽可能能向后转移，然后看j是否小于i，如果小于就说明找到了一个最靠前的j能转移，转移即可，否则说明没有一个状态是之前出现过的，说明不能转移。代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include&lt;bits/stdc++.h&gt;#define sigma_size 26using namespace std;const int maxn = 2e5 + 5;typedef long long ll;int len[maxn * 2]; //最长子串的长度(该节点字串数量=len[x]-len[f[x]])int f[maxn * 2]; //后缀链接(最短串前部减少一个字符所到达的状态)int ch[maxn * 2][sigma_size]; //状态转移(尾部加一个字符的下一个状态)(图)int idx; //节点编号int last; //最后节点char s[maxn];ll pc, qc;ll dp[2 * maxn];int n;void init() &#123; //初始化 last = idx = 1; //1表示root起始点 空集 f[1] = len[1] = 0; memset(ch[1], 0, sizeof(ch[1]));&#125;//SAM建图void add(int c) &#123; //插入字符，为字符ascll码值 int x = ++idx; //创建一个新节点x; len[x] = len[last] + 1; // 长度等于最后一个节点+1 int p; //第一个有C转移的节点; for (p = last; p &amp;&amp; !ch[p][c]; p = f[p])ch[p][c] = x;//沿着后缀连接 将所有没有字符c转移的节点直接指向新节点 if (!p)f[x] = 1; //全部都没有c的转移 直接将新节点后缀连接到起点 else &#123; int q = ch[p][c]; //p通过c转移到的节点 if (len[p] + 1 == len[q]) //pq是连续的 f[x] = q; //将新节点后缀连接指向q即可,q节点的被后缀连接数+1 else &#123; int nq = ++idx; //不连续 需要复制一份q节点 len[nq] = len[p] + 1; //令nq与p连续 f[nq] = f[q]; //因后面link[q]改变此处不加cnt memcpy(ch[nq], ch[q], sizeof(ch[q])); //复制q的信息给nq for (; p &amp;&amp; ch[p][c] == q; p = f[p]) ch[p][c] = nq; //沿着后缀连接 将所有通过c转移为q的改为nq f[q] = f[x] = nq; //将x和q后缀连接改为nq &#125; &#125; last = x; //更新最后处理的节点&#125;int main() &#123; while(~scanf("%s", s + 1))&#123; init(); scanf("%lld %lld", &amp;pc, &amp;qc); n = strlen(s + 1); for(int i = 1; i &lt;= 2 * n; i++) &#123; dp[i] = 1e18; memset(ch[i], 0, sizeof(ch[i])); f[i] = 0; len[i] = 0; &#125; int l = 1; int p = 1; for(int r = 1; r &lt;= n; r++)&#123; int c = s[r] - 'a'; dp[r] = dp[r - 1] + pc; while((!ch[p][c] || r - l + 1 &gt; l - 1) &amp;&amp; l &lt;= r)&#123; add(s[l++] - 'a'); while(p &amp;&amp; len[f[p]] &gt;= r - l) p = f[p]; if(!p) p = 1; &#125; p = ch[p][c]; while(p &amp;&amp; len[f[p]] &gt;= r - l + 1) p = f[p]; if(!p) p = 1; if(l &lt;= r) dp[r] = min(dp[r], dp[l - 1] + qc); &#125; printf("%lld\n", dp[n]); &#125; return 0;&#125;]]></content>
      <categories>
        <category>后缀自动机</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2019 Multi-University Training Contest 1-B(Operation)]]></title>
    <url>%2F2019%2F07%2F23%2F2019-Multi-University-Training-Contest-1-B-Operation%2F</url>
    <content type="text"><![CDATA[链接：http://acm.hdu.edu.cn/showproblem.php?pid=6579思路：一开始觉得傻逼题，线段树维护线性基怎么这么弱智，然后又MLE又TLE就自闭了。其实这个题可以贪心，我们先从左到右对线性基做前缀，也就是后一个线性基是由前一个基础上插入当前位置的数得来的。插入时需要注意，从高到低枚举，如果空闲就插入，如果有了则比较之前插入数的端点和当前端点，如果当前端点大，就把这个位置更换为当前数，然后拿原本的这个数继续往向低位重复上述操作。因为是从高位到低位，矩阵是上三角矩阵，所以高位的端点越靠右越好，交换后相当于交换了插入顺序。最后贪心求最大值即可。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e6 + 5;struct Linebasis&#123; int p[32]; //p是上三角矩阵，b是对角矩阵 int pos[32]; void init()&#123; memset(p, 0, sizeof(p)); memset(pos, 0, sizeof(pos)); &#125; void insert(int x, int id)&#123; for(int i = 30; i &gt;= 0; i--)&#123; if((x &gt;&gt; i) &amp; 1)&#123; if(!p[i])&#123; p[i] = x; pos[i] = id; return; &#125; else &#123; if(id &gt; pos[i]) &#123; swap(id, pos[i]); swap(p[i], x); &#125; x ^= p[i]; &#125; &#125; &#125; &#125; int querymax(int l)&#123; int res = 0; for(int i = 30; i &gt;= 0; i--)&#123; if(pos[i] &gt;= l &amp;&amp; (res ^ p[i]) &gt; res) res ^= p[i]; &#125; return res; &#125;&#125;sol[maxn];int T, n, q;int main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); cin &gt;&gt; T; while(T--)&#123; int last = 0; cin &gt;&gt; n &gt;&gt; q; for(int i = 0; i &lt;= n + q; i++) sol[i].init(); for(int i = 1; i &lt;= n; i++)&#123; int x; cin &gt;&gt; x; Linebasis tmp = sol[i - 1]; tmp.insert(x, i); sol[i] = tmp; &#125; for(int i = 1; i &lt;= q; i++)&#123; int op, x, y; cin &gt;&gt; op &gt;&gt; x; if(op == 0)&#123; cin &gt;&gt; y; x = (x ^ last) % n + 1; y = (y ^ last) % n + 1; if(x &gt; y) swap(x, y); last = sol[y].querymax(x); cout &lt;&lt; last &lt;&lt; '\n'; &#125; else&#123; n++; x = x ^ last; Linebasis tmp = sol[n - 1]; tmp.insert(x, n); sol[n] = tmp; &#125; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>线性基</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2019 Multi-University Training Contest 1-A(Blank)]]></title>
    <url>%2F2019%2F07%2F23%2F2019-Multi-University-Training-Contest-1-A-Blank%2F</url>
    <content type="text"><![CDATA[链接：http://acm.hdu.edu.cn/showproblem.php?pid=6578思路：dp[a][b][c][d]表示0123四个数字最后结束的位置在abcd，因为四个数字无差别，我们可以把abcd的所有排列看成一种情况，换句话说，我们强制a &lt; b &lt; c &lt; d，这样就复杂度可以 / 24。考虑我们要枚举当前位置，所有d转移后的地方一定是i，所以这一维可以滚掉，用abc以及i - 1四个位置信息来判断所有以r为右端点的限制，如果都满足就可以转移，否则就不能转移。注意这个题实在有点卡时间，所以要注意写法。。。。代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 105;int dp[2][maxn][maxn][maxn];const int mod = 998244353;int T, n, m;inline void add(int &amp;x, int y)&#123; x += y; if(x &gt;= mod) x -= mod;&#125;typedef pair&lt;int, int&gt; pii;vector&lt;pii&gt; r[maxn];inline bool check(int a, int b, int c, int d, int pos)&#123; for(int i = 0; i &lt; r[pos].size(); i++)&#123; int s = 0; if(r[pos][i].first &lt;= a) s++; if(r[pos][i].first &lt;= b) s++; if(r[pos][i].first &lt;= c) s++; if(r[pos][i].first &lt;= d) s++; if(s != r[pos][i].second) return false; &#125; return true;&#125;int main()&#123; //freopen("in.txt", "r", stdin); ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); cin &gt;&gt; T; while(T--)&#123; cin &gt;&gt; n &gt;&gt; m; memset(dp, 0, sizeof(dp)); int o = 0; dp[0][0][0][0] = 1; for(int i = 0; i &lt;= n; i++) r[i].clear(); for(int i = 1; i &lt;= m; i++)&#123; int pl, pr, x; cin &gt;&gt; pl &gt;&gt; pr &gt;&gt; x; r[pr].push_back(pii(pl, x)); &#125; for(int i = 0; i &lt; n; i++)&#123; for(int j = i; j &gt;= 0; j--)&#123; for(int k = j; k &gt;= 0; k--)&#123; for(int p = k; p &gt;= 0; p--) &#123; if(check(i, j, k, i + 1, i + 1)) add(dp[o ^ 1][i][j][k], dp[o][j][k][p]); if(check(i, j, p, i + 1, i + 1)) add(dp[o ^ 1][i][j][p], dp[o][j][k][p]); if(check(i, k, p, i + 1, i + 1)) add(dp[o ^ 1][i][k][p], dp[o][j][k][p]); if(check(j, k, p, i + 1, i + 1)) add(dp[o ^ 1][j][k][p], dp[o][j][k][p]); dp[o][j][k][p] = 0; &#125; &#125; &#125; o ^= 1; &#125; int res = 0; for(int i = 0; i &lt;= n; i++) &#123; for (int j = 0; j &lt;= i; j++) &#123; for (int k = 0; k &lt;= j; k++) &#123; add(res, dp[o][i][j][k]); &#125; &#125; &#125; cout &lt;&lt; res &lt;&lt; '\n'; &#125; return 0;&#125;]]></content>
      <categories>
        <category>基础dp</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2019牛客暑期多校训练营(第二场)-E(MAZE)]]></title>
    <url>%2F2019%2F07%2F23%2F2019%E7%89%9B%E5%AE%A2%E6%9A%91%E6%9C%9F%E5%A4%9A%E6%A0%A1%E8%AE%AD%E7%BB%83%E8%90%A5-%E7%AC%AC%E4%BA%8C%E5%9C%BA-E-MAZE%2F</url>
    <content type="text"><![CDATA[链接：https://ac.nowcoder.com/acm/contest/882/E思路：考虑下一行某个点是由上一行转移而来（因为不能往上走），那么转移方程就是dp[i][j] = $\sum{dp[i - 1][k]}$，其中k是从第i行j向两边扩展，直到遇到第一个障碍为止。因为m只有10，那么行与行之间的转移我们可以用矩阵转移，那么修改某一个点就只用修改那一行的转移矩阵即可，然后线段树维护矩阵的乘积。最后求答案就求1-n的积，再乘两个答案向量即可。注意如果你转移是写的右乘，那么线段树乘法是右边乘以左边，反正要注意矩阵乘法的顺序。代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110#include &lt;bits/stdc++.h&gt;using namespace std;int n, m, q;const int mod = 1e9 + 7;const int maxn = 5e4 + 233;int c[maxn][14];struct Martix&#123; int m[14][14]; Martix()&#123; memset(m, 0, sizeof(m)); &#125;&#125;mat[maxn &lt;&lt; 2], base;void print(int o)&#123; for(int i = 1; i &lt;= m; i++)&#123; for(int j = 1; j &lt;= m; j++)&#123; printf("%d%c", mat[o].m[i][j], (j == m ? '\n' : ' ')); &#125; &#125;&#125;Martix operator*(const Martix &amp;a, const Martix &amp;b)&#123; Martix c; for(int i = 1; i &lt;= m; i++)&#123; for(int j = 1; j &lt;= m; j++)&#123; for(int k = 1; k &lt;= m; k++)&#123; c.m[i][j] = (c.m[i][j] + 1ll * a.m[i][k] * b.m[k][j]) % mod; &#125; &#125; &#125; return c;&#125;void pushup(int o)&#123; mat[o] = mat[o &lt;&lt; 1 | 1] * mat[o &lt;&lt; 1];&#125;void work(int o, int l)&#123; for(int i = 1; i &lt;= m; i++)&#123; int pl, pr; for(pl = i; pl; pl--)&#123; if(c[l][pl] == 1) break; &#125; for(pr = i; pr &lt;= m; pr++)&#123; if(c[l][pr] == 1) break; &#125; memset(mat[o].m[i], 0, sizeof(mat[o].m[i])); for(int j = pl + 1; j &lt;= pr - 1; j++)&#123; mat[o].m[i][j] = 1; &#125; &#125;&#125;void build(int o, int l, int r)&#123; if(l == r)&#123; work(o, l); return; &#125; int mid = l + r &gt;&gt; 1; build(o &lt;&lt; 1, l, mid); build(o &lt;&lt; 1 | 1, mid + 1, r); pushup(o);&#125;void update(int o, int tl, int tr, int pos)&#123; if(tr &lt; pos || pos &lt; tl) return; if(pos == tr &amp;&amp; pos == tl)&#123; work(o, tl); return; &#125; int mid = tl + tr &gt;&gt; 1; update(o &lt;&lt; 1, tl, mid, pos); update(o &lt;&lt; 1 | 1, mid + 1, tr, pos); pushup(o);&#125;Martix query(int o, int tl, int tr, int l, int r)&#123; if(tr &lt; l || r &lt; tl) return base; if(l &lt;= tl &amp;&amp; tr &lt;= r) return mat[o]; int mid = tl + tr &gt;&gt; 1; return query(o &lt;&lt; 1 | 1, mid + 1, tr, l, r) * query(o &lt;&lt; 1, tl, mid, l, r) ;&#125;int main()&#123; scanf("%d %d %d", &amp;n, &amp;m, &amp;q); for(int i = 1; i &lt;= m; i++)base.m[i][i] = 1; for(int i = 1; i &lt;= n; i++)&#123; for(int j = 1; j &lt;= m; j++)&#123; scanf("%1d", &amp;c[i][j]); &#125; &#125; build(1, 1, n); while(q--)&#123; int op, x, y; scanf("%d %d %d", &amp;op, &amp;x, &amp;y); if(op == 2)&#123; Martix res; res.m[x][1] = 1; res = query(1, 1, n, 1, n) * res; printf("%d\n", res.m[y][1]); &#125; else&#123; c[x][y] ^= 1; update(1, 1, n, x); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>线段树</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2019牛客暑期多校训练营(第二场)-D(Kth Minimum Clique)]]></title>
    <url>%2F2019%2F07%2F23%2F2019%E7%89%9B%E5%AE%A2%E6%9A%91%E6%9C%9F%E5%A4%9A%E6%A0%A1%E8%AE%AD%E7%BB%83%E8%90%A5-%E7%AC%AC%E4%BA%8C%E5%9C%BA-D-Kth-Minimum-Clique%2F</url>
    <content type="text"><![CDATA[链接：https://ac.nowcoder.com/acm/contest/882/D思路：考虑从小到大开始向外拓展，一个大的团一定是其中任意一个子集都是团，也就是说可以从小的往大的拓展，那么我们考虑从空点开始拓展，为了不重复，我们按节点编号从小到大拓展，这样就可以不重复了，因为每100个点会有1个点出堆，所以堆中最多10000个状态，也不会炸。代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;struct node&#123; ll w; bitset&lt;105&gt; sta; int id; bool operator&lt; (const node &amp;r) const&#123; return w &gt; r.w; &#125;&#125;;priority_queue&lt;node&gt; q;int n, k;bitset&lt;105&gt; mp[105];int v[105];ll bfs()&#123; q.push(node&#123;0, 0, 0&#125;); while(!q.empty())&#123; node p = q.top(); q.pop(); k--; if(!k)&#123; return p.w; &#125; for(int i = p.id + 1; i &lt;= n; i++)&#123; if((mp[i] &amp; p.sta) == p.sta)&#123; node t; t.id = i; t.sta = p.sta; t.sta[i] = 1; t.w = p.w + v[i]; q.push(t); &#125; &#125; &#125; return -1;&#125;int main()&#123; scanf("%d %d", &amp;n, &amp;k); for(int i = 1; i &lt;= n; i++) scanf("%d", &amp;v[i]); for(int i = 1; i &lt;= n; i++)&#123; for(int j = 1; j &lt;= n; j++)&#123; int x; scanf("%1d", &amp;x); mp[i][j] = x; &#125; &#125; printf("%lld\n", bfs()); return 0;&#125;]]></content>
      <categories>
        <category>bfs</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2019牛客暑期多校训练营(第二场)-B(Eddy Walker 2)]]></title>
    <url>%2F2019%2F07%2F23%2F2019%E7%89%9B%E5%AE%A2%E6%9A%91%E6%9C%9F%E5%A4%9A%E6%A0%A1%E8%AE%AD%E7%BB%83%E8%90%A5-%E7%AC%AC%E4%BA%8C%E5%9C%BA-B-Eddy-Walker-2%2F</url>
    <content type="text"><![CDATA[链接：https://ac.nowcoder.com/acm/contest/882/B思路：A的那个概率极其傻逼，没看到是前缀积一直以为结论错了，就不想写题解了。这个题首先讨论一下n无穷的情况，那么我们假设走k步，那么期望的步数就是1 + 2 + 3 + …. + k = $\frac{k * (k + 1)}{2}$，这之中踏过了k个点，那么某一个点踏过的概率就是$\frac{2}{k + 1}$，答案就是这个。如果不是无穷，我们就要考虑递推了，很明显的一个矩阵快速幂，但矩阵有1000大，普通矩阵快速幂要T，这个时候就要用BM了，具体原理看这里吧 https://www.cnblogs.com/LiuRunky/p/Berlekamp_Massey.html， 反正只要是线性递推，多放几项进去就可以推出后面的了，就当收一个板子了。代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122#include &lt;bits/stdc++.h&gt;using namespace std;#define rep(i,a,n) for (int i=a;i&lt;n;i++)#define per(i,a,n) for (int i=n-1;i&gt;=a;i--)#define pb push_back#define mp make_pair#define all(x) (x).begin(),(x).end()#define fi first#define se second#define SZ(x) ((int)(x).size())typedef vector&lt;int&gt; VI;typedef long long ll;typedef pair&lt;int, int&gt; PII;const ll mod = 1000000007;ll pow_mod(ll a, ll b) &#123; ll res = 1; a %= mod; assert(b &gt;= 0); for (; b; b &gt;&gt;= 1) &#123; if (b &amp; 1)res = res * a%mod; a = a * a%mod; &#125;return res; &#125;// headll n, k;ll inv;namespace linear_seq &#123; const int N = 10010; ll res[N], base[N], _c[N], _md[N]; vector&lt;int&gt; Md; void mul(ll *a, ll *b, int k) &#123; rep(i, 0, k + k) _c[i] = 0; rep(i, 0, k) if (a[i]) rep(j, 0, k) _c[i + j] = (_c[i + j] + a[i] * b[j]) % mod; for (int i = k + k - 1; i &gt;= k; i--) if (_c[i]) rep(j, 0, SZ(Md)) _c[i - k + Md[j]] = (_c[i - k + Md[j]] - _c[i] * _md[Md[j]]) % mod; rep(i, 0, k) a[i] = _c[i]; &#125; int solve(ll n, VI a, VI b) &#123; // a 系数 b 初值 b[n+1]=a[0]*b[n]+... // printf("%d\n",SZ(b)); ll ans = 0, pnt = 0; int k = SZ(a); assert(SZ(a) == SZ(b)); rep(i, 0, k) _md[k - 1 - i] = -a[i]; _md[k] = 1; Md.clear(); rep(i, 0, k) if (_md[i] != 0) Md.push_back(i); rep(i, 0, k) res[i] = base[i] = 0; res[0] = 1; while ((1ll &lt;&lt; pnt) &lt;= n) pnt++; for (int p = pnt; p &gt;= 0; p--) &#123; mul(res, res, k); if ((n &gt;&gt; p) &amp; 1) &#123; for (int i = k - 1; i &gt;= 0; i--) res[i + 1] = res[i]; res[0] = 0; rep(j, 0, SZ(Md)) res[Md[j]] = (res[Md[j]] - res[k] * _md[Md[j]]) % mod; &#125; &#125; rep(i, 0, k) ans = (ans + res[i] * b[i]) % mod; if (ans &lt; 0) ans += mod; return ans; &#125; VI BM(VI s) &#123; VI C(1, 1), B(1, 1); int L = 0, m = 1, b = 1; rep(n, 0, SZ(s)) &#123; ll d = 0; rep(i, 0, L + 1) d = (d + (ll) C[i] * s[n - i]) % mod; if (d == 0) ++m; else if (2 * L &lt;= n) &#123; VI T = C; ll c = mod - d * pow_mod(b, mod - 2) % mod; while (SZ(C) &lt; SZ(B) + m) C.pb(0); rep(i, 0, SZ(B)) C[i + m] = (C[i + m] + c * B[i]) % mod; L = n + 1 - L; B = T; b = d; m = 1; &#125; else &#123; ll c = mod - d * pow_mod(b, mod - 2) % mod; while (SZ(C) &lt; SZ(B) + m) C.pb(0); rep(i, 0, SZ(B)) C[i + m] = (C[i + m] + c * B[i]) % mod; ++m; &#125; &#125; return C; &#125; int gao(VI a, ll n) &#123; VI c = BM(a); c.erase(c.begin()); rep(i, 0, SZ(c)) c[i] = (mod - c[i]) % mod; return solve(n, c, VI(a.begin(), a.begin() + SZ(c))); &#125;&#125;;int T;ll f[3000];int main() &#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); cin &gt;&gt; T; while(T--)&#123; cin &gt;&gt; k &gt;&gt; n; if(n == -1)&#123; cout &lt;&lt; 2 * pow_mod(k + 1, mod - 2) % mod &lt;&lt; '\n'; continue; &#125; VI dp; for(int i = 0; i &lt;= 2 * k; i++) f[i] = 0; f[0] = 1; inv = pow_mod(k, mod - 2); for(int i = 1; i &lt;= 2 * k; i++)&#123; for(int j = 1; j &lt;= k; j++)&#123; if(i &gt;= j) f[i] = (f[i] + f[i - j] * inv) % mod; &#125; &#125; for(int i = 0; i &lt;= 2 * k; i++) dp.push_back(f[i]); cout &lt;&lt; linear_seq::gao(dp, n) &lt;&lt; '\n'; &#125; return 0;&#125;]]></content>
      <categories>
        <category>矩阵快速幂</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[HDU-3949(XOR)]]></title>
    <url>%2F2019%2F07%2F19%2FHDU-3949-XOR%2F</url>
    <content type="text"><![CDATA[链接：http://acm.hdu.edu.cn/showproblem.php?pid=3949思路：先推荐一篇博客，比较清楚 https://blog.csdn.net/SSimpLe_Y/article/details/79872441 线性基概念拿这个模板题来讲讲线性基。回想线性代数中的极大无关组，即用极大无关组可以的线性组合可以表示出其他所有向量。在异或的运算下，线性基可以通过运算表示处其他所有的元素。 线性基构造算法的性质1、任何一个元素都可以被线性基表示，且表方法唯一。前者是线性基的性质，后者采取反证法，考虑不唯一，那么有两个子集能表示，消掉元素后得到存在两个不同的子集的异或和相等，与线性基定一矛盾。2、线性基构造出来所需的元素等于秩。3、构造出来线性基呈上三角矩阵，通过高斯消元（rebuild）可以将其变换为对角矩阵。 构造方法构造方法很简单，直接从高位开始往低位枚举，如果当前这位没有元素且待插入元素这位为1，则把元素插入到这里，然后退出。否则将其与该位已经存在的元素异或。 几个经典问题1、求异或和最大:如果是上三角矩阵，采取从高位到低位的贪心策略，即异或后变大就异或，否则不异或，最后返回结果。如果是对角矩阵，直接把所有的线性基异或起来即可。2、求异或和最小：找到最小的位置存在的线性基即可3、求第k小：这时候用构造出的上三角矩阵就不能解决这个问题了，我们要把上三角矩阵变换成对角矩阵，然后再把不为零的都按顺序拿出来。这时候矩阵已经变成对角矩阵（至少是行最简形矩阵），我们异或上某一行的值，答案就会变大一点。我们可以想象，从一个数组 a = {8,4,2,1}中选出几个，求能组成第k小的值是多少，利用二进制的性质，如果k的二进制第i位为1，我们就加上数组里第i大的数。这里的异或上一个值也会变大一点，所以可以用同样的思想。记得要特判是否存在0，方法是看n的大小和秩的大小是否相等，相等则说明线性无关，即不存在。4、存在性：看能否插入即可，不能插入则存在。 本题就解决了。。。。代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;struct Linebasis&#123; ll p[65], b[65]; int cnt; bool flag; void init()&#123; memset(p, 0, sizeof(p)); memset(b, 0, sizeof(b)); cnt = 0; flag = false; &#125; bool insert(ll x)&#123; for(int i = 62; i &gt;= 0; i--)&#123; if((x &gt;&gt; i) &amp; 1)&#123; if(!p[i])&#123; p[i] = x; break; &#125; x ^= p[i]; &#125; &#125; if(x) cnt++; else flag = true; return x &gt; 0; &#125; Linebasis operator +(const Linebasis &amp; r) const&#123; Linebasis res = r; for(int i = 0; i &lt;= 62; i++) &#123; if(p[i]) res.insert(p[i]); &#125; return res; &#125; ll querymax(ll x = 0)&#123; ll res = x; for(int i = 62; i &gt;= 0; i--)&#123; if((res ^ p[i]) &gt; res) res ^= p[i]; &#125; return res; &#125; ll querymin()&#123; for(int i = 0; i &lt;= 62; i++)&#123; if(p[i]) return p[i]; &#125; return 0; &#125; void rebuild()&#123; for(int i = 62; i &gt;= 0; i--)&#123; for(int j = i - 1; j &gt;= 0; j--)&#123; if((p[i] &gt;&gt; j) &amp; 1) p[i] ^= p[j]; &#125; &#125; cnt = 0; for(int i = 0; i &lt;= 62; i++)&#123; if(p[i]) b[cnt++] = p[i]; &#125; &#125; ll kthmax(ll k)&#123; if(flag) k--; ll res = 0; if(!k) return 0; if(k &gt;= (1ll &lt;&lt; cnt)) return -1; for(int i = 62; i &gt;= 0; i--)&#123; if((k &gt;&gt; i) &amp; 1) res ^= b[i]; &#125; return res; &#125;&#125;sol;int main()&#123; int n, T, q; ll k; scanf("%d", &amp;T); for(int kase = 1; kase &lt;= T; kase++) &#123; sol.init(); scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) &#123; ll x; scanf("%lld", &amp;x); sol.insert(x); &#125; scanf("%d", &amp;q); printf("Case #%d:\n", kase); sol.rebuild(); while(q--)&#123; scanf("%lld", &amp;k); printf("%lld\n", sol.kthmax(k)); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>线性基</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2019牛客暑期多校训练营(第一场)-H(XOR)]]></title>
    <url>%2F2019%2F07%2F19%2F2019%E7%89%9B%E5%AE%A2%E6%9A%91%E6%9C%9F%E5%A4%9A%E6%A0%A1%E8%AE%AD%E7%BB%83%E8%90%A5-%E7%AC%AC%E4%B8%80%E5%9C%BA-H-XOR%2F</url>
    <content type="text"><![CDATA[链接：https://ac.nowcoder.com/acm/contest/881/H思路：在下一篇的线性基模板题我再补充一下线性基的一些东西，本篇主要讲下知道了线性基怎么做这个题。考虑这个式子，看到某种合法方案 方案里的元素个数，自然想到转换为统计单点贡献，即每个数在多少种方案中出现。那么我们考虑某个元素必选，还剩下n - 1个元素，我们用这n - 1个元素来构造线性基，设秩为r，如果这个元素能被这n - 1个元素的线性基表示，那么方案数就是$2^{n - r - 1}$。简单证明一下，首先如果不能表示，说明线性基和该元素线性无关，则不可能异或和为0（异或和为0必须二者相等），所以贡献为0。如果能表示，考虑在非基元素中选一个子集，其基内元素必有唯一的子集与之对应使得整个的异或和为0（如果有两个，说明基内有两个不同的子集使得和相等，约掉后得到基内有两个不同子集的异或和相等，与线性基的定义矛盾），所以这样做出来保证了所有合法的方案都被统计到了。剩下的就是考虑如何统计，每次暴力建基肯定不行，我们可以先把n个元素的线性基建出来，其秩最多为62，对于非基元素的贡献都一样，总的贡献是(n - r) $2^{n - r - 1}$，那么剩下我们只用考虑基内元素即可。我们把非基元素建一个线性基，每次枚举一个基内元素，再将剩下元素和非基元素的线性基合并，如果合并后的线性基与整个的线性基秩相等，说明可以表示，就统计贡献，否则贡献为0。记得特判一下，当秩和总元素个数相等的时候答案为0即可。代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int n;const int maxn = 1e5 + 5;const int mod = 1e9 + 7;ll a[maxn];vector&lt;ll&gt; r;ll pow_mod(ll q, ll w)&#123; ll ret = 1; while(w)&#123; if(w &amp; 1) ret = ret * q % mod; q = q * q % mod; w &gt;&gt;= 1; &#125; return ret;&#125;struct Linebasis&#123; ll p[65], b[65]; int cnt; bool flag; void init()&#123; memset(p, 0, sizeof(p)); memset(b, 0, sizeof(b)); cnt = 0; flag = false; &#125; bool insert(int i)&#123; ll x = a[i]; for(int i = 62; i &gt;= 0; i--)&#123; if((x &gt;&gt; i) &amp; 1)&#123; if(!p[i])&#123; p[i] = x; break; &#125; x ^= p[i]; &#125; &#125; if(x) cnt++; else flag = true; return x &gt; 0; &#125; Linebasis operator +(const Linebasis &amp; r) const&#123; Linebasis res = r; for(int i = 0; i &lt;= 62; i++) &#123; if(p[i]) res.insert(p[i]); &#125; return res; &#125; ll querymax(ll x = 0)&#123; ll res = x; for(int i = 62; i &gt;= 0; i--)&#123; if((res ^ p[i]) &gt; res) res ^= p[i]; &#125; return res; &#125; ll querymin()&#123; for(int i = 0; i &lt;= 62; i++)&#123; if(p[i]) return p[i]; &#125; return 0; &#125; void rebuild()&#123; for(int i = 62; i &gt;= 0; i--)&#123; for(int j = i - 1; j &gt;= 0; j--)&#123; if((p[i] &gt;&gt; j) &amp; 1) p[i] ^= p[j]; &#125; &#125; cnt = 0; for(int i = 0; i &lt;= 62; i++)&#123; if(p[i]) b[cnt++] = p[i]; &#125; &#125; ll kthmax(ll k)&#123; if(flag) k--; ll res = 0; if(!k) return 0; if(k &gt;= (1ll &lt;&lt; cnt)) return -1; for(int i = 62; i &gt;= 0; i--)&#123; if((k &gt;&gt; i) &amp; 1) res ^= b[i]; &#125; return res; &#125;&#125;sol, other, tmp;int main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); while(cin &gt;&gt; n)&#123; for(int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i]; r.clear(); sol.init(); other.init(); for(int i = 1; i &lt;= n; i++) &#123; if(!sol.insert(i)) other.insert(i); else r.push_back(i); &#125; if(sol.cnt == n)&#123; cout &lt;&lt; "0\n"; continue; &#125; ll fp = pow_mod(2, (n - sol.cnt - 1)); ll res = (n - sol.cnt) * fp % mod; for(int i = 0; i &lt; r.size(); i++)&#123; tmp = other; for(int j = 0; j &lt; r.size(); j++)&#123; if(i == j) continue; tmp.insert(r[j]); &#125; if(tmp.cnt == sol.cnt) res = (res + fp) % mod; &#125; cout &lt;&lt; res &lt;&lt; '\n'; &#125; return 0;&#125;]]></content>
      <categories>
        <category>线性基</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2019牛客暑期多校训练营(第一场)-I(Points Division)]]></title>
    <url>%2F2019%2F07%2F19%2F2019%E7%89%9B%E5%AE%A2%E6%9A%91%E6%9C%9F%E5%A4%9A%E6%A0%A1%E8%AE%AD%E7%BB%83%E8%90%A5-%E7%AC%AC%E4%B8%80%E5%9C%BA-I-Points-Division%2F</url>
    <content type="text"><![CDATA[链接：https://ac.nowcoder.com/acm/contest/881/I思路：按题意，我们可以找到一条折线把点划分为a，b两个集合，考虑在这个折线上dp，我们假设初始全是b集合的点，我们用dp[i]表示选的a集合的点种高度y最大为i的最大值，考虑转移：如果当前点要选为a，它的高度为y，那么只能从1-y-1的dp状态转移过来，那么需要把1-y-1的值都加上a-b的差值；如果当前点选b，那么可以由1-y转移过来，并且值为1-y里面的最大值。这个过程我们可以用线段树来维护。线段树上维护最大值，update表示区间加，这样就可以满足上述操作。注意如果有一些点是y值相同，我们需要从上到下处理，这是因为上面的y是不能由同x的下面的y转移过来的，所以从上到下处理就避免了这个问题。代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 1e5 + 233;int n;ll mx[maxn &lt;&lt; 2], tag[maxn &lt;&lt; 2];vector&lt;int&gt; pos;void pushup(int o)&#123; mx[o] = max(mx[o &lt;&lt; 1], mx[o &lt;&lt; 1 | 1]);&#125;void pushdown(int o)&#123; if(tag[o])&#123; mx[o &lt;&lt; 1] += tag[o]; mx[o &lt;&lt; 1 | 1] += tag[o]; tag[o &lt;&lt; 1] += tag[o]; tag[o &lt;&lt; 1 | 1] += tag[o]; tag[o] = 0; &#125;&#125;void build(int o, int l, int r)&#123; tag[o] = 0; if(l == r) &#123; mx[o] = 0; return; &#125; int mid = l + r &gt;&gt; 1; build(o &lt;&lt; 1, l, mid); build(o &lt;&lt; 1 | 1, mid + 1, r); pushup(o);&#125;void update(int o, int tl, int tr, int l, int r, ll v)&#123; if(tl &gt; r || tr &lt; l) return; if(l &lt;= tl &amp;&amp; tr &lt;= r)&#123; mx[o] += v; tag[o] += v; return; &#125; int mid = tl + tr &gt;&gt; 1; pushdown(o); update(o &lt;&lt; 1, tl, mid, l, r, v); update(o &lt;&lt; 1 | 1, mid + 1, tr, l, r, v); pushup(o);&#125;ll query(int o, int tl, int tr, int l, int r)&#123; if(tl &gt; r || tr &lt; l) return -1e18; if(l &lt;= tl &amp;&amp; tr &lt;= r) return mx[o]; pushdown(o); int mid = tl + tr &gt;&gt; 1; return max(query(o &lt;&lt; 1, tl, mid, l, r), query(o &lt;&lt; 1 | 1, mid + 1, tr, l, r));&#125;struct node&#123; int x, y, a, b; bool operator&lt;(const node &amp;r) const&#123; return x &lt; r.x || (x == r.x &amp;&amp; y &gt; r.y); &#125;&#125;q[maxn];int main() &#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); while (cin &gt;&gt; n) &#123; pos.clear(); pos.push_back(0); ll sum = 0; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; q[i].x &gt;&gt; q[i].y &gt;&gt; q[i].a &gt;&gt; q[i].b; pos.push_back(q[i].y); &#125; sort(q + 1, q + n + 1); for (int i = 1; i &lt;= n; i++) sum += q[i].b; sort(pos.begin(), pos.end()); pos.resize(unique(pos.begin(), pos.end()) - pos.begin()); build(1, 1, pos.size()); for (int i = 1; i &lt;= n; i++) &#123; int y = lower_bound(pos.begin(), pos.end(), q[i].y) - pos.begin() + 1; ll x1 = query(1, 1, pos.size(), 1, y); ll x2 = query(1, 1, pos.size(), y, y); update(1, 1, pos.size(), 1, y - 1, q[i].a - q[i].b); update(1, 1, pos.size(), y, y, x1 - x2); &#125; cout &lt;&lt; sum + query(1, 1, pos.size(), 1, pos.size()) &lt;&lt; '\n'; &#125; return 0;&#125;]]></content>
      <categories>
        <category>线段树</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2019牛客暑期多校训练营(第一场)-C(Euclidean Distance)]]></title>
    <url>%2F2019%2F07%2F19%2F2019%E7%89%9B%E5%AE%A2%E6%9A%91%E6%9C%9F%E5%A4%9A%E6%A0%A1%E8%AE%AD%E7%BB%83%E8%90%A5-%E7%AC%AC%E4%B8%80%E5%9C%BA-C-Euclidean-Distance%2F</url>
    <content type="text"><![CDATA[链接：https://ac.nowcoder.com/acm/contest/881#question思路：题解说的什么拉格朗日乘子法完全忘了啊，，，后面有空再补吧，其实仔细分析这个题贪心是能做的。考虑对于$a_i$ &lt; 0的部分其实是没用的，用0去匹配最小代价，而且不消耗贡献，肯定选0，那么问题就变成了$a_i &gt; 0$的部分怎么匹配是最好的，很容易发现，假设我们把每个$p_i$放到对应的$a_i$上再调整，大的$a_i$调整相同距离需要的代价更大，也就是说如果不得不离一定距离，我们希望大的$a_i$差的距离更小，那么其实我们就只用从大到小匹配到最多的位置，把m全部分配到这一段位置内，所有点$p_i$相等，为这一段的平均点，后面的点都放在0处即可。顺便从hs那里收获一枚分数运算的板子代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;ll n, m;const int maxn = 1e5 + 233;ll a[maxn], sum[maxn];struct frac&#123; ll x, y; frac(ll a, ll b)&#123; assert(b); if(b &lt; 0) a = -a, b = -b; if(a)&#123; ll g = __gcd(abs(a), b); a /= g; b /= g; &#125; else b = 1; x = a, y = b; &#125; frac(ll a)&#123; x = a, y = 1; &#125; void print()&#123; if(y == 1) printf("%lld\n", x); else printf("%lld/%lld\n", x, y); &#125; frac operator+(const frac &amp;r) const&#123; return frac(x * r.y + y * r.x, y * r.y); &#125; frac operator-(const frac &amp;r) const&#123; return frac(x * r.y - y * r.x, y * r.y); &#125; frac operator*(const frac &amp;r) const&#123; return frac(x * r.x, y * r.y); &#125; frac operator/(const frac &amp;r) const&#123; return frac(x * r.y, y * r.x); &#125;&#125;;int main()&#123; while(~scanf("%lld %lld", &amp;n, &amp;m)) &#123; for (int i = 1; i &lt;= n; i++) scanf("%lld", &amp;a[i]); sort(a + 1, a + n + 1, greater&lt;ll&gt;()); for (int i = 1; i &lt;= n; i++) sum[i] = sum[i - 1] + a[i]; int k = 1; for (int i = 1; i &lt;= n; i++) &#123; if (sum[i] - i * a[i] &lt;= m) &#123; k = i; &#125; &#125; frac res = (frac(sum[k], m) - 1) / k; res = res * res * k; for (int i = k + 1; i &lt;= n; i++) &#123; res = res + frac(a[i], m) * frac(a[i], m); &#125; res.print(); &#125; return 0;&#125;]]></content>
      <categories>
        <category>贪心</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[bzoj-2780(Sevenk Love Oimaster)]]></title>
    <url>%2F2019%2F07%2F18%2Fbzoj-2780-Sevenk-Love-Oimaster%2F</url>
    <content type="text"><![CDATA[链接：https://www.lydsy.com/JudgeOnline/problem.php?id=2780思路：喜闻乐见SAM, SA, AC都可以做的题，而且每种都是非常有代表性的，挨个讲一讲，篇幅比较长。 1.后缀自动机:这个好像其实就算是广义后缀自动机？每次插完一个串后把last置为root，然后继续插下一个串。考虑询问串在SAM上跑，跑到最终节点，那么它fail树的子树上都是该子串的后缀，那么问询问串在多少个模板串中出现过，其实就是问最终节点的子树中有多少不同种类的模板串。这里一共有如下三种方法：1.1:树上莫队：区间不同种类数，那么dfs序后转树上莫队是个比较常见的做法，复杂度O(n$\sqrt{n}$)1.2:SAM上暴力跳：在每次插模板串的每个字符后，都从该点开始沿fail树暴力跳到根节点，然后路上更新每个点是否出现过该种串，以及总的出现次数，最后找到询问串对应最终节点，访问答案即可。暴力跳的复杂度已经证明过也是O(n$\sqrt{n}$)的。1.3:dfs序 + 树状数组：区间种类数还有树状数组的做法，按右端点排序，然后统计出每种串相同的最近前面出现的位置，离线树状数组统计答案即可。复杂度O(nlogn)。 2.后缀数组：后缀数组就是老套路，把所有串拼起来，中间用一个没出现过的字符分割来，然后找到每一个询问串对应的位置，两边二分找到最远的lcp &gt;= 当前len的位置，在这个l到r区间里统计模板串不同出现次数，两种做法：2.1:莫队：变成了区间里的莫队，统计即可。2.2：dfs序 + 树状数组：同上 3.AC自动机：AC自动机可能是最容易错的一种做法，因为它的fail树和SAM的fail树实在是容易混淆。AC自动机的fail树是最长后缀与前缀相同。我们对询问串建立AC自动机，拿模板串在上面跑，跑过的所有点都要++，然后再统计子树信息即可，方法同上。3.1:莫队：变成了区间里的莫队，统计即可。3.2：dfs序 + 树状数组：同上代码：SAM暴力跳：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include&lt;bits/stdc++.h&gt;#define sigma_size 28using namespace std;const int maxn = 4e5 + 5;const int mod = 1e9 + 7;typedef long long ll;int len[maxn * 2]; //最长子串的长度(该节点字串数量=len[x]-len[f[x]])int f[maxn * 2]; //后缀链接(最短串前部减少一个字符所到达的状态)int cnt[maxn * 2]; //被后缀连接的数int ch[maxn * 2][sigma_size]; //状态转移(尾部加一个字符的下一个状态)(图)int idx; //节点编号int last; //最后节点ll epos[maxn * 2]; // enpos数（该状态子串出现数量）char s[maxn];int vis[maxn * 2];int res[maxn * 2];int n, q; void init() &#123; //初始化 last = idx = 1; //1表示root起始点 空集 f[1] = len[1] = 0; memset(ch[1], 0, sizeof(ch[1]));&#125; //SAM建图void add(int c, int id) &#123; //插入字符，为字符ascll码值 int x = ++idx; //创建一个新节点x; len[x] = len[last] + 1; // 长度等于最后一个节点+1 epos[x] = 1; //接受节点子串除后缀连接还需加一 int p; //第一个有C转移的节点; for (p = last; p &amp;&amp; !ch[p][c]; p = f[p])ch[p][c] = x;//沿着后缀连接 将所有没有字符c转移的节点直接指向新节点 if (!p)f[x] = 1, cnt[1]++; //全部都没有c的转移 直接将新节点后缀连接到起点 else &#123; int q = ch[p][c]; //p通过c转移到的节点 if (len[p] + 1 == len[q]) //pq是连续的 f[x] = q, cnt[q]++; //将新节点后缀连接指向q即可,q节点的被后缀连接数+1 else &#123; int nq = ++idx; //不连续 需要复制一份q节点 len[nq] = len[p] + 1; //令nq与p连续 vis[nq] = vis[q]; res[nq] = res[q]; //别忘了复制多添加的信息。 f[nq] = f[q]; //因后面link[q]改变此处不加cnt memcpy(ch[nq], ch[q], sizeof(ch[q])); //复制q的信息给nq for (; p &amp;&amp; ch[p][c] == q; p = f[p]) ch[p][c] = nq; //沿着后缀连接 将所有通过c转移为q的改为nq f[q] = f[x] = nq; //将x和q后缀连接改为nq cnt[nq] += 2; // nq增加两个后缀连接 &#125; &#125; last = x; //更新最后处理的节点 for(; vis[x] != id &amp;&amp; x; x = f[x])&#123; vis[x] = id, res[x]++; &#125;&#125; int main() &#123; scanf("%d%d", &amp;n, &amp;q); init(); for(int i = 1; i &lt;= n; i++)&#123; scanf("%s", s + 1); last = 1; for(int j = 1, len = strlen(s + 1); j &lt;= len; j++) add(s[j] - 'a', i); &#125; while(q--)&#123; scanf("%s", s + 1); int now = 1; int i, len = strlen(s + 1); for(i = 1; i &lt;= len; i++)&#123; if(ch[now][s[i] - 'a']) now = ch[now][s[i] - 'a']; else break; &#125; if(i == len + 1) printf("%d\n", res[now]); else puts("0"); &#125; return 0;&#125; SAM + dfs序 + 树状数组123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140#include&lt;bits/stdc++.h&gt;#define sigma_size 28using namespace std;const int maxn = 1e5 + 5;const int mod = 1e9 + 7;typedef long long ll;int len[maxn * 2]; //最长子串的长度(该节点字串数量=len[x]-len[f[x]])int f[maxn * 2]; //后缀链接(最短串前部减少一个字符所到达的状态)int cnt[maxn * 2]; //被后缀连接的数int ch[maxn * 2][sigma_size]; //状态转移(尾部加一个字符的下一个状态)(图)int idx; //节点编号int last; //最后节点char s[maxn];vector&lt;int&gt; sta[maxn * 2];int n, m;int in[maxn * 2];int sz;vector&lt;int&gt; G[maxn * 2];int pre[maxn * 2];vector&lt;int&gt; ne[maxn * 2];int out[maxn * 2];int c[maxn * 2];int id[maxn * 2]; struct node&#123; int l, r, id; bool operator &lt;(const node &amp;x) const&#123; return r &lt; x.r; &#125;&#125;q[maxn]; int res[maxn]; int lowbit(int x)&#123; return x &amp; (-x);&#125; void update(int x, int d)&#123; while(x &lt; maxn * 2)&#123; c[x] += d; x += lowbit(x); &#125;&#125; int query(int x)&#123; int ret = 0; while(x)&#123; ret += c[x]; x -= lowbit(x); &#125; return ret;&#125; void init() &#123; //初始化 last = idx = 1; //1表示root起始点 空集 f[1] = len[1] = 0; memset(ch[1], 0, sizeof(ch[1]));&#125; //SAM建图void add(int c, int id) &#123; //插入字符，为字符ascll码值 int x = ++idx; //创建一个新节点x; len[x] = len[last] + 1; // 长度等于最后一个节点+1 int p; //第一个有C转移的节点; for (p = last; p &amp;&amp; !ch[p][c]; p = f[p])ch[p][c] = x;//沿着后缀连接 将所有没有字符c转移的节点直接指向新节点 if (!p)f[x] = 1, cnt[1]++; //全部都没有c的转移 直接将新节点后缀连接到起点 else &#123; int q = ch[p][c]; //p通过c转移到的节点 if (len[p] + 1 == len[q]) //pq是连续的 f[x] = q, cnt[q]++; //将新节点后缀连接指向q即可,q节点的被后缀连接数+1 else &#123; int nq = ++idx; //不连续 需要复制一份q节点 len[nq] = len[p] + 1; //令nq与p连续 f[nq] = f[q]; //因后面link[q]改变此处不加cnt memcpy(ch[nq], ch[q], sizeof(ch[q])); //复制q的信息给nq for (; p &amp;&amp; ch[p][c] == q; p = f[p]) ch[p][c] = nq; //沿着后缀连接 将所有通过c转移为q的改为nq f[q] = f[x] = nq; //将x和q后缀连接改为nq cnt[nq] += 2; // nq增加两个后缀连接 &#125; &#125; last = x; //更新最后处理的节点 sta[x].push_back(id);&#125; void dfs(int u, int fa)&#123; in[u] = ++sz; id[sz] = u; for(int i = 0; i &lt; G[u].size(); i++)&#123; int v = G[u][i]; if(v == fa) continue; dfs(v, u); &#125; out[u] = sz;&#125; int main() &#123; scanf("%d %d", &amp;n, &amp;m); init(); for(int i = 1; i &lt;= n; i++)&#123; scanf("%s", s); last = 1; for(int j = 0, len = strlen(s); j &lt; len; j++) add(s[j] - 'a', i); &#125; for(int i = 1; i &lt;= idx; i++) &#123; G[f[i]].push_back(i); &#125; dfs(1, 0); for(int i = 1; i &lt;= m; i++)&#123; scanf("%s", s); int now = 1; for(int j = 0, len = strlen(s); j &lt; len &amp;&amp; now; j++)&#123; now = ch[now][s[j] - 'a']; &#125; q[i].l = in[now], q[i].r = out[now], q[i].id = i; &#125; for(int i = 1; i &lt;= sz; i++)&#123; for(int j = 0; j &lt; sta[id[i]].size(); j++)&#123; if(pre[sta[id[i]][j]]) ne[i].push_back(pre[sta[id[i]][j]]); pre[sta[id[i]][j]] = i; &#125; &#125; sort(q + 1, q + m + 1); int j = 1; for(int i = 1; i &lt;= m; i++)&#123; if(q[i].r == 0) continue; while(j &lt;= sz &amp;&amp; j &lt;= q[i].r)&#123; for(int k = 0; k &lt; ne[j].size(); k++)&#123; update(ne[j][k], -1); &#125; update(j, sta[id[j]].size()); j++; &#125; res[q[i].id] = query(q[i].r) - query(q[i].l - 1); &#125; for(int i = 1; i &lt;= m; i++) cout &lt;&lt; res[i] &lt;&lt; '\n'; return 0;&#125; SA + 树状数组(有点卡常过不了)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 600005;int s[maxn];int sa[maxn],t[maxn],t2[maxn],c[maxn], n,m, tt;int r[maxn], h[maxn];int d[maxn][25];char ch[maxn]; //n为原字符长度，放于s[]的0-n-1位置，s[n]为0，build_sa传入的参数为（n+1，字符范围） void build_sa(int n, int m) &#123;//n为原串长度+1，字符值在0-m-1 int i, *x = t, *y = t2; for (i = 0; i &lt; m; i++)c[i] = 0; for (i = 0; i &lt; n; i++)c[x[i] = s[i]]++; for (i = 1; i &lt; m; i++)c[i] += c[i - 1]; for (i = n - 1; i &gt;= 0; i--)sa[--c[x[i]]] = i; for (int k = 1; k &lt;= n; k &lt;&lt;= 1) &#123; int p = 0; for (i = n - k; i &lt; n; i++)y[p++] = i; for (i = 0; i &lt; n; i++)if (sa[i] &gt;= k)y[p++] = sa[i] - k; for (i = 0; i &lt; m; i++)c[i] = 0; for (i = 0; i &lt; n; i++)c[x[y[i]]]++; for (i = 0; i &lt; m; i++)c[i] += c[i - 1]; for (i = n - 1; i &gt;= 0; i--)sa[--c[x[y[i]]]] = y[i]; swap(x, y); p = 1; x[sa[0]] = 0; for (i = 1; i &lt; n; i++) x[sa[i]] = y[sa[i - 1]] == y[sa[i]] &amp;&amp; y[sa[i - 1] + k] == y[sa[i] + k] ? p - 1 : p++; if (p &gt;= n)break; m = p; &#125;&#125; //最好从0开始，这样sa[n-1] = 0,可以把上一次的数据清空void getheight() &#123; int i, j, k = 0; for (i = 1; i &lt;= n; i++) r[sa[i]] = i; for (i = 0; i &lt; n; h[r[i++]] = k) for (k ? k-- : 0, j = sa[r[i] - 1]; s[i + k] == s[j + k]; k++);&#125; struct node&#123; int l, r, id; bool operator &lt;(const node &amp;x) const&#123; return r &lt; x.r; &#125;&#125;q[60010]; int res[60010], tmp[maxn], pos[maxn], sum[maxn]; int lowbit(int x)&#123; return x &amp; (-x);&#125; void add(int x, int d)&#123; while(x &lt; maxn)&#123; sum[x] += d; x += lowbit(x); &#125;&#125; int query(int x)&#123; int ret = 0; while(x)&#123; ret += sum[x]; x -= lowbit(x); &#125; return ret;&#125; void RMQ_init() &#123; for (int i = 1; i &lt;= n; i++)d[i][0] = h[i]; for (int j = 1; (1 &lt;&lt; j) &lt;= n; j++) for (int i = 1; i + (1 &lt;&lt; j) - 1 &lt;= n; i++) d[i][j] = min(d[i][j - 1], d[i + (1 &lt;&lt; (j - 1))][j - 1]);&#125; int RMQ(int l, int r) &#123; if (l &gt; r)swap(l, r); int k = 0; while (1 &lt;&lt; (k + 1) &lt;= r - l + 1)k++; return min(d[l][k], d[r - (1 &lt;&lt; k) + 1][k]);&#125; int ask[60010];int len[60010];int pre[maxn], ne[maxn]; int main()&#123; scanf("%d %d", &amp;tt, &amp;m); for(int i = 1; i &lt;= tt; i++)&#123; scanf("%s", ch); for(int j = 0, len = strlen(ch); j &lt; len; j++)&#123; s[n] = ch[j] - 'a' + 1; tmp[n++] = i; &#125; s[n++] = 30 + i; &#125; for(int i = 1; i &lt;= m; i++)&#123; scanf("%s", ch); ask[i] = n; len[i] = strlen(ch); for(int j = 0; j &lt; len[i]; j++)&#123; s[n++] = ch[j] - 'a' + 1; &#125; s[n++] = 30 + tt + i; &#125; s[n] = 0; build_sa(n + 1, tt + m + 35); getheight(); RMQ_init(); for(int i = 1; i &lt;= n; i++) pos[i] = tmp[sa[i]]; for(int i = 1; i &lt;= m; i++)&#123; int id = r[ask[i]]; int lb = 1, ub = id - 1, pl = id, pr = id; if(h[id] &lt; len[i])&#123; q[i].l = q[i].r = id; q[i].id = i; continue; &#125; while(ub &gt;= lb)&#123; int mid = ub + lb &gt;&gt; 1; if(RMQ(mid + 1, id) &gt;= len[i]) ub = mid - 1, pl = mid; else lb = mid + 1; &#125; lb = id + 1, ub = n; while(ub &gt;= lb)&#123; int mid = ub + lb &gt;&gt; 1; if(RMQ(id + 1, mid) &gt;= len[i]) lb = mid + 1, pr = mid; else ub = mid - 1; &#125; q[i].l = pl, q[i].r = pr, q[i].id = i; &#125; sort(q + 1, q + m + 1); for(int i = 1; i &lt;= n; i++)&#123; ne[i] = pre[pos[i]]; pre[pos[i]] = i; &#125; int j = 1; for(int i = 1; i &lt;= m; i++)&#123; while(j &lt;= n &amp;&amp; j &lt;= q[i].r)&#123; if(!pos[j]) &#123; j++; continue; &#125; if(ne[j]) add(ne[j], -1); add(j, 1); j++; &#125; res[q[i].id] = query(q[i].r) - query(q[i].l - 1); &#125; for(int i = 1; i &lt;= m; i++) cout &lt;&lt; res[i] &lt;&lt; '\n'; return 0;&#125; AC自动机 + dfs序 + 树状数组123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178#include&lt;bits/stdc++.h&gt;using namespace std; const int maxnode = 6e5 + 100;const int sigma_size = 26;int n, m; string str[10010];string s; typedef long long ll;int ch[maxnode][sigma_size];int val[maxnode];int f[maxnode];int last[maxnode];int sz;vector&lt;int&gt; pos[maxnode];vector&lt;int&gt; sta[maxnode], ne[maxnode];ll c[maxnode];vector&lt;int&gt; G[maxnode];int in[maxnode], out[maxnode], id;int pre[maxnode], rk[maxnode];bool vis[maxnode]; int lowbit(int x)&#123; return x &amp; (-x);&#125; void add(int x, int d)&#123; while(x &lt; maxnode)&#123; c[x] += d; x += lowbit(x); &#125;&#125; ll query(int x)&#123; int ret = 0; while(x)&#123; ret += c[x]; x -= lowbit(x); &#125; return ret;&#125; void init() &#123; sz = 1; memset(ch[0], 0, sizeof(ch[0]));&#125; int idx(char c) &#123; return c - 'a';&#125; void insert(string s ,int v, int x) &#123; int u = 0; for (int i = 0; i &lt; s.size(); i++) &#123; int c = idx(s[i]); if (!ch[u][c]) &#123; ch[u][c] = sz; memset(ch[sz], 0, sizeof(ch[sz])); val[sz++] = 0; &#125; u = ch[u][c]; &#125; val[u] = v; pos[u].push_back(x);&#125; void getfail() &#123; queue&lt;int&gt; q; f[0] = 0; for (int i = 0; i &lt; sigma_size; i++) &#123; int u = ch[0][i]; if (u) &#123; f[u] = last[u] = 0; q.push(u); &#125; &#125; while (!q.empty()) &#123; int r = q.front(); q.pop(); //val[r] |= val[f[r]]; //AC自动机 + dp时会用 for (int c = 0; c &lt; sigma_size; c++) &#123; int u = ch[r][c]; if (!u) &#123; ch[r][c] = ch[f[r]][c]; continue; &#125; q.push(u); int v = f[r]; while (v &amp;&amp; !ch[v][c])v = f[v]; f[u] = ch[v][c]; last[u] = val[f[u]] ? f[u] : last[f[u]]; &#125; &#125;&#125; void find(string s, int x) &#123; int j = 0; for (int i = 0; i &lt; s.size(); i++) &#123; int c = idx(s[i]); j = ch[j][c]; sta[j].push_back(x); //跑过的所有点都要统计信息 &#125;&#125; void dfs(int u, int fa)&#123; vis[u] = 1; in[u] = ++id; rk[id] = u; for(int i = 0; i &lt; G[u].size(); i++)&#123; int v = G[u][i]; if(v == fa) continue; dfs(v, u); &#125; out[u] = id;&#125; struct node&#123; int l, r, id; bool operator &lt; (const node &amp;x) const&#123; return r &lt; x.r; &#125;&#125;q[60010];ll res[60010]; int main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); cin &gt;&gt; n &gt;&gt; m; init(); for(int i = 1; i &lt;= n; i++)&#123; cin &gt;&gt; str[i]; &#125; for(int i = 1; i &lt;= m; i++) &#123; cin &gt;&gt; s; insert(s, 1, i); &#125; getfail(); for(int i = 1; i &lt;= n; i++)&#123; find(str[i], i); &#125; for(int i = 1; i &lt; sz; i++) G[f[i]].push_back(i); for(int i = 0; i &lt; sz; i++) &#123; if(!vis[i]) dfs(i, 0); &#125; for(int i = 1; i &lt;= id; i++)&#123; if(val[rk[i]])&#123; for(int j = 0; j &lt; pos[rk[i]].size(); j++) &#123; int k = pos[rk[i]][j]; q[k].l = in[rk[i]], q[k].r = out[rk[i]], q[k].id = k; &#125; &#125; &#125; sort(q + 1, q + m + 1); for(int i = 1; i &lt;= id; i++)&#123; for(int j = 0; j &lt; sta[rk[i]].size(); j++)&#123; if(pre[sta[rk[i]][j]]) ne[i].push_back(pre[sta[rk[i]][j]]); pre[sta[rk[i]][j]] = i; &#125; &#125; int j = 1; for(int i = 1; i &lt;= m; i++)&#123; while(j &lt;= id &amp;&amp; j &lt;= q[i].r) &#123; for (int k = 0; k &lt; ne[j].size(); k++) &#123; add(ne[j][k], -1); &#125; add(j, sta[rk[j]].size()); j++; &#125; res[q[i].id] = query(q[i].r) - query(q[i].l - 1); &#125; for(int i = 1; i &lt;= m; i++) cout &lt;&lt; res[i] &lt;&lt; '\n'; return 0;&#125;]]></content>
      <categories>
        <category>后缀自动机</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[bzoj-1878(HH的项链)]]></title>
    <url>%2F2019%2F07%2F17%2Fbzoj-1878-HH%E7%9A%84%E9%A1%B9%E9%93%BE%2F</url>
    <content type="text"><![CDATA[链接：https://www.lydsy.com/JudgeOnline/problem.php?id=1878思路：莫队模板题，不说了，重点说一下另一种离线的树状数组的做法。考虑从左到右扫，对于某个询问的区间，一个数可能出现多次，而我们只计算一次即可，也就是说只有最右边出现的一次是有效的。那么我们考虑对于所有询问按右端点排序，预处理出每个数前面出现的位置，然后处理每个询问，当前面出现过的时候，把前面最近一次出现的位置上-1（如果没有就不操作），该位置+1，然后该组询问的答案就变成了l-r的区间和，复杂度O(nlogn)。这个题就这样做完了，重点其实不在这个题上，对于树链并(一个子树内统计不同出现的次数)，我们可以把数按dfs序压成数列，然后就可以把一个子树上的统计变为与该题完全类似的区间上的统计了，这样就可以完全树链并的操作了，后面有题目会体现的。代码：莫队12345678910111213141516171819202122232425262728293031323334#include &lt;bits/stdc++.h&gt;using namespace std;struct node&#123; int l, r, pos, id; bool operator &lt;(const node &amp;x) const&#123; return pos ^ x.pos ? l &lt; x.l : (pos &amp; 1 ? r &lt; x.r : r &gt; x.r); &#125;&#125;q[200010];int res[200010];int n, m, sz;int a[100010], cnt[1000010];int main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); cin &gt;&gt; n ; sz = sqrt(n); for(int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i]; cin &gt;&gt; m; for(int i = 1; i &lt;= m; i++) cin &gt;&gt; q[i].l &gt;&gt; q[i].r, q[i].id = i, q[i].pos = q[i].l / sz; sort(q + 1, q + m + 1); int ans = 0, l = 1, r = 0; for(int i = 1; i &lt;= m; i++)&#123; while(l &lt; q[i].l) ans -= !--cnt[a[l++]]; while(l &gt; q[i].l) ans += !cnt[a[--l]]++; while(r &lt; q[i].r) ans += !cnt[a[++r]]++; while(r &gt; q[i].r) ans -= !--cnt[a[r--]]; res[q[i].id] = ans; &#125; for(int i = 1; i &lt;= m; i++) cout &lt;&lt; res[i] &lt;&lt; '\n'; return 0;&#125; dfs序 + 树状数组：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;bits/stdc++.h&gt;using namespace std; int c[1000010];int pre[1000010];int ne[100010];struct node&#123; int l, r, id; bool operator &lt; (const node &amp;x) const&#123; return r &lt; x.r; &#125;&#125;q[200010];int a[100010];int n, m;int res[200010]; int lowbit(int x)&#123; return x &amp; (-x);&#125; void add(int x, int d)&#123; while(x &lt; 1000010)&#123; c[x] += d; x += lowbit(x); &#125;&#125; int query(int x)&#123; int ret = 0; while(x)&#123; ret += c[x]; x -= lowbit(x); &#125; return ret;&#125; int main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); cin &gt;&gt; n; for(int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i]; for(int i = 1; i &lt;= n; i++)&#123; ne[i] = pre[a[i]]; pre[a[i]] = i; &#125; cin &gt;&gt; m; for(int i = 1; i &lt;= m; i++) cin &gt;&gt; q[i].l &gt;&gt; q[i].r, q[i].id = i; sort(q + 1, q + m + 1); int j = 1; for(int i = 1; i &lt;= m; i++)&#123; while(j &lt;= q[i].r &amp;&amp; j &lt;= n)&#123; if(ne[j]) add(ne[j], -1); add(j, 1); j++; &#125; res[q[i].id] = query(q[i].r) - query(q[i].l - 1); &#125; for(int i = 1; i &lt;= m; i++) cout &lt;&lt; res[i] &lt;&lt; '\n'; return 0;&#125;]]></content>
      <categories>
        <category>莫队</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[HDU-6562(Lovers)]]></title>
    <url>%2F2019%2F07%2F17%2FHDU-6562-Lovers%2F</url>
    <content type="text"><![CDATA[链接：http://acm.hdu.edu.cn/showproblem.php?pid=6562思路：说是硬核线段树，感觉没有某些神仙扫描线的线段树硬核，不过场上要想出这个题不是一件容易的事情，这里主要理一下当时想的思路。首先搞清楚题目要求什么，询问是区间和，那好，维护区间和肯定少不了。考虑拼一个串上去，需要哪些信息才能维护区间和，首先拼在后面，那么直接加上拼的这个串的值，其次拼在前面，贡献是v * $\sum10^{每个点位数}$，那么我们发现我们需要知道每个点的位数，要维护一个区间$10^{位数}$的和，这样第二个维护的信息出来了。一共1e5次操作，所以位数不会超过2e5，预处理出10的2e5次幂。考虑线段树还要满足标记之间能够拼接，这样复杂度才是正确的。考虑两个标记拼接，前面和后面情况是反着的，可以分开维护，然后还需要知道标记的长度，所以第三个维护的信息出来了—标记长度。这样这个题其实思路就结束了，剩下的就是慢慢把pushdown的部分写完这个题就结束了。代码：~~~c++ include using namespace std; typedef long long ll;const int mod = 1e9 + 7;const int maxn = 1e5 + 233;ll sum[maxn &lt;&lt; 2];ll tag[2][maxn &lt;&lt; 2];ll num[maxn &lt;&lt; 2];ll cnt[maxn &lt;&lt; 2];ll fac[maxn &lt;&lt; 2];int T, n, q; void pushup(int o){ sum[o] = (sum[o &lt;&lt; 1] + sum[o &lt;&lt; 1 | 1]) % mod; num[o] = (num[o &lt;&lt; 1] + num[o &lt;&lt; 1 | 1]) % mod;} void pushdown(int o, int m){ if(cnt[o]){ sum[o &lt;&lt; 1] = (sum[o &lt;&lt; 1] fac[cnt[o]] + num[o &lt;&lt; 1] fac[cnt[o]] % mod tag[0][o] + (m - (m &gt;&gt; 1)) tag[1][o]) % mod; sum[o &lt;&lt; 1 | 1] = (sum[o &lt;&lt; 1 | 1] fac[cnt[o]] + num[o &lt;&lt; 1 | 1] fac[cnt[o]] % mod tag[0][o] + (m &gt;&gt; 1) tag[1][o]) % mod; tag[0][o &lt;&lt; 1] = (tag[0][o] fac[cnt[o &lt;&lt; 1]] + tag[0][o &lt;&lt; 1]) % mod; tag[0][o &lt;&lt; 1 | 1] = (tag[0][o] fac[cnt[o &lt;&lt; 1 | 1]] + tag[0][o &lt;&lt; 1 | 1]) % mod; tag[1][o &lt;&lt; 1] = (tag[1][o &lt;&lt; 1] fac[cnt[o]] + tag[1][o]) % mod; tag[1][o &lt;&lt; 1 | 1] = (tag[1][o &lt;&lt; 1 | 1] fac[cnt[o]] + tag[1][o]) % mod; num[o &lt;&lt; 1] = (num[o &lt;&lt; 1] fac[2 cnt[o]]) % mod; num[o &lt;&lt; 1 | 1] = (num[o &lt;&lt; 1 | 1] fac[2 cnt[o]]) % mod; cnt[o &lt;&lt; 1] += cnt[o]; cnt[o &lt;&lt; 1 | 1] += cnt[o]; cnt[o] = 0, tag[0][o] = tag[1][o] = 0; }} void build(int o, int l, int r){ tag[0][o] = tag[1][o] = 0; sum[o] = 0; cnt[o] = 0; num[o] = 1; if(l == r){ return; } int mid = l + r &gt;&gt; 1; build(o &lt;&lt; 1, l, mid); build(o &lt;&lt; 1 | 1, mid + 1, r); pushup(o);} void update(int o, int tl, int tr, int l, int r, int v){ if(tl &gt; r || tr &lt; l) return; if(tl &gt;= l &amp;&amp; tr &lt;= r){ tag[0][o] = (v fac[cnt[o]] + tag[0][o]) % mod; tag[1][o] = (tag[1][o] 10 + v) % mod; sum[o] = (v num[o] 10 + sum[o] 10 + 1ll (tr - tl + 1) v) % mod; num[o] = num[o] 100 % mod; cnt[o]++; return; } pushdown(o, tr - tl + 1); int mid = tl + tr &gt;&gt; 1; update(o &lt;&lt; 1, tl, mid, l, r, v); update(o &lt;&lt; 1 | 1, mid + 1, tr, l, r, v); pushup(o);} ll query(int o, int tl, int tr, int l, int r){ if(tl &gt; r || tr &lt; l) return 0; if(tl &gt;= l &amp;&amp; tr &lt;= r) return sum[o]; pushdown(o, tr - tl + 1); int mid = tl + tr &gt;&gt; 1; return (query(o &lt;&lt; 1, tl, mid, l, r) + query(o &lt;&lt; 1 | 1, mid + 1, tr, l, r)) % mod;} int main(){ ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); fac[0] = 1; for(int i = 1; i &lt; 4 maxn; i++) fac[i] = fac[i - 1] 10 % mod; cin &gt;&gt; T; for(int kase = 1; kase &lt;= T; kase++){ cin &gt;&gt; n &gt;&gt; q; build(1, 1, n); cout &lt;&lt; “Case “ &lt;&lt; kase &lt;&lt; “:\n”; while(q—){ string s; int x, y, z; cin &gt;&gt; s &gt;&gt; x &gt;&gt; y; if(s == “wrap”){ cin &gt;&gt; z; update(1, 1, n, x, y, z); } else{ cout &lt;&lt; query(1, 1, n, x, y) &lt;&lt; ‘\n’; } } } return 0;}~~·]]></content>
      <categories>
        <category>线段树</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[bzoj-2154(Crash的数字表格)]]></title>
    <url>%2F2019%2F07%2F17%2Fbzoj-2154-Crash%E7%9A%84%E6%95%B0%E5%AD%97%E8%A1%A8%E6%A0%BC%2F</url>
    <content type="text"><![CDATA[链接：https://www.lydsy.com/JudgeOnline/problem.php?id=2154思路：求$\sum_{i = 1}^{n}\sum_{j = 1}^{m}lcm(i, j)$老规矩推公式： \sum_{i = 1}^{n}\sum_{j = 1}^{m}\frac{ij}{gcd(i, j)}考虑枚举gcd(i, j): \sum_{d = 1}^{min(n, m)}d\sum_{i = 1}^{\lfloor\frac{n}{d}\rfloor}\sum_{j = 1}^{\lfloor\frac{m}{d}\rfloor}ij\ [gcd(i, j) == 1]根据莫比乌斯函数性质： \sum_{d = 1}^{min(n, m)}d\sum_{i = 1}^{\lfloor\frac{n}{d}\rfloor}\sum_{j = 1}^{\lfloor\frac{m}{d}\rfloor}ij\sum_{g | gcd(i, j)}\mu(g)枚举g: \sum_{d = 1}^{min(n, m)}d\sum_{g = 1}^{min(\lfloor\frac{n}{d}\rfloor, \lfloor\frac{m}{d}\rfloor)}g^2\mu(g)\sum_{i = 1}^{\lfloor\frac{n}{gd}\rfloor}\sum_{j = 1}^{\lfloor\frac{m}{gd}\rfloor}ij发现后面那一块求和是两个等差数列求和，O(1)可以算出来，中间那个可以预处理$g^2\mu(g)$的前缀和，然后可以整除分块做，前面求和也可以整除分块做，相当于对于d * (常数)，对d求一次等差数列即可。注：能不取模的地方就别取模，1e7取模也是要T的啊。。。。代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e7 + 233;const int mod = 20101009;const int inv = 10050505;const int inv2 = 15075757;bool vis[maxn];vector&lt;int&gt; prime;int mu[maxn];typedef long long ll;ll sum[maxn];int n, m;void init()&#123; mu[1] = 1; for(int i = 2; i &lt; maxn; i++)&#123; if(!vis[i]) mu[i] = -1, prime.push_back(i); for(int j = 0; j &lt; prime.size() &amp;&amp; i * prime[j] &lt; maxn; j++)&#123; vis[i * prime[j]] = 1; if(i % prime[j] == 0) break; mu[i * prime[j]] = -mu[i]; &#125; &#125; for(int i = 1; i &lt; maxn; i++) sum[i] = sum[i - 1] + 1ll * mu[i] * i * i;&#125;int main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); cin &gt;&gt; n &gt;&gt; m; if(n &gt; m) swap(n, m); init(); ll res = 0; for(int lb = 1, ub; lb &lt;= n; lb = ub + 1)&#123; ub = min(n / (n / lb), m / (m / lb)); ll ans = 0; for(int l = 1, r; l &lt;= n / lb; l = r + 1)&#123; r = min((n / lb) / (n / lb / l), (m / lb) / (m / lb / l)); ans = (ans + 1ll * (n / lb / l) * (n / lb / l + 1) % mod * (m / lb / l) % mod * (m / lb / l + 1) % mod * ((sum[r] - sum[l - 1]) % mod + mod) % mod * inv2) % mod; &#125; res = (res + 1ll * (ub + lb) * (ub - lb + 1) % mod * inv % mod * ans) % mod; &#125; cout &lt;&lt; res &lt;&lt; '\n'; return 0;&#125;]]></content>
      <categories>
        <category>莫比乌斯反演</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[bzoj-1396(识别子串)]]></title>
    <url>%2F2019%2F07%2F15%2Fbzoj-1396-%E8%AF%86%E5%88%AB%E5%AD%90%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[链接：https://www.lydsy.com/JudgeOnline/problem.php?id=1396思路：挺好的一个SAM题目。首先因为是要求跟的字串出现次数有关的问题，很容易就想到SAM，那么只出现一次就肯定是找那些right集合为1的状态。考虑这个状态需要更新哪些位置。我们假设这个状态对于的位置为r, 最长串为maxlen, 最短串为minlen,那么对于[r - maxlen + 1, r - minlen + 1]这个区间上某个位置i，我们用r - i + 1来更新最小值。但还没结束，考虑如果这个状态的fail树的上一个状态的size不为1，那么就无法更新后面点的答案，后面点的答案有可能就是前面一个状态的最短串长，也就是说对于[r - minlen, r]这个区间上的某个位置i，我们用minlen来更新。这样我们发现两种情况可以用两个线段树来维护，第一种把i提出去就好了。最后取两种情况的最小值就是答案。代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126#include&lt;bits/stdc++.h&gt;#define sigma_size 28using namespace std;const int maxn = 1e5 + 5;const int mod = 1e9 + 7;typedef long long ll;int len[maxn * 2]; //最长子串的长度(该节点字串数量=len[x]-len[f[x]])int f[maxn * 2]; //后缀链接(最// 短串前部减少一个字符所到达的状态)int cnt[maxn * 2]; //被后缀连接的数int ch[maxn * 2][sigma_size]; //状态转移(尾部加一个字符的下一个状态)(图)int idx; //节点编号int last; //最后节点ll epos[maxn * 2]; // enpos数（该状态子串出现数量）char s[maxn];int r[maxn * 2];int mn[2][maxn &lt;&lt; 2], tag[2][maxn &lt;&lt; 2];void init() &#123; //初始化 last = idx = 1; //1表示root起始点 空集 f[1] = len[1] = 0; memset(ch[1], 0, sizeof(ch[1]));&#125;//SAM建图void add(int c, int pos) &#123; //插入字符，为字符ascll码值 int x = ++idx; //创建一个新节点x; len[x] = len[last] + 1; // 长度等于最后一个节点+1 epos[x] = 1; //接受节点子串除后缀连接还需加一 r[x] = pos; int p; //第一个有C转移的节点; for (p = last; p &amp;&amp; !ch[p][c]; p = f[p])ch[p][c] = x;//沿着后缀连接 将所有没有字符c转移的节点直接指向新节点 if (!p)f[x] = 1, cnt[1]++; //全部都没有c的转移 直接将新节点后缀连接到起点 else &#123; int q = ch[p][c]; //p通过c转移到的节点 if (len[p] + 1 == len[q]) //pq是连续的 f[x] = q, cnt[q]++; //将新节点后缀连接指向q即可,q节点的被后缀连接数+1 else &#123; int nq = ++idx; //不连续 需要复制一份q节点 len[nq] = len[p] + 1; //令nq与p连续 f[nq] = f[q]; //因后面link[q]改变此处不加cnt memcpy(ch[nq], ch[q], sizeof(ch[q])); //复制q的信息给nq for (; p &amp;&amp; ch[p][c] == q; p = f[p]) ch[p][c] = nq; //沿着后缀连接 将所有通过c转移为q的改为nq f[q] = f[x] = nq; //将x和q后缀连接改为nq cnt[nq] += 2; // nq增加两个后缀连接 &#125; &#125; last = x; //更新最后处理的节点&#125;void getpos() &#123; //求npos数，即该节点字串出现次数 queue&lt;int&gt; q; for (int i = 1; i &lt;= idx; i++) if (!cnt[i])q.push(i); //将所有没被后缀连接指向的节点入队 while (!q.empty()) &#123; int x = q.front(); q.pop(); epos[f[x]] += epos[x]; //子串数量等于所有后缀连接指向该节点的子串数量和+是否为接受节点 if (--cnt[f[x]] == 0)q.push(f[x]); //当所有后缀连接指向该节点的处理完毕后再入队 &#125;&#125;void pushup(int o, int t)&#123; mn[t][o] = min(mn[t][o &lt;&lt; 1], mn[t][o &lt;&lt; 1 | 1]);&#125;void pushdown(int o, int t)&#123; if(tag[t][o] != 1e9)&#123; tag[t][o &lt;&lt; 1] = min(tag[t][o], tag[t][o &lt;&lt; 1]); tag[t][o &lt;&lt; 1 | 1] = min(tag[t][o], tag[t][o &lt;&lt; 1 | 1]); mn[t][o &lt;&lt; 1] = min(mn[t][o &lt;&lt; 1], tag[t][o]); mn[t][o &lt;&lt; 1 | 1] = min(mn[t][o &lt;&lt; 1 | 1], tag[t][o]); &#125;&#125;void build(int o, int l, int r, int t)&#123; mn[t][o] = tag[t][o] = 1e9; if(l == r)&#123; return; &#125; int mid = l + r &gt;&gt; 1; build(o &lt;&lt; 1, l, mid, t); build(o &lt;&lt; 1 | 1, mid + 1, r, t); pushup(o, t);&#125;void update(int o, int tl, int tr, int l, int r, int v, int t)&#123; if(l &gt; tr || r &lt; tl) return; if(l &lt;= tl &amp;&amp; tr &lt;= r)&#123; mn[t][o] = min(mn[t][o], v); tag[t][o] = min(tag[t][o], v); return; &#125; pushdown(o, t); int mid = tl + tr &gt;&gt; 1; update(o &lt;&lt; 1, tl, mid, l, r, v, t); update(o &lt;&lt; 1 | 1, mid + 1, tr, l, r, v, t); pushup(o, t);&#125;int query(int o, int tl, int tr, int l, int r, int t)&#123; if(l &gt; tr || r &lt; tl) return 1e9; if(l &lt;= tl &amp;&amp; tr &lt;= r) return mn[t][o]; pushdown(o, t); int mid = tl + tr &gt;&gt; 1; return min(query(o &lt;&lt; 1, tl, mid, l, r, t), query(o &lt;&lt; 1 | 1, mid + 1, tr, l, r, t));&#125;int main() &#123; scanf("%s", s + 1); init(); int n = strlen(s + 1); for(int i = 1; i &lt;= n; i++) add(s[i] - 'a', i); getpos(); build(1, 1, n, 0); build(1, 1, n, 1); for(int i = 1; i &lt;= idx; i++)&#123; if(epos[i] == 1)&#123; update(1, 1, n, 1, r[i] - len[f[i]], r[i] + 1, 0); update(1, 1, n, r[i] - len[f[i]], r[i], len[f[i]] + 1, 1); &#125; &#125; for(int i = 1; i &lt;= n; i++) cout &lt;&lt; min(query(1, 1, n, i, i, 0) - i, query(1, 1, n, i, i, 1)) &lt;&lt; '\n'; return 0;&#125;]]></content>
      <categories>
        <category>后缀自动机</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[bzoj-3529(数表)]]></title>
    <url>%2F2019%2F07%2F15%2Fbzoj-3529-%E6%95%B0%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[链接：https://www.lydsy.com/JudgeOnline/problem.php?id=3529思路：定义f(i)为i的因子和，题目求$\sum_{i = 1}^n\sum_{j = 1}^mf(gcd(i, j)) (f(gcd(i, j)) &lt;= a)的和$，关于a的限制比较麻烦，我们先考虑没有a的限制怎么做。即： \sum_{i = 1}^n\sum_{j = 1}^mf(gcd(i, j))考虑枚举gcd(i, j)： \sum_{d = 1}^{min(n, m)}f(d)\sum_{i = 1}^{\lfloor\frac{n}{d}\rfloor}\sum_{j = 1}^{\lfloor\frac{m}{d}\rfloor}[gcd(i, j) == 1]利用莫比乌斯函数的性质可变为： \sum_{d = 1}^{min(n, m)}f(d)\sum_{i = 1}^{\lfloor\frac{n}{d}\rfloor}\sum_{j = 1}^{\lfloor\frac{m}{d}\rfloor}\sum_{t|gcd(i, j)}\mu(t)考虑枚举t: \sum_{d = 1}^{min(n, m)}f(d)\sum_{t = 1}^{min(\lfloor\frac{n}{d}\rfloor, \lfloor\frac{m}{d}\rfloor)}\mu(t)\lfloor\frac{n}{dt}\rfloor\lfloor\frac{m}{dt}\rfloor改为枚举p = dt: \sum_{d = 1}^{min(n, m)}f(d)\sum_{p = 1}^{min(n, m)}\mu(\frac{p}{d})\lfloor\frac{n}{p}\rfloor\lfloor\frac{m}{p}\rfloor将p提前： \sum_{p = 1}^{min(n, m)}\lfloor\frac{n}{p}\rfloor\lfloor\frac{m}{p}\rfloor\sum_{d|p}f(d)\mu(\frac{p}{d})这样我们可以nlogn预处理出后面的卷积，前面可以用整除分块来做。但现在有a的限制，在新式子中是f(d)，我们考虑离线来处理这个问题。按a从小到大排序，每次把f(d) &lt;= a的贡献用bit维护一下，然后整除分块求解即可。复杂度O((q + n)logn)注意一个取模可以让他对int自然溢出，然后最后答案和2147483647与一下即可。代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e5 + 233;bool vis[maxn];vector&lt;int&gt; prime;int mu[maxn];typedef pair&lt;int, int&gt; pii;pii f[maxn];int c[maxn], T;int res[maxn];struct node&#123; int n, m, a, id; bool operator &lt;(const node &amp;x) const&#123; return a &lt; x.a; &#125;&#125;q[maxn];int lowbit(int x)&#123; return x &amp; (-x);&#125;void add(int x, int d)&#123; while(x &lt; maxn)&#123; c[x] += d; x += lowbit(x); &#125;&#125;int query(int x)&#123; int res = 0; while(x)&#123; res += c[x]; x -= lowbit(x); &#125; return res;&#125;void init() &#123; mu[1] = 1; for (int i = 2; i &lt; maxn; i++) &#123; if (!vis[i]) prime.push_back(i), mu[i] = -1; for (int j = 0; j &lt; prime.size() &amp;&amp; i * prime[j] &lt; maxn; j++) &#123; vis[i * prime[j]] = 1; if (i % prime[j] == 0) break; mu[i * prime[j]] = -mu[i]; &#125; &#125; for (int i = 1; i &lt; maxn; i++) &#123; for (int j = 1; j * i &lt; maxn; j++) &#123; f[i * j].first += i; &#125; f[i].second = i; &#125; sort(f + 1, f + maxn);&#125;int getans(int n, int m)&#123; int ans = 0; for(int l = 1, r; l &lt;= n; l = r + 1)&#123; r = min(n / (n / l), m / (m / l)); ans += (n / l) * (m / l) * (query(r) - query(l - 1)); &#125; return ans;&#125;int main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); init(); cin &gt;&gt; T; for(int i = 1; i &lt;= T; i++) &#123; cin &gt;&gt; q[i].n &gt;&gt; q[i].m &gt;&gt; q[i].a, q[i].id = i; if(q[i].n &gt; q[i].m) swap(q[i].n, q[i].m); &#125; sort(q + 1, q + T + 1); int j = 1; for(int i = 1; i &lt;= T; i++)&#123; for(; j &lt; maxn &amp;&amp; f[j].first &lt;= q[i].a; j++)&#123; for(int k = 1; k * f[j].second &lt; maxn; k++)&#123; add(k * f[j].second, f[j].first * mu[k]); &#125; &#125; res[q[i].id] = getans(q[i].n, q[i].m); res[q[i].id] &amp;= 0x7fffffff; &#125; for(int i = 1; i &lt;= T; i++) cout &lt;&lt; res[i] &lt;&lt; '\n'; return 0;&#125;]]></content>
      <categories>
        <category>莫比乌斯反演</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Round 503 (by SIS, Div.1)-D(Large Triangle)]]></title>
    <url>%2F2019%2F07%2F13%2FCodeforces-Round-503-by-SIS-Div-1-D-Large-Triangle%2F</url>
    <content type="text"><![CDATA[链接：https://codeforces.com/contest/1019/problem/D思路：非常好一个计算几何题，求最大最小三角形面积，三角形以及四边形面积存在性问题都可以用这个方法解决。方法的核心是枚举一个向量，然后维护一个序列，使得在这个向量左边的点随着下标变大离向量越近，在这个向量右边的点随着下标变大离向量越远。我们先将点按先x后y的顺序排序，然后枚举向量，并且把向量按斜率排序(最好是第一个点是排序较小的点，这样向量排序后第一个向量是斜率最小的)。然后我们考虑两个相邻斜率的向量，其序列中哪些点的相对位置要发生变化，我们发现只有第一个向量的两个点的相对位置要发生变化，其他的都不会变，这个可以画图直观感受一下。这样我们每次枚举完向量后将这两个点在序列中的位置交换一下即可维护序列的单调性。考虑初始情况，相当于是按照向量y轴排序的，而第一个又是斜率最小的，一定是y轴后的第一个，所以满足情况（排序按叉积逆时针排最好）。这样我们就可以考虑在每一个向量上对序列进行二分寻找是否存在面积为S的三角形，如果是求最大最小，只用求最远点和最近点即可解决。代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll; typedef struct P&#123; ll x, y; P(ll x = 0, ll y = 0) : x(x), y(y)&#123;&#125; P operator +(const P &amp;r) const&#123; return P(x + r.x, y + r.y); &#125; P operator -(const P &amp;r) const&#123; return P(x - r.x, y - r.y); &#125; P operator *(const ll &amp;r) const&#123; return P(x * r, y * r); &#125; P operator /(const ll &amp;r) const&#123; return P(x / r, y / r); &#125; bool operator &lt; (const P &amp;r) const&#123; return x &lt; r.x || (x == r.x &amp;&amp; y &lt; r.y); &#125; bool operator == (const P &amp;r) const&#123; return x == r.x &amp;&amp; y == r.y; &#125; void read()&#123; scanf("%lld %lld", &amp;x, &amp;y); &#125; void print()&#123; printf("%lld %lld\n", x, y); &#125;&#125;V; ll Dot(V a, V b)&#123; return a.x * b.x + a.y * b.y;&#125; ll Cross(V a, V b)&#123; return a.x * b.y - a.y * b.x;&#125; const int maxn = 2020;P r[maxn];P t[maxn * maxn];int p[maxn];int n;ll s; bool cmp(P &amp;a, P &amp;b)&#123; return Cross(r[a.y] - r[a.x], r[b.y] - r[b.x]) &gt; 0;&#125; int main()&#123; scanf("%d %lld", &amp;n, &amp;s); for(int i = 1; i &lt;= n; i++) r[i].read(), p[i] = i; sort(r + 1, r + n + 1); int len = 0; for(int i = 1; i &lt;= n; i++)&#123; for(int j = i + 1; j &lt;= n; j++)&#123; t[++len] = P(i, j); &#125; &#125; sort(t + 1, t + len + 1, cmp); for(int i = 1; i &lt;= len; i++) &#123; int a = t[i].x; int b = t[i].y; if (p[a] &gt; p[b]) swap(a, b); int lb = 1, ub = p[a] - 1; while (lb &lt;= ub) &#123; int mid = lb + ub &gt;&gt; 1; ll tmp = abs(Cross(r[p[b]] - r[p[a]], r[mid] - r[p[a]])); if (tmp == 2 * s) &#123; puts("Yes"); r[p[a]].print(); r[p[b]].print(); r[mid].print(); return 0; &#125; else if (tmp &lt; 2 * s) &#123; ub = mid - 1; &#125; else lb = mid + 1; &#125; lb = p[b] + 1, ub = n; while (lb &lt;= ub) &#123; int mid = lb + ub &gt;&gt; 1; ll tmp = abs(Cross(r[p[b]] - r[p[a]], r[mid] - r[p[a]])); if (tmp == 2 * s) &#123; puts("Yes"); r[p[a]].print(); r[p[b]].print(); r[mid].print(); return 0; &#125; else if (tmp &lt; 2 * s) &#123; lb = mid + 1; &#125; else ub = mid - 1; &#125; swap(p[a], p[b]); swap(r[p[a]], r[p[b]]); &#125; puts("No"); return 0;&#125;]]></content>
      <categories>
        <category>计算几何</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2018-2019 ACM-ICPC Asia Shenyang Regional Contest-I(Distance Between Sweethearts)]]></title>
    <url>%2F2019%2F07%2F10%2F2018-2019-ACM-ICPC-Asia-Shenyang-Regional-Contest-I-Distance-Between-Sweethearts%2F</url>
    <content type="text"><![CDATA[链接：https://codeforces.com/gym/101955/problem/I思路：本题的难点在怎么处理这个max上，看一看数据范围，2000 emmmm，看来是要从小到大枚举最大值了。我们枚举最大值i，然后可以把三对boy与girl差距为i的方案记入cur数组，那么我们考虑，最大值为i的贡献有哪些，可能是其中1、2、3为最大值，我们当然可以把所有情况都列完求解，然后就喜题TLE了。。。。。我们用sum来记录最大值小于等于i的，那么其实当前最大值为i的贡献就是sum[i]做fwt的方案 - sum[i - 1]做fwt的方案。我们只用记录上一次fwt的结果，然后把cur数组累加到sum数组上，然后再fwt，两次的结果相减，就是最大值为i的方案，统计贡献即可。这样就可以少掉大量的常数，然后就可以过了。代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 2050;typedef long long ll;typedef unsigned long long ull;ll cur[3][maxn], sum[3][maxn], tmp[maxn];ll t[maxn];int p[2][3];ull res;void fwt(ll a[], int n) &#123; for (int i = 1; i &lt; n; i &lt;&lt;= 1)&#123; for (int p = i &lt;&lt; 1, j = 0; j &lt; n; j += p) &#123; for (int k = 0; k &lt; i; k++) &#123; ll x = a[j + k], y = a[j + k + i]; a[j + k] = x + y, a[j + k + i] = x - y; &#125; &#125; &#125;&#125;void ufwt(ll a[], int n) &#123; for (int i = 1; i &lt; n; i &lt;&lt;= 1) &#123; for (int p = i &lt;&lt; 1, j = 0; j &lt; n; j += p) &#123; for (int k = 0; k &lt; i; k++) &#123; ll x = a[j + k], y = a[j + k + i]; a[j + k] = 1ll * (x + y) / 2, a[j + k + i] = (x - y) / 2; &#125; &#125; &#125;&#125;int T;void solve(ll a[], ll b[], ll c[], ll d[], int n)&#123; fwt(a, n); fwt(b, n); fwt(c, n); for(int i = 0; i &lt; n; i++) d[i] = a[i] * b[i] * c[i]; ufwt(a, n); ufwt(b, n); ufwt(c, n); ufwt(d, n);&#125;int main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); cin &gt;&gt; T; int kase = 0; while(T--)&#123; for(int i = 0; i &lt; 2; i++) &#123; for(int j = 0; j &lt; 3; j++) &#123; cin &gt;&gt; p[i][j]; &#125; &#125; memset(sum, 0, sizeof(sum)); res = 0; sum[0][0] = min(p[0][0], p[1][0]) + 1; sum[1][0] = min(p[0][1], p[1][1]) + 1; sum[2][0] = min(p[0][2], p[1][2]) + 1; solve(sum[0], sum[1], sum[2], tmp, 2048); memcpy(t, tmp, sizeof(tmp)); for(int i = 1; i &lt; 2048; i++)&#123; memset(cur, 0, sizeof(cur)); for(int j = 0; j &lt; 3; j++) &#123; for (int k = 0; k &lt;= min(p[0][j], p[1][j] - i); k++) &#123; cur[j][(i + k) ^ k]++; &#125; for (int k = 0; k &lt;= min(p[1][j], p[0][j] - i); k++) &#123; cur[j][(i + k) ^ k]++; &#125; &#125; for(int j = 0; j &lt; 3; j++)&#123; for(int k = 0; k &lt; 2048; k++)&#123; sum[j][k] += cur[j][k]; &#125; &#125; solve(sum[0], sum[1], sum[2], tmp, 2048); for(int j = 0; j &lt; 2048; j++) res += (i ^ j) * (tmp[j] - t[j]); memcpy(t, tmp, sizeof(tmp)); &#125; cout &lt;&lt; "Case #" &lt;&lt; ++kase &lt;&lt; ": " &lt;&lt; res &lt;&lt; '\n'; &#125; return 0;&#125;]]></content>
      <categories>
        <category>FWT</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[luogu-P3594(WIL-Wilcze doły)]]></title>
    <url>%2F2019%2F07%2F09%2Fluogu-P3594-WIL-Wilcze-doly%2F</url>
    <content type="text"><![CDATA[链接：https://www.luogu.org/problemnew/show/P3594思路：可以考虑尺取法，因为一定是把d用满是最优的，所以中间一段求长度为d的最大连续和可以考虑用数据结构维护一下，但这样会多个log不知道会不会被卡掉。当然这个是随l，r的移动而改变的，自然就想到了滑动窗口，也就可以用单调队列dp来优化，每次r移动到最右边不能满足的位置，然后每移动一下把一个可行的连续长度为d的区间放到单调队列里，check的时候取队首元素check即可。代码：1234567891011121314151617181920212223242526272829303132333435363738#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int n, d;ll p;const int maxn = 2e6 + 233;int a[maxn];int head, tail, I[maxn];ll sum[maxn], Q[maxn];int l, r;bool check()&#123; if(head &lt;= tail) return sum[r] - sum[l - 1] - Q[head] &lt;= p; return sum[r] - sum[l - 1] &lt;= p;&#125;int main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); cin &gt;&gt; n &gt;&gt; p &gt;&gt; d; for(int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i], sum[i] = sum[i - 1] + a[i]; r = 0; head = 1, tail = 0; int res = 0; for(l = 1; l &lt;= n; l++)&#123; while(head &lt;= tail &amp;&amp; I[head] &lt; l) head++; while(r &lt;= n &amp;&amp; check())&#123; r++; ll tmp = sum[r] - sum[max(0, r - d)]; while(head &lt;= tail &amp;&amp; Q[tail] &lt;= tmp) tail--; Q[++tail] = tmp; I[tail] = max(1, r - d + 1); &#125; res = max(res, r - l); &#125; cout &lt;&lt; res &lt;&lt; '\n'; return 0;&#125;]]></content>
      <categories>
        <category>单调队列dp</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[HDU-2462(The Luckiest number)]]></title>
    <url>%2F2019%2F07%2F08%2FHDU-2462-The-Luckiest-number%2F</url>
    <content type="text"><![CDATA[链接：http://acm.hdu.edu.cn/showproblem.php?pid=2462思路：假设最终答案是n个8，运用等比数列求和公式可以得出t = $\frac{8}{9}*(10^x - 1)$。那么由t % n == 0可以得出： 8*(10^x - 1) \equiv 0 \ (mod \ 9n)两边同时除以d = gcd(8, 9n): 10^x \equiv 1 \ (mod \ \frac{9n}{d})接下来两种方法都可以做了，一种是典型的exbsgs，套上板子就行。第二种就是欧拉定理，首先在这里给出一个结论，最小的x一定是$\phi(\frac{9n}{d})$的因子，证明如下：假设最小的$x_0$有: \phi(\frac{n}{d}) = qx_0 + r(0 \leq r < x_0)我们可以得到: 10^{\phi(\frac{9n}{d})}\equiv 1 \ (mod \ \frac{9n}{d})即: 10^{\phi(qx_0 + r)}\equiv 1 \ (mod \ \frac{9n}{d})由于: 10^{x_0}\equiv 1 \ (mod \ \frac{9n}{d})得到: 10^r\equiv 1 \ (mod \ \frac{9n}{d})这样的$x_0$不是最小的，矛盾，所以一定是因子。所以我们只用枚举因子，快速幂检验结果是否符合，并更新最小值即可。两种方法都要注意一下，中间取模的时候可能会爆long long代码：欧拉定理1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef __int128 LL;ll n;ll euler(ll x)&#123; ll res = x; for(int i = 2; 1ll * i * i &lt;= x; i++)&#123; if(x % i == 0)&#123; res -= res / i; while(x % i == 0) x /= i; &#125; &#125; if(x &gt; 1) res -= res / x; return res;&#125;ll pow_mod(ll q, ll w, ll mod)&#123; ll ret = 1; while(w)&#123; if(w &amp; 1) ret = (LL)ret * q % mod; q = (LL)q * q % mod; w &gt;&gt;= 1; &#125; return ret;&#125;int main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int kase = 0; while(cin &gt;&gt; n)&#123; if(!n) break; n *= 9; n /= __gcd(n, 8ll); ll x = euler(n); cout &lt;&lt; "Case " &lt;&lt; ++kase &lt;&lt; ": "; ll res = 1e18; for(int i = 1; 1ll * i * i &lt;= x; i++)&#123; if(x % i) continue; if(pow_mod(10, i, n) == 1)&#123; res = min(res, (ll)i); &#125; if(pow_mod(10, x / i, n) == 1)&#123; res = min(res, (ll)x / i); &#125; &#125; if(res == 1e18) res = 0; cout &lt;&lt; res &lt;&lt; '\n'; &#125; return 0;&#125; bsgs1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef __int128 LL;unordered_map&lt;ll, ll&gt; mp;ll pow_mod(ll q, ll w, ll mod)&#123; ll ret = 1; while(w)&#123; if(w &amp; 1) ret = (LL)ret * q % mod; q = (LL)q * q % mod; w &gt;&gt;= 1; &#125; return ret;&#125;ll exbsgs(ll a, ll b, ll c)&#123; ll cnt = 0, d = 1, t; while((t = __gcd(a, c)) != 1)&#123; if(b % t) return 0; ++cnt, b /= t, c /= t, d = d * a / t % c; if(d == b) return cnt; &#125; mp.clear(); ll x = sqrt(c) + 1, tmp = b % c; for(int i = 0; i &lt; x; i++)mp[tmp] = i, tmp = (LL)tmp * a % c; ll y = tmp = pow_mod(a, x, c); tmp = (LL)tmp * d % c; for(int i = 1; i &lt;= x; i++)&#123; if(mp.count(tmp))return x * i - mp[tmp] + cnt; tmp = (LL)tmp * y % c; &#125; return 0;&#125;int main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); ll x; int kase = 0; while(cin &gt;&gt; x)&#123; if(!x) break; x *= 9; ll g = __gcd(x, 8ll); x /= g; ll res = exbsgs(10, 1, x); cout &lt;&lt; "Case " &lt;&lt; ++kase &lt;&lt; ": " &lt;&lt; res &lt;&lt; '\n'; &#125; return 0;&#125;]]></content>
      <categories>
        <category>同余</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[luogu-P3327(约数个数和)]]></title>
    <url>%2F2019%2F07%2F08%2Fluogu-P3327-%E7%BA%A6%E6%95%B0%E4%B8%AA%E6%95%B0%E5%92%8C%2F</url>
    <content type="text"><![CDATA[链接：https://www.luogu.org/problemnew/show/P3327思路：这个题有一个非常重要的点，必须知道才能做，就是: d(ij) = \sum_{x|i}\sum_{y|j}[gcd(x, y) = 1]简单证明一下：考虑对于某个质因子t，i有p个t质因子，j有q个t质因子，那么他俩合起来能提供p + q + 1种可能，做如下变化： p + q + 1 = \sum_{x = 1}^p\sum_{y = 1}^q[gcd(t^x, t^y) = 1]这个变化不好想，但正确性是显而易见的。那么对于每一个质因子我们都有如下的式子，把他们乘起来就变成了上述的结论。那么我们就开始推公式： Ans = \sum_{i = 1}^N\sum_{j = 1}^Md(ij) = \sum_{i = 1}^N\sum_{j = 1}^M\sum_{x|i}\sum_{y|j}[gcd(x, y) = 1]$根据莫比乌斯函数\sum_{d|n}\mu(d) = [n = 1]$可以得到 Ans = \sum_{i = 1}^N\sum_{j = 1}^Md(ij) = \sum_{i = 1}^N\sum_{j = 1}^M\sum_{x|i}\sum_{y|j}\sum_{d|gcd(x, y)}\mu(d)改成枚举d: Ans = \sum_{i = 1}^N\sum_{j = 1}^Md(ij) = \sum_{i = 1}^N\sum_{j = 1}^M\sum_{x|i}\sum_{y|j}\sum_{d = 1}^{min(x, y)}\mu(d) * [d | gcd(x, y)]由枚举i, j的约数x, y改为直接枚举x, y： Ans = \sum_{x = 1}^N\sum_{y = 1}^M\sum_{d = 1} ^ {min(x, y)}\mu(d) * [d|gcd(x, y)] * \lfloor\frac{N}{x}\rfloor\lfloor\frac{M}{y}\rfloor更改x，y为dx，dy，消去[d|gcd(x, y)]： Ans = \sum_{d = 1}^{min(N, M)}\mu(d)(\sum_{x = 1}^{\lfloor\frac{N}{d}\rfloor}\lfloor\frac{N}{dx}\rfloor)(\sum_{y = 1}^{\lfloor\frac{M}{d}\rfloor}\lfloor\frac{M}{dy}\rfloor)之后对于里面的求和我们可以运用整除分块预处理答案，然后前缀和处理，对于多组询问外面再用整除分块求解答案即可。代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 1e5 + 233;vector&lt;int&gt; prime;bool vis[maxn];ll sum[maxn], g[maxn];int mu[maxn];int T, n, m;void init()&#123; mu[1] = 1; for(int i = 2; i &lt; maxn; i++)&#123; if(!vis[i]) prime.emplace_back(i), mu[i] = -1; for(int j = 0; j &lt; prime.size() &amp;&amp; i * prime[j] &lt; maxn; j++)&#123; vis[i * prime[j]] = 1; if(i % prime[j] == 0) break; mu[i * prime[j]] = -mu[i]; &#125; &#125; for(int i = 1; i &lt; maxn; i++)&#123; for(int l = 1, r; l &lt;= i; l = r + 1)&#123; r = i / (i / l); g[i] += 1ll * (r - l + 1) * (i / l); &#125; sum[i] = sum[i - 1] + mu[i]; &#125;&#125;int main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); cin &gt;&gt; T; init(); while(T--)&#123; cin &gt;&gt; n &gt;&gt; m; if(n &gt; m) swap(n, m); ll res = 0; for(int l = 1, r; l &lt;= n; l = r + 1)&#123; r = min(n / (n / l), m / (m / l)); res += (sum[r] - sum[l - 1]) * g[n / l] * g[m / l]; &#125; cout &lt;&lt; res &lt;&lt; '\n'; &#125; return 0;&#125;]]></content>
      <categories>
        <category>莫比乌斯反演</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[luogu-P2569(股票交易)]]></title>
    <url>%2F2019%2F07%2F08%2Fluogu-P2569-%E8%82%A1%E7%A5%A8%E4%BA%A4%E6%98%93%2F</url>
    <content type="text"><![CDATA[链接：https://www.luogu.org/problemnew/show/P2569思路：很不错一个题，这个题其实难点在限制有两个，一个是天数上的限制，一个是买的物品上的限制，如果没弄清单调队列(像我一样)，就不知道怎么处理。我们先来看看，天数大于符号，不是从前面当当前的一段区间，所以这段是没法用单调队列优化的，那么我们就必须用dp来记录这一维度。首先dp[i][j]表示第i天，手上有j张股票的时候所能赚的最多的钱。考虑转移，如果什么都不做，dp[i][j] = max(dp[i][j], dp[i - 1][j])，那么当j确定的时候，我们需要的是前i天的最大值，由于有这个转移，所以保证了满足限制的最后一天的结果是最优的，这样天数的限制就被消除了，我们只用直接看dp[i - w - 1][j]处的值就可以找到最大的值了。如果买或者卖，把方程展开后都可以用单调队列优化，这里就不再详细写了。代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;bits/stdc++.h&gt;using namespace std;int n, m, k;const int maxn = 2010;int dp[maxn][maxn];int head, tail, Q[maxn], I[maxn];int main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); cin &gt;&gt; n &gt;&gt; m &gt;&gt; k; for(int i = 0; i &lt;= n; i++)&#123; for(int j = 0; j &lt;= m; j++)&#123; dp[i][j] = -1e9; &#125; &#125; dp[0][0] = 0; for(int i = 1; i &lt;= n; i++)&#123; int a, b, c, d; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d; for(int j = 0; j &lt;= c; j++) dp[i][j] = max(dp[i][j], -j * a); for(int j = 0; j &lt;= m; j++) dp[i][j] = max(dp[i][j], dp[i - 1][j]); if(i &lt;= k) continue; head = 1, tail = 0; for(int j = 0; j &lt;= m; j++)&#123; while(head &lt;= tail &amp;&amp; Q[tail] &lt;= dp[i - k - 1][j] + j * a) tail--; Q[++tail] = dp[i - k - 1][j] + j * a; I[tail] = j; while(head &lt;= tail &amp;&amp; j - I[head] &gt; c) head++; dp[i][j] = max(dp[i][j], Q[head] - j * a); &#125; head = 1, tail = 0; for(int j = m; j &gt;= 0; j--)&#123; while(head &lt;= tail &amp;&amp; Q[tail] &lt;= dp[i - k - 1][j] + j * b) tail--; Q[++tail] = dp[i - k - 1][j] + j * b; I[tail] = j; while(head &lt;= tail &amp;&amp; I[head] - j &gt; d) head++; dp[i][j] = max(dp[i][j], Q[head] - j * b); &#125; &#125; int res = 0; for(int i = 1; i &lt;= n; i++)&#123; for(int j = 0; j &lt;= m; j++)&#123; res = max(res, dp[i][j]); &#125; &#125; cout &lt;&lt; res &lt;&lt; '\n'; return 0;&#125;]]></content>
      <categories>
        <category>单调队列dp</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[luogu-P2254(瑰丽华尔兹)]]></title>
    <url>%2F2019%2F07%2F08%2Fluogu-P2254-%E7%91%B0%E4%B8%BD%E5%8D%8E%E5%B0%94%E5%85%B9%2F</url>
    <content type="text"><![CDATA[链接：https://www.luogu.org/problemnew/show/P2254思路：对于每一个移动方向，相当于一段区间，后面的可以从前面的一段区间转移过来，这不正好是单调队列所要解决的问题吗，所以我们顺着方向dp，用单调队列优化即可。注意如果碰到障碍，前面所有已经放入的状态都不可能转移到之后的状态了，这时候只需要把队列清空就好了。代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 205;int dp[maxn][maxn];int head, tail, Q[maxn], I[maxn];int n, m, sx, sy, k;char s[maxn][maxn];int main()&#123; scanf("%d %d %d %d %d", &amp;n, &amp;m, &amp;sx, &amp;sy, &amp;k); for(int i = 1; i &lt;= n; i++) scanf("%s", s[i] + 1); for(int i = 1; i &lt;= n; i++)&#123; for(int j = 1; j &lt;= m; j++)&#123; dp[i][j] = -1e9; &#125; &#125; dp[sx][sy] = 0; for(int o = 1; o &lt;= k; o++)&#123; int l, r, t; scanf("%d %d %d", &amp;l, &amp;r, &amp;t); if(t == 1)&#123; for(int j = 1; j &lt;= m; j++)&#123; head = 1, tail = 0; for(int i = n; i; i--)&#123; if(s[i][j] == 'x')&#123; head = 1, tail = 0; continue; &#125; int tmp = dp[i][j] + i; while(head &lt;= tail &amp;&amp; Q[tail] &lt;= tmp) tail--; Q[++tail] = tmp; I[tail] = i; while(head &lt;= tail &amp;&amp; I[head] - i &gt; r - l + 1) head++; dp[i][j] = max(dp[i][j], Q[head] - i); &#125; &#125; &#125; else if(t == 2)&#123; for(int j = 1; j &lt;= m; j++)&#123; head = 1, tail = 0; for(int i = 1; i &lt;= n; i++)&#123; if(s[i][j] == 'x')&#123; head = 1, tail = 0; continue; &#125; int tmp = dp[i][j] - i; while(head &lt;= tail &amp;&amp; Q[tail] &lt;= tmp) tail--; Q[++tail] = tmp; I[tail] = i; while(head &lt;= tail &amp;&amp; i - I[head] &gt; r - l + 1) head++; dp[i][j] = max(dp[i][j], Q[head] + i); &#125; &#125; &#125; else if(t == 3)&#123; for(int i = 1; i &lt;= n; i++)&#123; head = 1, tail = 0; for(int j = m; j; j--)&#123; if(s[i][j] == 'x')&#123; head = 1, tail = 0; continue; &#125; int tmp = dp[i][j] + j; while(head &lt;= tail &amp;&amp; Q[tail] &lt;= tmp) tail--; Q[++tail] = tmp; I[tail] = j; while(head &lt;= tail &amp;&amp; I[head] - j &gt; r - l + 1) head++; dp[i][j] = max(dp[i][j], Q[head] - j); &#125; &#125; &#125; else&#123; for(int i = 1; i &lt;= n; i++)&#123; head = 1, tail = 0; for(int j = 1; j &lt;= m; j++)&#123; if(s[i][j] == 'x')&#123; head = 1, tail = 0; continue; &#125; int tmp = dp[i][j] - j; while(head &lt;= tail &amp;&amp; Q[tail] &lt;= tmp) tail--; Q[++tail] = tmp; I[tail] = j; while(head &lt;= tail &amp;&amp; j - I[head] &gt; r - l + 1) head++; dp[i][j] = max(dp[i][j], Q[head] + j); &#125; &#125; &#125; &#125; int res = 0; for(int i = 1; i &lt;= n; i++)&#123; for(int j = 1; j &lt;= m; j++)&#123; res = max(res, dp[i][j]); &#125; &#125; printf("%d\n", res); return 0;&#125;]]></content>
      <categories>
        <category>单调队列dp</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[luogu-P1776(宝物筛选)]]></title>
    <url>%2F2019%2F07%2F08%2Fluogu-P1776-%E5%AE%9D%E7%89%A9%E7%AD%9B%E9%80%89%2F</url>
    <content type="text"><![CDATA[链接：https://www.luogu.org/problemnew/show/P1776思路：裸的多重背包，我们考虑朴素的算法，首先枚举第几个物品，再枚举重量，再枚举当前需要用几个，这样是O(nmW)的。这个优化方法就非常特别了，考虑单调队列是对于一段限定的区间里面取最大值，那么在这个问题中哪些状态是属于一段区间的呢，突然发现必须要余数相同的那些状态才有可能属于一个区间，余数相同的这些状态就可以用单调队列优化。所以我们按照余数分类，余数相同的那些状态我们一起转移。原来我们有转移方程： dp[i] = max(dp[j] + (i - j) / w * v), (i - j) \% w = 0我们按照余数改写： dp[d + i * w] = max(dp[d + j * w] + (i - j) * v), (i - j)]]></content>
      <categories>
        <category>单调队列dp</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[luogu-P2257(YY的GCD)]]></title>
    <url>%2F2019%2F07%2F07%2Fluogu-P2257-YY%E7%9A%84GCD%2F</url>
    <content type="text"><![CDATA[链接:https://www.luogu.org/problemnew/show/P2257思路：给定N, M,求1&lt;=x&lt;=N, 1&lt;=y&lt;=M且gcd(x, y)为质数的(x, y)有多少对。我们设 f(d) = \sum_{i = 1}^n\sum_{j = 1}^m[gcd(i, j) = d]F(n) = \sum_{n|d}f(d) = \lfloor\frac{N}{n}\rfloor\lfloor\frac{M}{n}\rfloorf(n) = \sum_{n|d}\mu(\frac{d}{n})F(d)得出： Ans = \sum_{p\in{prime}}f(p)莫比乌斯反演得到： Ans = \sum_{p\in{prime}}\sum_{p|d}\mu(\frac{d}{p})F(d)$我们更改枚举项，枚举\lfloor\frac{d}{p}\rfloor$： Ans = \sum_{p\in{prime}}\sum_{d = 1}^{min(\lfloor\frac{n}{p}\rfloor, \lfloor\frac{m}{p}\rfloor)}\mu(d)\lfloor\frac{n}{dp}\rfloor\lfloor\frac{m}{dp}\rfloor我们将dp换成T： Ans = \sum_{T = 1}^{min(n, m)}\lfloor\frac{n}{T}\rfloor\lfloor\frac{m}{T}\rfloor(\sum_{t|T, t\in{prime}}\mu(\frac{T}{t}))推到这里就可以解决了，由于是多组数据，我们需要预处理。后面的对$\mu$求和我们可以事先预处理出来，剩下的就是整除分块求答案即可。代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e7 + 233;int mu[maxn];vector&lt;int&gt; prime;bool vis[maxn];typedef long long ll;ll sum[maxn], g[maxn];void init()&#123; mu[1] = 1; for(int i = 2; i &lt; maxn; i++)&#123; if(!vis[i]) &#123; mu[i] = -1; prime.emplace_back(i); &#125; for(int j = 0; j &lt; prime.size() &amp;&amp; i * prime[j] &lt; maxn; j++)&#123; vis[i * prime[j]] = 1; if(i % prime[j] == 0) break; mu[i * prime[j]] = -mu[i]; &#125; &#125; for(int j = 0; j &lt; prime.size(); j++)&#123; for(int i = 1; i * prime[j] &lt; maxn; i++) g[i * prime[j]] += mu[i]; &#125; for(int i = 1; i &lt; maxn; i++) sum[i] = sum[i - 1] + g[i];&#125;int T, n, m;int main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); cin &gt;&gt; T; init(); while(T--)&#123; cin &gt;&gt; n &gt;&gt; m; if(n &gt; m) swap(n, m); ll res = 0; for(int l = 1, r; l &lt;= n; l = r + 1)&#123; r = min(n / (n / l), m / (m / l)); res += 1ll * (n / l) * (m / l) * (sum[r] - sum[l - 1]); &#125; cout &lt;&lt; res &lt;&lt; '\n'; &#125; return 0;&#125;]]></content>
      <categories>
        <category>莫比乌斯反演</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[luogu-P3455(ZAP-Queries)]]></title>
    <url>%2F2019%2F07%2F07%2Fluogu-P3455-ZAP-Queries%2F</url>
    <content type="text"><![CDATA[链接：https://www.luogu.org/problemnew/show/P3455思路：求$\sum_{i = 1} ^ a\sum_{j = 1} ^ b[gcd(i, j) = d]$。我们设: f(k) = \sum_{i = 1} ^ a\sum_{j = 1} ^ b[gcd(i, j) = k]那么有: F(n) = \sum_{n|k}f(k) = \lfloor\frac{a}{n}\rfloor\lfloor\frac{b}{n}\rfloor从而有： f(n) = \sum_{n|k}\mu(\lfloor\frac{k}{n}\rfloor)F(k)$将枚举项 \lfloor\frac{k}{d}\rfloor 变为t$： ans = \sum_{t = 1}^{min(\lfloor\frac{a}{d}\rfloor, \lfloor\frac{b}{d}\rfloor)}\mu(t)\lfloor\frac{a}{td}\rfloor\lfloor\frac{b}{td}\rfloor然后有多组数据，用一下整除分块求前缀和就可以解决了。代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 5e4 + 233;typedef long long ll;ll sum[maxn];bool vis[maxn];int mu[maxn];vector&lt;int&gt; prime;int T, a, b, d;void init()&#123; mu[1] = 1; for(int i = 2; i &lt; maxn; i++)&#123; if(!vis[i])&#123; mu[i] = -1; prime.emplace_back(i); &#125; for(int j = 0; j &lt; prime.size() &amp;&amp; i * prime[j] &lt; maxn; j++)&#123; vis[i * prime[j]] = 1; if(i % prime[j] == 0) break; mu[i * prime[j]] = -mu[i]; &#125; &#125; for(int i = 1; i &lt; maxn; i++) sum[i] = sum[i - 1] + mu[i];&#125;int main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); init(); cin &gt;&gt; T; while(T--)&#123; cin &gt;&gt; a &gt;&gt; b &gt;&gt; d; a /= d, b /= d; if(a &gt; b) swap(a, b); ll res = 0; for(int l = 1, r; l &lt;= a; l = r + 1)&#123; r = min(a / (a / l), b / (b / l)); res += 1ll * (a / l) * (b / l) * (sum[r] - sum[l - 1]); &#125; cout &lt;&lt; res &lt;&lt; '\n'; &#125; return 0;&#125;]]></content>
      <categories>
        <category>莫比乌斯反演</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[hdu-5909(Tree Cutting)]]></title>
    <url>%2F2019%2F07%2F07%2Fhdu-5909-Tree-Cutting%2F</url>
    <content type="text"><![CDATA[链接:http://acm.hdu.edu.cn/showproblem.php?pid=5909思路：相当于求树上某个连通块异或和为x的有多少个，很容易想到dp，先将无根树转换为有根树，dp[u][i]表示以u为根节点的子树异或和为i的方案数，然后向上合并，合并过程中父节点必选，跟子节点的方案进行卷积，用fwt加速卷积过程即可。代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include &lt;bits/stdc++.h&gt;using namespace std;const int mod = 1e9 + 7;const int rev = (mod + 1) &gt;&gt; 1;const int maxn = 1 &lt;&lt; 12;typedef long long ll;ll a[maxn], b[maxn], c[maxn];int n, m;int T;ll v[maxn];vector&lt;int&gt; G[maxn];ll dp[1010][1 &lt;&lt; 12];inline ll add(int x, int y)&#123; x += y; return x &gt;= mod ? x - mod : x;&#125;inline ll sub(int x, int y)&#123; x -= y; return x &lt; 0 ? x + mod : x;&#125;void fwt(ll a[], int n) &#123; for (int i = 1; i &lt; n; i &lt;&lt;= 1)&#123; for (int p = i &lt;&lt; 1, j = 0; j &lt; n; j += p) &#123; for (int k = 0; k &lt; i; k++) &#123; int x = a[j + k], y = a[j + k + i]; a[j + k] = add(x, y), a[j + k + i] = sub(x, y); &#125; &#125; &#125;&#125;void ufwt(ll a[], int n) &#123; for (int i = 1; i &lt; n; i &lt;&lt;= 1) &#123; for (int p = i &lt;&lt; 1, j = 0; j &lt; n; j += p) &#123; for (int k = 0; k &lt; i; k++) &#123; int x = a[j + k], y = a[j + k + i]; a[j + k] = 1ll * (x + y) * rev % mod, a[j + k + i] = 1ll * (x - y + mod) * rev % mod; &#125; &#125; &#125;&#125;void solve(ll a[], ll b[], ll c[])&#123; fwt(a, m); fwt(b, m); for(int i = 0; i &lt; m; i++) c[i] = 1ll * a[i] * b[i] % mod; ufwt(a, m); ufwt(b, m); ufwt(c, m);&#125;void dfs(int u, int f)&#123; dp[u][v[u]] = 1; for(int i = 0; i &lt; G[u].size(); i++)&#123; int v = G[u][i]; if(v == f) continue; dfs(v, u); memcpy(a, dp[u], sizeof(dp[u])); memcpy(b, dp[v], sizeof(dp[v])); solve(a, b, c); for(int j = 0; j &lt; m; j++) dp[u][j] = add(dp[u][j], c[j]); &#125;&#125;int main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); cin &gt;&gt; T; while(T--)&#123; cin &gt;&gt; n &gt;&gt; m; for(int i = 1; i &lt;= n; i++) G[i].clear(), cin &gt;&gt; v[i]; memset(dp, 0, sizeof(dp)); for(int i = 1; i &lt; n; i++)&#123; int u, v; cin &gt;&gt; u &gt;&gt; v; G[u].emplace_back(v); G[v].emplace_back(u); &#125; dfs(1, 0); for(int i = 0; i &lt; m; i++)&#123; ll res = 0; for(int j = 1; j &lt;= n; j++) res = add(res, dp[j][i]); cout &lt;&lt; res &lt;&lt; (i == m - 1 ? '\n' : ' '); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>FWT</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Round 296 (Div.1)-D(Fuzzy Search)]]></title>
    <url>%2F2019%2F07%2F06%2FCodeforces-Round-296-Div-1-D-Fuzzy-Search%2F</url>
    <content type="text"><![CDATA[链接：https://codeforces.com/contest/528/problem/D思路：从lls那里顺来的一个FFT的题目，结果题目我居然看了快半h才明白是什么意思？？？给定母串和模式串，字符集大小为4，给定k，模式串在某个位置匹配当且仅当任意位置模式串的这个字符所对应的母串的位置的左右k个字符之内有一个与它相同的，求匹配次数。我们考虑匹配某个字符，我们可以将能匹配的位置为1，不能匹配的位置为0，然后卷积，看最后结果不为0的点。这个题就是四个字符分开匹配，对于S串我们先倒置，然后如果某个位置字符相同，前后k个内都可以匹配，这个时候我们可以差分处理一下，然后卷积，卷积的结果就表示这个点能和模式串中几个点匹配，最终把四个字符的结果合起来，能匹配数量等于模式串长度的点就可以作为答案，统计一下答案有多少即可。代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 3e6 + 5;typedef long long ll;#define db doubleconst db pi = acos(-1);int n, m, k;ll c[maxn];int pos[maxn];char s[maxn], t[maxn];int cnt[maxn];struct cp &#123; db x, y; inline cp(db a = 0, db b = 0) : x(a), y(b) &#123;&#125; inline cp operator+(const cp &amp;r) const &#123; return cp(x + r.x, y + r.y); &#125; inline cp operator-(const cp &amp;r) const &#123; return cp(x - r.x, y - r.y); &#125; inline cp operator*(const cp &amp;r) const &#123; return cp(x * r.x - y * r.y, x * r.y + y * r.x); &#125; inline cp conj() &#123; return cp(x, -y); &#125;&#125;a[maxn], b[maxn];void fft(cp *a, int n, int f) &#123; int i, j, k; for (i = j = 0; i &lt; n; ++i) &#123; if (i &lt; pos[i]) swap(a[i], a[pos[i]]); for (k = n &gt;&gt; 1; (j ^= k) &lt; k; k &gt;&gt;= 1); &#125; for (i = 1; i &lt; n; i &lt;&lt;= 1) &#123; cp wn(cos(pi / i), f * sin(pi / i)); for (j = 0; j &lt; n; j += i &lt;&lt; 1) &#123; cp w(1, 0); for (k = 0; k &lt; i; ++k, w = w * wn) &#123; cp x = a[j + k], y = w * a[i + j + k]; a[j + k] = x + y; a[i + j + k] = x - y; &#125; &#125; &#125; if (f == -1) for (i = 0; i &lt; n; ++i) a[i].x /= n;&#125;void solve(char cc) &#123; memset(cnt, 0, sizeof(cnt)); for(int i = 0; i &lt; maxn; i++) a[i].x = a[i].y = 0; for(int i = 0; i &lt;= n; i++)&#123; if(s[i] == cc)&#123; cnt[max(i - k, 0)]++; cnt[min(i + k + 1, n + 1)]--; &#125; &#125; for(int i = 1; i &lt;= n; i++) cnt[i] += cnt[i - 1]; for(int i = 0; i &lt;= n; i++)&#123; if(cnt[i]) a[i].x = 1; else a[i].x = 0; &#125; for(int i = 0; i &lt;= m; i++)&#123; if(t[i] == cc) a[i].y = 1; else a[i].y = 0; &#125; int i, j, k; for (k = 1; k &lt;= m + n; k &lt;&lt;= 1); j = __builtin_ctz(k) - 1; for (i = 0; i &lt; k; i++)pos[i] = pos[i &gt;&gt; 1] &gt;&gt; 1 | ((i &amp; 1) &lt;&lt; j); fft(a, k, 1); cp Q(0, -0.25); for (i = 0, j; i &lt; k; ++i) j = (k - i) &amp; (k - 1), b[i] = (a[i] * a[i] - (a[j] * a[j]).conj()) * Q; fft(b, k, -1); for (i = 0; i &lt;= n + m; ++i) &#123; c[i] += int(b[i].x + 0.2); &#125;&#125;int main()&#123; scanf("%d %d %d %s %s",&amp;n, &amp;m, &amp;k, s, t); for(int i = 0; i &lt; n / 2; i++) swap(s[i], s[n - 1 - i]); n--, m--; solve('A'); solve('T'); solve('G'); solve('C'); ll res = 0; for(int i = 0; i &lt;= n + m; i++)&#123; if(c[i] == m + 1) res++; &#125; cout &lt;&lt; res &lt;&lt; '\n'; return 0;&#125;]]></content>
      <categories>
        <category>FFT</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[bzoj-4589(Hard Nim)]]></title>
    <url>%2F2019%2F07%2F04%2Fbzoj-4589-Hard-Nim%2F</url>
    <content type="text"><![CDATA[链接：https://www.lydsy.com/JudgeOnline/problem.php?id=4589思路：首先了解FWT解决的是$C_k$ = $A_i$ op $B_j$ (i op j = k)(op可为&amp; | ^ 三种运算)。复杂度是O(nlogn)。其实这个东西并不需要掌握原理，只需要知道怎么用即可。本题中，相当于选出n个素数，使得他们的异或和等于0。考虑如果选两个，就是两个a序列卷积一下，三个就是两个的结果再和a序列卷积一下。我们知道，卷积通过变化后可以转化位乘法，那么多次相同的数列卷积转为幂运算，这样我们就可以快速幂解决，然后再还原回来即可。注意代码中有些小细节。代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include &lt;bits/stdc++.h&gt;using namespace std;const int mod = 1e9 + 7;const int rev = (mod + 1) &gt;&gt; 1;const int maxn = 1 &lt;&lt; 17;typedef long long ll;ll a[maxn];int n, m;bool vis[maxn];vector&lt;int&gt; prime;void init()&#123; for(int i = 2; i &lt;= 50000; i++)&#123; if(!vis[i]) prime.push_back(i); //这里线性筛不要写错了 for(int j = 0; j &lt; prime.size() &amp;&amp; i * prime[j] &lt;= 50000; j++)&#123; vis[i * prime[j]] = 1; if(i % prime[j] == 0) break; &#125; &#125;&#125;inline ll add(ll x, ll y)&#123; x += y; return x &gt;= mod ? x - mod : x;&#125;inline ll sub(ll x, ll y)&#123; x -= y; return x &lt; 0 ? x + mod : x;&#125;ll pow_mod(ll q, ll w)&#123; ll ret = 1; while(w)&#123; if(w &amp; 1) ret = ret * q % mod; q = q * q % mod; w &gt;&gt;= 1; &#125; return ret;&#125;void fwt(ll a[], int n) &#123; for (int i = 1; i &lt; n; i &lt;&lt;= 1)&#123; for (int p = i &lt;&lt; 1, j = 0; j &lt; n; j += p) &#123; for (int k = 0; k &lt; i; k++) &#123; ll x = a[j + k], y = a[j + k + i]; a[j + k] = add(x, y), a[j + k + i] = sub(x, y); &#125; &#125; &#125;&#125;void ufwt(ll a[], int n) &#123; for (int i = 1; i &lt; n; i &lt;&lt;= 1) &#123; for (int p = i &lt;&lt; 1, j = 0; j &lt; n; j += p) &#123; for (int k = 0; k &lt; i; k++) &#123; ll x = a[j + k], y = a[j + k + i]; a[j + k] = 1ll * (x + y) * rev % mod, a[j + k + i] = 1ll * (x - y + mod) * rev % mod; &#125; &#125; &#125;&#125;void solve(ll a[], int t)&#123; fwt(a, t); for(int i = 0; i &lt; t; i++) a[i] = pow_mod(a[i], n); ufwt(a, t); cout &lt;&lt; a[0] &lt;&lt; '\n';&#125;int main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); init(); while(cin &gt;&gt; n &gt;&gt; m) &#123; memset(a, 0, sizeof(a)); for(int i = 0; i &lt; prime.size() &amp;&amp; prime[i] &lt;= m; i++)&#123; a[prime[i]] = 1; &#125; int t = 1; while (t &lt;= m) t &lt;&lt;= 1; //注意此处是小于等于 solve(a, t); &#125; return 0;&#125;]]></content>
      <categories>
        <category>FWT</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[The 2019 ACM-ICPC China Shannxi Provincial Programming Contest-E(Tree)]]></title>
    <url>%2F2019%2F07%2F03%2FThe-2019-ACM-ICPC-China-Shannxi-Provincial-Programming-Contest-E-Tree%2F</url>
    <content type="text"><![CDATA[链接：https://nanti.jisuanke.com/t/39272思路：这个题树链剖分的部分是很基础的，其实重点是线段树上怎么维护。首先我们需要两个标记，一个与标记一个或标记，通过按位分析，我们可以发现与运算与异或满足分配律，或运算不满足，推一推规律我们知道一堆异或和 和一个数与，结果跟这堆数的数量的奇偶性有关。于是我们可以推出规律，然后根据奇偶分情况维护即可。最重要的一个问题是两个标记间怎么更新才能消除顺序的影响。我们联想到之前一个线段树的题，就是既有乘法标记又有加法标记，更新乘法标记的时候需要顺带把加法标记也更新了，然后加法标记就只用更新自己即可。这里也是如此，我们更新与运算的时候把或运算的标记更新即可。代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e5 + 233;int f[maxn], rk[maxn], id[maxn], sz[maxn], son[maxn], top[maxn], d[maxn];int n, q, idx;typedef long long ll;ll a[maxn];ll xsum[maxn &lt;&lt; 2], taga[maxn &lt;&lt; 2], tago[maxn &lt;&lt; 2];vector&lt;int&gt; G[maxn];void pushup(int o)&#123; xsum[o] = xsum[o &lt;&lt; 1] ^ xsum[o &lt;&lt; 1 | 1];&#125;void pushdown(int o, int m)&#123; if(taga[o] != -1)&#123; taga[o &lt;&lt; 1] &amp;= taga[o]; taga[o &lt;&lt; 1 | 1] &amp;= taga[o]; tago[o &lt;&lt; 1] &amp;= taga[o]; tago[o &lt;&lt; 1 | 1] &amp;= taga[o]; xsum[o &lt;&lt; 1] &amp;= taga[o]; xsum[o &lt;&lt; 1 | 1] &amp;= taga[o]; taga[o] = -1; &#125; if(tago[o])&#123; if((m - (m &gt;&gt; 1)) &amp; 1)&#123; xsum[o &lt;&lt; 1] |= tago[o]; tago[o &lt;&lt; 1] |= tago[o]; &#125; else&#123; xsum[o &lt;&lt; 1] &amp;= (~tago[o]); tago[o &lt;&lt; 1] |= tago[o]; &#125; if((m &gt;&gt; 1) &amp; 1)&#123; xsum[o &lt;&lt; 1 | 1] |= tago[o]; tago[o &lt;&lt; 1 | 1] |= tago[o]; &#125; else &#123; xsum[o &lt;&lt; 1 | 1] &amp;= (~tago[o]); tago[o &lt;&lt; 1 | 1] |= tago[o]; &#125; tago[o] = 0; &#125;&#125;void build(int o, int l, int r)&#123; taga[o] = -1; tago[o] = 0; if(l == r)&#123; xsum[o] = a[rk[l]]; return; &#125; int mid = l + r &gt;&gt; 1; build(o &lt;&lt; 1, l, mid); build(o &lt;&lt; 1 | 1, mid + 1, r); pushup(o);&#125;void update(int o, int tl, int tr, int l, int r, ll v, bool f)&#123; if(tl &gt; r || tr &lt; l) return; if(l &lt;= tl &amp;&amp; tr &lt;= r)&#123; if(f) taga[o] &amp;= v, tago[o] &amp;= v, xsum[o] &amp;= v; else if((tr - tl + 1) &amp; 1) tago[o] |= v, xsum[o] |= v; else xsum[o] &amp;= (~v), tago[o] |= v; return; &#125; pushdown(o, tr - tl + 1); int mid = tl + tr &gt;&gt; 1; update(o &lt;&lt; 1, tl, mid, l, r, v, f); update(o &lt;&lt; 1 | 1, mid + 1, tr, l, r, v, f); pushup(o);&#125;ll query(int o, int tl, int tr, int l, int r)&#123; if(tl &gt; r || tr &lt; l) return 0; if(l &lt;= tl &amp;&amp; tr &lt;= r) return xsum[o]; pushdown(o, tr - tl + 1); int mid = tl + tr &gt;&gt; 1; return query(o &lt;&lt; 1, tl, mid, l, r) ^ query(o &lt;&lt; 1 | 1, mid + 1, tr, l, r);&#125;void dfs1(int u, int fa)&#123; d[u] = d[fa] + 1; sz[u] = 1; f[u] = fa; for(auto &amp;v : G[u])&#123; if(v == fa) continue; dfs1(v, u); sz[u] += sz[v]; if(sz[son[u]] &lt; sz[v]) son[u] = v; &#125;&#125;void dfs2(int u, int t)&#123; top[u] = t; id[u] = ++idx; rk[idx] = u; if(son[u]) dfs2(son[u], t); for(auto &amp;v : G[u])&#123; if(v == f[u] || v == son[u]) continue; dfs2(v, v); &#125;&#125;int main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); cin &gt;&gt; n &gt;&gt; q; for(int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i]; for(int i = 1; i &lt; n; i++)&#123; int u, v; cin &gt;&gt; u &gt;&gt; v; G[u].emplace_back(v); G[v].emplace_back(u); &#125; dfs1(1, 0); dfs2(1, 1); build(1, 1, n); while(q--)&#123; ll op, s, t; cin &gt;&gt; op &gt;&gt; s &gt;&gt; t; if(op == 1)&#123; while(s)&#123; update(1, 1, n, id[top[s]], id[s], t, 0); s = f[top[s]]; &#125; &#125; else if(op == 2)&#123; while(s)&#123; update(1, 1, n, id[top[s]], id[s], t, 1); s = f[top[s]]; &#125; &#125; else&#123; ll res = t; while(s)&#123; res ^= query(1, 1, n, id[top[s]], id[s]); s = f[top[s]]; &#125; if(res == 0) cout &lt;&lt; "NO\n"; else cout &lt;&lt; "YES\n"; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>树链剖分</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[luogu-P3384(树链剖分)]]></title>
    <url>%2F2019%2F06%2F30%2Fluogu-P3384-%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86%2F</url>
    <content type="text"><![CDATA[链接：https://www.luogu.org/problemnew/show/P3384思路：总算是苟活着学到了树剖了，具体推荐这个博客https://www.cnblogs.com/ivanovcraft/p/9019090.html。 感觉学完点分治后树剖其实入门挺容易的，后面再补几个相关题目。树剖其实就是按照dfs序，然后转成线性的，可能需要查询路径上的东西，那么我们可以往上跳，直到跳到二者在一条重链上为止，由于重链的序号是连续的，可以直接在线段树上查询，暴力跳的过程我们就暴力查询或者修改即可。如果是要统计子树的信息我们可以得到子树进去和出来时的序号（对应线段树上的一段连续的序列），查询对应区间即可。本题中，路径上的值加上一个z，就是先暴力跳到一条重链上，暴力跳的过程中暴力修改，然后重链连续的区间修改。查询类似。子树就是查其对应的一段区间，修改类似。代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e5 + 233;int f[maxn], son[maxn], d[maxn], sz[maxn], top[maxn], id[maxn], rk[maxn], out[maxn];vector&lt;int&gt; G[maxn];int idx;typedef long long ll;ll sum[maxn &lt;&lt; 2], tag[maxn &lt;&lt; 2];int a[maxn];int n, m, r, p;void dfs1(int u, int fa)&#123; f[u] = fa; d[u] = d[fa] + 1; sz[u] = 1; for(auto &amp;v : G[u])&#123; if(v == fa) continue; dfs1(v, u); sz[u] += sz[v]; if(sz[v] &gt; sz[son[u]]) son[u] = v; &#125;&#125;void dfs2(int u, int t)&#123; top[u] = t; id[u] = ++idx; rk[idx] = u; if(son[u]) dfs2(son[u], t); for(auto &amp; v : G[u])&#123; if(v == f[u] || v == son[u]) continue; dfs2(v, v); &#125; out[u] = idx;&#125;void pushup(int o)&#123; sum[o] = (sum[o &lt;&lt; 1] + sum[o &lt;&lt; 1 | 1]) % p;&#125;void pushdown(int o, int m)&#123; if(tag[o])&#123; sum[o &lt;&lt; 1] = (sum[o &lt;&lt; 1] + tag[o] * (m - (m &gt;&gt; 1))) % p; sum[o &lt;&lt; 1 | 1] = (sum[o &lt;&lt; 1 | 1] + tag[o] * (m &gt;&gt; 1)) % p; tag[o &lt;&lt; 1] = (tag[o &lt;&lt; 1] + tag[o]) % p; tag[o &lt;&lt; 1 | 1] = (tag[o &lt;&lt; 1 | 1] + tag[o]) % p; tag[o] = 0; &#125;&#125;void build(int o, int l, int r)&#123; if(l == r)&#123; sum[o] = a[rk[l]]; return; &#125; int mid = l + r &gt;&gt; 1; build(o &lt;&lt; 1, l, mid); build(o &lt;&lt; 1 | 1, mid + 1, r); pushup(o);&#125;void update(int o, int tl, int tr, int l, int r, ll v)&#123; if(tl &gt; r || tr &lt; l) return; if(tl &gt;= l &amp;&amp; tr &lt;= r)&#123; sum[o] = (sum[o] + (tr - tl + 1) * v) % p; tag[o] = (tag[o] + v) % p; return; &#125; pushdown(o, tr - tl + 1); int mid = tl + tr &gt;&gt; 1; update(o &lt;&lt; 1, tl, mid, l, r, v); update(o &lt;&lt; 1 | 1, mid + 1, tr, l, r, v); pushup(o);&#125;ll query(int o, int tl, int tr, int l, int r)&#123; if(tl &gt; r || tr &lt; l) return 0; if(tl &gt;= l &amp;&amp; tr &lt;= r) return sum[o]; pushdown(o, tr - tl + 1); int mid = tl + tr &gt;&gt; 1; return (query(o &lt;&lt; 1, tl, mid, l, r) + query(o &lt;&lt; 1 | 1, mid + 1, tr, l, r)) % p;&#125;int main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); cin &gt;&gt; n &gt;&gt; m &gt;&gt; r &gt;&gt; p; for(int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i]; for(int i = 1; i &lt; n; i++)&#123; int u, v; cin &gt;&gt; u &gt;&gt; v; G[u].emplace_back(v); G[v].emplace_back(u); &#125; dfs1(r, 0); dfs2(r, r); build(1, 1, idx); for(int i = 1; i &lt;= m; i++)&#123; int o, x, y, v; cin &gt;&gt; o &gt;&gt; x; if(o == 1)&#123; cin &gt;&gt; y &gt;&gt; v; while(top[x] != top[y])&#123; if(d[top[x]] &gt; d[top[y]])&#123; update(1, 1, idx, id[top[x]], id[x], v); x = f[top[x]]; &#125; else&#123; update(1, 1, idx, id[top[y]], id[y], v); y = f[top[y]]; &#125; &#125; if(d[x] &gt; d[y]) swap(x, y); update(1, 1, idx, id[x], id[y], v); &#125; if(o == 2)&#123; ll res = 0; cin &gt;&gt; y; while(top[x] != top[y])&#123; if(d[top[x]] &gt; d[top[y]])&#123; res = (res + query(1, 1, idx, id[top[x]], id[x])) % p; x = f[top[x]]; &#125; else&#123; res = (res + query(1, 1, idx, id[top[y]], id[y])) % p; y = f[top[y]]; &#125; &#125; if(d[x] &gt; d[y]) swap(x, y); res = (res + query(1, 1, idx, id[x], id[y])) % p; cout &lt;&lt; res &lt;&lt; '\n'; &#125; if(o == 3)&#123; cin &gt;&gt; v; update(1, 1, idx, id[x], out[x], v); &#125; if(o == 4)&#123; cout &lt;&lt; query(1, 1, idx, id[x], out[x]) &lt;&lt; '\n'; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>树链剖分</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[洛谷-P4195(exBSGS)]]></title>
    <url>%2F2019%2F06%2F30%2F%E6%B4%9B%E8%B0%B7-P4195-exBSGS%2F</url>
    <content type="text"><![CDATA[链接：https://www.luogu.org/problemnew/show/P4195思路：bsgs算法以及拓展bsgs算法都用来解决形如$a^x$ = b (mod c)这类问题，如果gcd(a, c) = 1,那么就可以用bsgs算法。bsgs算法其实非常好理解，就可以理解为一种变向的分块，我们将x写为形如i * m - j的形式，容易证明m = $c ^ {0.5}$的时候，复杂度最低，我们将a的0 - m次幂放入hash表中，然后从1 - m枚举i，然后查找hash表中是否有对应的值，如果有则有答案，如果所有的都没搜索到就无解，注意一个小细节，当j有多个值时，肯定取最大的一个，所以从前到后建立hash表即可。当gcd(a, c) != 1的时候，这个时候就要用拓展bsgs算法了，其实也就是在前面同时除以一下gcd(a, c)，一直到二者的gcd为1，再用朴素的bsgs算法即可，这里不再赘述了。代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;unordered_map&lt;ll, ll&gt; mp;ll p, b, n;ll pow_mod(ll q, ll w, ll mod)&#123; ll ret = 1; while(w)&#123; if(w &amp; 1) ret = ret * q % mod; q = q * q % mod; w &gt;&gt;= 1; &#125; return ret;&#125;ll bsgs(ll a, ll b, ll c)&#123; // a ^ x = b (mod c) if(b == 1) return 0; if(a == 0 &amp;&amp; b != 0) return -1; mp.clear(); ll x = ceil(sqrt(c)), tmp = b % c; for(int i = 0; i &lt; x; i++) mp.emplace(tmp, i), tmp = tmp * a % c; ll y = tmp = pow_mod(a, x, c); for(int i = 1; i &lt;= x; i++)&#123; if(mp.count(tmp)) return x * i - mp[tmp]; tmp = tmp * y % c; &#125; return -1;&#125;ll exbsgs(ll a, ll b, ll c)&#123; if(b == 1) return 0; if(a == 0 &amp;&amp; b != 0) return -1; ll cnt = 0, d = 1, t; while((t = __gcd(a, c)) != 1)&#123; if(b % t) return -1; ++cnt, b /= t, c /= t, d = d * a / t % c; if(d == b) return cnt; &#125; mp.clear(); ll x = sqrt(c) + 1, tmp = b % c; for(int i = 0; i &lt; x; i++)mp[tmp] = i, tmp = tmp * a % c; ll y = pow_mod(a, x, c); tmp = d; for(int i = 1; i &lt;= x; i++)&#123; tmp = tmp * y % c; if(mp.count(tmp)) return x * i - mp[tmp] + cnt; &#125; return -1;&#125;int main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); while(cin &gt;&gt; p &gt;&gt; n &gt;&gt; b) &#123; if(!p &amp;&amp; !n &amp;&amp; !b) break; ll res = exbsgs(p, b, n); if (res &lt; 0) cout &lt;&lt; "No Solution\n"; else cout &lt;&lt; res &lt;&lt; '\n'; &#125; return 0;&#125;]]></content>
      <categories>
        <category>bsgs</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[The 2019 ACM-ICPC China Shannxi Provincial Programming Contest-J(And And And)]]></title>
    <url>%2F2019%2F06%2F04%2FThe-2019-ACM-ICPC-China-Shannxi-Provincial-Programming-Contest-J-And-And-And%2F</url>
    <content type="text"><![CDATA[链接：https://nanti.jisuanke.com/t/39277思路：一开始没想清楚点分治上的细节，因为维护的是点对的子树大小，所以我们要用个map计数，每次对一条链统计完贡献后再全部更新，这样就保证了贡献一定是跨过了当前枚举的这个点。但有个问题，不能每次枚举点就dfs求以该点为根的各点的子树大小，但统计贡献时可能子树大小是上面的部分(排开路径外的部分可能在上侧)，怎么办呢？可以用lca来判断两点关系，如果是祖孙关系那么深度浅的那个点统计的就是上面的部分，否则就是下面的部分。这样就做完了，复杂度O(nlognlogn)然后qls的做法就显得又简单又好做，考虑定根并统计各点子树大小，如果点对不是祖孙关系则贡献为两个sz相乘，否则为深的sz乘(n - 浅的那个点到深的那个点路径上第二个点的子树的sz)，这时候我们第一遍dfs先全部按照非祖孙关系算，每次走到一个点统计贡献后就塞到map里，第二遍dfs考虑把一条链上的点贡献更改正确，那么就树上差分一下，进去的时候更新，统计贡献，出来的时候把更新删除，这样就保证所有统计的都是一条链上的。这个方法显得非常容易。代码：点分治123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 2e5 + 233;typedef long long ll;typedef pair&lt;int, ll&gt; pii;vector&lt;pii&gt; G[maxn];ll sz[maxn], son[maxn];int n;const ll mod = 1e9 + 7;map&lt;ll, ll&gt; cnt;ll d[maxn];int size, rt;ll num[maxn];bool vis[maxn];ll res;int dep[maxn], f[maxn][20];void add(ll &amp;x, ll y)&#123; x += y; if(x &gt;= mod) x -= mod;&#125;void getroot(int u, int f)&#123; sz[u] = 1, son[u] = 0; for(auto &amp;it : G[u])&#123; int v = it.first; if(v == f || vis[v]) continue; getroot(v, u); sz[u] += sz[v]; son[u] = max(son[u], sz[v]); &#125; son[u] = max(son[u], size - sz[u]); if(son[u] &lt; son[rt]) rt = u;&#125;void dfs2(int u, int fa)&#123; num[u] = 1; f[u][0] = fa; dep[u] = dep[fa] + 1; for(int i = 1; i &lt;= 19; i++) f[u][i] = f[f[u][i - 1]][i - 1]; for(auto &amp;it : G[u])&#123; int v = it.first; if(v == fa) continue; dfs2(v, u); num[u] += num[v]; &#125;&#125;int lca(int u, int v)&#123; if(dep[u] &gt; dep[v]) swap(u, v); for(int i = 19; i &gt;= 0; i--)&#123; if(dep[f[v][i]] &gt; dep[u]) v = f[v][i]; &#125; if(f[v][0] == u) return v; return -1;&#125;void get(int u, int f, int x, bool flag)&#123; if(flag) &#123; if(dep[u] &lt; dep[x]) &#123; int t = lca(u, x); ll tmp; if(t == -1) tmp = num[u]; else tmp = n - num[t]; add(res, 1ll * cnt[d[u]] * tmp % mod); &#125; else add(res, 1ll * cnt[d[u]] * num[u] % mod); &#125; else &#123; if(dep[u] &lt; dep[x]) &#123; int t = lca(u, x); ll tmp; if(t == -1) tmp = num[u]; else tmp = n - num[t]; add(cnt[d[u]], tmp % mod); &#125; else add(cnt[d[u]], num[u] % mod); &#125; if(d[u] == 0 &amp;&amp; flag) &#123; if(dep[u] &lt; dep[x]) &#123; int t = lca(u, x); ll tmp; if(t == -1) tmp = num[u]; else tmp = n - num[t]; add(res, 1ll * tmp * num[x] % mod); &#125; else&#123; int t = lca(x, u); ll tmp; if(t == -1) tmp = num[x]; else tmp = n - num[t]; add(res, 1ll * tmp * num[u] % mod); &#125; &#125; for(auto &amp;it : G[u])&#123; int v = it.first; if(vis[v] || v == f) continue; d[v] = d[u] ^ it.second; get(v, u, x, flag); &#125;&#125;void solve(int u, int x, ll w)&#123; d[u] = w; get(u, 0, x, 1); get(u, 0, x, 0);&#125;void dfs(int u)&#123; cnt.clear(); vis[u] = 1; for(auto &amp;it : G[u]) &#123; int v = it.first; if (vis[v]) continue; solve(v, u, it.second); &#125; // cout &lt;&lt; u &lt;&lt; ' ' &lt;&lt; res &lt;&lt; '\n'; for(auto &amp;it : G[u])&#123; int v = it.first; if(vis[v]) continue; size = sz[v]; rt = 0; getroot(v, 0); // cout &lt;&lt; rt &lt;&lt; '\n'; dfs(rt); &#125;&#125;int main()&#123; // freopen("in.txt", "r", stdin); ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); cin &gt;&gt; n; son[0] = 1e9; for(int i = 2; i &lt;= n; i++)&#123; int v; ll w; cin &gt;&gt; v &gt;&gt; w; G[i].emplace_back(v, w); G[v].emplace_back(i, w); &#125; size = n; getroot(1, 0); dfs2(rt, 0); dfs(rt); cout &lt;&lt; res % mod &lt;&lt; '\n'; return 0;&#125; dfs + map乱搞123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef pair&lt;int, ll&gt; pii;const int maxn = 1e5 + 233;ll d[maxn];vector&lt;pii&gt; G[maxn];int n;map&lt;ll, ll&gt; m1, m2;const ll mod = 1e9 + 7;ll res;ll sz[maxn];void add(ll &amp;x, ll y)&#123; x += y; if(x &gt;= mod) x -= mod;&#125;void sub(ll &amp;x, ll y)&#123; x -= y; if(x &lt; 0) x += mod;&#125;void dfs(int u, int f)&#123; sz[u] = 1; for(auto &amp;it : G[u])&#123; int v = it.first; if(v == f) continue; dfs(v, u); sz[u] += sz[v]; &#125;&#125;void dfs1(int u, int f)&#123; add(res, sz[u] * m1[d[u]] % mod); add(m1[d[u]], sz[u]); for(auto &amp;it : G[u])&#123; int v = it.first; if(v == f) continue; d[v] = d[u] ^ it.second; dfs1(v, u); &#125;&#125;void dfs2(int u, int f)&#123; add(m2[d[f]], n - sz[u]); add(res, m2[d[u]] * sz[u] % mod); sub(m2[d[u]], sz[u]); for(auto &amp;it : G[u])&#123; int v = it.first; if(v == f) continue; dfs2(v, u); &#125; add(m2[d[u]], sz[u]); sub(m2[d[f]], n - sz[u]);&#125;int main()&#123; //freopen("in.txt", "r", stdin); ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); cin &gt;&gt; n; for(int i = 2; i &lt;= n; i++)&#123; int v; ll w; cin &gt;&gt; v &gt;&gt; w; G[i].emplace_back(v, w); G[v].emplace_back(i, w); &#125; dfs(1, 0); dfs1(1, 0); dfs2(1, 0); cout &lt;&lt; res &lt;&lt; '\n'; return 0;&#125;]]></content>
      <categories>
        <category>点分治</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[ACM-ICPC World Finals 2019-G(First of Her Name)]]></title>
    <url>%2F2019%2F05%2F23%2FACM-ICPC-World-Finals-2019-G-First-of-Her-Name%2F</url>
    <content type="text"><![CDATA[链接：https://vjudge.net/problem/Kattis-firstofhername思路：给出了一棵倒序的trie树，然后给你一些询问串，问能跟trie树上多少前缀匹配。首先因为每次只在trie上增加一个字符，并且所有串都不一样，所以trie上每一个点都对应了一个串，那么原问题变为了，将询问串倒置，问在trie树上有多少子串等于这个倒置后的串。那么这就是广义SAM的模板题了，直接对trie树建广义SAM，然后拓扑排序后累加字串出现次数，然后直接拿倒置的询问串在上面跑即可，如果跑不到就中断了答案为0，否则为最终状态的子串数目。第二种做法，也是标程给出的做法，用AC自动机来做，不知道还记得之前的套路与否：对于这种一堆询问串，问在一堆串的出现次数的统计，我们拿询问串建AC自动机，拿串在自动机上去跑，并且沿途计数++，最后沿着fail树拓扑排序累加答案，最后访问询问串对应的节点的答案即可。本题还是，由于trie上每个点都对应着唯一一个串，原问题就是相当于在trie上找询问串出线了多少次，我们将trie类比为一个串一样，拿trie在自动机上面去跑，沿途经过的点计数++，然后把自动机按fail拓扑序累加，最后更新每个询问串位置的答案即可。代码：广义SAM12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include&lt;bits/stdc++.h&gt;using namespace std;#define sigma_size 26const int maxn = 1e6 + 5;typedef long long ll;int len[maxn * 2]; //最长子串的长度(该节点字串数量=len[x]-len[f[x]])int f[maxn * 2]; //后缀链接(最短串前部减少一个字符所到达的状态)int cnt[maxn * 2]; //被后缀连接的数int ch[maxn * 2][sigma_size]; //状态转移(尾部加一个字符的下一个状态)(图)int idx; //节点编号int epos[maxn * 2]; // enpos数（该状态子串出现数量）int n, m;int pos[maxn * 2];char s[maxn];void init() &#123; //初始化 idx = 1; //1表示root起始点 空集 f[1] = len[1] = 0; memset(ch[1], 0, sizeof(ch[1]));&#125;//SAM建图int add(int c, int last) &#123; //插入字符，为字符ascll码值 int x = ++idx; //创建一个新节点x; len[x] = len[last] + 1; // 长度等于最后一个节点+1 epos[x] = 1; //接受节点子串除后缀连接还需加一 int p; //第一个有C转移的节点; for (p = last; p &amp;&amp; !ch[p][c]; p = f[p])ch[p][c] = x;//沿着后缀连接 将所有没有字符c转移的节点直接指向新节点 if (!p)f[x] = 1, cnt[1]++; //全部都没有c的转移 直接将新节点后缀连接到起点 else &#123; int q = ch[p][c]; //p通过c转移到的节点 if (len[p] + 1 == len[q]) //pq是连续的 f[x] = q, cnt[q]++; //将新节点后缀连接指向q即可,q节点的被后缀连接数+1 else &#123; int nq = ++idx; //不连续 需要复制一份q节点 len[nq] = len[p] + 1; //令nq与p连续 f[nq] = f[q]; //因后面link[q]改变此处不加cnt memcpy(ch[nq], ch[q], sizeof(ch[q])); //复制q的信息给nq for (; p &amp;&amp; ch[p][c] == q; p = f[p]) ch[p][c] = nq; //沿着后缀连接 将所有通过c转移为q的改为nq f[q] = f[x] = nq; //将x和q后缀连接改为nq cnt[nq] += 2; // nq增加两个后缀连接 &#125; &#125; last = x; //更新最后处理的节点 return last;&#125;void getpos() &#123; //求npos数，即该节点字串出现次数 queue&lt;int&gt; q; for (int i = 1; i &lt;= idx; i++) if (!cnt[i])q.push(i); //将所有没被后缀连接指向的节点入队 while (!q.empty()) &#123; int x = q.front(); q.pop(); epos[f[x]] += epos[x]; //子串数量等于所有后缀连接指向该节点的子串数量和+是否为接受节点 if (--cnt[f[x]] == 0)q.push(f[x]); //当所有后缀连接指向该节点的处理完毕后再入队 &#125;&#125;int main() &#123; scanf("%d%d", &amp;n, &amp;m); init(); pos[0] = 1; for(int i = 1; i &lt;= n; i++)&#123; int x; scanf("%s%d", s, &amp;x); pos[i] = add(s[0] - 'A', pos[x]); &#125; getpos(); for(int i = 1; i &lt;= m; i++)&#123; scanf("%s", s + 1); int x = strlen(s + 1); int now = 1; int j; for(j = x; j; j--)&#123; if(ch[now][s[j] - 'A']) now = ch[now][s[j] - 'A']; else break; &#125; if(!j) printf("%d\n", epos[now]); else printf("0\n"); &#125; return 0;&#125; trie在AC自动机跑123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118#include&lt;bits/stdc++.h&gt;using namespace std;const int maxnode = 1e6+100;const int sigma_size = 26;int n, m;char s[maxnode];int ch[maxnode][sigma_size];int val[maxnode];int f[maxnode];int last[maxnode];int sz, num;int cnt[maxnode];int que[maxnode], qt;int trie[maxnode][sigma_size];vector&lt;int&gt; id[maxnode];int pos[maxnode];int ans[maxnode];void init() &#123; sz = 1; num = 1; memset(ch[0], 0, sizeof(ch[0]));&#125;int idx(char c) &#123; return c - 'A';&#125;int add(int u, int c)&#123; if(!trie[u][c])&#123; trie[u][c] = num; memset(trie[num], 0, sizeof(trie[num])); num++; &#125; u = trie[u][c]; return u;&#125;void insert(char *s, int x, int v = 1) &#123; int n = strlen(s); int u = 0; for (int i = n - 1; i &gt;= 0; i--) &#123; int c = idx(s[i]); if (!ch[u][c]) &#123; ch[u][c] = sz; memset(ch[sz], 0, sizeof(ch[sz])); val[sz++] = 0; &#125; u = ch[u][c]; &#125; val[u] = v; id[u].push_back(x);&#125;void getfail() &#123; queue&lt;int&gt; q; f[0] = 0; for (int i = 0; i &lt; sigma_size; i++) &#123; int u = ch[0][i]; if (u) &#123; f[u] = last[u] = 0; q.push(u); que[++qt] = u; &#125; &#125; while (!q.empty()) &#123; int r = q.front(); q.pop(); //val[r] |= val[f[r]]; //AC自动机 + dp时会用 for (int c = 0; c &lt; sigma_size; c++) &#123; int u = ch[r][c]; if (!u) &#123; ch[r][c] = ch[f[r]][c]; continue; &#125; q.push(u); que[++qt] = u; int v = f[r]; while (v &amp;&amp; !ch[v][c])v = f[v]; f[u] = ch[v][c]; last[u] = val[f[u]] ? f[u] : last[f[u]]; &#125; &#125;&#125;void dfs(int u, int p)&#123; cnt[p]++; for(int i = 0; i &lt; sigma_size; i++)&#123; if(trie[u][i]) dfs(trie[u][i], ch[p][i]); &#125;&#125;int main()&#123; init(); scanf("%d %d", &amp;n, &amp;m); for(int i = 1; i &lt;= n; i++)&#123; int x; scanf("%s %d", s, &amp;x); pos[i] = add(pos[x], idx(s[0])); &#125; for(int i = 1; i &lt;= m; i++)&#123; scanf("%s", s); insert(s, i); &#125; getfail(); dfs(0, 0); for(int i = qt; i; i--) cnt[f[que[i]]] += cnt[que[i]]; for(int i = 1; i &lt; sz; i++)&#123; for(int j = 0; j &lt; id[i].size(); j++)&#123; ans[id[i][j]] = cnt[i]; &#125; &#125; for(int i = 1; i &lt;= m; i++) printf("%d\n", ans[i]); return 0;&#125;]]></content>
      <categories>
        <category>后缀自动机</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[bzoj-3172(单词)]]></title>
    <url>%2F2019%2F05%2F23%2Fbzoj-3172-%E5%8D%95%E8%AF%8D%2F</url>
    <content type="text"><![CDATA[链接：https://www.lydsy.com/JudgeOnline/problem.php?id=3172思路：学到一种新思路，以前都是用父亲节点信息更新子节点，这样可以维护出trie树上某点包括那些单词节点。这次的是先拿询问串来建AC自动机，注意插入trie树时经过的路径都计数++，然后我们按照fail树的拓扑序从下到上累加，因为一个点指向的点一定是它的某个前缀，一个串有几个能与该前缀匹配的点就会产生多少个链接过去。这样累加后查询下在该点的累加值就是出现次数的答案。所以套路就是：对于给出一些串和询问串，把询问串拿来建trie，然后串拿到trie上去跑，并将跑过的点计数++，然后拓扑序在fail累加，最后看询问串的单词节点处的计数值就是出现的次数。代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include&lt;bits/stdc++.h&gt;using namespace std; const int maxnode = 1e6+100;const int sigma_size = 26;int n;char s[maxnode]; int ch[maxnode][sigma_size];int val[maxnode];int f[maxnode];int last[maxnode];int sz;int cnt[maxnode];int id[maxnode];int que[maxnode], qt; void init() &#123; sz = 1; memset(ch[0], 0, sizeof(ch[0]));&#125; int idx(char c) &#123; return c - 'a';&#125; void insert(char *s, int x, int v = 1) &#123; int n = strlen(s); int u = 0; for (int i = 0; i &lt; n; i++) &#123; int c = idx(s[i]); if (!ch[u][c]) &#123; ch[u][c] = sz; memset(ch[sz], 0, sizeof(ch[sz])); val[sz++] = 0; &#125; u = ch[u][c]; cnt[u]++; &#125; val[u] = v; id[x] = u;&#125; void getfail() &#123; queue&lt;int&gt; q; f[0] = 0; for (int i = 0; i &lt; sigma_size; i++) &#123; int u = ch[0][i]; if (u) &#123; f[u] = last[u] = 0; q.push(u); que[++qt] = u; &#125; &#125; while (!q.empty()) &#123; int r = q.front(); q.pop(); //val[r] |= val[f[r]]; //AC自动机 + dp时会用 for (int c = 0; c &lt; sigma_size; c++) &#123; int u = ch[r][c]; if (!u) &#123; ch[r][c] = ch[f[r]][c]; continue; &#125; q.push(u); que[++qt] = u; int v = f[r]; while (v &amp;&amp; !ch[v][c])v = f[v]; f[u] = ch[v][c]; last[u] = val[f[u]] ? f[u] : last[f[u]]; &#125; &#125; for(int i = qt; i; i--) cnt[f[que[i]]] += cnt[que[i]];&#125; int main()&#123; init(); scanf("%d", &amp;n); for(int i = 1; i &lt;= n; i++)&#123; scanf("%s", s); insert(s, i); &#125; getfail(); for(int i = 1; i &lt;= n; i++) printf("%d\n", cnt[id[i]]); return 0;&#125;]]></content>
      <categories>
        <category>AC自动机</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[bzoj-3926(诸神眷顾的幻想乡)]]></title>
    <url>%2F2019%2F05%2F23%2Fbzoj-3926-%E8%AF%B8%E7%A5%9E%E7%9C%B7%E9%A1%BE%E7%9A%84%E5%B9%BB%E6%83%B3%E4%B9%A1%2F</url>
    <content type="text"><![CDATA[链接：https://www.lydsy.com/JudgeOnline/problem.php?id=3926思路：广义后缀自动机的模板题，反正建议以后广义后缀自动机都直接拓扑排序，不要用基数排序，基数排序非常容易出现翻车事故。这个题就是将20个叶子节点拿来暴力dfs插入SAM中，记得插的时候子节点要接着父节点插，最后dfs或者拓扑排序统计答案即可。代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include&lt;bits/stdc++.h&gt;using namespace std; int sigma_size;const int maxn = 2e6 + 5;typedef long long ll;int len[maxn * 2]; //最长子串的长度(该节点字串数量=len[x]-len[f[x]])int f[maxn * 2]; //后缀链接(最短串前部减少一个字符所到达的状态)int cnt[maxn * 2]; //被后缀连接的数int ch[maxn * 2][11]; //状态转移(尾部加一个字符的下一个状态)(图)int idx; //节点编号int epos[maxn * 2]; // enpos数（该状态子串出现数量）int n;vector&lt;int&gt; G[100005];int d[100005];int col[100005]; void init() &#123; //初始化 idx = 1; //1表示root起始点 空集 f[1] = len[1] = 0; memset(ch[1], 0, sizeof(ch[1]));&#125; //SAM建图int add(int c, int last) &#123; //插入字符，为字符ascll码值 int x = ++idx; //创建一个新节点x; len[x] = len[last] + 1; // 长度等于最后一个节点+1 epos[x] = 1; //接受节点子串除后缀连接还需加一 int p; //第一个有C转移的节点; for (p = last; p &amp;&amp; !ch[p][c]; p = f[p])ch[p][c] = x;//沿着后缀连接 将所有没有字符c转移的节点直接指向新节点 if (!p)f[x] = 1, cnt[1]++; //全部都没有c的转移 直接将新节点后缀连接到起点 else &#123; int q = ch[p][c]; //p通过c转移到的节点 if (len[p] + 1 == len[q]) //pq是连续的 f[x] = q, cnt[q]++; //将新节点后缀连接指向q即可,q节点的被后缀连接数+1 else &#123; int nq = ++idx; //不连续 需要复制一份q节点 len[nq] = len[p] + 1; //令nq与p连续 f[nq] = f[q]; //因后面link[q]改变此处不加cnt memcpy(ch[nq], ch[q], sizeof(ch[q])); //复制q的信息给nq for (; p &amp;&amp; ch[p][c] == q; p = f[p]) ch[p][c] = nq; //沿着后缀连接 将所有通过c转移为q的改为nq f[q] = f[x] = nq; //将x和q后缀连接改为nq cnt[nq] += 2; // nq增加两个后缀连接 &#125; &#125; last = x; //更新最后处理的节点 return last;&#125; void dfs(int u, int f, int last)&#123; int t = add(col[u], last); for(int i = 0; i &lt; G[u].size(); i++)&#123; int v = G[u][i]; if(v == f) continue; dfs(v, u, t); &#125;&#125; int main() &#123; scanf("%d %d", &amp;n, &amp;sigma_size); init(); for(int i = 1; i &lt;= n; i++) scanf("%d", &amp;col[i]); for(int i = 1; i &lt; n; i++)&#123; int u, v; scanf("%d %d", &amp;u, &amp;v); G[u].push_back(v); G[v].push_back(u); d[u]++, d[v]++; &#125; for(int i = 1; i &lt;= n; i++)&#123; if(d[i] == 1) dfs(i, 0, 1); &#125; ll res = 0; for(int i = 1; i &lt;= idx; i++) res += len[i] - len[f[i]]; printf("%lld\n", res); return 0;&#125;]]></content>
      <categories>
        <category>后缀自动机</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Round 221 (Div.1)-D(Tree and Queries)]]></title>
    <url>%2F2019%2F05%2F22%2FCodeforces-Round-221-Div-1-D-Tree-and-Queries%2F</url>
    <content type="text"><![CDATA[链接：https://codeforces.com/contest/375/problem/D思路：看了lls的博客，发现了这个题，以前做的树上都是两点间路径上的某些统计问题，对于一个子树的突然愣了不知道怎么搞。其实后来发现很简单，如果是树上路径，我们是dfs序，进出都要记录一下，这样可以恰好容斥去掉中间进去又出来过的节点。但是子树就只需要复制一遍，记录进入时就行，出来时不需要再复制只需要记录位置即可。这样也就是等同于在序列上的一段。至于大于等于某个k的节点数，我们用个数组记录某个颜色出现多少次，再用某个数组记录至少出现x次的有多少个即可。然后就可以很明显的更新了。 思考一下如果要求子树小于等于(转为大于对立面)，出现的种类(维护出现次数)等怎么做。 总结一下，树上莫队，如果求两点间路径，则要复制两边，dfs序进入和出来都要复制；如果是求一个子树内的，那么只要复制一遍，且进去和出来都记录一下位置即可。代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e5 + 233;struct node&#123; int l, r, k, pos, id; bool operator &lt;(const node &amp;x) const&#123; return pos ^ x.pos ? l &lt; x.l : (pos &amp; 1 ? r &lt; x.r : r &gt; x.r); &#125;&#125;q[maxn];int a[maxn];vector&lt;int&gt; G[maxn];int in[maxn], out[maxn], ntime;int c[maxn];int cnt[maxn];int num[maxn];int ans[maxn];int n, m;int sz;void dfs(int u, int f)&#123; in[u] = ++ntime; c[ntime] = a[u]; for(auto &amp;v : G[u])&#123; if(v == f) continue; dfs(v, u); &#125; out[u] = ntime;&#125;int main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); cin &gt;&gt; n &gt;&gt; m; for(int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i]; for (int i = 1; i &lt; n; ++i) &#123; int u, v; cin &gt;&gt; u &gt;&gt; v; G[u].emplace_back(v); G[v].emplace_back(u); &#125; dfs(1, 0); sz = sqrt(n + 0.5); int l = 1, r = 0; for(int i = 1; i &lt;= m; i++)&#123; cin &gt;&gt; q[i].l &gt;&gt; q[i].k; q[i].r = out[q[i].l]; q[i].l = in[q[i].l]; q[i].id = i; q[i].pos = q[i].l / sz; &#125; sort(q + 1, q + m + 1); for(int i = 1; i &lt;= m; i++)&#123; while(l &lt; q[i].l) num[cnt[c[l++]]--]--; while(l &gt; q[i].l) num[++cnt[c[--l]]]++; while(r &lt; q[i].r) num[++cnt[c[++r]]]++; while(r &gt; q[i].r) num[cnt[c[r--]]--]--; ans[q[i].id] = num[q[i].k]; &#125; for(int i = 1; i &lt;= m; i++) cout &lt;&lt; ans[i] &lt;&lt; '\n'; return 0;&#125;]]></content>
      <categories>
        <category>莫队</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[P4149[IOI2011]-(Race)]]></title>
    <url>%2F2019%2F05%2F22%2FP4149-IOI2011-Race%2F</url>
    <content type="text"><![CDATA[链接:https://www.luogu.org/problemnew/show/P4149思路:题目求树上路径长为k时最短的边数。考虑点分治，如果我们想要应用容斥，就不能直接更新最小值，因为取最小值不存在逆运算，这时候我们要把所有边数的方案都存下来，然后就可以容斥了，最后直接从小到大扫一遍看i为多少时方案不为0，即为最小值，这样做复杂度O(nlognlogn)，因为每棵子树里面还需要排序一下，然后O(n)统计答案。这是比较传统的做法 考虑怎么样才能不重复计算，即每次更新最小值的两个端点都必须以你当前枚举的点为lca，因为之前是把所有子树的都统计了一起处理，再减去各个子树分开时的方案，从而得到横跨枚举点的方案，其实我们只用先统计方案再更新子树就可以避免子树内不合法的情况的更新。考虑维护一下t[x] = y，表示当距离为x时，最少经过y条边，每次我们先对子树内所有点都更新(此时t里面保存的信息是不包括这个子树的信息)，等所有子树的点都更新完后我们再把子树更新到t里面去，这样就可以避免不合法情况计算入内。完了后再清空即可(注意不要memset，直接再遍历一遍子树把访问到的点清空就行了)。这样复杂度为O(nlogn)，比上面复杂度稍好。代码：容斥计数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include &lt;bits/stdc++.h&gt;using namespace std;struct edge&#123; int from, to, dist;&#125;;typedef pair&lt;int, int&gt; pii;const int maxn = 4e5 + 233;vector&lt;int&gt; G[maxn];pii d[maxn], q[maxn];int size, sz[maxn], son[maxn], rt, ans[2 * maxn];vector&lt;edge&gt; edges;int n, k, tot;bool vis[maxn];void addedge(int from, int to, int dist)&#123; edges.push_back(edge&#123;from, to, dist&#125;); G[from].push_back(edges.size() - 1);&#125;void getroot(int u, int f)&#123; sz[u] = 1, son[u] = 0; for(int i = 0; i &lt; G[u].size(); i++)&#123; edge &amp;e = edges[G[u][i]]; if(vis[e.to] || e.to == f) continue; getroot(e.to, u); sz[u] += sz[e.to]; son[u] = max(son[u], sz[e.to]); &#125; son[u] = max(son[u], size - sz[u]); if(son[u] &lt; son[rt]) rt = u;&#125;void get(int u, int f)&#123; if(d[u].first &lt;= k) q[++tot] = d[u]; for(int i = 0; i &lt; G[u].size(); i++)&#123; edge &amp;e = edges[G[u][i]]; if(vis[e.to] || e.to == f) continue; d[e.to].first = d[u].first + e.dist; d[e.to].second = d[u].second + 1; get(e.to, u); &#125;&#125;void solve(int u, int v, int w, int x)&#123; tot = 0; d[u] = pii(v, w); get(u, 0); sort(q + 1, q + tot + 1); int l = 1, r = tot; while(l &lt;= r)&#123; while(l &lt; r &amp;&amp; q[l].first + q[r].first &gt; k) r--; for (int i = r; q[l].first + q[i].first == k ; i--) ans[q[l].second + q[i].second] += x; l++; &#125;&#125;void dfs(int u)&#123; vis[u] = 1; solve(u, 0, 0, 1); for(int i = 0; i &lt; G[u].size(); i++)&#123; edge &amp;e = edges[G[u][i]]; if(vis[e.to]) continue; rt = 0; solve(e.to, e.dist, 1, -1); size = sz[e.to]; getroot(e.to, 0); dfs(rt); &#125;&#125;int main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); cin &gt;&gt; n &gt;&gt; k; for(int i = 1; i &lt; n; i++)&#123; int u, v, w; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; u++, v++; addedge(u, v, w); addedge(v, u, w); &#125; size = n; son[0] = 1e9; getroot(1, 0); dfs(rt); int res = -1; for(int i = 0; i &lt;= n; i++)&#123; if(ans[i] &gt; 0)&#123; res = i; break; &#125; &#125; cout &lt;&lt; res &lt;&lt; '\n'; return 0;&#125; 巧妙分开避免不合法情况123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103#include &lt;bits/stdc++.h&gt;using namespace std;struct edge&#123; int from, to, dist;&#125;;const int maxn = 4e5 + 233;vector&lt;int&gt; G[maxn];int size, sz[maxn], son[maxn], rt, ans;vector&lt;edge&gt; edges;int n, k;bool vis[maxn];int t[maxn * 3];int d[maxn], dep[maxn];void addedge(int from, int to, int dist)&#123; edges.push_back(edge&#123;from, to, dist&#125;); G[from].push_back(edges.size() - 1);&#125;void getroot(int u, int f)&#123; sz[u] = 1, son[u] = 0; for(int i = 0; i &lt; G[u].size(); i++)&#123; edge &amp;e = edges[G[u][i]]; if(vis[e.to] || e.to == f) continue; getroot(e.to, u); sz[u] += sz[e.to]; son[u] = max(son[u], sz[e.to]); &#125; son[u] = max(son[u], size - sz[u]); if(son[u] &lt; son[rt]) rt = u;&#125;void get(int u, int f)&#123; if(d[u] &lt;= k) ans = min(ans, t[k - d[u]] + dep[u]); for(int i = 0; i &lt; G[u].size(); i++)&#123; edge &amp;e = edges[G[u][i]]; if(e.to == f || vis[e.to]) continue; d[e.to] = d[u] + e.dist; dep[e.to] = dep[u] + 1; get(e.to, u); &#125;&#125;void update(int u, int f, bool flag)&#123; if(d[u] &lt;= k)&#123; if(flag) t[d[u]] = min(t[d[u]], dep[u]); else t[d[u]] = 1e8; &#125; for(int i = 0; i &lt; G[u].size(); i++)&#123; edge &amp;e = edges[G[u][i]]; if(vis[e.to] || e.to == f) continue; update(e.to, u, flag); &#125;&#125;void dfs(int u)&#123; vis[u] = 1; t[0] = 0; for(int i = 0; i &lt; G[u].size(); i++) &#123; edge &amp;e = edges[G[u][i]]; if (vis[e.to]) continue; dep[e.to] = 1; d[e.to] = e.dist; get(e.to, 0); update(e.to, 0, 1); &#125; for(int i = 0; i &lt; G[u].size(); i++)&#123; edge &amp;e = edges[G[u][i]]; if(vis[e.to]) continue; update(e.to, 0, 0); &#125; for(int i = 0; i &lt; G[u].size(); i++)&#123; edge &amp;e = edges[G[u][i]]; if (vis[e.to]) continue; rt = 0; size = sz[e.to]; getroot(e.to, 0); dfs(rt); &#125;&#125;int main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); cin &gt;&gt; n &gt;&gt; k; for(int i = 1; i &lt; n; i++)&#123; int u, v, w; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; u++, v++; addedge(u, v, w); addedge(v, u, w); &#125; for(int i = 0; i &lt;= k; i++) t[i] = 1e8; ans = 1e9; size = n; son[0] = 1e9; getroot(1, 0); dfs(rt); if(ans &gt;= 1e8) ans = -1; cout &lt;&lt; ans &lt;&lt; '\n'; return 0;&#125;]]></content>
      <categories>
        <category>点分治</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[hdu-6532(Chessboard)]]></title>
    <url>%2F2019%2F05%2F20%2Fhdu-6532-Chessboard%2F</url>
    <content type="text"><![CDATA[链接：http://acm.hdu.edu.cn/showproblem.php?pid=6532思路：lls是真的强啊，一眼就看出来怎么建图了。首先把所有棋子的所在行列拿出来，然后离散化，对于所有行限制，二分找到离散化后的行结点中第一个大于他的位置(如果比最后一个还大则忽略)，然后该点向下一个点连一条容量为y，费用为0的边，同理列限制(只是改成向上连因为是流出，好像向下也可以这个没细想，我是向上的。)。然后所有棋子对应的行结点向列结点连一条容量为1，费用为-i的边，源点连向第一个行结点，第一个列结点连向汇点，跑一个最大费用流即可。代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 2000;const int INF = 1e9;int n, m;struct edge &#123; int from, to, cap, flow, cost;&#125;;int tot, s, t;vector&lt;edge&gt; edges;vector&lt;int&gt; G[maxn];int inq[maxn];int d[maxn];int p[maxn];int a[maxn];vector&lt;int&gt; h, c;int vh[maxn], vc[maxn];int u[maxn], v[maxn];void init() &#123; for (int i = 0; i &lt;= t; i++)G[i].clear(); edges.clear();&#125;void addedge(int from,int to,int cap,int cost) &#123; edges.push_back(edge&#123;from, to, cap, 0, cost&#125;); edges.push_back(edge&#123;to, from, 0, 0, -cost&#125;); tot = edges.size(); G[from].push_back(tot - 2); G[to].push_back(tot - 1);&#125;bool spfa(int &amp;flow,int &amp;cost) &#123; for (int i = 0; i &lt;= t; i++)d[i] = INF; memset(inq, 0, sizeof(inq)); d[s] = 0; inq[s] = 1; p[s] = 0; a[s] = INF; queue&lt;int&gt; q; q.push(s); while (!q.empty()) &#123; int u = q.front(); q.pop(); inq[u] = 0; for (int i = 0; i &lt; G[u].size(); i++) &#123; edge &amp;e = edges[G[u][i]]; if (e.cap &gt; e.flow &amp;&amp; d[e.to] &gt; d[u] + e.cost) &#123; d[e.to] = d[u] + e.cost; p[e.to] = G[u][i]; a[e.to] = min(a[u], e.cap - e.flow); if (!inq[e.to]) &#123; q.push(e.to); inq[e.to] = 1; &#125; &#125; &#125; &#125; if (d[t] == INF)return false; flow += a[t]; cost += d[t] * a[t]; int u = t; while (u != s) &#123; edges[p[u]].flow += a[t]; edges[p[u] ^ 1].flow -= a[t]; u = edges[p[u]].from; &#125; return true;&#125;int mincost() &#123; int flow = 0, cost = 0; while (spfa(flow, cost)); return cost;&#125;int main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); while(cin &gt;&gt; n)&#123; h.clear(), c.clear(); for(int i = 1; i &lt;= n; i++)&#123; cin &gt;&gt; u[i] &gt;&gt; v[i]; h.push_back(u[i]); c.push_back(v[i]); &#125; sort(h.begin(), h.end()); h.resize(unique(h.begin(), h.end()) - h.begin()); sort(c.begin(), c.end()); c.resize(unique(c.begin(), c.end()) - c.begin()); t = c.size() + h.size() + 1; s = 0; for(int i = 0; i &lt;= h.size(); i++) vh[i] = 1e9; for(int i = 0; i &lt;= c.size(); i++) vc[i] = 1e9; init(); cin &gt;&gt; m; for(int i = 1; i &lt;= m; i++)&#123; char o[10]; int x, y; cin &gt;&gt; o &gt;&gt; x &gt;&gt; y; if(o[0] == 'R')&#123; int lb = 1; int ub = h.size(); int ans = h.size(); while(ub &gt;= lb)&#123; int mid = ub + lb &gt;&gt; 1; if(h[mid - 1] &gt;= x)&#123; ans = mid; ub = mid - 1; &#125; else lb = mid + 1; &#125; if(h[ans - 1] &lt; x) continue; vh[ans] = min(vh[ans], y); &#125; else &#123; int lb = 1; int ub = c.size(); int ans = c.size(); while (ub &gt;= lb) &#123; int mid = ub + lb &gt;&gt; 1; if (c[mid - 1] &gt;= x) &#123; ans = mid; ub = mid - 1; &#125; else lb = mid + 1; &#125; if(c[ans - 1] &lt; x) continue; vc[ans] = min(vc[ans], y); &#125; &#125; for(int i = 1; i &lt;= h.size(); i++) &#123; addedge(i - 1, i, vh[i], 0); &#125; for(int i = 2; i &lt;= c.size(); i++) &#123; addedge(i + h.size(), i + h.size() - 1, vc[i], 0); &#125; addedge(h.size() + 1, t, vc[1], 0); for(int i = 1; i &lt;= n; i++)&#123; int x = lower_bound(h.begin(), h.end(), u[i]) - h.begin() + 1; int y = lower_bound(c.begin(), c.end(), v[i]) - c.begin() + 1; addedge(x, y + h.size(), 1, -i); &#125; cout &lt;&lt; -mincost() &lt;&lt; '\n'; &#125; return 0;&#125;]]></content>
      <categories>
        <category>网络流</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[hdu-6534(Chika and Friendly Pairs)]]></title>
    <url>%2F2019%2F05%2F20%2Fhdu-6534-Chika-and-Friendly-Pairs%2F</url>
    <content type="text"><![CDATA[链接：http://acm.hdu.edu.cn/showproblem.php?pid=6534思路：时常在怀疑自己为这么菜呜呜呜，比赛前才学了莫队比赛上就懵了，然后队友慢慢写过了我只能回来补题，补的时候我也没咋多想啊十五分钟就写完了。。。为啥比赛的时候就是想不清楚呢。 回到题目，就是一个普通的莫队，每次更新的时候用树状数组维护一下就好了，注意先在外面预处理好每个离散化后的数左右最远能到的位置，这样总复杂度O($n ^ {\frac{3}{2}} logn$)，事实上好像有去掉log的离线做法我暂时还不太会，后面学了来补吧。这个题是真的对不起队友系列，导致后面没时间做一个很简单的费用流了。代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 27000 + 233;struct node&#123; int l, r, id, pos; bool operator&lt;(const node &amp;x)const&#123; return pos ^ x.pos ? l &lt; x.l : (pos &amp; 1 ? r &lt; x.r : r &gt; x.r); &#125;&#125;q[maxn];typedef long long ll;int a[maxn], b[maxn];ll c[maxn];int pl[maxn], pr[maxn];int n, m, k;int sz, len;ll res;ll ans[maxn];int lowbit(int x)&#123; return x &amp; (-x);&#125;void add(int x, int d)&#123; while(x &lt; maxn)&#123; c[x] += d; x += lowbit(x); &#125;&#125;ll query(int x)&#123; ll ret = 0; while(x)&#123; ret += c[x]; x -= lowbit(x); &#125; return ret;&#125;int main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); cin &gt;&gt; n &gt;&gt; m &gt;&gt; k; for(int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i], b[i] = a[i]; sort(b + 1, b + n + 1); len = unique(b + 1, b + n + 1) - b - 1; sz = sqrt(n); for(int i = 1; i &lt;= m; i++)&#123; cin &gt;&gt; q[i].l &gt;&gt; q[i].r; q[i].pos = q[i].l / sz; q[i].id = i; &#125; sort(q + 1, q + m + 1); for(int i = 1; i &lt;= len; i++)&#123; int lb = 1, ub = i; pl[i] = i; while(ub &gt;= lb)&#123; int mid = ub + lb &gt;&gt; 1; if(b[i] - b[mid] &lt;= k)&#123; pl[i] = mid; ub = mid - 1; &#125; else lb = mid + 1; &#125; lb = i, ub = len; pr[i] = len; while(ub &gt;= lb)&#123; int mid = ub + lb &gt;&gt; 1; if(b[mid] - b[i] &lt;= k)&#123; pr[i] = mid; lb = mid + 1; &#125; else ub = mid - 1; &#125; &#125; int l = 1, r = 0; for(int i = 1; i &lt;= m; i++)&#123; while(l &lt; q[i].l)&#123; int x = lower_bound(b + 1, b + len + 1, a[l]) - b; add(x, -1); res -= query(pr[x]) - query(pl[x] - 1); l++; &#125; while(l &gt; q[i].l)&#123; l--; int x = lower_bound(b + 1, b + len + 1, a[l]) - b; res += query(pr[x]) - query(pl[x] - 1); add(x, 1); &#125; while(r &lt; q[i].r)&#123; r++; int x = lower_bound(b + 1, b + len + 1, a[r]) - b; res += query(pr[x]) - query(pl[x] - 1); add(x, 1); &#125; while(r &gt; q[i].r)&#123; int x = lower_bound(b + 1, b + len + 1, a[r]) - b; add(x, -1); res -= query(pr[x]) - query(pl[x] - 1); r--; &#125; ans[q[i].id] = res; &#125; for(int i = 1; i &lt;= m; i++)&#123; cout &lt;&lt; ans[i] &lt;&lt; '\n'; &#125; return 0;&#125;]]></content>
      <categories>
        <category>莫队</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[poj-1741(Tree)]]></title>
    <url>%2F2019%2F05%2F20%2Fpoj-1741-Tree%2F</url>
    <content type="text"><![CDATA[链接：http://poj.org/problem?id=1741思路：点分治模板题。首先找出树的重心，然后开始向下统计答案，每次统计该点及其子树中所有点对的贡献，统计时先把所有点深度求出来，然后排个序，然后用双指针单调统计一下其中 &lt;= k的答案贡献，然后向子树中递归，寻找子树中的重心再重复步骤。注意进入前因为我们多统计了不穿过该点的贡献，多算的就是各个子树内部的加上那条边时多出来的贡献，所以再减去就行了。由于每次都是找重心，最多logn层，每次操作都是nlogn，总的复杂度nlognlogn。代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;const int maxn = 1e4 + 233;vector&lt;int&gt; G[maxn];int n, k;int d[maxn], son[maxn], rt, sz[maxn], q[maxn], tot;bool vis[maxn];typedef long long ll;ll res;int size;struct edge&#123; int from, to, dist;&#125;;vector&lt;edge&gt; edges;void addedge(int from, int to, int dist)&#123; edges.push_back(edge&#123;from, to, dist&#125;); G[from].push_back(edges.size() - 1);&#125;void init()&#123; rt = 0; son[0] = 1e9; for(int i = 1; i &lt;= n; i++) G[i].clear(), vis[i] = 0; res = 0; edges.clear();&#125;void getroot(int u, int f)&#123; sz[u] = 1, son[u] = 0; for(int i = 0; i &lt; G[u].size(); i++)&#123; edge &amp;e = edges[G[u][i]]; if(e.to == f || vis[e.to]) continue; getroot(e.to, u); sz[u] += sz[e.to]; son[u] = max(son[u], sz[e.to]); &#125; son[u] = max(son[u], size - sz[u]); if(son[u] &lt; son[rt]) rt = u;&#125;void get(int u, int f)&#123; q[++tot] = d[u]; for(int i = 0; i &lt; G[u].size(); i++)&#123; edge &amp;e = edges[G[u][i]]; if(e.to == f || vis[e.to]) continue; d[e.to] = d[u] + e.dist; get(e.to, u); &#125;&#125;ll solve(int u, int v)&#123; tot = 0; d[u] = v; get(u, 0); sort(q + 1, q + tot + 1); int r = tot, l = 1; ll ans = 0; while(l &lt; r)&#123; if(q[l] + q[r] &lt;= k)ans += r - l, l++; else r--; &#125; return ans;&#125;void dfs(int u)&#123; vis[u] = 1; res += solve(u, 0); for(int i = 0; i &lt; G[u].size(); i++)&#123; edge &amp;e = edges[G[u][i]]; if(vis[e.to]) continue; res -= solve(e.to, e.dist); size = sz[e.to]; rt = 0; getroot(e.to, 0); dfs(rt); &#125;&#125;int main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); while(cin &gt;&gt; n &gt;&gt; k &amp;&amp; (n || k))&#123; init(); for(int i = 1; i &lt; n; i++) &#123; int u, v, w; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; addedge(u, v, w); addedge(v, u, w); &#125; size = n; getroot(1, 0); dfs(rt); cout &lt;&lt; res &lt;&lt; '\n'; &#125; return 0;&#125;]]></content>
      <categories>
        <category>点分治</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[poj-1655(Balancing Act)]]></title>
    <url>%2F2019%2F05%2F20%2Fpoj-1655-Balancing%20Act%2F</url>
    <content type="text"><![CDATA[链接：http://poj.org/problem?id=1741思路：求树的重心。为什么放到点分治里面呢，因为他是点分治的前提。重心是指最大子树的节点数最小的根结点，其实用一次树形dp就做出来了，中间维护一下每个点的son，表示最大的子节点个数，然后统计下答案即可。代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;const int maxn = 20000 + 233;int T, n;vector&lt;int&gt; G[maxn];int sz[maxn], son[maxn];int ans, res;void init()&#123; for(int i = 1; i &lt;= n; i++) G[i].clear(); res = 1e9, ans = 0;&#125;void dfs(int u, int f)&#123; sz[u] = 1, son[u] = 0; for(int i = 0; i &lt; G[u].size(); i++)&#123; int v = G[u][i]; if(v == f) continue; dfs(v, u); sz[u] += sz[v]; son[u] = max(son[u], sz[v]); &#125; son[u] = max(son[u], n - sz[u]); if(son[u] &lt; res)&#123; res = son[u]; ans = u; &#125;&#125;int main()&#123; scanf("%d", &amp;T); while(T--)&#123; scanf("%d", &amp;n); init(); for(int i = 1; i &lt; n; i++)&#123; int u, v; scanf("%d %d", &amp;u, &amp;v); G[u].push_back(v); G[v].push_back(u); &#125; dfs(1, 0); printf("%d %d\n", ans, res); &#125; return 0;&#125;]]></content>
      <categories>
        <category>点分治</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[bzoj-2152(聪聪可可)]]></title>
    <url>%2F2019%2F05%2F20%2Fbzoj-2152-%E8%81%AA%E8%81%AA%E5%8F%AF%E5%8F%AF%2F</url>
    <content type="text"><![CDATA[链接：https://www.lydsy.com/JudgeOnline/problem.php?id=2152思路：求树上路径问题，典型用点分治。本质上其实就是求有多少点对之间的路径和是3的倍数，那么我们可以记录到根的距离，然后记录模3结果为0，1，2的分别有多少，统计答案是就是sum[0] sum[0] + 2 sum[1] * sum[2]。代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 2e4 + 233; typedef long long ll;struct edge&#123; int from, to, dist;&#125;; int n, rt;vector&lt;int&gt; G[maxn];vector&lt;edge&gt; edges;int d[maxn], sum[3];int son[maxn], sz[maxn], size;ll cnt;bool vis[maxn]; void addedge(int from, int to, int dist)&#123; edges.push_back(edge&#123;from, to, dist&#125;); G[from].push_back(edges.size() - 1);&#125; void getroot(int u, int f)&#123; son[u] = 0, sz[u] = 1; for(int i = 0; i &lt; G[u].size(); i++)&#123; edge &amp;e = edges[G[u][i]]; if(vis[e.to] || e.to == f)continue; getroot(e.to, u); sz[u] += sz[e.to]; son[u] = max(son[u], sz[e.to]); &#125; son[u] = max(son[u], size - sz[u]); if(son[u] &lt; son[rt]) rt = u;&#125; void get(int u, int f)&#123; sum[d[u] % 3]++; for(int i = 0; i &lt; G[u].size(); i++)&#123; edge &amp;e = edges[G[u][i]]; if(vis[e.to] || e.to == f) continue; d[e.to] = d[u] + e.dist; get(e.to, u); &#125;&#125; ll solve(int u, int v)&#123; d[u] = v; memset(sum, 0, sizeof(sum)); get(u, 0); ll ans = 1ll * sum[2] * sum[1] * 2 + sum[0] * sum[0]; return ans;&#125; void dfs(int u)&#123; vis[u] = 1; cnt += solve(u, 0); for(int i = 0; i &lt; G[u].size(); i++)&#123; edge &amp;e = edges[G[u][i]]; if(vis[e.to]) continue; cnt -= solve(e.to, e.dist); rt = 0; size = sz[e.to]; getroot(e.to, 0); dfs(rt); &#125;&#125; int main()&#123; scanf("%d", &amp;n); for(int i = 1; i &lt; n; i++)&#123; int u, v, w; scanf("%d %d %d", &amp;u, &amp;v, &amp;w); addedge(u, v, w); addedge(v, u, w); &#125; son[0] = 1e9; size = n; getroot(1, 0); dfs(rt); ll g = __gcd(cnt, 1ll * n * n); printf("%lld/%lld\n", cnt / g, 1ll * n * n / g); return 0;&#125;]]></content>
      <categories>
        <category>点分治</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[ZOJ-4100(Vertices in the Pocket)]]></title>
    <url>%2F2019%2F05%2F17%2FZOJ-4100-Vertices-in-the-Pocket%2F</url>
    <content type="text"><![CDATA[链接：https://vjudge.net/problem/ZOJ-4100思路：挺好一个题，想了几天细节，还写了很久，结果有一个地方没开long long挂掉了。说下思路，首先最少很好求，就直接减边数就行了，关键是最大。我们容易发现，优先把所有块内的要先填完，然后依次连最大的两个，然后再把块内连完，如果还不够就再跟剩下最大的连。由于块内所有的都已经连满了，所以只要块的大小相同就无差别。那么这个题我们可以想到离线先处理所有可能出现的块大小，然后离散化建一个权值线段树(从大到小)，然后合并的时候就用并查集合并并且在线段树上更新即可。查询的时候直接在线段树上二分，线段树维护连通块数目，点数以及能连的边数三个信息，然后锁定到一个叶子结点，在叶子节点上二分找到连通块数目的答案即可。中间的计算公式可以自行手算推一推，非常简单。代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 2e5 + 5;typedef long long ll;struct ask&#123; ll t, l, r;&#125;a[maxn];vector&lt;int&gt; r;int f[maxn];ll sum[maxn &lt;&lt; 2], cnt[maxn &lt;&lt; 2], val[maxn &lt;&lt; 2];int n, q;ll sz[maxn];int find(int u)&#123; return u == f[u] ? u : f[u] = find(f[u]);&#125;void pushup(int o)&#123; sum[o] = sum[o &lt;&lt; 1] + sum[o &lt;&lt; 1 | 1]; cnt[o] = cnt[o &lt;&lt; 1] + cnt[o &lt;&lt; 1 | 1]; val[o] = val[o &lt;&lt; 1] + val[o &lt;&lt; 1 | 1] + sum[o &lt;&lt; 1] * sum[o &lt;&lt; 1 | 1];&#125;void build(int o, int l, int r)&#123; if(l == r)&#123; sum[o] = 0; cnt[o] = 0; val[o] = 0; return; &#125; int mid = l + r &gt;&gt; 1; build(o &lt;&lt; 1, l, mid); build(o &lt;&lt; 1 | 1, mid + 1, r); pushup(o);&#125;void update(int o, int tl, int tr, int x, ll v, ll w)&#123; if(x &gt; tr || x &lt; tl) return; if(x == tl &amp;&amp; x == tr)&#123; if(w == 1) val[o] += sum[o] * v; sum[o] += v; cnt[o] += w; if(w == -1) val[o] += sum[o] * v; return; &#125; int mid = tl + tr &gt;&gt; 1; update(o &lt;&lt; 1, tl, mid, x, v, w); update(o &lt;&lt; 1 | 1, mid + 1, tr, x ,v, w); pushup(o);&#125;int query(int o, int tl, int tr, ll x1, ll x2, ll s, ll v)&#123; if(tl == tr)&#123; ll lb = 0; ll ub = cnt[o]; ll ans = cnt[o]; while(ub &gt;= lb)&#123; ll mid = ub + lb &gt;&gt; 1; if(s + x1 * r[tl - 1] * mid + 1ll * (mid - 1) * mid / 2 * r[tl - 1] * r[tl - 1] &gt;= v)&#123; ans = mid; ub = mid - 1; &#125; else lb = mid + 1; &#125; return x2 + ans; &#125; int mid = tl + tr &gt;&gt; 1; if(s + val[o &lt;&lt; 1] + x1 * sum[o &lt;&lt; 1] &gt;= v) return query(o &lt;&lt; 1, tl, mid, x1, x2, s, v); return query(o &lt;&lt; 1 | 1, mid + 1, tr, x1 + sum[o &lt;&lt; 1], x2 + cnt[o &lt;&lt; 1], s + val[o &lt;&lt; 1] + x1 * sum[o &lt;&lt; 1], v);&#125;int T;int main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); cin &gt;&gt; T; while(T--) &#123; r.clear(); cin &gt;&gt; n &gt;&gt; q; for(int i = 1; i &lt;= n; i++) f[i] = i, sz[i] = 1; r.push_back(1); for (int i = 1; i &lt;= q; i++)&#123; cin &gt;&gt; a[i].t &gt;&gt; a[i].l; if(a[i].t == 1) &#123; cin &gt;&gt; a[i].r; int fx = find(a[i].l); int fy = find(a[i].r); if(fx == fy) continue; f[fy] = fx; sz[fx] += sz[fy]; r.push_back(sz[fx]); &#125; &#125; sort(r.begin(), r.end(), greater&lt;int&gt;()); r.resize(unique(r.begin(), r.end()) - r.begin()); build(1, 1, r.size()); for(int i = 1; i &lt;= n; i++) &#123; int x = lower_bound(r.begin(), r.end(), 1, greater&lt;int&gt;()) - r.begin() + 1; update(1, 1, r.size(), x, 1, 1); f[i] = i, sz[i] = 1; &#125; ll res = 0; int num = n; for(int i = 1; i &lt;= q; i++)&#123; if(a[i].t == 1)&#123; int fx = find(a[i].l); int fy = find(a[i].r); if(fx == fy)&#123; res--; continue; &#125; num--; res += 1ll * sz[fx] * sz[fy] - 1; int x = lower_bound(r.begin(), r.end(), sz[fx], greater&lt;int&gt;()) - r.begin() + 1; update(1, 1, r.size(), x, -sz[fx], -1); x = lower_bound(r.begin(), r.end(), sz[fy], greater&lt;int&gt;()) - r.begin() + 1; update(1, 1, r.size(), x, -sz[fy], -1); f[fy] = fx; sz[fx] += sz[fy]; x = lower_bound(r.begin(), r.end(), sz[fx], greater&lt;int&gt;()) - r.begin() + 1; update(1, 1, r.size(), x, sz[fx], 1); &#125; else&#123; //cout &lt;&lt; res &lt;&lt; '\n'; ll r1 = num - a[i].l; if(r1 &lt; 1) r1 = 1; ll r2; ll tmp = a[i].l - res; if(tmp &lt;= 0) r2 = num; else&#123; r2 = num - query(1, 1, r.size(), 0, 0, 0, tmp) + 1; &#125; cout &lt;&lt; r1 &lt;&lt; ' ' &lt;&lt; r2 &lt;&lt; '\n'; &#125; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>线段树</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[ZOJ-4110(Strings in the Pocket)]]></title>
    <url>%2F2019%2F05%2F05%2FZOJ-4110-Strings-in-the-Pocket%2F</url>
    <content type="text"><![CDATA[链接：https://vjudge.net/problem/ZOJ-4110思路：找到左边不一样的分界线，再找到右边不一样的分界线，如果中间那段相等，考虑肯定是向两边拓展，如果只向一边拓展，比如右边拓展一个，那么可以推出最右边两个和最左边两个都是相同的，这样与最左边两个是分界线矛盾了，所以必然是两个一起向外面拓展，并且拓展到第一个不一样的位置就结束了，看最远能拓展多远即可。如果中间倒过来不相等就无解了。还有一种情况就是两个串完全相等，这样问题就变成了回文串的个数，manacher搞一下即可。代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include&lt;bits/stdc++.h&gt;using namespace std;const int N = 2000000 + 600;int cnt, len;char s[N], ss[N * 2], t[N];int p[N * 2];typedef long long ll;ll res;int T;void init()&#123;//将每两个字符中插入一个字符 len = strlen(s), cnt = 1; ss[0] = '!'; ss[cnt] = '#'; for(int i = 0; i &lt; len; i++) ss[++cnt] = s[i], ss[++cnt] = '#'; ss[++cnt] = '\0';&#125;void manacher()&#123; init(); int pos = 0, mx = 0; for(int i = 1; i &lt; cnt; i++)&#123; if(i &lt; mx) p[i] = min(p[pos * 2 - i], mx - i); else p[i] = 1; while(ss[i + p[i]] == ss[i - p[i]]) p[i]++; if(mx &lt; i + p[i]) mx = i + p[i], pos = i; res += p[i] / 2; &#125;&#125;int main()&#123; scanf("%d", &amp;T); while(T--)&#123; scanf("%s %s", s, t); len = strlen(s); res = 0; int l = len - 1, r = 0; for(int i = 0; i &lt; len; i++)&#123; if(s[i] != t[i])&#123; l = i; break; &#125; &#125; for(int i = len - 1; i &gt;= 0; i--)&#123; if(s[i] != t[i])&#123; r = i; break; &#125; &#125; if(l &gt; r)&#123; init(); manacher(); printf("%lld\n", res); continue; &#125; bool f = false; for(int i = l, j = r; i &lt;= r; i++, j--)&#123; if(s[i] != t[j])&#123; f = true; break; &#125; &#125; if(f)&#123; printf("0\n"); continue; &#125; res = 1; while(l &gt; 0 &amp;&amp; r &lt; len - 1)&#123; if(s[l - 1] != t[r + 1]) break; res++, l--, r++; &#125; printf("%lld\n", res); &#125; return 0;&#125;]]></content>
      <categories>
        <category>manacher</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[ZOJ-4102(Array in the Pocket)]]></title>
    <url>%2F2019%2F05%2F05%2FZOJ-4102-Array-in-the-Pocket%2F</url>
    <content type="text"><![CDATA[链接：https://vjudge.net/problem/ZOJ-4102思路：一开始给的思路是对的，即先看有没有已经到一半的必须要填的，如果有就填，没有就找最小的看是否跟当前位置一样，一样就后移一个数，否则就填这个最小的。然后学会了set维护的方式，用第一个set来表示最小的数，用第二个来表示当前的需要填的(新数组)和待填(原数组)数量，首先去第二个里面看最大的数量是否等于剩下的数量，如果等于就必须填，否则去第一个里面找最小的，拿出来看是否和原位置一样，如果一样填后面一个，不一样填该数，然后更新一下两个set即可。感觉如果熟练set的用法的话这个题应该是非常简单。代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;bits/stdc++.h&gt;using namespace std;int n;typedef pair&lt;int, int&gt; pii;const int maxn = 1e5 + 5;set&lt;pii&gt; s1, s2;int cnt[maxn], cc[maxn];int T;int a[maxn];int res[maxn];int main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); cin &gt;&gt; T; while(T--)&#123; s1.clear(), s2.clear(); cin &gt;&gt; n; for(int i = 1; i &lt;= n; i++) cnt[i] = cc[i] = 0; for(int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i], cnt[a[i]]++, cc[a[i]] += 2; for(int i = 1; i &lt;= n; i++)&#123; if(cnt[i])&#123; s1.insert(pii(i, cnt[i])); s2.insert(pii(cc[i], i)); &#125; &#125; if((--s2.end())-&gt;first &gt; n)&#123; cout &lt;&lt; "Impossible\n"; continue; &#125; for(int i = 1; i &lt;= n; i++)&#123; s2.erase(pii(cc[a[i]], a[i])); s2.insert(pii(--cc[a[i]], a[i])); set&lt;pii&gt;::iterator p = --s2.end(); if(p-&gt;first == n - i + 1)&#123; res[i] = p-&gt;second; &#125; else&#123; if(a[i] == s1.begin()-&gt;first) res[i] = (++s1.begin())-&gt;first; else res[i] = s1.begin()-&gt;first; &#125; s1.erase(pii(res[i], cnt[res[i]])); if(--cnt[res[i]])s1.insert(pii(res[i], cnt[res[i]])); s2.erase(pii(cc[res[i]], res[i])); if(--cc[res[i]]) s2.insert(pii(cc[res[i]], res[i])); &#125; for(int i = 1; i &lt;= n; i++) cout &lt;&lt; res[i] &lt;&lt; (i == n ? '\n' : ' '); &#125; return 0;&#125;]]></content>
      <categories>
        <category>贪心</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Round 187 (Div.1)-C(Sereja and Subsequences)]]></title>
    <url>%2F2019%2F05%2F05%2FCodeforces-Round-187-Div-1-C-Sereja-and-Subsequences%2F</url>
    <content type="text"><![CDATA[链接：https://codeforces.com/problemset/problem/314/C思路：令dp[i]表示以元素值为i的元素结尾的方案数，那么转移就是从$\sum_{j=1}^i dp[i] * (a[i] + 1)$，这个可以用前缀和来维护，但是本题最难的问题是重复怎么去除，其实也很简单，我们记录一下前一个这个值得到的值，那么本次更新的贡献就是二者之差，由于前缀和需要更新，树状数组维护一下即可。代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e6 + 5;typedef long long ll;ll c[maxn];int pre[maxn];const ll mod = 1e9 + 7;int n;void add(ll &amp;x, ll y)&#123; x += y; if(x &gt;= mod) x -= mod;&#125;int lowbit(int x)&#123; return x &amp; (-x);&#125;void update(int x, ll d)&#123; while(x &lt; maxn)&#123; add(c[x], d); x += lowbit(x); &#125;&#125;ll query(int x)&#123; ll ret = 0; while(x)&#123; add(ret, c[x]); x -= lowbit(x); &#125; return ret;&#125;int main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); cin &gt;&gt; n; ll res = 0; for(int i = 1; i &lt;= n; i++)&#123; int x; cin &gt;&gt; x; ll tmp = query(x); ll y = (x * (tmp + 1 - pre[x]) % mod + mod) % mod; add(res, y); update(x, y); pre[x] = 1 + tmp; &#125; cout &lt;&lt; query(maxn) &lt;&lt; '\n'; return 0;&#125;]]></content>
      <categories>
        <category>基础dp</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[MemSQL Start[c]UP 3.0 - Round 2 (onsite finalists)-D(Buy Low Sell High)]]></title>
    <url>%2F2019%2F05%2F05%2FMemSQL-Start-c-UP-3-0-Round-2-onsite-finalists-D-Buy-Low-Sell-High%2F</url>
    <content type="text"><![CDATA[链接：https://codeforces.com/problemset/problem/865/D思路：真的是非常好一个贪心题，我一直在想怎么配对，这个题其实就引入了一个新的思路。首先我们知道肯定买和卖的数量是一样的，怎么样才能一样呢，我们每天买一张并且卖一张就肯定一样了，但不一定是要买今天的，我们对于一个新股票，我们把它价值取负放进优先队列里，然后默认它要卖，再从优先队列里取一个出来当作买的(如果是同一个就相当于不买也不卖了)，这样优先队列就相当于一个中转站，给了贪心一个反悔的策略，但是可能整个股票还要作为买的，所以我们要把股票放入优先队列中两次即可。代码：1234567891011121314151617181920212223#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 3e5 + 5;int n;priority_queue&lt;int&gt; q;int main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); cin &gt;&gt; n; ll res = 0; for(int i = 1; i &lt;= n; i++)&#123; int x; cin &gt;&gt; x; q.emplace(-x); q.emplace(-x); res += x + q.top(); q.pop(); &#125; cout &lt;&lt; res &lt;&lt; '\n'; return 0;&#125;]]></content>
      <categories>
        <category>贪心</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Round 334 (Div.1)-B(Lieges of Legendre)]]></title>
    <url>%2F2019%2F05%2F05%2FCodeforces-Round-334-Div-1-B-Lieges-of-Legendre%2F</url>
    <content type="text"><![CDATA[链接：https://codeforces.com/problemset/problem/603/C思路：首先需要学习一下SG函数和SG定理，我们定义mex(x) = {后续状态的SG函数中最小未出现的非负整数}，比如mex(2) = {0, 1}, 那么mex(2) = 2。SG(x) = mex(x)。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于本题，如果k为偶数，对于偶数分解后全部异或起来一定为0，所以就直接向-1转移即可，前几项不符合规律，后面的就满足奇0偶1的结果。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于k为奇数，偶数我们考虑往-1和/2两个方向转移，排除前几项之外的奇数都是0，那么就是看/2的值，决定答案是1还是2即可，还是手算前几项就ok了。代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e5 + 5;int f[maxn];int n, k;int dfs(int x)&#123; if(x &lt;= 6) return f[x]; if(x &amp; 1) return 0; return dfs(x / 2) == 1 ? 2 : 1;&#125;int main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); cin &gt;&gt; n &gt;&gt; k; if(k &amp; 1)&#123; f[0] = 0; f[1] = 1; f[2] = 0; f[3] = 1; f[4] = 2; f[5] = 0; f[6] = 2; &#125; else&#123; f[0] = 0; f[1] = 1; f[2] = 2; f[3] = 0; f[4] = 1; f[5] = 0; f[6] = 1; &#125; int res = 0; for(int i = 1; i &lt;= n; i++)&#123; int a; cin &gt;&gt; a; if(k &amp; 1)&#123; if(a &lt;= 6) res ^= f[a]; else res ^= a &amp; 1 ? 0 : dfs(a); &#125; else &#123; if (a &lt;= 6) res ^= f[a]; else res ^= a &amp; 1 ? 0 : 1; &#125; &#125; if(res) cout &lt;&lt; "Kevin\n"; else cout &lt;&lt; "Nicky\n"; return 0;&#125;]]></content>
      <categories>
        <category>博弈</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Round 285 (Div.2)-D(Misha and Permutations Summation)]]></title>
    <url>%2F2019%2F05%2F04%2FCodeforces-Round-285-Div-2-D-Misha-and-Permutations-Summation%2F</url>
    <content type="text"><![CDATA[链接：https://codeforces.com/problemset/problem/501/D思路：首先看一下康拓展开的表达式，排列的序列数X与排列的关系： x = a_0 * (n - 1)! + a_1 * (n - 2)! + ... + a_{n - 1} * 0!其中$a_i$指的是位置i后面小于$a_i$值的个数那么我们可以算出两个排列的康拓展开，因为要对n!取模，好像必须要高精度了，这时候一个巧妙的方法来了，我们可以模拟进制的高精度取模方法，不断进位然后取模，给阶乘也弄一个类似的，不必算出两个排列对应x的和，而是算出每一项的系数，然后从最低位开始向上加，进位(最后一个进位舍掉，相当于取模)，最后结果的系数就是最终排列的每一项了。代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 2e5 + 5;int c[maxn], f[maxn];int n;int lowbit(int x)&#123; return x &amp; (-x);&#125;void add(int x, int d)&#123; while(x &lt; maxn)&#123; c[x] += d; x += lowbit(x); &#125;&#125;int query(int x)&#123; int res = 0; while(x)&#123; res += c[x]; x -= lowbit(x); &#125; return res;&#125;int main()&#123; scanf("%d", &amp;n); for(int i = 1; i &lt;= n; i++) add(i, 1); for (int i = 1; i &lt;= n; ++i) &#123; int x; scanf("%d", &amp;x); x++; add(x, -1); f[n - i + 1] = query(x); &#125; for(int i = 1; i &lt;= n; i++) add(i, 1); for(int i = 1; i &lt;= n; ++i) &#123; int x; scanf("%d", &amp;x); x++; add(x, -1); f[n - i + 1] += query(x); &#125; for(int i = 1; i &lt;= n; i++)&#123; f[i + 1] += f[i] / i; f[i] %= i; &#125; for(int i = 1; i &lt;= n; i++) add(i, 1); for(int i = n; i &gt;= 1; i--)&#123; int lb = 1, ub = n, ans = 1; while(ub &gt;= lb)&#123; int mid = lb + ub &gt;&gt; 1; if(query(mid) &gt;= f[i] + 1)&#123; ub = mid - 1; ans = mid; &#125; else lb = mid + 1; &#125; add(ans, -1); cout &lt;&lt; ans - 1 &lt;&lt; ' '; &#125; cout &lt;&lt; '\n'; return 0;&#125;]]></content>
      <categories>
        <category>康拓展开</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Educational Codeforces Round 64 (Rated for Div.2)-E(Special Segments of Permutation)]]></title>
    <url>%2F2019%2F05%2F04%2FEducational-Codeforces-Round-64-Rated-for-Div-2-E-Special-Segments-of-Permutation%2F</url>
    <content type="text"><![CDATA[链接：https://codeforces.com/contest/1156/problem/E思路：用单调栈求出一个数左右第一个比他大的数，然后需要证明一个结论，如果我们每次枚举左右中小的那个区间，那么每个数枚举次数不会超过logn次，因为每次都枚举的小的一边，所以每次都至少要除以2，最后不会超过logn次，然后暴力枚举答案即可。代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;bits/stdc++.h&gt;using namespace std;int n;const int maxn = 2e5 + 5;int a[maxn], pos[maxn];int l[maxn], r[maxn];typedef long long ll;ll res;stack&lt;int&gt; s;void update(int x, int l, int r, bool f)&#123; if(!f)&#123; for(int i = l; i &lt; x; i++)&#123; if(pos[a[x] - a[i]] &gt; x &amp;&amp; pos[a[x] - a[i]] &lt;= r) res++; &#125; &#125; else&#123; for(int i = x + 1; i &lt;= r; i++)&#123; if(pos[a[x] - a[i]] &lt; x &amp;&amp; pos[a[x] - a[i]] &gt;= l) res++; &#125; &#125;&#125;int main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); cin &gt;&gt; n; for(int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i], pos[a[i]] = i; for(int i = 1; i &lt;= n; i++)&#123; while(!s.empty() &amp;&amp; a[s.top()] &lt; a[i])&#123; r[s.top()] = i; s.pop(); &#125; s.emplace(i); &#125; while(!s.empty())&#123; r[s.top()] = n + 1; s.pop(); &#125; for(int i = n; i; i--)&#123; while(!s.empty() &amp;&amp; a[s.top()] &lt; a[i])&#123; l[s.top()] = i; s.pop(); &#125; s.emplace(i); &#125; while(!s.empty())&#123; l[s.top()] = 0; s.pop(); &#125; //for(int i = 1; i &lt;= n; i++) cout &lt;&lt; i &lt;&lt; ' ' &lt;&lt; l[i] &lt;&lt; ' ' &lt;&lt; r[i] &lt;&lt; '\n'; for(int i = 1; i &lt;= n; i++)&#123; int le = l[i] + 1; int ri = r[i] - 1; if(i - le &lt; ri - i) update(i, le, ri, 0); else update(i, le, ri, 1); &#125; cout &lt;&lt; res &lt;&lt; '\n'; return 0;&#125;]]></content>
      <categories>
        <category>暴力</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Round 345 (Div.1)-C(Table Compression)]]></title>
    <url>%2F2019%2F05%2F04%2FCodeforces-Round-345-Div-1-C-Table-Compression%2F</url>
    <content type="text"><![CDATA[链接：https://codeforces.com/problemset/problem/650/C思路：之前在cf做过一个类似的题，本题思路跟之前那个差不多，把行和列拉出来排序，然后从前往后相同的并查集一下，不同的建边，然后就变为了关于并查集的一个DAG，拓扑排序然后dp一下即可代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116#include &lt;bits/stdc++.h&gt;using namespace std;int n, m;const int maxn = 1e6 + 5;int par[maxn];int a[maxn];int ord[maxn];int tmp[maxn];vector&lt;int&gt; G[maxn];int deg[maxn];int id[maxn];int sz;int ans[maxn];int find(int u)&#123; return u == par[u] ? u : par[u] = find(par[u]);&#125;bool cmp(int x, int y)&#123; return tmp[x] &lt; tmp[y];&#125;void merge(int u, int v)&#123; int fx = find(u); int fy = find(v); if(u == v) return; par[fy] = fx;&#125;int main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); cin &gt;&gt; n &gt;&gt; m; for(int i = 1; i &lt;= n * m; i++) cin &gt;&gt; a[i], par[i] = i; for(int i = 1; i &lt;= n; i++)&#123; for(int j = 1; j &lt;= m; j++)&#123; tmp[j] = a[(i - 1) * m + j]; ord[j] = j; &#125; sort(ord + 1, ord + 1 + m, cmp); for(int j = 1; j &lt; m; j++)&#123; if(tmp[ord[j]] == tmp[ord[j + 1]])&#123; merge((i - 1) * m + ord[j], (i - 1) * m + ord[j + 1]); &#125; &#125; &#125; for(int i = 1; i &lt;= m; i++)&#123; for(int j = 1; j &lt;= n; j++)&#123; tmp[j] = a[(j - 1) * m + i]; ord[j] = j; &#125; sort(ord + 1, ord + 1 + n, cmp); for(int j = 1; j &lt; n; j++)&#123; if(tmp[ord[j]] == tmp[ord[j + 1]])&#123; merge((ord[j] - 1) * m + i, (ord[j + 1] - 1) * m + i); &#125; &#125; &#125; for(int i = 1; i &lt;= n * m; i++)&#123; int f = find(i); if(!id[f]) id[f] = ++sz; &#125; for(int i = 1; i &lt;= n; i++)&#123; for(int j = 1; j &lt;= m; j++)&#123; tmp[j] = a[(i - 1) * m + j]; ord[j] = j; &#125; sort(ord + 1, ord + 1 + m, cmp); for(int j = 1; j &lt; m; j++)&#123; if(tmp[ord[j]] &lt; tmp[ord[j + 1]])&#123; G[id[find((i - 1) * m + ord[j])]].emplace_back(id[find((i - 1) * m + ord[j + 1])]); deg[id[find((i - 1) * m + ord[j + 1])]]++; &#125; &#125; &#125; for(int i = 1; i &lt;= m; i++)&#123; for(int j = 1; j &lt;= n; j++)&#123; tmp[j] = a[(j - 1) * m + i]; ord[j] = j; &#125; sort(ord + 1, ord + 1 + n, cmp); for(int j = 1; j &lt; n; j++)&#123; if(tmp[ord[j]] &lt; tmp[ord[j + 1]])&#123; G[id[find((ord[j] - 1) * m + i)]].emplace_back(id[find((ord[j + 1] - 1) * m + i)]); deg[id[find((ord[j + 1] - 1) * m + i)]]++; &#125; &#125; &#125; int res = 0; queue&lt;int&gt; q; for(int i = 1; i &lt;= sz; i++)if(!deg[i]) q.emplace(i), ans[i] = 1; while(!q.empty())&#123; int u = q.front(); q.pop(); for(auto &amp;v : G[u])&#123; deg[v]--; ans[v] = max(ans[v], ans[u] + 1); if(!deg[v]) q.emplace(v); &#125; &#125; for(int i = 1; i &lt;= n; i++)&#123; for(int j = 1; j &lt;= m; j++)&#123; cout &lt;&lt; res + ans[id[find((i - 1) * m + j)]] &lt;&lt; (j == m ? '\n' : ' '); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>并查集</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Educational Codeforces Round 64 (Rated for Div.2)-F(Card Bag)]]></title>
    <url>%2F2019%2F05%2F02%2FEducational-Codeforces-Round-64-Rated-for-Div-2-F-Card-Bag%2F</url>
    <content type="text"><![CDATA[链接：https://codeforces.com/contest/1156/problem/F思路：问题就是求有多少排列满足$a_1 &lt; a_2 &lt; a_3….. &lt; a_k = a_{k+1}$ ，考虑把原数组排序并去重，记录每个数出线了多少次，类似于背包一样dp。令dp[i][j]表示第i个数是最后一个选的，选了j个的方案数，sum[i][j]表示前i个数中选了j个的方案，然后对于每个i更新完后统计一下对答案的贡献，然后前缀和优化转移一下即可。代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 5050;ll dp[maxn][maxn];ll sum[maxn][maxn];const ll mod = 998244353;int n, m;int a[maxn];ll fac[maxn], inv[maxn];int cnt[maxn];// dp[i][j]表示枚举到第i个结束，选了j个的总方案// sum[i][j]表示前i个，选了j个合法方案的总和void add(ll &amp;x, ll y)&#123; x += y; if(x &gt;= mod) x -= mod;&#125;ll pow_mod(ll q, ll w)&#123; ll ret = 1; while(w)&#123; if(w &amp; 1) ret = ret * q % mod; q = q * q % mod; w &gt;&gt;= 1; &#125; return ret;&#125;int main()&#123; cin &gt;&gt; n; fac[0] = 1, inv[0] = 1; for(int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i], cnt[a[i]]++, fac[i] = fac[i - 1] * i % mod, inv[i] = pow_mod(fac[i], mod - 2); sort(a + 1, a + n + 1); m = unique(a + 1, a + n + 1) - a - 1; ll res = 0; dp[0][0] = 1; sum[0][0] = 1; for(int i = 1; i &lt;= m; i++)&#123; for(int j = 1; j &lt;= i; j++)&#123; add(dp[i][j], cnt[a[i]] * sum[i - 1][j - 1] % mod); &#125; for(int j = 0; j &lt;= i; j++)&#123; add(sum[i][j], sum[i - 1][j]); add(sum[i][j], dp[i][j]); &#125; if(cnt[a[i]] &gt; 1)&#123; for(int j = 0; j &lt;= i; j++)&#123; add(res, dp[i][j] * (cnt[a[i]] - 1) % mod * fac[n - j - 1] % mod); &#125; &#125; &#125; res = res * inv[n] % mod; cout &lt;&lt; res &lt;&lt; '\n'; return 0;&#125;]]></content>
      <categories>
        <category>基础dp</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Educational Codeforces Round 64(Rated for Div.2)-D(0-1-Tree)]]></title>
    <url>%2F2019%2F05%2F02%2FEducational-Codeforces-Round-64-Rated-for-Div-2-D-0-1-Tree%2F</url>
    <content type="text"><![CDATA[链接：https://codeforces.com/contest/1156/problem/D思路：考虑一条路径必然是形如0000000011111111的，那么我们发现一条路径可以通过中转点来计数，这样就不重不漏，这样我们想到可以建两个并查集，一个是由0边组成的一个是由1边组成的，然后维护并查集的大小，最后答案就是所有点的0里面的个数 * 1里面的个数 - 1。代码：12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 2e5 + 5;int f[2][maxn];int sz[2][maxn];int n;int find(int *f, int u)&#123; return f[u] == u ? u : f[u] = find(f, f[u]);&#125;void merge(int *f, int *sz, int u, int v)&#123; int fx = find(f, u); int fy = find(f, v); if(fx == fy) return; sz[fx] += sz[fy]; f[fy] = fx;&#125;int main()&#123; scanf("%d", &amp;n); for (int i = 1; i &lt;= n; ++i) &#123; sz[0][i] = sz[1][i] = 1; f[0][i] = f[1][i] = i; &#125; for (int i = 1; i &lt; n; ++i) &#123; int u, v, w; scanf("%d %d %d", &amp;u, &amp;v, &amp;w); merge(f[w], sz[w], u, v); &#125; ll res = 0; for(int i = 1; i &lt;= n; i++) res += 1ll * sz[0][find(f[0], i)] * sz[1][find(f[1], i)] - 1; printf("%lld\n", res); return 0;&#125;]]></content>
      <categories>
        <category>并查集</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Codeforces-Round-210-(Div.1)-B(Levko and Array)]]></title>
    <url>%2F2019%2F05%2F02%2FCodeforces-Round-210-Div-1-B-Levko-and-Array%2F</url>
    <content type="text"><![CDATA[链接：https://codeforces.com/contest/360/problem/B思路：这个题dp思路就比较巧妙，首先先二分最后的答案，然后令dp[i]表示i是最后一个不同的元素，此时前i个元素相邻的差的绝对值小于二分值时所需要的最小的更改次数，那么转移就是dp[i] = min{dp[j] + i - j - 1} (j &lt; i)。最后找所有的i，看是否存在dp[i] + n - i &lt;= k即可。代码：123456789101112131415161718192021222324252627282930313233343536373839#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 2020;int dp[maxn];typedef long long ll;int n, k;ll a[maxn];bool check(ll x)&#123; for(int i = 1; i &lt;= n; i++) dp[i] = i - 1; for(int i = 1; i &lt;= n; i++)&#123; for(int j = i + 1; j &lt;= n; j++)&#123; if(abs(a[j] - a[i]) &lt;= 1ll * (j - i) * x)&#123; dp[j] = min(dp[j], dp[i] + j - i - 1); &#125; &#125; if(dp[i] + n - i &lt;= k) return true; &#125; return false;&#125;int main()&#123; scanf("%d%d", &amp;n, &amp;k); for (int i = 1; i &lt;= n; ++i) &#123; scanf("%lld", &amp;a[i]); &#125; ll lb = 0, ub = 2e9, ans = 0; while(ub &gt;= lb)&#123; ll mid = ub + lb &gt;&gt; 1; if(check(mid))&#123; ub = mid - 1; ans = mid; &#125; else lb = mid + 1; &#125; printf("%lld\n", ans); return 0;&#125;]]></content>
      <categories>
        <category>基础dp</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Codeforces-Round-551-(Div.2)-D(Serval and Rooted Tree)]]></title>
    <url>%2F2019%2F05%2F02%2FCodeforces-Round-551-Div-2-D-Serval-and-Rooted-Tree%2F</url>
    <content type="text"><![CDATA[链接：https://codeforces.com/contest/1153/problem/D思路：令dp[u]表示u的子树中传上来的数是第k大的数，那么如果边是min，dp[u] = sum{dp[v]}， 如果是max，dp[u] = min{dp[v]}, 最后k - dp[1] + 1就是答案。代码：12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 3e5 + 5;int f[maxn];int ok[maxn];int n, k;vector&lt;int&gt; G[maxn];int dp[maxn];int deg[maxn];void dfs(int u, int fa)&#123; if(ok[u] == 1 &amp;&amp; deg[u]) dp[u] = 1e9; for(auto &amp;v : G[u])&#123; if(v == fa) continue; dfs(v, u); if(ok[u] == 0) dp[u] += dp[v]; else dp[u] = min(dp[u], dp[v]); &#125;&#125;int main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); cin &gt;&gt; n; for (int i = 1; i &lt;= n; ++i) &#123; cin &gt;&gt; ok[i]; &#125; for (int i = 2; i &lt;= n; ++i) &#123; cin &gt;&gt; f[i]; G[i].emplace_back(f[i]); G[f[i]].emplace_back(i); deg[f[i]]++; &#125; for(int i = 1; i &lt;= n; i++) if(!deg[i]) dp[i] = 1, k++; dfs(1, 0); cout &lt;&lt; k - dp[1] + 1 &lt;&lt; '\n'; return 0;&#125;]]></content>
      <categories>
        <category>树形dp</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Codeforces-Round-311-(Div.2)-D(Vitaly and Cycle)]]></title>
    <url>%2F2019%2F04%2F25%2FCodeforces-Round-311-Div-2-D-Vitaly-and-Cycle%2F</url>
    <content type="text"><![CDATA[链接：https://codeforces.com/problemset/problem/557/D思路：一条边都没时就是三条边，任意选三个点即可，如果所有联通块数量都小于等于2，那么就是2条边，相当于有几条边就有几个双连通块，然后在剩下的n - 2个点中任意选一个即可。否则我们对每个连通块二分染色，如果存在奇圈就不用，否则贡献是黑点任意选两个或者白点任意选两个。(之前做的时候没有发现贡献就是黑白的单独算，以为跟连通块里面图的形状有关，其实没有)代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e5 + 5;typedef long long ll;vector&lt;int&gt; G[maxn];int color[maxn];int deg[maxn];int n, m;int a, b;bool flag = true;void dfs(int u, int c)&#123; color[u] = c; if(c == 1) a++; else b++; for(auto &amp;v : G[u])&#123; if(color[v] &amp;&amp; color[v] != 3 - c)&#123; flag = false; return; &#125; else if(color[v]) continue; dfs(v, 3 - c); &#125;&#125;int main() &#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= m; i++) &#123; int u, v; cin &gt;&gt; u &gt;&gt; v; G[u].emplace_back(v); G[v].emplace_back(u); deg[u]++, deg[v]++; &#125; if(!m)&#123; cout &lt;&lt; 3 &lt;&lt; ' ' &lt;&lt; 1ll * n * (n - 1) * (n - 2) / 6; return 0; &#125; int i; for(i = 1; i &lt;= n; i++)&#123; if(deg[i] &gt; 1) break; &#125; if(i &gt; n)&#123; cout &lt;&lt; 2 &lt;&lt; ' ' &lt;&lt; 1ll * m * (n - 2) &lt;&lt; '\n'; return 0; &#125; ll res = 0; for(i = 1; i &lt;= n; i++)&#123; if(!color[i])&#123; a = b = 0; dfs(i, 1); if(!flag) break; res += 1ll * b * (b - 1) / 2 + 1ll * a * (a - 1) / 2; &#125; &#125; if(i &lt;= n)&#123; cout &lt;&lt; 0 &lt;&lt; ' ' &lt;&lt; 1 &lt;&lt; '\n'; return 0; &#125; cout &lt;&lt; 1 &lt;&lt; ' ' &lt;&lt; res &lt;&lt; '\n'; return 0;&#125;]]></content>
      <categories>
        <category>思维</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Codeforces-Round-266-(Div.2)-D(Increase Sequence)]]></title>
    <url>%2F2019%2F04%2F25%2FCodeforces-Round-266-Div-2-D-Increase-Sequence%2F</url>
    <content type="text"><![CDATA[链接：https://codeforces.com/contest/466/problem/D思路：这种用open表示第二维的题好像是第二次见了，这样的好处是可以把状态压下来。我们用dp[i][j]表示到第i个点，左括号比右括号多j个的方案数，那么该点可以不用括号，可以用一个左括号一个右括号，可以用一个左括号，可以用一个右括号，都是当且仅当数量 + a[i] == h的时候才能转移，初始化要注意一下不能从0，因为不是所有的初始都为1，有的是无解的，我们要根据1的位置判断初始的值。非常好的dp题，也是非常不错的一个套路，用括号的方式把原来的选区间转换成了一个dp问题。代码：1234567891011121314151617181920212223242526272829303132333435#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 2010;typedef long long ll;const ll mod = 1e9 + 7;ll dp[maxn][maxn];void add(ll &amp;x, ll y)&#123; x += y; if(x &gt;= mod) x -= mod;&#125;int a[maxn], n, h;int main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); cin &gt;&gt; n &gt;&gt; h; for(int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i]; if(a[1] == h || a[1] == h - 1) dp[1][0] = 1; if(a[1] == h - 1) dp[1][1] = 1; for(int i = 2; i &lt;= n; i++)&#123; for(int j = 0; j &lt;= i; j++)&#123; if(a[i] + j == h)&#123; add(dp[i][j], dp[i - 1][j]); if(j) add(dp[i][j], dp[i - 1][j - 1]); &#125; else if(a[i] + j + 1 == h)&#123; add(dp[i][j], (ll)(j + 1) * (dp[i - 1][j] + dp[i - 1][j + 1]) % mod); &#125; &#125; &#125; cout &lt;&lt; dp[n][0] &lt;&lt; '\n'; return 0;&#125;]]></content>
      <categories>
        <category>基础dp</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[P4781-(拉格朗日插值)]]></title>
    <url>%2F2019%2F04%2F24%2FP4781-%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E6%8F%92%E5%80%BC%2F</url>
    <content type="text"><![CDATA[链接：https://www.luogu.org/problemnew/show/P4781思路：模板题，直接用公式暴力插就好，公式推导详情请看 https://www.luogu.org/problemnew/solution/P4781代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 2020;const ll mod = 998244353;int n, k;ll x[maxn], y[maxn], a[maxn], inv[maxn][maxn];ll pow_mod(ll q, ll w)&#123; ll ret = 1; while(w)&#123; if(w &amp; 1) ret = ret * q % mod; q = q * q % mod; w &gt;&gt;= 1; &#125; return ret;&#125;int main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); cin &gt;&gt; n &gt;&gt; k; for(int i = 1; i &lt;= n; i++) cin &gt;&gt; x[i] &gt;&gt; y[i]; for(int i = 1; i &lt;= n; i++)&#123; for(int j = 1; j &lt;= n; j++)&#123; inv[i][j] = pow_mod((x[i] - x[j]) % mod + mod, mod - 2); &#125; &#125; for(int i = 1; i &lt;= n; i++)&#123; a[i] = y[i]; for(int j = 1; j &lt;= n; j++)&#123; if(i == j) continue; a[i] = a[i] * inv[i][j] % mod; &#125; &#125; ll res = 0; for(int i = 1; i &lt;= n; i++)&#123; ll ans = a[i]; for(int j = 1; j &lt;= n; j++)&#123; if(i == j) continue; ans = ans * ((k - x[j]) % mod + mod) % mod; &#125; res = (res + ans) % mod; &#125; cout &lt;&lt; res &lt;&lt; '\n'; return 0;&#125;]]></content>
      <categories>
        <category>拉格朗日插值法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Educational-Codeforces-Round-63-(Rated-for-Div.2)-E(Guess the Root)]]></title>
    <url>%2F2019%2F04%2F24%2FEducational-Codeforces-Round-63-Rated-for-Div-2-E-Guess-the-Root%2F</url>
    <content type="text"><![CDATA[链接：https://codeforces.com/contest/1155/problem/E思路：不同于以往交互题就二分，这个交互题有点意思，其实只用11个询问就够了，因为我们已知最高次项就是10，我们只需要11次询问我们就可以把函数用拉格朗日插值法唯一确定下来(取模也是一样的，当时以为有取模就确定不了)，然后对于11-(p - 1)我们暴力查看值是否为0即可。代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;ll x[12], y[12], a[12];const ll mod = 1e6 + 3;ll pow_mod(ll q, ll w)&#123; ll ret = 1; while(w)&#123; if(w &amp; 1) ret = ret * q % mod; q = q * q % mod; w &gt;&gt;= 1; &#125; return ret;&#125;int main()&#123; for(int i = 0; i &lt;= 10; i++)&#123; x[i] = i; cout &lt;&lt; "? " &lt;&lt; i &lt;&lt; endl; cin &gt;&gt; y[i]; if(!y[i])&#123; cout &lt;&lt; "! " &lt;&lt; i &lt;&lt; endl; return 0; &#125; &#125; for(int i = 0; i &lt;= 10; i++)&#123; a[i] = y[i]; for(int j = 0; j &lt;= 10; j++)&#123; if(i == j) continue; a[i] = a[i] * pow_mod(x[i] - x[j] + mod, mod - 2) % mod; &#125; &#125; for(int i = 11; i &lt; mod; i++)&#123; ll res = 0; for(int j = 0; j &lt;= 10; j++)&#123; ll ans = a[j]; for(int k = 0; k &lt;= 10; k++)&#123; if(j == k) continue; ans = ans * (i - k + mod) % mod; &#125; res = (res + ans) % mod; &#125; if(res == 0)&#123; cout &lt;&lt; "! " &lt;&lt; i &lt;&lt; endl; return 0; &#125; &#125; cout &lt;&lt; "! -1" &lt;&lt; endl; return 0;&#125;]]></content>
      <categories>
        <category>拉格朗日插值法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[bzoj-2588(Count on a tree)]]></title>
    <url>%2F2019%2F04%2F22%2Fbzoj-2588-Count-on-a-tree%2F</url>
    <content type="text"><![CDATA[链接：https://www.lydsy.com/JudgeOnline/problem.php?id=2588思路：树上主席树，之前做的对边建主席树就非常好写，可以分成两段求和，这个在整合信息时必须整合成 sum[u] + sum[v] - sum[lca(u, v)] - sum[fa[lca(u, v)]]，而且之前的是在转移的时候update，对点权建的话就必须在转移外面update，我就是因为把根节点update漏掉了然后一直wa，后来发现按照边那样update的话根节点没有update，然后就是转化为静态主席树的经典问题了。代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e5 + 5;int sum[maxn * 20], ls[maxn * 20], rs[maxn * 20], root[maxn * 20];int a[maxn], b[maxn];int f[maxn][20], idx;vector&lt;int&gt; G[maxn];int dep[maxn];int n, m, q;void update(int pre, int &amp;o, int l, int r, int p, int v)&#123; o = ++idx; sum[o] = sum[pre] + v, ls[o] = ls[pre], rs[o] = rs[pre]; if(l == r)return; int mid = l + r &gt;&gt; 1; if(p &lt;= mid) update(ls[pre], ls[o], l, mid, p, v); else update(rs[pre], rs[o], mid + 1, r, p, v);&#125;int query(int u, int v, int lca, int lcafa, int l, int r, int k)&#123; if(l == r) return l; int mid = l + r &gt;&gt; 1, x = sum[ls[u]] - sum[ls[lca]] + sum[ls[v]] - sum[ls[lcafa]]; if(x &gt;= k) return query(ls[u], ls[v], ls[lca], ls[lcafa], l, mid, k); return query(rs[u], rs[v], rs[lca], rs[lcafa], mid + 1, r, k - x);&#125;void dfs(int u, int fa)&#123; dep[u] = dep[fa] + 1; f[u][0] = fa; int x = lower_bound(b + 1, b + m + 1, a[u]) - b; update(root[fa], root[u], 1, m, x, 1); for(int i = 1; i &lt;= 19; i++) f[u][i] = f[f[u][i - 1]][i - 1]; for(int i = 0; i &lt; G[u].size(); i++)&#123; int v = G[u][i]; if(v == fa) continue; dfs(v, u); &#125;&#125;int lca(int u, int v)&#123; if(dep[u] &gt; dep[v]) swap(u, v); for(int i = 19; i &gt;= 0; i--)&#123; if(dep[u] &lt;= dep[f[v][i]]) v = f[v][i]; &#125; if(u == v) return u; for(int i = 19; i &gt;= 0; i--)&#123; if(f[u][i] != f[v][i]) u = f[u][i], v = f[v][i]; &#125; return f[u][0];&#125;int main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); cin &gt;&gt; n &gt;&gt; q; for(int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i], b[i] = a[i]; for(int i = 1; i &lt; n; i++)&#123; int u, v; cin &gt;&gt; u &gt;&gt; v; G[u].push_back(v); G[v].push_back(u); &#125; sort(b + 1, b + n + 1); m = unique(b + 1, b + n + 1) - b - 1; dfs(1, 0); int last = 0; while(q--)&#123; int l, r, k; cin &gt;&gt; l &gt;&gt; r &gt;&gt; k; l ^= last; int res = lca(l, r); last = b[query(root[l], root[r], root[res], root[f[res][0]], 1, m, k)]; cout &lt;&lt; last; if(q) cout &lt;&lt; '\n'; &#125; return 0;&#125;]]></content>
      <categories>
        <category>可持久化线段树</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[The-Preliminary-Contest-for-ICPC-China-Nanchang-National-J(Distance on the tree)]]></title>
    <url>%2F2019%2F04%2F21%2FThe-Preliminary-Contest-for-ICPC-China-Nanchang-National-J-Distance-on-the-tree%2F</url>
    <content type="text"><![CDATA[链接：https://nanti.jisuanke.com/t/38229思路：典型的树上主席树，开始想复杂了想用欧拉序把树给扒下来然后再建主席树，事实上直接在dfs的时候就可以建树了。先把所有边权离散化，然后dfs的时候把边权加进去，最后查询的时候找到两个点的lca，然后分别查询两边路径对应区间的值即可。有几个地方细节要注意，因为这种做法查询在线，所以要用upper_bound然后再-1，找到最后一个符合的位置，再者还要特判一下upper_bound求出来为0的情况，直接输出0即可。不然返回的是离散化后1对应边权的个数。 lls还写了一个超骚的离线树剖 + 树状数组，ddc给我说他可能写复杂了感觉会比主席树好写，不管了以后学了树剖再来补这个内容吧。 树剖来了。还是先进行树剖，然后将询问和边都按从小到大进行排序，处理某一个询问时把小于等于当前k的边加入到bit中，然后树剖上进行查询更新答案即可。代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 2e5 + 5;int root[maxn &lt;&lt; 5], sum[maxn &lt;&lt; 5], ls[maxn &lt;&lt; 5], rs[maxn &lt;&lt; 5];int n, m, q;vector&lt;int&gt; G[maxn];int f[maxn][20];int dep[maxn];int idx;int len;int b[maxn];struct edge&#123; int from, to, dist;&#125;;vector&lt;edge&gt; edges;void addedge(int from, int to, int dist)&#123; edges.push_back(edge&#123;from, to, dist&#125;); G[from].emplace_back(edges.size() - 1);&#125;void build(int &amp;o, int l, int r)&#123; o = ++idx; if(l == r) return; int mid = l + r &gt;&gt; 1; build(ls[o], l, mid); build(rs[o], mid + 1, r);&#125;void update(int pre, int &amp;o, int l, int r, int p, int v)&#123; o = ++idx; ls[o] = ls[pre], rs[o] = rs[pre], sum[o] = sum[pre] + v; if(l == r) return; int mid = l + r &gt;&gt; 1; if(p &lt;= mid) update(ls[pre], ls[o], l, mid, p, v); else update(rs[pre], rs[o], mid + 1, r, p, v);&#125;int query(int pre, int now, int l, int r, int k)&#123; int mid = l + r &gt;&gt; 1, x = sum[ls[now]] - sum[ls[pre]]; if(l == r) return sum[now] - sum[pre]; if(k &lt;= mid) return query(ls[pre], ls[now], l, mid, k); return query(rs[pre], rs[now], mid + 1, r, k) + x;&#125;void dfs(int u, int fa)&#123; dep[u] = dep[fa] + 1; f[u][0] = fa; for(int i = 1; i &lt;= 19; i++) f[u][i] = f[f[u][i - 1]][i - 1]; for(int i = 0; i &lt; G[u].size(); i++)&#123; edge &amp;e = edges[G[u][i]]; if(e.to == fa) continue; int p = lower_bound(b + 1, b + len + 1, e.dist) - b; update(root[u], root[e.to], 1, len, p, 1); dfs(e.to, u); &#125;&#125;int lca(int u, int v)&#123; if(dep[u] &gt; dep[v]) swap(u, v); for(int i = 19; i &gt;= 0; i--)&#123; if(dep[f[v][i]] &gt;= dep[u]) v = f[v][i]; &#125; if(u == v) return u; for(int i = 19; i &gt;= 0; i--)&#123; if(f[u][i] != f[v][i]) u = f[u][i], v = f[v][i]; &#125; return f[u][0];&#125;int main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); cin &gt;&gt; n &gt;&gt; q; for(int i = 1; i &lt; n; i++)&#123; int u, v, w; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; addedge(u, v, w); addedge(v, u, w); b[i] = w; &#125; sort(b + 1, b + n); len = unique(b + 1, b + n) - b - 1; build(root[0], 1, len); dfs(1, 0); while(q--)&#123; int u, v, w; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; int x = upper_bound(b + 1, b + len + 1, w) - b - 1; //注意特判，不然为0和1返回的是同一个答案。 if(!x)&#123; cout &lt;&lt; 0 &lt;&lt; '\n'; continue; &#125; int res = lca(u, v); cout &lt;&lt; query(root[res], root[u], 1, len, x) + query(root[res], root[v], 1, len, x) &lt;&lt; '\n'; &#125; return 0;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e5 + 233;int f[maxn], sz[maxn], top[maxn], d[maxn], son[maxn], id[maxn], rk[maxn], idx;int n, m;int res[maxn];struct edge&#123; int from, to, dist; bool operator &lt;(const edge &amp;e) const&#123; return dist &lt; e.dist; &#125;&#125;;struct Q&#123; int u, v, k, id; bool operator &lt;(const Q &amp;x) const&#123; return k &lt; x.k; &#125;&#125;q[maxn];vector&lt;edge&gt; edges;vector&lt;int&gt; G[maxn];int c[maxn];int lowbit(int x)&#123; return x &amp; (-x);&#125;void add(int x, int d)&#123; while(x &lt; maxn)&#123; c[x] += d; x += lowbit(x); &#125;&#125;int sum(int x)&#123; int res = 0; while(x)&#123; res += c[x]; x -= lowbit(x); &#125; return res;&#125;void dfs1(int u, int fa)&#123; d[u] = d[fa] + 1; f[u] = fa; sz[u] = 1; for(int i = 0; i &lt; G[u].size(); i++)&#123; edge &amp;e = edges[G[u][i]]; if(e.to == fa) continue; dfs1(e.to, u); sz[u] += sz[e.to]; if(sz[e.to] &gt; sz[son[u]]) son[u] = e.to; &#125;&#125;void dfs2(int u, int t)&#123; top[u] = t; id[u] = ++idx; rk[idx] = u; if(son[u]) dfs2(son[u], t); for(int i = 0; i &lt; G[u].size(); i++)&#123; edge &amp;e = edges[G[u][i]]; if(e.to == son[u] || e.to == f[u]) continue; dfs2(e.to, e.to); &#125;&#125;int main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); cin &gt;&gt; n &gt;&gt; m; for(int i = 1; i &lt; n; i++)&#123; int u, v, w; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; edges.push_back(edge&#123;u, v, w&#125;); edges.push_back(edge&#123;v, u, w&#125;); &#125; sort(edges.begin(), edges.end()); for(int i = 0; i &lt; edges.size(); i++)&#123; edge &amp;e = edges[i]; G[e.from].push_back(i); &#125; dfs1(1, 0); dfs2(1, 1); for(int i = 1; i &lt;= m; i++)&#123; cin &gt;&gt; q[i].u &gt;&gt; q[i].v &gt;&gt; q[i].k; q[i].id = i; &#125; sort(q + 1, q + m + 1); int j = 0; for(int i = 1; i &lt;= m; i++)&#123; while(j &lt; edges.size() &amp;&amp; edges[j].dist &lt;= q[i].k)&#123; if(d[edges[j].from] &lt; d[edges[j].to]) &#123; j++; continue; &#125; int x = edges[j].from; add(id[x], 1); j++; &#125; int x = q[i].u; int y = q[i].v; while(top[x] != top[y])&#123; if(d[top[x]] &lt; d[top[y]]) swap(x, y); res[q[i].id] += sum(id[x]) - sum(id[top[x]] - 1); x = f[top[x]]; &#125; if(d[x] &gt; d[y]) swap(x, y); res[q[i].id] += sum(id[y]) - sum(id[x]); &#125; for(int i = 1; i &lt;= m; i++) cout &lt;&lt; res[i] &lt;&lt; '\n'; return 0;&#125;]]></content>
      <categories>
        <category>可持久化线段树</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[SP10707-COT2(Count on a tree II)]]></title>
    <url>%2F2019%2F04%2F21%2FSP10707-COT2-Count-on-a-tree-II%2F</url>
    <content type="text"><![CDATA[链接：https://www.luogu.org/problemnew/show/SP10707思路：树上莫队的比较基础的题目，但是第一次写还是到处出错，一来是路径判断的条件不太熟悉，二来是lca点因为不包括在路径中，所以要单独考虑，而且如果点访问过就-，没访问过就+，这样可以抵消掉了欧拉序中进入某个子树路径的问题，就完美去掉了重复计数和遗漏计数，最后记得把lca的贡献再还回去即可。代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e5 + 5;int a[maxn], b[maxn], c[maxn];int n, m, k;struct node&#123; int l, r, id, pos, lca; bool operator&lt; (const node &amp;x)const&#123; return pos ^ x.pos ? l &lt; x.l : (pos &amp; 1 ? r &lt; x.r : r &gt; x.r); &#125;&#125;q[maxn];int sz, ans[maxn], cnt[maxn];int idx, in[maxn], out[maxn];int f[maxn][20], dep[maxn];bool vis[maxn];int ord[maxn];vector&lt;int&gt; G[maxn];void dfs(int u, int fa)&#123; dep[u] = dep[fa] + 1; f[u][0] = fa; in[u] = ++idx; ord[idx] = u; for(int i = 1; i &lt;= 19; i++) f[u][i] = f[f[u][i - 1]][i - 1]; for(auto &amp;v : G[u])&#123; if(v == fa) continue; dfs(v, u); &#125; out[u] = ++idx; ord[idx] = u;&#125;int lca(int u, int v)&#123; if(dep[u] &gt; dep[v]) swap(u, v); for(int i = 19; i &gt;= 0; i--)&#123; if(dep[u] &lt;= dep[f[v][i]]) v = f[v][i]; &#125; if(u == v) return u; for(int i = 19; i &gt;= 0; i--)&#123; if(f[u][i] != f[v][i]) u = f[u][i], v = f[v][i]; &#125; return f[u][0];&#125;int res;//如果之前访问过就减少，没访问过就增加。void work(int pos)&#123; vis[pos] ? res -= !--cnt[c[pos]] : res += !cnt[c[pos]]++; vis[pos] ^= 1;&#125;int main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); cin &gt;&gt; n &gt;&gt; k; for(int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i], b[i] = a[i]; for(int i = 1; i &lt; n; i++)&#123; int u, v; cin &gt;&gt; u &gt;&gt; v; G[u].emplace_back(v); G[v].emplace_back(u); &#125; //离散化 sort(b + 1, b + n + 1); m = unique(b + 1, b + n + 1) - b - 1; dfs(1, 0); sz = sqrt(2 * n + 0.5); for(int i = 1; i &lt;= n; i++) c[i] = lower_bound(b + 1, b + m + 1, a[i]) - b; int l = 1, r = 0; cnt[0] = 1; for(int i = 1; i &lt;= k; i++)&#123; int l, r; cin &gt;&gt; l &gt;&gt; r; q[i].id = i; //区间判断条件 int res = lca(l, r); if(in[l] &gt; in[r]) swap(l, r); if(res == l) q[i].l = in[l], q[i].r = in[r]; else q[i].l = out[l], q[i].r = in[r], q[i].lca = res; q[i].pos = q[i].l / sz; &#125; sort(q + 1, q + k + 1); for(int i = 1; i &lt;= k; i++)&#123; while(l &lt; q[i].l) work(ord[l++]); while(l &gt; q[i].l) work(ord[--l]); while(r &lt; q[i].r) work(ord[++r]); while(r &gt; q[i].r) work(ord[r--]); //lca贡献单独考虑 if(q[i].lca) work(q[i].lca); ans[q[i].id] = res; if(q[i].lca) work(q[i].lca); &#125; for(int i = 1; i &lt;= k; i++) cout &lt;&lt; ans[i] &lt;&lt; '\n'; return 0;&#125;]]></content>
      <categories>
        <category>莫队</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[bzoj-2120(数颜色)]]></title>
    <url>%2F2019%2F04%2F19%2Fbzoj-2120-%E6%95%B0%E9%A2%9C%E8%89%B2%2F</url>
    <content type="text"><![CDATA[链接：https://www.lydsy.com/JudgeOnline/problem.php?id=2120思路：带修改的莫队，也就是在普通莫队上加一维表示时间，然后多一个时间指针，跟左右端点一样排序后暴力移动修改即可，注意修改时间后要把当前点颜色和储存修改颜色的值swap一下，因为离开这个时间点的时候就可以swap改回来。带修改莫队的块大小取n的2/3次方，总的复杂度为n的5/3次方。代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;bits/stdc++.h&gt;using namespace std; const int maxn = 1e4 + 5;int n, m;int pos[1000010]; struct node&#123; int l, r, t, id; bool operator&lt;(const node &amp;x)const&#123; return pos[l] ^ pos[x.l] ? l &lt; x.l : (pos[r] ^ pos[x.r] ? r &lt; x.r : t &lt; x.t); &#125;&#125;q[maxn]; typedef pair&lt;int, int&gt; pii;pii c[maxn]; int ans[maxn];int cntq, cntt, cnt[1000010];int a[maxn];int sz;char ch[10]; int main()&#123; scanf("%d %d", &amp;n, &amp;m); sz = pow(n, 2.0 / 3.0); for(int i = 1; i &lt;= n; i++) scanf("%d", &amp;a[i]); for(int i = 1; i &lt;= m; i++)&#123; int l, r; scanf("%s %d %d", ch, &amp;l, &amp;r); if(ch[0] == 'Q')&#123; cntq++; q[cntq].l = l; q[cntq].r = r; q[cntq].id = cntq; q[cntq].t = cntt; &#125; else&#123; ++cntt; c[cntt].first = l; c[cntt].second = r; &#125; &#125; for(int i = 1; i &lt; 1000010; i++) pos[i] = i / sz; sort(q + 1, q + cntq + 1); int l = 1, r = 0, t = 0; cnt[0] = 1; int res = 0; for(int i = 1; i &lt;= cntq; i++)&#123; while(l &lt; q[i].l) res -= !--cnt[a[l++]]; while(l &gt; q[i].l) res += !cnt[a[--l]]++; while(r &lt; q[i].r) res += !cnt[a[++r]]++; while(r &gt; q[i].r) res -= !--cnt[a[r--]]; while(t &lt; q[i].t)&#123; ++t; if(q[i].l &lt;= c[t].first &amp;&amp; c[t].first &lt;= q[i].r) res -= !--cnt[a[c[t].first]] - !cnt[c[t].second]++; swap(a[c[t].first], c[t].second); &#125; while(t &gt; q[i].t)&#123; if(q[i].l &lt;= c[t].first &amp;&amp; c[t].first &lt;= q[i].r) res -= !--cnt[a[c[t].first]] - !cnt[c[t].second]++; swap(a[c[t].first], c[t].second); --t; &#125; ans[q[i].id] = res; &#125; for(int i = 1; i &lt;= cntq; i++) printf("%d\n", ans[i]); return 0;&#125;]]></content>
      <categories>
        <category>莫队</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Codeforces-Round-225-(Div.1)-D(Antimatter)]]></title>
    <url>%2F2019%2F04%2F19%2FCodeforces-Round-225-Div-1-D-Antimatter%2F</url>
    <content type="text"><![CDATA[链接：https://codeforces.com/problemset/problem/383/D思路：dp[i][j]表示前i个数，和为j的方案数，可以由前面的方案转移过来，也可以从这里开始产生新的方案，然后统计贡献和即可。代码：12345678910111213141516171819202122232425262728293031#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;ll dp[2][22100];int n;const ll mod = 1e9 + 7;void add(ll &amp;x, ll y)&#123; x += y; if(x &gt;= mod) x -= mod;&#125;int main()&#123; cin &gt;&gt; n; int o = 0; ll res = 0; for(int i = 1; i &lt;= n; i++)&#123; int x; cin &gt;&gt; x; for(int j = 1000; j &lt;= 21000; j++)&#123; dp[o][j] = (dp[!o][j - x] + dp[!o][j + x]) % mod; &#125; dp[o][11000 + x]++; dp[o][11000 - x]++; add(res, dp[o][11000]); o = !o; &#125; cout &lt;&lt; res &lt;&lt; '\n'; return 0;&#125;]]></content>
      <categories>
        <category>基础dp</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Codeforces-Round-317-[AimFund-Thanks-Round]-(Div.1)-B(Minimization)]]></title>
    <url>%2F2019%2F04%2F18%2FCodeforces-Round-317-AimFund-Thanks-Round-Div-1-B-Minimization%2F</url>
    <content type="text"><![CDATA[链接：https://codeforces.com/problemset/problem/571/B思路：又是自己想了个假贪心想了半天，事实上贪心如果很难想到能满足方法的时候应该就是个dp题了，我们考虑其实可以看成k条链，并且每条连上一定放的是排序后的连续的一段，那么问题转化为了排序后序列划分为k条链，每条的长度必须为n / k或者n / k + 1，那么用dp[i][j]表示选了i个n / k的链，选了j个n / k + 1的链，然后每次代价为链上最后一个数 - 第一个数，更新即可。代码：12345678910111213141516171819202122232425262728293031#include &lt;bits/stdc++.h&gt;using namespace std;int n, k;int sz;const int maxn = 3e5 + 5;int a[maxn];typedef long long ll;ll dp[5005][5005];int main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); cin &gt;&gt; n &gt;&gt; k; int x1 = k - n % k, x2 = n % k; for(int i = 0; i &lt;= x1; i++)&#123; for(int j = 0; j &lt;= x2; j++)&#123; dp[i][j] = 1e18; &#125; &#125; for(int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i]; sort(a + 1, a + n + 1); dp[0][0] = 0; for(int i = 0; i &lt;= x1; i++)&#123; for(int j = 0; j &lt;= x2; j++)&#123; if(i &lt; x1) dp[i + 1][j] = min(dp[i + 1][j], dp[i][j] + a[(i + 1) * (n / k) + j * (n / k + 1)] - a[i * (n / k) + j * (n / k + 1) + 1]); if(j &lt; x2) dp[i][j + 1] = min(dp[i][j + 1], dp[i][j] + a[i * (n / k) + (j + 1) * (n / k + 1)] - a[i * (n / k) + j * (n / k + 1) + 1]); &#125; &#125; cout &lt;&lt; dp[x1][x2] &lt;&lt; '\n'; return 0;&#125;]]></content>
      <categories>
        <category>基础dp</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Codeforces-Round-250-(Div.1)-D(The Child and Sequence)]]></title>
    <url>%2F2019%2F04%2F17%2FCodeforces-Round-250-Div-1-D-The-Child-and-Sequence%2F</url>
    <content type="text"><![CDATA[链接：https://codeforces.com/problemset/problem/438/D思路：看到这个题就想起了camp讲过这个题，主要是区间取模怎么处理，我们考虑一个数取模，如果比他大就不用变，比他小我们可以分为两个情况考虑：大于它一半和小于它一半，如果大于说明至少要减去一半，如果小于说明余数肯定小于一半，所以怎么最后都至少小于一半，所以最多取模logx次，那么整个2操作最多取模nlogx次，加上3操作因为是单点修改，所以一共最多nlogxlogx次，这个题就做完了。代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e5 + 5;typedef long long ll;int a[maxn], mx[maxn &lt;&lt; 2], tag[maxn &lt;&lt; 2];ll sum[maxn &lt;&lt; 2];int n, m;void pushup(int o)&#123; sum[o] = sum[o &lt;&lt; 1] + sum[o &lt;&lt; 1 | 1]; mx[o] = max(mx[o &lt;&lt; 1], mx[o &lt;&lt; 1 | 1]);&#125;void build(int o, int l, int r)&#123; tag[o] = -1; if(l == r)&#123; sum[o] = mx[o] = a[l]; return; &#125; int mid = l + r &gt;&gt; 1; build(o &lt;&lt; 1, l, mid); build(o &lt;&lt; 1 | 1, mid + 1, r); pushup(o);&#125;void update(int o, int tl, int tr, int l, int r, int x)&#123; if(tl &gt; r || tr &lt; l)return; if(tl &gt;= l &amp;&amp; tr &lt;= r)&#123; if(mx[o] &lt; x) return; if(tl == tr)&#123; mx[o] %= x; sum[o] %= x; return; &#125; &#125; int mid = tl + tr &gt;&gt; 1; update(o &lt;&lt; 1, tl, mid, l, r, x); update(o &lt;&lt; 1 | 1, mid + 1, tr, l, r, x); pushup(o);&#125;void change(int o, int tl, int tr, int pos, int x)&#123; if(tl &gt; pos || tr &lt; pos) return; if(tl == tr &amp;&amp; tl == pos)&#123; sum[o] = x; mx[o] = x; return; &#125; int mid = tl + tr &gt;&gt; 1; change(o &lt;&lt; 1, tl, mid, pos, x); change(o &lt;&lt; 1 | 1, mid + 1, tr, pos, x); pushup(o);&#125;ll query(int o, int tl, int tr, int l, int r)&#123; if(tl &gt; r || tr &lt; l) return 0; if(tl &gt;= l &amp;&amp; tr &lt;= r) return sum[o]; int mid = tl + tr &gt;&gt; 1; return query(o &lt;&lt; 1, tl, mid, l, r) + query(o &lt;&lt; 1 | 1, mid + 1, tr, l, r);&#125;int main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); cin &gt;&gt; n &gt;&gt; m; for(int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i]; build(1, 1, n); for(int i = 1; i &lt;= m; i++)&#123; int t, l, r; cin &gt;&gt; t &gt;&gt; l &gt;&gt; r; if(t == 1) cout &lt;&lt; query(1, 1, n, l, r) &lt;&lt; '\n'; else if(t == 2)&#123; int x; cin &gt;&gt; x; update(1, 1, n, l, r, x); &#125; else change(1, 1, n, l, r); &#125; return 0;&#125;]]></content>
      <categories>
        <category>线段树</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Codeforces-Round-526-(Div.1)-B(The Fair Nut and Strings)]]></title>
    <url>%2F2019%2F04%2F17%2FCodeforces-Round-526-Div-1-B-The-Fair-Nut-and-Strings%2F</url>
    <content type="text"><![CDATA[链接：https://codeforces.com/contest/1083/problem/B思路：按位统计，相当于看以这个前缀作为二进制数之间有多少个数，然后和k取一个最小值加入统计答案即可(因为如果大于k只能取k个，贪心取不同的前缀即可，否则二进制数只有那么多只能取数量个)。代码：123456789n, k = map(int, input().split())a = input()b = input()res = 0ans = 0for i in range(0, n): res = min(res * 2 + (b[i] == 'b') - (a[i] == 'b'), k) ans += min(res + 1, k)print(ans)]]></content>
      <categories>
        <category>思维</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Codeforces-Round-277-(Div.2)-D(Valid Sets)]]></title>
    <url>%2F2019%2F04%2F17%2FCodeforces-Round-277-Div-2-D-Valid-Sets%2F</url>
    <content type="text"><![CDATA[链接：https://codeforces.com/problemset/problem/486/D思路：考虑以每个点为根，并为最大值，然后进行dfs统计，遇到比他大的就停止，好像这样就可以避免重复了，但是如果有些点位置相等怎么办呢？有个很巧妙的做法，定向即可，即比较一下根结点的大小，因为一堆相等点中编号最大值只有一个，这样也就只会被统计一次，就非常完美解决了计数重复的问题了。代码：1234567891011121314151617181920212223242526272829303132333435363738#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 2005;ll v[maxn];const ll mod = 1e9 + 7;vector&lt;int&gt; G[maxn];ll tmp;int n, d;ll dfs(int u, int f, int r)&#123; if(v[u] &gt; tmp || v[u] &lt; tmp - d ||(v[u] == tmp &amp;&amp; r &gt; u)) return 1; ll ret = 1; for(auto &amp;v : G[u])&#123; if(v == f) continue; ret = ret * dfs(v, u, r) % mod; &#125; return (ret + 1) % mod;&#125;int main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); cin &gt;&gt; d &gt;&gt; n; for(int i = 1; i &lt;= n; i++) cin &gt;&gt; v[i]; for(int i = 1; i &lt; n; i++)&#123; int u, v; cin &gt;&gt; u &gt;&gt; v; G[u].emplace_back(v); G[v].emplace_back(u); &#125; ll res = 0; for(int i = 1; i &lt;= n; i++) tmp = v[i], res += dfs(i, 0, i); res = ((res - n) % mod + mod) % mod; cout &lt;&lt; res &lt;&lt; '\n'; return 0;&#125;]]></content>
      <categories>
        <category>思维</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Codeforces-Round-340-(Div.2)-E(XOR and Favorite Number)]]></title>
    <url>%2F2019%2F04%2F17%2FCodeforces-Round-340-Div-2-E-XOR-and-Favorite-Number%2F</url>
    <content type="text"><![CDATA[链接：https://codeforces.com/problemset/problem/617/E思路：学习了一波莫队，我们先对所有a求一个异或的前缀和，考虑如果删除一个点，删除的是a[r] ^ a[l - 1] = k中符合条件的r的个数，转换一下就是删除cnt[k ^ a[l - 1]]的个数，加的话直接正常加上去就行了,注意下奇偶排序可以优化一大笔时间。代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;bits/stdc++.h&gt;using namespace std;int n, m, k, sz;const int maxn = 1e5 + 5;struct node&#123; int l, r, id, pos; bool operator &lt;(const node &amp;x)const&#123; return pos != x.pos ? l &lt; x.l : (pos &amp; 1) ? r &lt; x.r : r &gt; x.r; &#125;&#125;q[maxn];int a[maxn];typedef long long ll;ll cnt[maxn * 20];ll ans[maxn];ll res;void add(int x)&#123; res += cnt[a[x] ^ k]; cnt[a[x]]++;&#125;void del(int x)&#123; cnt[a[x]]--; res -= cnt[a[x] ^ k];&#125;int main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); cin &gt;&gt; n &gt;&gt; m &gt;&gt; k; sz = sqrt(n); for(int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i], a[i] ^= a[i - 1]; for(int i = 1; i &lt;= m; i++) cin &gt;&gt; q[i].l &gt;&gt; q[i].r, q[i].id = i, q[i].pos = q[i].l / sz; sort(q + 1, q + m + 1); int l = 1, r = 0; cnt[0] = 1; res = 0; for(int i = 1; i &lt;= m; i++)&#123; while(l &lt; q[i].l) del(l - 1), l++; while(l &gt; q[i].l) l--, add(l - 1); while(r &gt; q[i].r) del(r) , r--; while(r &lt; q[i].r) r++, add(r); ans[q[i].id] = res; &#125; for(int i = 1; i &lt;= m; i++) cout &lt;&lt; ans[i] &lt;&lt; '\n'; return 0;&#125;]]></content>
      <categories>
        <category>莫队</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Educational-Codeforces-Round-2-E(Lomsat gelral)]]></title>
    <url>%2F2019%2F04%2F17%2FEducational-Codeforces-Round-2-E-Lomsat-gelral%2F</url>
    <content type="text"><![CDATA[链接：https://codeforces.com/problemset/problem/600/E思路：基本上算是线段树合并的裸题了吧，dfs的时候直接跟儿子合并，最后再把这个点的贡献update上去即可，然后记录答案即可。也可以用更简单的map的启发式合并，学习了一下网上的优美写法。代码：线段树合并1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 2e5 + 5;typedef long long ll;ll maxv[maxn &lt;&lt; 5];int ls[maxn &lt;&lt; 5], rs[maxn &lt;&lt; 5], root[maxn &lt;&lt; 5];ll rt[maxn &lt;&lt; 5];int idx;vector&lt;int&gt; G[maxn];int n;int color[maxn];ll ans[maxn];void pushup(int o)&#123; if(maxv[ls[o]] &lt; maxv[rs[o]])&#123; maxv[o] = maxv[rs[o]]; rt[o] = rt[rs[o]]; &#125; else if(maxv[ls[o]] &gt; maxv[rs[o]])&#123; maxv[o] = maxv[ls[o]]; rt[o] = rt[ls[o]]; &#125; else&#123; maxv[o] = maxv[ls[o]]; rt[o] = rt[ls[o]] + rt[rs[o]]; &#125;&#125;void update(int &amp;o, int l, int r, int x)&#123; if(!o) o = ++idx; if(l == r)&#123; maxv[o]++; rt[o] = x; return; &#125; int mid = l + r &gt;&gt; 1; if(x &lt;= mid) update(ls[o], l, mid, x); else update(rs[o], mid + 1, r, x); pushup(o);&#125;int merge(int o1, int o2, int l, int r)&#123; if(!o1 || !o2) return o1 + o2; if(l == r)&#123; maxv[o1] += maxv[o2]; rt[o1] = l; return o1; &#125; int mid = l + r &gt;&gt; 1; ls[o1] = merge(ls[o1], ls[o2], l, mid); rs[o1] = merge(rs[o1], rs[o2], mid + 1, r); pushup(o1); return o1;&#125;void dfs(int u, int f)&#123; for(auto &amp;v : G[u])&#123; if(v == f) continue; dfs(v, u); merge(root[u], root[v], 1, n); &#125; update(root[u], 1, n, color[u]); ans[u] = rt[root[u]];&#125;int main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); cin &gt;&gt; n; for(int i = 1; i &lt;= n; i++) cin &gt;&gt; color[i], root[i] = ++idx; for(int i = 1; i &lt; n; i++)&#123; int u, v; cin &gt;&gt; u &gt;&gt; v; G[u].emplace_back(v); G[v].emplace_back(u); &#125; dfs(1, 0); for(int i = 1; i &lt;= n; i++) cout &lt;&lt; ans[i] &lt;&lt; (i == n ? '\n' : ' '); return 0;&#125; map启发式合并123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e5 + 5;map&lt;int, int&gt; tr[maxn];int n, c[maxn];vector&lt;int&gt; G[maxn];typedef long long ll;ll ans[maxn];ll x[maxn], y[maxn];int id[maxn];void merge(int &amp;u, int v)&#123; if(tr[u].size() &lt; tr[v].size()) swap(u, v); for(auto it = tr[v].begin(); it != tr[v].end(); it++)&#123; auto &amp;t = tr[u][it-&gt;first]; t += it-&gt;second; if(x[u] == t) y[u] += it-&gt;first; if(x[u] &lt; t) x[u] = t, y[u] = it-&gt;first; &#125;&#125;void dfs(int u, int f)&#123; x[u] = 1, y[u] = c[u]; id[u] = u; for(auto &amp;v : G[u])&#123; if(v == f) continue; dfs(v, u); merge(id[u], id[v]); &#125; ans[u] = y[id[u]];&#125;int main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); cin &gt;&gt; n; for(int i = 1; i &lt;= n; i++) cin &gt;&gt; c[i]; for(int i = 1; i &lt; n; i++)&#123; int u, v; cin &gt;&gt; u &gt;&gt; v; G[u].emplace_back(v); G[v].emplace_back(u); &#125; for(int i = 1; i &lt;= n; i++) tr[i][c[i]] = 1; dfs(1, 0); for(int i = 1; i &lt;= n; i++) cout &lt;&lt; ans[i] &lt;&lt; (i == n ? '\n' : ' '); return 0;&#125;]]></content>
      <categories>
        <category>线段树合并</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Codeforces-Round-302-(Div.1)-B(Destroying Roads)]]></title>
    <url>%2F2019%2F04%2F17%2FCodeforces-Round-302-Div-1-B-Destroying-Roads%2F</url>
    <content type="text"><![CDATA[链接：https://codeforces.com/problemset/problem/543/B思路：首先求出任意两点间的最短路，因为边权都是1所以直接bfs就可以解决，然后我们考虑如果答案不是两个最短路值相加，中间必有一段是重合的，且起点终点分别是到这一段两个端点的最短路，所以直接枚举重合的部分即可。代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 3010;int d[maxn][maxn];int n, m;bool vis[maxn];vector&lt;int&gt; G[maxn];void bfs(int s)&#123; memset(vis, 0, sizeof(vis)); queue&lt;int&gt; q; q.emplace(s); vis[s] = 1; while(!q.empty())&#123; int u = q.front(); q.pop(); for(auto &amp;v : G[u])&#123; if(vis[v]) continue; d[s][v] = d[s][u] + 1; vis[v] = 1; q.emplace(v); &#125; &#125;&#125;int s1, t1, l1, s2, t2, l2;int main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); cin &gt;&gt; n &gt;&gt; m; for(int i = 1; i &lt;= m; i++)&#123; int u, v; cin &gt;&gt; u &gt;&gt; v; G[u].emplace_back(v); G[v].emplace_back(u); &#125; for(int i = 1; i &lt;= n; i++)&#123; bfs(i); &#125; cin &gt;&gt; s1 &gt;&gt; t1 &gt;&gt; l1 &gt;&gt; s2 &gt;&gt; t2 &gt;&gt; l2; if(d[s1][t1] &gt; l1 || d[s2][t2] &gt; l2)&#123; cout &lt;&lt; -1 &lt;&lt; '\n'; return 0; &#125; int res = d[s1][t1] + d[s2][t2]; for(int i = 1; i &lt;= n; i++)&#123; for(int j = i + 1; j &lt;= n; j++)&#123; if(d[s1][i] + d[i][j] + d[j][t1] &lt;= l1 &amp;&amp; d[s2][i] + d[i][j] + d[j][t2] &lt;= l2) res = min(res, d[s1][i] + d[j][t1] + d[s2][i] + d[j][t2] + d[i][j]); if(d[s1][j] + d[i][j] + d[i][t1] &lt;= l1 &amp;&amp; d[s2][i] + d[i][j] + d[j][t2] &lt;= l2) res = min(res, d[s1][j] + d[i][t1] + d[s2][i] + d[j][t2] + d[i][j]); if(d[s1][j] + d[i][j] + d[i][t1] &lt;= l1 &amp;&amp; d[s2][j] + d[i][j] + d[i][t2] &lt;= l2) res = min(res, d[s1][j] + d[i][t1] + d[s2][j] + d[i][t2] + d[i][j]); if(d[s1][i] + d[i][j] + d[j][t1] &lt;= l1 &amp;&amp; d[s2][j] + d[i][j] + d[i][t2] &lt;= l2) res = min(res, d[s1][i] + d[j][t1] + d[s2][j] + d[i][t2] + d[i][j]); &#125; &#125; cout &lt;&lt; m - res &lt;&lt; '\n'; return 0;&#125;]]></content>
      <categories>
        <category>最短路</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2016-ACM-ICPC-World-Finals-A(Balanced Diet)]]></title>
    <url>%2F2019%2F04%2F14%2F2016-ACM-ICPC-World-Finals-A-Balanced-Diet%2F</url>
    <content type="text"><![CDATA[链接：https://codeforces.com/gym/101242/attachments思路：把式子转一下，改成整数形式，然后维护一下还剩多少天可以不吃糖，优先取一个最近的出来就行了，如果取出来已经比当前天数小了，就说明不可行了。代码:123456789101112131415161718192021222324252627282930313233343536373839#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef pair&lt;ll, int&gt; pii;priority_queue&lt;pii, vector&lt;pii&gt;, greater&lt;pii&gt; &gt; q;const int maxn = 1e5 + 5;ll a[maxn], b[maxn];int n, k;ll sum;pii cal(int j, int i)&#123; return pii(((b[i] + 1) * sum - (k + j) * a[i] + a[i] - 1) / a[i] + j, i);&#125;int main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); cin &gt;&gt; n &gt;&gt; k; for(int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i], sum += a[i]; for(int i = 1; i &lt;= k; i++)&#123; int x; cin &gt;&gt; x; b[x]++; &#125; for(int i = 1; i &lt;= n; i++)q.emplace(cal(0, i)); for(int i = 1; i &lt;= sum + 1; i++)&#123; pii p = q.top(); q.pop(); b[p.second]++; q.emplace(cal(i, p.second)); if(q.top().first &lt;= i)&#123; cout &lt;&lt; i - 1 &lt;&lt; '\n'; return 0; &#125; &#125; cout &lt;&lt; "forever\n"; return 0;&#125;]]></content>
      <categories>
        <category>贪心</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[CCPC-2016-2017-Finals-E(Problem Buyer)]]></title>
    <url>%2F2019%2F04%2F11%2FCCPC-2016-2017-Finals-E-Problem-Buyer%2F</url>
    <content type="text"><![CDATA[链接：https://codeforces.com/gym/101206/attachments思路：这个题一开始看错题了，然后写完怎么都不对发现题读错了，然后整场心态崩了开始自闭。其实思路很接近正解了，对于某一题我们假设有k个问题可以覆盖他，那么至少要选n - k + 1才能保证这个问题肯定被覆盖了，那么我们对所有的取max好像就完了，我们用优先队列维护下右端点和序号就可以。但是其实不太对，因为如果只有一个题覆盖某两个区间，其实是无解的，所以我们每次对一个问题做完后从队列中pop一个右端点最小的问题对应给他，这样保证是最优的，那么这个题就真的做完了，其实想通了真的很简单。。。。。代码：12345678910111213141516171819202122232425262728293031323334353637#include &lt;bits/stdc++.h&gt;using namespace std;typedef pair&lt;int, int&gt; pii;priority_queue&lt;pii, vector&lt;pii&gt;, greater&lt;pii&gt; &gt; q;int T, n, m;typedef long long ll;const int maxn = 1e5 + 5;pii a[maxn];int c[maxn];int main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int kase = 0; cin &gt;&gt; T; while(T--)&#123; while(!q.empty())q.pop(); cin &gt;&gt; n &gt;&gt; m; for(int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i].first &gt;&gt; a[i].second; for(int i = 1; i &lt;= m; i++) cin &gt;&gt; c[i]; int j = 1; int res = 0; sort(a + 1, a + n + 1); sort(c + 1, c + m + 1); for(int i = 1; i &lt;= m; i++)&#123; while(j &lt;= n &amp;&amp; c[i] &gt;= a[j].first) q.emplace(a[j].second, j), j++; while(!q.empty() &amp;&amp; a[q.top().second].second &lt; c[i]) q.pop(); res = max(res, n - (int)q.size() + 1); if(res &gt; n) break; q.pop(); &#125; cout &lt;&lt; "Case #" &lt;&lt; ++kase &lt;&lt; ": "; if(res &gt; n) cout &lt;&lt; "IMPOSSIBLE!\n"; else cout &lt;&lt; res &lt;&lt; '\n'; &#125; return 0;&#125;]]></content>
      <categories>
        <category>贪心</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[CCPC-2016-2017-Finals-I(Mr. Panda and Crystal)]]></title>
    <url>%2F2019%2F04%2F11%2FCCPC-2016-2017-Finals-I-Mr-Panda-and-Crystal%2F</url>
    <content type="text"><![CDATA[链接：https://codeforces.com/gym/101206/attachments思路：一看数据范围以为是网络流，发现怎么都没法流，结果xjc说是个完全背包马上就反应过来了，那么问题的难点就在怎么预处理出所有背包的重量，我们对于可以合成的宝石，可以证明这个重量一定是最小的，那么我们可以以这些点为源点去跑最短路，把所有点的合成方案都更新一遍，这样就处理完了，再来一个完全背包就美滋滋结束了。代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 300;typedef long long ll;typedef pair&lt;ll, int&gt; pii;vector&lt;vector&lt;pii&gt; &gt; G[maxn];int T;int n, m, k;ll v[maxn];ll w[maxn];ll dp[10010];priority_queue&lt;pii, vector&lt;pii&gt;, greater&lt;pii&gt; &gt; q;void init()&#123; memset(dp, 0, sizeof(dp)); for(int i = 0; i &lt;= n; i++) G[i].clear(), w[i] = 1e9; while(!q.empty()) q.pop();&#125;void dij()&#123; while(!q.empty())&#123; pii p = q.top(); q.pop(); int u = p.second; if(w[u] &lt; p.first) continue; for(int i = 1; i &lt;= n; i++)&#123; ll res = 1e18; for(int j = 0; j &lt; G[i].size(); j++) &#123; vector&lt;pii&gt; &amp;x = G[i][j]; ll sum = 0; for (int k = 0; k &lt; x.size(); k++) &#123; sum += w[x[k].first] * x[k].second; &#125; res = min(res, sum); &#125; if(w[i] &gt; res)&#123; w[i] = res; q.emplace(res, i); &#125; &#125; &#125;&#125;int main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int T; int kase = 0; cin &gt;&gt; T; while(T--)&#123; cin &gt;&gt; m &gt;&gt; n &gt;&gt; k; init(); for(int i = 1; i &lt;= n; i++)&#123; int x; cin &gt;&gt; x; if(x)&#123; int y, z; cin &gt;&gt; y &gt;&gt; z; w[i] = y; v[i] = z; q.emplace(w[i], i); &#125; else&#123; int y; cin &gt;&gt; y; v[i] = y; &#125; &#125; for(int i = 1; i &lt;= k; i++)&#123; int x, y; cin &gt;&gt; x &gt;&gt; y; vector&lt;pii&gt; tmp; while(y--)&#123; int u, v; cin &gt;&gt; u &gt;&gt; v; tmp.emplace_back(u, v); &#125; G[x].emplace_back(tmp); &#125; dij(); ll res = 0; for(int i = 1; i &lt;= n; i++)&#123; for(int j = 0; j + w[i] &lt;= m; j++)&#123; dp[j + w[i]] = max(dp[j + w[i]], dp[j] + v[i]); res = max(res, dp[j + w[i]]); &#125; &#125; cout &lt;&lt; "Case #" &lt;&lt; ++kase &lt;&lt; ": " &lt;&lt; res &lt;&lt; '\n'; &#125; return 0;&#125;]]></content>
      <categories>
        <category>基础dp</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[CCPC-2016-2017-Finals-G(Pandaland)]]></title>
    <url>%2F2019%2F04%2F11%2FCCPC-2016-2017-Finals-G-Pandaland%2F</url>
    <content type="text"><![CDATA[链接：https://codeforces.com/gym/101206/attachments思路：赛场上看到算了下暴力跑dij数据满的是5e9，没想到真的能跑过去，我真是服了，只需要枚举边然后去掉这条边对两个端点跑最短路即可，注意跑到终点就可以马上结束，这样会快很多，就轻轻松松卡过去了。好像正解跟这个是同一个复杂度所以应该没法卡。。。。代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103#include &lt;bits/stdc++.h&gt;using namespace std;struct edge&#123; int from, to, dist;&#125;;const int maxn = 8010;vector&lt;int&gt; G[maxn];vector&lt;edge&gt; edges;typedef pair&lt;int, int&gt; pii;int tot;int n;int sz;map&lt;pii, int&gt; id;int d[maxn];void init()&#123; for(int i = 0; i &lt;= sz; i++) G[i].clear(); edges.clear(); sz = 0; id.clear();&#125;void addedge(int from, int to, int dist)&#123; edges.push_back(edge&#123;from, to, dist&#125;); tot = edges.size(); G[from].emplace_back(tot - 1);&#125;int tmp;void dij(int s, int t)&#123; for(int i = 0; i &lt;= sz; i++) d[i] = 1e9; d[s] = 0; priority_queue&lt;pii, vector&lt;pii&gt;, greater&lt;pii&gt; &gt; q; q.emplace(0, s); while(!q.empty())&#123; pii p = q.top(); q.pop(); int u = p.second; if(u == t) return; if(d[u] &lt; p.first) continue; for(int i = 0; i &lt; G[u].size(); i++)&#123; if(tmp == G[u][i] || tmp + 1 == G[u][i]) continue; edge &amp;e = edges[G[u][i]]; if(d[e.to] &gt; d[u] + e.dist)&#123; d[e.to] = d[u] + e.dist; q.emplace(d[e.to], e.to); &#125; &#125; &#125;&#125;int main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int kase = 0; int T; cin &gt;&gt; T; while(T--)&#123; cin &gt;&gt; n; init(); for(int i = 1; i &lt;= n; i++)&#123; int a, b, c, d, e; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d &gt;&gt; e; if(!id[pii(a, b)]) id[pii(a, b)] = ++sz; if(!id[pii(c, d)]) id[pii(c, d)] = ++sz; addedge(id[pii(a, b)], id[pii(c, d)], e); addedge(id[pii(c, d)], id[pii(a, b)], e); &#125; int res = 1e9; for(int i = 0; i &lt; edges.size(); i += 2)&#123; tmp = i; int u = edges[i].from; int v = edges[i].to; dij(u, v); res = min(res, edges[i].dist + d[v]); &#125; if(res == 1e9) res = 0; cout &lt;&lt; "Case #" &lt;&lt; ++kase &lt;&lt; ": " &lt;&lt; res &lt;&lt; '\n'; &#125; return 0;&#125;/*250 0 0 1 20 0 1 0 20 1 1 1 21 0 1 1 21 0 0 1 591 1 3 1 11 1 1 3 23 1 3 3 21 3 3 3 11 1 2 2 22 2 3 3 33 1 2 2 12 2 1 3 24 1 5 1 4 */]]></content>
      <categories>
        <category>最短路</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[CCPC-2016-2017-Finals-B(Wash)]]></title>
    <url>%2F2019%2F04%2F11%2FCCPC-2016-2017-Finals-B-Wash%2F</url>
    <content type="text"><![CDATA[链接：https://codeforces.com/gym/101206/problem/B思路：平时贪心不证明，看题解以为自己懂了，一到比赛就直接凭感觉，然后带着队友暴毙。这场打的我真的很气，暴露的问题实在是太多了，一个是我读三个题全读错，一个是写之前不证明写了一半发现是假的，一个是卡题后不舍得放题心态开始崩盘，一下来补题的时候写的就飞快，哎好好调整吧果然离自己预想的还有很大距离。。。。。。言归正传说说这个题。首先考虑只有洗衣机，我们很容易得到一个非常简单的贪心方案，即用优先队列维护结束时间 + 洗衣时间，每次取最近的时间的洗衣机来洗衣即可。但是如果加入了烘干机我们发现大家都不是一起开始洗的了，这时候选择哪台烘干机就成了问题，无法证明贪心的正确性。其实可以这样想，当最先的一件衣服洗完后，大家都停住别洗了，剩下洗的时候我们放到烘干后再开始算，这样大家又是一起开始愉快烘干衣服了，这样最早烘干的先然弥补最晚洗完的衣服的时间是最优的，于是得到正解，我们都按一起开始工作对洗衣机和烘干机操作，排序后最小和最大相加，求其中的max即可得到最快时间。代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;bits/stdc++.h&gt;using namespace std;int l, n, m;const int maxn = 1e6 + 5;int T;typedef long long ll;ll a[maxn], b[maxn];ll r1[maxn], r2[maxn];typedef pair&lt;ll, int&gt; pii;priority_queue&lt;pii, vector&lt;pii&gt;, greater&lt;pii&gt; &gt; q;int main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int kase = 0; cin &gt;&gt; T; while(T--)&#123; cin &gt;&gt; l &gt;&gt; n &gt;&gt; m; for(int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i]; for(int i = 1; i &lt;= m; i++) cin &gt;&gt; b[i]; sort(a + 1, a + n + 1); sort(b + 1, b + m + 1); for(int i = 1; i &lt;= n; i++) q.emplace(a[i], i); for(int i = 1; i &lt;= l; i++)&#123; pii p = q.top(); q.pop(); r1[i] = p.first; p.first += a[p.second]; q.emplace(p); &#125; while(!q.empty()) q.pop(); for(int i = 1; i &lt;= m; i++) q.emplace(b[i], i); for(int i = 1; i &lt;= l; i++)&#123; pii p = q.top(); q.pop(); r2[i] = p.first; p.first += b[p.second]; q.emplace(p); &#125; while(!q.empty()) q.pop(); sort(r1 + 1, r1 + l + 1); sort(r2 + 1, r2 + l + 1); ll res = 0; for(int i = 1; i &lt;= l; i++)&#123; res = max(res, r1[i] + r2[l - i + 1]); &#125; cout &lt;&lt; "Case #" &lt;&lt; ++kase &lt;&lt; ": " &lt;&lt; res &lt;&lt; '\n'; &#125; return 0;&#125;]]></content>
      <categories>
        <category>贪心</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2016-2017-ACM-ICPC-CHINA-Final-J(Mr.Panda and TubeMaster)]]></title>
    <url>%2F2019%2F04%2F10%2F2016-2017-ACM-ICPC-CHINA-Final-J-Mr-Panda-and-TubeMaster%2F</url>
    <content type="text"><![CDATA[链接：https://codeforces.com/gym/101194/attachments思路：记得哪位大神说过，网络流的难题好题都是要拆点的，果不其然。这个题一看很容易往网络流方面想，但是如何建图真的是非常难想。首先要求是一个环流或者没有，其次有些格子必须要流。我们观察得知，4种格子可以分为两类，并且相邻格子必然是两类中的各一个，这就有点像二分图染色了。我们给格子染色，然后给流定向，令流的方向为黑色到白色，一个环流可以看成是从某个点出发然后到这个点结束。我们想到了把一个点拆成入点和出点。因为给流定向了，所以对于某个点，如果他是黑色点，他就跟左右格子的入点连，否则跟上下格子入点连，这样原问题就变成了一个二分图最大权匹配。剩下的就是必须选，我们考虑非必须选，那么就是可以自己跟自己匹配抵消，所以我们把所有非必须选的格子自己跟自己连边即可。最后用费用流跑个最大流即可。 如果最大流跟格子数相等，说明原问题有解，输出最大费用即可，否则就无解。正确性：如果不是必须边，则可以跟自己匹配，如果是必须边，则必须连别人的，则最大流必然会对应一种环，如若不然，这个点的入点的所有边都没有流量，相等于入点没有匹配，那么最大流最多为总点数 - 1，此时不为最大流，证明完毕。代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 2000;const int inf = 1e9;int n, m;int tot, s, t;struct edge&#123; int from, to, cap, flow, cost;&#125;;vector&lt;int&gt; G[maxn];vector&lt;edge&gt; edges;int inq[maxn];int d[maxn], p[maxn], a[maxn];void init()&#123; edges.clear(); for(int i = 0; i &lt;= t; i++) G[i].clear();&#125;void addedge(int from, int to, int cap, int cost)&#123; edges.push_back(edge&#123;from, to, cap, 0, cost&#125;); edges.push_back(edge&#123;to, from, 0, 0, -cost&#125;); tot = edges.size(); G[from].emplace_back(tot - 2); G[to].emplace_back(tot - 1);&#125;bool spfa(int &amp;flow, int &amp;cost)&#123; for(int i = 0; i &lt;= t; i++) d[i] = inf; memset(inq, 0, sizeof(inq)); d[s] = 0; inq[s] = 1; p[s] = 0; a[s] = inf; queue&lt;int&gt; q; q.emplace(s); while(!q.empty())&#123; int u = q.front(); q.pop(); inq[u] = 0; for(int i = 0; i &lt; G[u].size(); i++)&#123; edge &amp;e = edges[G[u][i]]; if(e.cap &gt; e.flow &amp;&amp; d[e.to] &gt; d[u] + e.cost)&#123; d[e.to] = d[u] + e.cost; p[e.to] = G[u][i]; a[e.to] = min(a[u], e.cap - e.flow); if(!inq[e.to])&#123; q.emplace(e.to); inq[e.to] = 1; &#125; &#125; &#125; &#125; if(d[t] == inf) return false; flow += a[t]; cost += d[t] * a[t]; int u = t; while(u != s)&#123; edges[p[u]].flow += a[t]; edges[p[u] ^ 1].flow -= a[t]; u = edges[p[u]].from; &#125; return true;&#125;void mincost(int &amp;flow, int &amp;cost)&#123; while(spfa(flow, cost));&#125;int val[50][50], var[50][50];int idl[50][50], idr[50][50];int T;bool ok[50][50];int main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); cin &gt;&gt; T; int kase = 0; while(T--)&#123; cin &gt;&gt; n &gt;&gt; m; memset(ok, 0, sizeof(ok)); for(int i = 1; i &lt;= n; i++)&#123; for(int j = 1; j &lt; m; j++)&#123; cin &gt;&gt; val[i][j]; &#125; &#125; for(int i = 1; i &lt; n; i++)&#123; for(int j = 1; j &lt;= m; j++)&#123; cin &gt;&gt; var[i][j]; &#125; &#125; int cnt = 0; for(int i = 1; i &lt;= n; i++)&#123; for(int j = 1; j &lt;= m; j++)&#123; idl[i][j] = ++cnt, idr[i][j] = ++cnt; &#125; &#125; s = 0, t = cnt + 1; init(); for(int i = 1; i &lt;= n; i++)&#123; for(int j = 1; j &lt;= m; j++)&#123; if((i + j) &amp; 1)&#123; if(i &gt; 1) addedge(idl[i][j], idr[i - 1][j], 1, -var[i - 1][j]); if(i &lt; n) addedge(idl[i][j], idr[i + 1][j], 1, -var[i][j]); &#125; else&#123; if(j &gt; 1) addedge(idl[i][j], idr[i][j - 1], 1, -val[i][j - 1]); if(j &lt; m) addedge(idl[i][j], idr[i][j + 1], 1, -val[i][j]); &#125; addedge(s, idl[i][j], 1, 0); addedge(idr[i][j], t, 1, 0); &#125; &#125; int q; cin &gt;&gt; q; while(q--)&#123; int x, y; cin &gt;&gt; x &gt;&gt; y; ok[x][y] = 1; &#125; for(int i = 1; i &lt;= n; i++)&#123; for(int j = 1; j &lt;= m; j++)&#123; if(!ok[i][j]) addedge(idl[i][j], idr[i][j], 1, 0); &#125; &#125; int flow = 0, cost = 0; mincost(flow, cost); cout &lt;&lt; "Case #" &lt;&lt; ++kase &lt;&lt; ": "; if(flow != n * m) cout &lt;&lt; "Impossible\n"; else cout &lt;&lt; -cost &lt;&lt; '\n'; &#125; return 0;&#125;/*24 40 0 -10 1 00 -1 -10 1 01 0 1 0-1 -1 0 01 1 -1 -113 32 30 00 00 0 021 12 3*/]]></content>
      <categories>
        <category>网络流</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Codeforces-Round-546-(Div.2)-D(Nastya Is Buying Lunch)]]></title>
    <url>%2F2019%2F04%2F09%2FCodeforces-Round-546-Div-2-D-Nastya-Is-Buying-Lunch%2F</url>
    <content type="text"><![CDATA[链接：https://codeforces.com/contest/1136/problem/D思路：首先可以简单验证一下，如果有多个都可以到达最后一个，那么跟谁先先后顺序无关，我们考虑每次找最近的能跟最后交换的交换，怎么快速判断成了关键，首先肯定是倒着推，如果能交换的话意味着他可以交换到当前这个人前面的位置，我们假设这个人已经向前进了x步，那么就是在他后面的人数 + x = n - i, 如果可以交换，我们就把当前人交换到这个人后面(相当于踢出队列)，否则我们标记一下这个人位于后面，以便向前递推的时候计算有多少人在他后面用。代码：1234567891011121314151617181920212223242526272829303132#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 3e5 + 5;int n, m;vector&lt;int&gt; G[maxn];int a[maxn];bool vis[maxn];int main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); cin &gt;&gt; n &gt;&gt; m; for(int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i]; for(int i = 1; i &lt;= m; i++)&#123; int u, v; cin &gt;&gt; u &gt;&gt; v; G[u].emplace_back(v); &#125; int res = 0; vis[a[n]] = 1; for(int i = n - 1; i; i--)&#123; int v = a[i]; int cnt = 0; for(int j = 0; j &lt; G[v].size(); j++)&#123; if(vis[G[v][j]])cnt++; &#125; if(i + res + cnt == n) res++; else vis[v] = 1; &#125; cout &lt;&lt; res &lt;&lt; '\n'; return 0;&#125;]]></content>
      <categories>
        <category>贪心</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Codeforces-Round-546-(Div.2)-E(Nastya Hasn't Written a Legend)]]></title>
    <url>%2F2019%2F04%2F09%2FCodeforces-Round-546-Div-2-E-Nastya-Hasn-t-Written-a-Legend%2F</url>
    <content type="text"><![CDATA[链接：https://codeforces.com/contest/1136/problem/E思路：还是有很高难度的啊，很多性质都不那么容易发现。首先我们需要看出，如果更新某个点，那么在它后面存在一个点，他之后的都不用再更新，他之前的(包括他)都需要更新，这个可以很简单的证明一下。然后我们就要考虑怎么快速求出需要更新的那一段的值了，假设区间是l-r,那么更新后的每个点分别是a[l] + x, a[l] + b[l] + x, a[l] + b[l] + b[l + 1] + x ……. ，我们把他求和，发现与b数组的前缀和的前缀和有关，即c是b数组前缀和，d是c数组前缀和，那么就可以表示为(a[l] - b[l]) * (r - l + 1) + d[r] - d[l - 1]，发现这个就是线段树最基本的赋值，那么这个题就直接做完了(一开始不会，看了题解会了也还是慢慢写了1个半小时，实在是弟中弟。。。。。)代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e5 + 5;typedef long long ll;ll tag[maxn &lt;&lt; 2], sum[maxn &lt;&lt; 2];const ll inf = 1e18;ll a[maxn], b[maxn], c[maxn], d[maxn];int n, q;inline void pushup(int o)&#123; sum[o] = sum[o &lt;&lt; 1] + sum[o &lt;&lt; 1 | 1];&#125;void build(int o, int l, int r)&#123; tag[o] = -inf; if(l == r)&#123; sum[o] = a[l]; return; &#125; int mid = l + r &gt;&gt; 1; build(o &lt;&lt; 1, l, mid); build(o &lt;&lt; 1 | 1, mid + 1, r); pushup(o);&#125;void pushdown(int o, int l, int r)&#123; if(tag[o] != -inf)&#123; int mid = l + r &gt;&gt; 1; tag[o &lt;&lt; 1] = tag[o]; tag[o &lt;&lt; 1 | 1] = tag[o]; sum[o &lt;&lt; 1] = d[mid] - d[l - 1] + (mid - l + 1) * tag[o]; sum[o &lt;&lt; 1 | 1] = d[r] - d[mid] + (r - mid) * tag[o]; tag[o] = -inf; &#125;&#125;void update(int o, int tl, int tr, int l, int r, ll v)&#123; if(tl &gt; r || tr &lt; l)return; if(l &lt;= tl &amp;&amp; tr &lt;= r)&#123; tag[o] = v; sum[o] = (tr - tl + 1) * v + d[tr] - d[tl - 1]; return; &#125; pushdown(o, tl, tr); int mid = tl + tr &gt;&gt; 1; update(o &lt;&lt; 1, tl, mid, l, r, v); update(o &lt;&lt; 1 | 1, mid + 1, tr, l, r, v); pushup(o);&#125;ll query(int o, int tl, int tr, int l, int r)&#123; if(tl &gt; r || tr &lt; l) return 0; if(l &lt;= tl &amp;&amp; tr &lt;= r) return sum[o]; pushdown(o, tl, tr); int mid = tl + tr &gt;&gt; 1; return query(o &lt;&lt; 1, tl, mid, l, r) + query(o &lt;&lt; 1 | 1, mid + 1, tr, l, r);&#125;int main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); cin &gt;&gt; n; for(int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i]; build(1, 1, n); for(int i = 2; i &lt;= n; i++) cin &gt;&gt; b[i]; for(int i = 2; i &lt;= n; i++) c[i] = c[i - 1] + b[i]; for(int i = 2; i &lt;= n; i++) d[i] = d[i - 1] + c[i]; cin &gt;&gt; q; while(q--)&#123; string s; int l, r; cin &gt;&gt; s &gt;&gt; l &gt;&gt; r; if(s[0] == 's')cout &lt;&lt; query(1, 1, n, l, r) &lt;&lt; '\n'; else&#123; int lb = l, ub = n; int ans = l; ll tmp = query(1, 1, n, l, l); while(ub &gt;= lb)&#123; int mid = lb + ub &gt;&gt; 1; if(query(1, 1, n, mid, mid) - tmp - r &lt; c[mid] - c[l])&#123; ans = mid; lb = mid + 1; &#125; else ub = mid - 1; &#125; update(1, 1, n, l, ans, tmp - c[l] + r); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>线段树</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[P4768-[NOI2018](归程)]]></title>
    <url>%2F2019%2F04%2F08%2FP4768-NOI2018-%E5%BD%92%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[链接：https://www.luogu.org/problemnew/show/P4768思路：一开始写挂了debug半天，发现自己又陷入了惯性思维中，原来的题都是Kruskal的边权，但是这个题是水位，我们Kruskal的对象应该是水位，最短路我们可以一开始跑出来，然后在重构树上我们深搜并倍增并且维护一下每个点子树的最短路径，由于从叶子到根的最短距离是单调不增的，我们倍增到最大的满足水位的位置，然后找子树所有点中最短路径最短的一个就是答案。代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 2e6 + 5;typedef long long ll;int n, m, q;ll d[maxn];int x, w, k, mod;int par[maxn], f[maxn][20], ch[maxn][2];int h[maxn];int T;int sz;struct edge&#123; int u, v, w, h; bool operator&lt;(const edge &amp;r)const&#123; return h &gt; r.h; &#125;&#125;;vector&lt;int&gt; G[maxn];vector&lt;edge&gt; edges;ll ans[maxn];void addedge(int u, int v, int w, int h)&#123; edges.push_back(edge&#123;u, v, w, h&#125;); G[u].emplace_back(edges.size() - 1);&#125;void init()&#123; edges.clear(); for(int i = 1; i &lt; maxn; i++) par[i] = i, d[i] = 1e18, G[i].clear(), ans[i] = 1e18; memset(f, 0, sizeof(f)); memset(ch, 0, sizeof(ch));&#125;typedef pair&lt;int, int&gt; pii;void dij()&#123; priority_queue&lt;pii, vector&lt;pii&gt;, greater&lt;pii&gt; &gt; q; q.emplace(0, 1); d[1] = 0; while(!q.empty())&#123; pii p = q.top(); q.pop(); int u = p.second; if(d[u] &lt; p.first) continue; for(int i = 0; i &lt; G[u].size(); i++)&#123; edge &amp;e = edges[G[u][i]]; if(d[e.v] &gt; d[u] + e.w)&#123; d[e.v] = d[u] + e.w; q.emplace(d[e.v], e.v); &#125; &#125; &#125;&#125;int find(int a)&#123; return par[a] == a ? a : par[a] = find(par[a]);&#125;void kruskal()&#123; sz = n; sort(edges.begin(), edges.end()); for(int i = 0; i &lt; edges.size(); i++)&#123; int fx = find(edges[i].u); int fy = find(edges[i].v); if(fx == fy)continue; sz++; ch[sz][0] = fx; ch[sz][1] = fy; par[fx] = par[fy] = f[fx][0] = f[fy][0] = sz; d[sz] = ans[i] = 1e18; h[sz] = edges[i].h; &#125;&#125;void dfs(int u)&#123; ans[u] = min(ans[u], d[u]); for(int i = 1; i &lt;= 19; i++) f[u][i] = f[f[u][i - 1]][i - 1]; if(u &lt;= n) return; dfs(ch[u][0]); dfs(ch[u][1]); ans[u] = min(ans[u], min(ans[ch[u][0]], ans[ch[u][1]]));&#125;int get(int u)&#123; for(int i = 19; i &gt;= 0; i--)&#123; if(f[u][i] &amp;&amp; h[f[u][i]] &gt; w) u = f[u][i]; &#125; return u;&#125;int main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); cin &gt;&gt; T; while(T--)&#123; init(); cin &gt;&gt; n &gt;&gt; m; for(int i = 1; i &lt;= m; i++)&#123; int u, v, w, hh; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w &gt;&gt; hh; addedge(u, v, w, hh); addedge(v, u, w, hh); &#125; dij(); kruskal(); dfs(sz); cin &gt;&gt; q &gt;&gt; k &gt;&gt; mod; int lastans = 0; while(q--)&#123; cin &gt;&gt; x &gt;&gt; w; x = (x + k * lastans - 1) % n + 1; w = (w + k * lastans) % (mod + 1); lastans = ans[get(x)]; cout &lt;&lt; lastans &lt;&lt; '\n'; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>Kruskal重构树</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[bzoj-3732(Network)]]></title>
    <url>%2F2019%2F04%2F07%2Fbzoj-3732-Network%2F</url>
    <content type="text"><![CDATA[链接：https://www.lydsy.com/JudgeOnline/problem.php?id=3732思路：怎么先把更难一点的题做了再来补了这个Kruskal重建树的入门题。。。这题是Kruskal重建树的标准用法，求图上两点任意路径中的最小值或者最大值，在Kruskal的并查集合并的过程中新建一个结点，结点的权值表示边权，连接原来要合并的两个结点，可以发现这个树满足二叉堆的性质，那么LCA的权值就是我们要求的答案(感谢王伟的上机题让我在上机时间逼着自己理解写出了lca，并且现在可以熟练默写了)。代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 3e4 + 100;int n, m, q;int par[maxn];int f[maxn][20];int ch[maxn][2];int sz;int dep[maxn];int cost[maxn];struct edge&#123; int u, v, w; bool operator&lt; (const edge &amp;r)const&#123; return w &lt; r.w; &#125; void read()&#123; scanf("%d %d %d", &amp;u, &amp;v, &amp;w); &#125;&#125;edges[maxn];int find(int a)&#123; return par[a] == a ? a : par[a] = find(par[a]);&#125;void kruskal()&#123; sort(edges, edges + m); sz = n; for(int i = 0; i &lt; m; i++)&#123; int fx = find(edges[i].u); int fy = find(edges[i].v); if(fx == fy) continue; sz++; par[fx] = sz; par[fy] = sz; f[fx][0] = f[fy][0] = sz; ch[sz][0] = fx; ch[sz][1] = fy; cost[sz] = edges[i].w; &#125;&#125;void dfs(int u, int fa)&#123; dep[u] = dep[fa] + 1; for(int i = 1; i &lt;= 19; i++) f[u][i] = f[f[u][i - 1]][i - 1]; if(u &lt;= n) return; dfs(ch[u][0], u); dfs(ch[u][1], u);&#125;int lca(int u, int v)&#123; if(dep[u] &gt; dep[v]) swap(u, v); for(int i = 19; i &gt;= 0; i--)&#123; if(dep[f[v][i]] &gt;= dep[u]) v = f[v][i]; &#125; if(u == v) return u; for(int i = 19; i &gt;= 0; i--)&#123; if(f[u][i] != f[v][i]) u = f[u][i], v = f[v][i]; &#125; return f[u][0];&#125;int main()&#123; scanf("%d %d %d", &amp;n, &amp;m, &amp;q); for(int i = 0; i &lt; m; i++)edges[i].read(); for(int i = 1; i &lt; maxn; i++) par[i] = i; kruskal(); dfs(sz, 0); while(q--)&#123; int a, b; scanf("%d %d", &amp;a, &amp;b); printf("%d\n", cost[lca(a, b)]); &#125; return 0;&#125;]]></content>
      <categories>
        <category>Kruskal重构树</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2016-2017-ACM-ICPC-CHINA-Final-G(Pandaria)]]></title>
    <url>%2F2019%2F04%2F07%2F2016-2017-ACM-ICPC-CHINA-Final-G-Pandaria%2F</url>
    <content type="text"><![CDATA[链接：https://codeforces.com/gym/101194/attachments思路：真·硬核数据结构题，Kruskal重构树 https://blog.csdn.net/hwzzyr/article/details/81190442 写的不错，主要解决图上两点所有路径中最大/最小边。我们在并查集合并的过程中，每次都新建一个点，用来保存边权，原图上两点之间的边最大/最小值就是重构树上LCA的值，本题相当于要求所有能到的，也就是相当于在树上求从一个叶结点开始所能走到的最高的点，这个我们用树上倍增就可以做完。那么本题另外一个难点来了，怎么维护所有点当中颜色最多的点，这个时候要用线段树合并 + 动态开点了，https://www.cnblogs.com/Mychael/p/8665589.html 。由于叶结点在权值线段树上只更新一个位置的点，所以只需要新建logn个结点，两个点合并的时候由于重复点非常少，均摊下来也是logn的，本题中为了保留左右子树的信息，我们合并的时候采用新建一个结点的方式合并。注意因为有新建结点，所以点数是原来的两倍，然后每个点需要logn个结点，所以线段树开40倍的空间，其他的开2倍的空间就好了。代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164#include &lt;bits/stdc++.h&gt;using namespace std;int T, n, m, q;const int maxn = 2e5 + 5;int val[maxn * 20], root[maxn * 20], sum[maxn * 20];int ls[maxn * 20], rs[maxn * 20];struct edge&#123; int from, to, dist; bool operator&lt; (const edge &amp;r)&#123; return dist &lt; r.dist; &#125;&#125;edges[2 * maxn];int par[maxn * 3], f[maxn * 3][20];int ch[maxn][2];int idx;int sz;int cost[maxn * 20];int ans[maxn * 20];int w, x;void init()&#123; memset(val, 0, sizeof(val)); memset(root, 0, sizeof(root)); memset(sum, 0, sizeof(sum)); memset(ls, 0, sizeof(ls)); memset(rs, 0, sizeof(rs)); memset(ch, 0, sizeof(ch)); for(int i = 1; i &lt; maxn * 3; i++) par[i] = i; idx = 0;&#125;int find(int u)&#123; return par[u] == u ? u : par[u] = find(par[u]);&#125;void kruskal()&#123; sort(edges, edges + m); sz = n; int cnt = 0; for(int i = 0; i &lt; m; i++)&#123; int u = edges[i].from; int v = edges[i].to; int fx = find(u); int fy = find(v); if(fx == fy)continue; cnt++; ch[++sz][0] = fx; ch[sz][1] = fy; f[fx][0] = sz; f[fy][0] = sz; par[fx] = sz; par[fy] = sz; cost[sz] = edges[i].dist; if(cnt == n - 1) return; &#125;&#125;void pushup(int o)&#123; if(sum[ls[o]] &gt;= sum[rs[o]])&#123; sum[o] = sum[ls[o]]; val[o] = val[ls[o]]; &#125; else&#123; sum[o] = sum[rs[o]]; val[o] = val[rs[o]]; &#125;&#125;void update(int &amp;o, int l, int r, int x)&#123; if(!o) o = ++idx; if(l == r)&#123; sum[o] = 1; val[o] = x; return; &#125; int mid = l + r &gt;&gt; 1; if(x &lt;= mid) update(ls[o], l, mid, x); else update(rs[o], mid + 1, r, x); pushup(o);&#125;int merge(int o1, int o2, int l, int r)&#123; if(!o1 || !o2)&#123; return o1 + o2; &#125; int t = ++idx; if(l == r)&#123; sum[t] = sum[o1] + sum[o2]; val[t] = val[o1]; return t; &#125; int mid = l + r &gt;&gt; 1; ls[t] = merge(ls[o1], ls[o2], l, mid); rs[t] = merge(rs[o1], rs[o2], mid + 1, r); pushup(t); return t;&#125;void dfs(int u)&#123; for(int j = 1; j &lt;= 19; j++)&#123; f[u][j] = f[f[u][j - 1]][j - 1]; &#125; if(u &lt;= n) return; dfs(ch[u][0]); dfs(ch[u][1]); root[u] = merge(root[ch[u][0]], root[ch[u][1]], 1, n); ans[u] = val[root[u]];&#125;int get(int u)&#123; for(int i = 19; i &gt;= 0; i--)&#123; if(cost[f[u][i]] &lt;= w &amp;&amp; f[u][i]) u = f[u][i]; &#125; return u;&#125;int main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); cin &gt;&gt; T; int kase = 0; while(T--)&#123; cin &gt;&gt; n &gt;&gt; m; init(); for(int i = 1; i &lt;= n; i++)&#123; cin &gt;&gt; cost[i]; ans[i] = cost[i]; update(root[i], 1, n, cost[i]); &#125; for(int i = 0; i &lt; m; i++) cin &gt;&gt; edges[i].from &gt;&gt; edges[i].to &gt;&gt; edges[i].dist; kruskal(); dfs(sz); cin &gt;&gt; q; int now = 0; cout &lt;&lt; "Case #" &lt;&lt; ++kase &lt;&lt; ":\n"; while(q--)&#123; cin &gt;&gt; x &gt;&gt; w; x ^= now, w ^= now; now = ans[get(x)]; cout &lt;&lt; now &lt;&lt; '\n'; &#125; &#125; return 0;&#125;/*15 62 1 1 3 21 2 21 3 42 3 73 4 54 5 65 3 341 10 05 56 11*/]]></content>
      <categories>
        <category>Kruskal重构树</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[UVA-10480(Sabotage)]]></title>
    <url>%2F2019%2F04%2F06%2FUVA-10480-Sabotage%2F</url>
    <content type="text"><![CDATA[链接：https://vjudge.net/problem/UVA-10480思路：求最小割及其输出方案，我们知道最小割等于最大流，那么怎么求方案呢，相当于要切断一个流路径上最短的边，我们从源点开始dfs，每次走还没流满的边，并标记访问到的节点，最后枚举所有边，如果两个点一个被访问过一个没被访问过，那么就是最小割上的边。代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114#include&lt;bits/stdc++.h&gt;using namespace std;int n, m;const int maxn = 550;const int INF = 1e9;typedef long long ll;struct edge &#123; int from, to, cap, flow;&#125;;int s,t,tot;vector&lt;edge&gt; edges;vector&lt;int&gt; G[maxn];bool vis[maxn];int d[maxn];int cur[maxn];void init() &#123; edges.clear(); for (int i = 0; i &lt;= t; i++)G[i].clear();&#125;void addedge(int from,int to,int cap) &#123; edges.push_back(edge&#123;from, to, cap, 0&#125;); edges.push_back(edge&#123;to, from, 0, 0&#125;); tot = edges.size(); G[from].push_back(tot - 2); G[to].push_back(tot - 1);&#125;bool bfs() &#123; memset(vis, 0, sizeof(vis)); queue&lt;int&gt; q; q.push(s); d[s] = 0; vis[s] = 1; while (!q.empty()) &#123; int x = q.front(); q.pop(); for (int i = 0; i &lt; G[x].size(); i++) &#123; edge &amp;e = edges[G[x][i]]; if (!vis[e.to] &amp;&amp; e.cap &gt; e.flow) &#123; vis[e.to] = 1; d[e.to] = d[x] + 1; q.push(e.to); &#125; &#125; &#125; return vis[t];&#125;int dfs(int x, int a) &#123; if (x == t || a == 0)return a; int flow = 0, f; for (int &amp;i = cur[x]; i &lt; G[x].size(); i++) &#123; edge &amp;e = edges[G[x][i]]; if (d[x] + 1 == d[e.to] &amp;&amp; (f = dfs(e.to, min(a, e.cap - e.flow))) &gt; 0) &#123; e.flow += f; edges[G[x][i] ^ 1].flow -= f; flow += f; a -= f; if (a == 0)break; &#125; &#125; return flow;&#125;ll maxflow() &#123; ll flow = 0; while (bfs()) &#123; memset(cur, 0, sizeof(cur)); flow += dfs(s, INF); &#125; return flow;&#125;bool ok[maxn];void find(int u)&#123; ok[u] = 1; for(int i = 0; i &lt; G[u].size(); i++)&#123; edge &amp;e = edges[G[u][i]]; if(ok[e.to] || e.cap - e.flow &lt;= 0)continue; find(e.to); &#125;&#125;int u[maxn], v[maxn];int main()&#123; while(~scanf("%d %d", &amp;n, &amp;m) &amp;&amp; (n || m))&#123; s = 0, t = n + 1; init(); memset(ok, 0, sizeof(ok)); addedge(s, 1, INF); addedge(2, t, INF); for(int i = 1; i &lt;= m; i++)&#123; int w; scanf("%d %d %d", &amp;u[i], &amp;v[i], &amp;w); addedge(u[i], v[i], w); addedge(v[i], u[i], w); &#125; maxflow(); find(0); for(int i = 1; i &lt;= m; i++)&#123; if((!ok[u[i]] &amp;&amp; ok[v[i]]) || (ok[u[i]] &amp;&amp; !ok[v[i]])) printf("%d %d\n", u[i], v[i]); &#125; puts(""); &#125; return 0;&#125;]]></content>
      <categories>
        <category>网络流</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2016-2017-ACM-ICPC-CHINA-Final-H(Great Cells)]]></title>
    <url>%2F2019%2F04%2F05%2F2016-2017-ACM-ICPC-CHINA-Final-H-Great-Cells%2F</url>
    <content type="text"><![CDATA[链接：https://codeforces.com/gym/101194/attachments思路：把式子拆开，1的部分很好算，就是所有的填法，考虑g ag的意义，表示每一个情况下 多少个格子满足，我们转换为单点贡献考虑，就相当于每一个点为great cells有多少种填法，那么就是除去这一行这一列比他小，其他的都随便，每个格子又都是等效的，所以统计贡献即可。代码：12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;ll n, m, k, T;const ll mod = 1e9 + 7;ll pow_mod(ll q, ll w)&#123; ll ret = 1; while(w)&#123; if(w &amp; 1) ret = ret * q % mod; q = q * q % mod; w &gt;&gt;= 1; &#125; return ret;&#125;int main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); cin &gt;&gt; T; int kase = 0; while(T--)&#123; cin &gt;&gt; n &gt;&gt; m &gt;&gt; k; ll res = 0; for(int i = 1; i &lt;= k; i++)&#123; res = (res + pow_mod((i - 1), n + m - 2)) % mod; &#125; res = res * n % mod * m % mod * pow_mod(k, n * m - n - m + 1) % mod; res = (res + pow_mod(k, n * m)) % mod; cout &lt;&lt; "Case #" &lt;&lt; ++kase &lt;&lt; ": " &lt;&lt; res &lt;&lt; '\n'; &#125; return 0;&#125;/* 3 2 2 2 2 3 2 3 4 5 */]]></content>
      <categories>
        <category>思维</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2016-2017-ACM-ICPC-CHINA-Final-C(Mr. Panda and Strips)]]></title>
    <url>%2F2019%2F04%2F05%2F2016-2017-ACM-ICPC-CHINA-Final-C-Mr-Panda-and-Strips%2F</url>
    <content type="text"><![CDATA[链接:https://codeforces.com/gym/101194/attachments思路：这个尺取好写不好想啊，标程都是n^2logn的，我们尺取第一段，然后从0-l，r-n尺取第二段，取其中最大的，复杂度O(n ^ 2)代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e5 + 5;int T;bool vis[maxn];int a[maxn];int n;//如果x被访问过， 右端点过不去，左端点先过去清空标记，右端点再过去又加上标记，标记不变//如果x没被访问过，右端点直接过去，左端点后过去清空标记，标记不变//所以不论怎么都是对的，只用放心尺取一段最大的就行了，虽然不知道这神仙怎么想出来这种写法的。。。。。int get(int l, int r)&#123; if(l &gt;= r) return 0; int x = l, y = l; int ans = 0; while(1)&#123; while(y &lt; r &amp;&amp; !vis[a[y]])&#123; vis[a[y]] = 1; y++; &#125; if(x == r &amp;&amp; y == r)break; ans = max(ans, y - x); vis[a[x]] = 0; x++; if(x == r &amp;&amp; y == r)break; &#125; return ans;&#125;int main()&#123; scanf("%d", &amp;T); for(int kase = 1; kase &lt;= T; kase++)&#123; scanf("%d", &amp;n); for(int i = 0; i &lt; n; i++) scanf("%d", &amp;a[i]), vis[a[i]] = 0; int l = 0, r = 0; int res = 1; while(1)&#123; while(r &lt; n &amp;&amp; !vis[a[r]])&#123; vis[a[r]] = 1; r++; res = max(res, r - l + max(get(0, l), get(r, n))); &#125; vis[a[l]] = 0; l++; res = max(res, r - l + max(get(0, l), get(r, n))); if(l == n &amp;&amp; r == n) break; &#125; printf("Case #%d: %d\n", kase, res); &#125; return 0;&#125;/* 3 3 1 2 3 8 3 1 2 1 6 1 2 5 3 1 1 1 */]]></content>
      <categories>
        <category>尺取法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2016-ACM-ICPC-World-Finals-E(Forever Young)]]></title>
    <url>%2F2019%2F04%2F05%2F2016-ACM-ICPC-World-Finals-E-Forever-Young%2F</url>
    <content type="text"><![CDATA[链接：https://codeforces.com/gym/101242/attachments思路：容易注意到，当进制 &gt; 1e6时，最终答案不会超过4位数，所以我们分两边枚举找答案，枚举进制10 - 1e6，可以求出对应的结果，判断是否合法即可，然后再枚举答案，相当于解一个2次方程，因为系数全部位正，所以当x &gt; 0时一定单调，二分找到对应的进制(有可能不存在)，最终取大的结果即可。(细节挺多的，主要是容易溢出，所以写的时候需要小心一点)。代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;ll n, m;int len;ll ok1()&#123; ll tmp; for(int i = 1000000; i &gt;= 10; i--)&#123; tmp = n; bool flag = false; ll res = 0; ll base = 1; while(tmp)&#123; if(tmp % i &gt;= 10)&#123; flag = true; break; &#125; res += base * (tmp % i); base *= 10; tmp /= i; &#125; if(flag) continue; if(res &gt;= m) &#123; return i; &#125; &#125; return 0;&#125;ll a[20];int check(ll x)&#123; ll res = 0; ll base = 1; for(int i = 0; i &lt; len; i++)&#123; res += a[i] * base; base *= x; if(res &gt; n)return 1; &#125; if(res == n) return 0; return -1;&#125;ll x0, x1, x2;ll ok2()&#123; ll res = 0; for(ll i = m; i &lt; 1000; i++)&#123; x0 = i % 10; x1 = i / 10 % 10; x2 = i / 100; ll lb = 0, ub; if(x2 == 0) ub = 1e18; else ub = 1e9; while(ub &gt;= lb)&#123; ll mid = ub + lb &gt;&gt; 1; ull tmp = x2 * mid * mid + x1 * mid + x0; if(tmp == n)&#123; res = max(res, mid); break; &#125; else if(tmp &gt; n) ub = mid - 1; else lb = mid + 1; &#125; &#125; return res;&#125;int main()&#123; cin &gt;&gt; n &gt;&gt; m; cout &lt;&lt; max(ok1(), ok2()) &lt;&lt; '\n'; return 0;&#125;]]></content>
      <categories>
        <category>思维</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2018-2019-ACM-ICPC-Asia-Nanjing-Regional-Contest-B(Tournament)]]></title>
    <url>%2F2019%2F04%2F03%2F2018-2019-ACM-ICPC-Asia-Nanjing-Regional-Contest-B-Tournament%2F</url>
    <content type="text"><![CDATA[链接：https://codeforces.com/gym/101981/problem/B思路：首先我们要证明一个东西，在l-r的村庄范围内如果只建一个庙，距离最短的肯定建在这些村庄的最中间的中位数的位置，如果有两个那么他们之间的任意一个位置即可。这个证明完后我们考虑所有的村庄都可以划分为连续的一段，使得这一段到他们中间的庙是距离最小的，那么我们其实就考虑转移只用考虑从上一次结束的位置以及下一次结束的位置。显而易见建满肯定是最优的，所以我们考虑wqs二分，然后根据单调决策性走一个二分栈，最后更新结果即可。代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;bits/stdc++.h&gt;using namespace std;int n, m;const int maxn = 3e5 + 5;int head, tail;typedef long long ll;ll sum[maxn];struct node&#123; int l, r, p;&#125;que[maxn];ll dp[maxn], v[maxn];int a[maxn];ll cal(int x, int y)&#123; return dp[x] + sum[y] + sum[x] - sum[x + y &gt;&gt; 1] - sum[x + y + 1 &gt;&gt; 1];&#125;bool cmp(int i, int j, int k)&#123; ll v1 = cal(i, k); ll v2 = cal(j, k); if(v1 == v2) return v[i] &lt;= v[j]; return v1 &lt; v2;&#125;int find(node u, int x)&#123; int l = u.l, r = u.r; while(l &lt;= r)&#123; int mid = l + r &gt;&gt; 1; if(cmp(x, u.p, mid)) r = mid - 1; else l = mid + 1; &#125; return r + 1;&#125;bool check(ll k)&#123; head = 1, tail = 1; que[tail] = node&#123;0, n, 0&#125;; for(int i = 1; i &lt;= n; i++)&#123; while(head &lt;= tail &amp;&amp; i &gt; que[head].r) head++; dp[i] = cal(que[head].p, i) + k; v[i] = v[que[head].p] + 1; if(head &gt; tail || cmp(i, que[tail].p, n))&#123; while(head &lt;= tail &amp;&amp; cmp(i, que[tail].p, que[tail].l)) tail--; if(head &gt; tail) que[++tail] = node&#123;i, n, i&#125;; else&#123; int t = find(que[tail], i); que[tail].r = t - 1; que[++tail] = node&#123;t, n, i&#125;; &#125; &#125; &#125; return v[n] &lt;= m;&#125;int main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); cin &gt;&gt; n &gt;&gt; m; for(int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i], sum[i] = sum[i - 1] + a[i]; ll lb = 0, ub = sum[n] + 100; ll ans = 0; while(ub &gt;= lb)&#123; ll mid = ub + lb &gt;&gt; 1; if(check(mid))&#123; ub = mid - 1; ans = dp[n] - 1ll * mid * m; &#125; else lb = mid + 1; &#125; cout &lt;&lt; ans &lt;&lt; '\n'; return 0;&#125;]]></content>
      <categories>
        <category>wqs二分</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2016-ACM-ICPC-World-Finals-B(Branch Assignment)]]></title>
    <url>%2F2019%2F04%2F03%2F2016-ACM-ICPC-World-Finals-B-Branch-Assignment%2F</url>
    <content type="text"><![CDATA[链接：https://codeforces.com/gym/101242/problem/B思路：前面的最短路部分不说了，问题转化为了把b个人分成至少s组，使得所有组的每个元素的(sz - 1) * (d1[i] + d2[i])最小。我们把f[i] = d1[i] + d2[i]，不难发现按照f[i]从小到大的顺序分组是最优的，而且分满s组的时候是最优的，那么这就满足wqs二分了，即必须在用满s个情况下可以达到最优解。我们二分权值后，问题变为了分任意组，每分一次权值 + C，求最后权值的最小值。可以打表或者证明验证满足单调决策性，那么我们可以用二分栈做完这个题，复杂度O(nlognlogC)。大多数人的做法都是n^2及以上的。这应该是最快的做法。代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 5005;struct edge&#123; int from, to, dist;&#125;;vector&lt;int&gt; g1[maxn], g2[maxn];vector&lt;edge&gt; edges1, edges2;int d1[maxn], d2[maxn];int f[maxn];int n, m;int b, s;typedef pair&lt;int, int&gt; pii;typedef long long ll;ll dp[maxn];void addedge(int from, int to, int dist)&#123; edges1.push_back(edge&#123;from, to, dist&#125;); edges2.push_back(edge&#123;to, from, dist&#125;); g1[from].push_back(edges1.size() - 1); g2[to].push_back(edges2.size() - 1);&#125;void dij()&#123; priority_queue&lt;pii, vector&lt;pii&gt;, greater&lt;pii&gt; &gt; q; q.push(pii(0, b + 1)); for(int i = 0; i &lt;= n; i++)d1[i] = d2[i] = 1e9; d1[b + 1] = d2[b + 1] = 0; while(!q.empty())&#123; pii p = q.top(); q.pop(); int u = p.second; if(d1[u] &lt; p.first)continue; for(int i = 0; i &lt; g1[u].size(); i++)&#123; edge &amp;e = edges1[g1[u][i]]; if(d1[e.to] &gt; d1[u] + e.dist)&#123; d1[e.to] = d1[u] + e.dist; q.push(pii(d1[e.to], e.to)); &#125; &#125; &#125; while(!q.empty())q.pop(); q.push(pii(0, b + 1)); while(!q.empty())&#123; pii p = q.top(); q.pop(); int u = p.second; if(d2[u] &lt; p.first)continue; for(int i = 0; i &lt; g2[u].size(); i++)&#123; edge &amp;e = edges2[g2[u][i]]; if(d2[e.to] &gt; d2[u] + e.dist)&#123; d2[e.to] = d2[u] + e.dist; q.push(pii(d2[e.to], e.to)); &#125; &#125; &#125;&#125;ll sum[maxn];struct node&#123; int l, r, p;&#125;que[maxn];int head, tail;ll v[maxn];ll cal(int x, int y)&#123; return dp[x] + 1ll * (y - x - 1) * (sum[y] - sum[x]);&#125;bool cmp(int i, int j, int k)&#123; ll v1 = cal(i, k); ll v2 = cal(j, k); if(v1 == v2) return v[i] &lt;= v[j]; return v1 &lt; v2;&#125;//注意要找的是第一个i比u.p大的位置，所以要注意二分等于情况的判断int find(node u, int x)&#123; int l = u.l, r = u.r; while(l &lt;= r)&#123; int mid = l + r &gt;&gt; 1; if(cmp(x, u.p, mid)) r = mid - 1; else l = mid + 1; &#125; return r + 1;&#125;bool check(ll k)&#123; head = 1, tail = 1; que[tail] = node&#123;1, b, 0&#125;; for(int i = 1; i &lt;= b; i++)&#123; while(head &lt;= tail &amp;&amp; i &gt; que[head].r) head++; dp[i] = cal(que[head].p, i) + k; v[i] = v[que[head].p] + 1; if(head &gt; tail || cmp(i, que[tail].p, b))&#123; while(head &lt;= tail &amp;&amp; cmp(i, que[tail].p, que[tail].l)) tail--; if(head &gt; tail) que[++tail] = node&#123;i + 1, b, i&#125;; else&#123; int t = find(que[tail], i); que[tail].r = t - 1; que[++tail] = node&#123;t, b, i&#125;; &#125; &#125; &#125; return v[b] &lt;= s;&#125;int main()&#123; // freopen("in.txt", "r", stdin); ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); cin &gt;&gt; n &gt;&gt; b &gt;&gt; s &gt;&gt; m; for(int i = 1; i &lt;= m; i++)&#123; int u, v, w; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; addedge(u, v, w); &#125; dij(); for(int i = 1; i &lt;= b; i++)f[i] = d1[i] + d2[i]; sort(f + 1, f + b + 1); for(int i = 1; i &lt;= b; i++) sum[i] = sum[i - 1] + f[i]; ll lb = 0, ub = b * sum[b]; ll ans = 0; while(ub &gt;= lb)&#123; ll mid = ub + lb &gt;&gt; 1; //求最小值小于等于的时候更新 if(check(mid))&#123; ub = mid - 1; ans = dp[b] - 1ll * mid * s; &#125; else lb = mid + 1; &#125; cout &lt;&lt; ans &lt;&lt; '\n'; return 0;&#125; 补一个大哥的分治写法，分治的话必须要保证决策点和转移点之间无关，即转移点在本次分治中不会成为决策点。本题中由于决策点都来源于上一次分组，所以决策点和转移点无关，可以用分治做，复杂度O(n^2logn)，不如wqs二分 + 二分栈，不过还是要会这种万能的写法。代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 5005;struct edge&#123; int from, to, dist;&#125;;vector&lt;int&gt; g1[maxn], g2[maxn];vector&lt;edge&gt; edges1, edges2;int d1[maxn], d2[maxn];int f[maxn];int n, m;int b, s;typedef pair&lt;int, int&gt; pii;typedef long long ll;ll dp[maxn][maxn];void addedge(int from, int to, int dist)&#123; edges1.push_back(edge&#123;from, to, dist&#125;); edges2.push_back(edge&#123;to, from, dist&#125;); g1[from].push_back(edges1.size() - 1); g2[to].push_back(edges2.size() - 1);&#125;void dij()&#123; priority_queue&lt;pii, vector&lt;pii&gt;, greater&lt;pii&gt; &gt; q; q.push(pii(0, b + 1)); for(int i = 0; i &lt;= n; i++)d1[i] = d2[i] = 1e9; d1[b + 1] = d2[b + 1] = 0; while(!q.empty())&#123; pii p = q.top(); q.pop(); int u = p.second; if(d1[u] &lt; p.first)continue; for(int i = 0; i &lt; g1[u].size(); i++)&#123; edge &amp;e = edges1[g1[u][i]]; if(d1[e.to] &gt; d1[u] + e.dist)&#123; d1[e.to] = d1[u] + e.dist; q.push(pii(d1[e.to], e.to)); &#125; &#125; &#125; while(!q.empty())q.pop(); q.push(pii(0, b + 1)); while(!q.empty())&#123; pii p = q.top(); q.pop(); int u = p.second; if(d2[u] &lt; p.first)continue; for(int i = 0; i &lt; g2[u].size(); i++)&#123; edge &amp;e = edges2[g2[u][i]]; if(d2[e.to] &gt; d2[u] + e.dist)&#123; d2[e.to] = d2[u] + e.dist; q.push(pii(d2[e.to], e.to)); &#125; &#125; &#125;&#125;ll sum[maxn];void solve(int i, int l, int r, int tl, int tr)&#123; if(l &gt; r) return; int mid = l + r &gt;&gt; 1; int pos = 0; for(int j = tl; j &lt;= min(mid - 1, tr); j++)&#123; ll tmp = dp[i - 1][j] + (mid - j - 1) * (sum[mid] - sum[j]); if(dp[i][mid] &gt; tmp)&#123; dp[i][mid] = tmp; pos = j; &#125; &#125; solve(i, l, mid - 1, tl, pos); solve(i, mid + 1, r, pos, tr);&#125;int main()&#123; // freopen("in.txt", "r", stdin); ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); cin &gt;&gt; n &gt;&gt; b &gt;&gt; s &gt;&gt; m; for(int i = 1; i &lt;= m; i++)&#123; int u, v, w; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; addedge(u, v, w); &#125; dij(); for(int i = 1; i &lt;= b; i++)f[i] = d1[i] + d2[i]; sort(f + 1, f + b + 1); for(int i = 1; i &lt;= b; i++) sum[i] = sum[i - 1] + f[i]; for(int i = 0; i &lt;= 5000; i++)&#123; for(int j = 0; j &lt;= 5000; j++)&#123; dp[i][j] = 1e18; &#125; &#125; dp[0][0] = 0; for(int i = 1; i &lt;= s; i++) solve(i, i, b, i - 1, b - 1); cout &lt;&lt; dp[s][b] &lt;&lt; '\n'; return 0;&#125;/*5 4 2 105 2 12 5 13 5 54 5 01 5 12 3 13 2 52 4 52 1 13 4 2 */]]></content>
      <categories>
        <category>wqs二分</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[P1912-[NOI2009](诗人小G)]]></title>
    <url>%2F2019%2F04%2F03%2FP1912-NOI2009-%E8%AF%97%E4%BA%BA%E5%B0%8FG%2F</url>
    <content type="text"><![CDATA[链接：https://www.luogu.org/problemnew/show/P1912思路：首先证明一下dp的转移方程满足四边形不等式，然后就没有然后了，暂时只学了二分栈/队列的写法，还不太会分治，后面有空学了分治再补分治的写法上来吧，注意这个题要开long double精度才够。代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485// luogu-judger-enable-o2#include &lt;bits/stdc++.h&gt;using namespace std;int T, n, l, p;typedef long double db;const int maxn = 1e5 + 5;db dp[maxn];struct node&#123; int l, r, p;&#125;que[maxn];int head, tail;db sum[maxn];string s[maxn];db pow_mod(db q, int w)&#123; db ret = 1; while(w)&#123; if(w &amp; 1) ret = ret * q; q = q * q; w &gt;&gt;= 1; &#125; return ret;&#125;db cal(int x, int y)&#123; return dp[x] + pow_mod(abs(sum[y] - sum[x] - l + y - x - 1), p);&#125;int find(node a, int x)&#123; int l = a.l, r = a.r; while(l &lt;= r)&#123; int mid = l + r &gt;&gt; 1; if(cal(a.p, mid) &lt; cal(x, mid))l = mid + 1; else r = mid - 1; &#125; return l;&#125;int from[maxn];void dfs(int x)&#123; if(x == 0)return; dfs(from[x]); for(int i = from[x] + 1; i &lt; x; i++)&#123; cout &lt;&lt; s[i] &lt;&lt; ' '; &#125; cout &lt;&lt; s[x] &lt;&lt; '\n';&#125;int main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); cin &gt;&gt; T; while(T--)&#123; cin &gt;&gt; n &gt;&gt; l &gt;&gt; p; for(int i = 1; i &lt;= n; i++)&#123; cin &gt;&gt; s[i]; sum[i] = sum[i - 1] + s[i].size(); &#125; head = 1, tail = 0; que[++tail] = node&#123;0, n, 0&#125;; for(int i = 1; i &lt;= n; i++)&#123; while(head &lt;= tail &amp;&amp; i &gt; que[head].r)head++; dp[i] = cal(que[head].p, i); from[i] = que[head].p; if(head &gt; tail || cal(i, n) &lt;= cal(que[tail].p, n))&#123; while(head &lt;= tail &amp;&amp; cal(i, que[tail].l) &lt;= cal(que[tail].p, que[tail].l))tail--; if(head &gt; tail) que[++tail] = node&#123;i, n, i&#125;; else&#123; int t = find(que[tail], i); que[tail].r = t - 1; que[++tail] = node&#123;t, n, i&#125;; &#125; &#125; &#125; if(dp[n] &gt; 1e18) cout &lt;&lt; "Too hard to arrange\n"; else cout &lt;&lt; (long long)dp[n] &lt;&lt; '\n', dfs(n); cout &lt;&lt; "--------------------\n"; &#125; return 0;&#125;]]></content>
      <categories>
        <category>决策单调性</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[bzoj-2654(tree)]]></title>
    <url>%2F2019%2F04%2F03%2Fbzoj-2654-tree%2F</url>
    <content type="text"><![CDATA[链接：https://www.lydsy.com/JudgeOnline/problem.php?id=2654思路：因为2016WF和2018南京B题去学了一下wqs二分，说起WF大哥最近去打WF了，真的是很羡慕啊希望自己也能有机会去。wqs二分用于解决选k个物品的问题，也叫做带权二分，首先保证dp的图形是个凸的，然后相当于二分一个权值，每次选一次这个物品就加上一次权值，然后就可以降维，最后看选出来的结果的x与k的大小决定二分的方向，结果上再减去k * 二分权值C，具体几何解释见https://www.cnblogs.com/CreeperLKF/p/9045491.html 。感谢原作者写的非常好，以及论文也可以参考，并且可以不用枚举小数。 本题相等于二分权值，然后选一次白边加上一次权值，最后看最优解选的白边数跟限制比较决定二分方向，最后可以得到答案。代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;bits/stdc++.h&gt;using namespace std; int n, m, k;struct edge&#123; int from, to, dist, type; bool operator&lt; (const edge&amp; r)const&#123; return dist &lt; r.dist || (dist == r.dist &amp;&amp; type &lt; r.type); &#125;&#125;; vector&lt;edge&gt; edges;const int maxn = 5e4 + 5;int par[maxn];typedef pair&lt;int, int&gt; pii; int getroot(int a)&#123; return par[a] == a ? a : par[a] = getroot(par[a]);&#125; pii kruskal(int mid)&#123; int res = 0; int ans = 0; int cnt = 0; for(int i = 0; i &lt; edges.size(); i++)&#123; edge &amp;e = edges[i]; if(e.type == 0) e.dist += mid; &#125; sort(edges.begin(), edges.end()); for(int i = 1; i &lt;= n; i++)par[i] = i; for(int i = 0; i &lt; edges.size(); i++)&#123; edge &amp;e = edges[i]; int u = e.from; int v = e.to; int p1 = getroot(u); int p2 = getroot(v); if(p1 == p2)continue; par[p2] = p1; cnt++; if(e.type == 0)res++; ans += e.dist; if(cnt == n - 1)break; &#125; for(int i = 0; i &lt; edges.size(); i++)&#123; edge &amp;e = edges[i]; if(e.type == 0) e.dist -= mid; &#125; return pii(ans, res);&#125; int main()&#123; scanf("%d %d %d", &amp;n, &amp;m, &amp;k); for(int i = 1; i &lt;= m; i++)&#123; int u, v, w, t; scanf("%d %d %d %d", &amp;u, &amp;v, &amp;w, &amp;t); u++ , v++; edges.push_back(edge&#123;u, v, w, t&#125;); &#125; int lb = -200, ub = 200; int ans = 0; while(ub &gt;= lb)&#123; int mid = ub + lb &gt;&gt; 1; pii o = kruskal(mid); //最大值大于等于可更新答案，最小值小于等于可更新答案 if(o.second &gt;= k)&#123; ans = o.first - k * mid; lb = mid + 1; &#125; else ub = mid - 1; &#125; printf("%d\n", ans); return 0;&#125;]]></content>
      <categories>
        <category>wqs二分</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2016 ACM-ICPC-World-Finals-G(Oil)]]></title>
    <url>%2F2019%2F03%2F29%2F2016-ACM-ICPC-World-Finals-G-Oil%2F</url>
    <content type="text"><![CDATA[链接：https://codeforces.com/gym/101242/attachments思路：一开始自己思路是对的啊，虽然不是最简单的。一开始想的是枚举一个点，然后剩下点极角排序，然后枚举第二个点，然后到旋转180度后的位置，看中间有多少点左右端点只有一个在一半的平面内，统计下贡献记录答案即可。事实上还有更简单的方法，因为点在1e6内，而且同一水平线的不会计入，代表y坐标差不会为0，我们用x / y的值排序即可。然后扫一遍就可以统计出答案了。代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;bits/stdc++.h&gt;using namespace std;typedef double db;typedef long long ll;struct seg&#123; db l, r, h;&#125;r[5000];int n;const db eps = 1e-8;int dcmp(db x) &#123; return x &lt; -eps ? -1 : x &gt; eps;&#125;struct event&#123; db u; ll v; int id;&#125;tmp[5000];ll res;bool cmp(event &amp;a, event &amp;b)&#123; return dcmp(a.u - b.u) &lt; 0 || (dcmp(a.u - b.u) == 0 &amp;&amp; a.id &lt; b.id);&#125;void solve(db x, db y, int z)&#123; int len = 0; for(int i = 1; i &lt;= n; i++) &#123; if (dcmp(y - r[i].h) == 0) continue; db k1 = (r[i].l - x) / (r[i].h - y); db k2 = (r[i].r - x) / (r[i].h - y); if (k1 &lt; k2) &#123; tmp[++len] = event&#123;k1, ll(r[i].r - r[i].l), 0&#125;; tmp[++len] = event&#123;k2, -ll(r[i].r - r[i].l), 1&#125;; &#125; else&#123; tmp[++len] = event&#123;k1, -ll(r[i].r - r[i].l), 0&#125;; tmp[++len] = event&#123;k2, ll(r[i].r - r[i].l), 1&#125;; &#125; &#125; sort(tmp + 1, tmp + len + 1, cmp); ll ans = r[z].r - r[z].l; ll sum = ans; for(int i = 1; i &lt;= len; i++)&#123; sum += tmp[i].v; ans = max(ans, sum); &#125; res = max(res, ans);&#125;int main()&#123; scanf("%d", &amp;n); for(int i = 1; i &lt;= n; i++)&#123; scanf("%lf %lf %lf", &amp;r[i].l, &amp;r[i].r, &amp;r[i].h); if(r[i].l &gt; r[i].r) swap(r[i].l, r[i].r); &#125; for(int i = 1; i &lt;= n; i++)&#123; solve(r[i].l, r[i].h, i); solve(r[i].r, r[i].h, i); &#125; printf("%lld\n", res); return 0;&#125;]]></content>
      <categories>
        <category>计算几何</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[HDU-3605(Escape)]]></title>
    <url>%2F2019%2F03%2F29%2FHDU-3605-Escape%2F</url>
    <content type="text"><![CDATA[链接：https://vjudge.net/problem/HDU-3605思路：点很多，直接建图肯定TLE，我们注意到星球最多10个，所以选择最多只有1024种，所以我们可以考虑统计每一种选择有多少个人，因为人是无差别的，这样复杂度就大大降低了，我们只用对这些选择，以及星球进行建图即可。代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149#include&lt;bits/stdc++.h&gt;using namespace std;int n, m;const int maxn = 2000;const int INF = 1e9;struct edge&#123; int from,to,cap,flow;&#125;;int tot,s,t;vector&lt;edge&gt; edges;vector&lt;int&gt; G[maxn];bool vis[maxn];int d[maxn];int cur[maxn];int p[maxn];int num[maxn];//比Dinic算法多了这两个数组，p数组标记父亲结点，num数组标记距离d[i]存在几个int T;void init()&#123; edges.clear(); for(int i = 0; i &lt;= t; i++)G[i].clear();&#125;void addedge(int from, int to, int cap) &#123; edges.push_back(edge&#123;from, to, cap, 0&#125;); edges.push_back(edge&#123;to, from, 0, 0&#125;); tot = edges.size(); G[from].push_back(tot - 2); G[to].push_back(tot - 1);&#125;int augmemt() &#123; int x = t, a = INF; while (x != s) &#123; edge &amp;e = edges[p[x]]; a = min(a, e.cap - e.flow); x = edges[p[x]].from; &#125; x = t; while (x != s) &#123; edges[p[x]].flow += a; edges[p[x] ^ 1].flow -= a;//更新反向边。 x = edges[p[x]].from; &#125; return a;&#125;void bfs() &#123; for(int i = 0; i &lt;= t; i++)d[i] = t; memset(vis, 0, sizeof(vis)); queue&lt;int&gt; q; q.push(t); d[t] = 0; vis[t] = 1; while (!q.empty()) &#123; int x = q.front(); q.pop(); int len = G[x].size(); for (int i = 0; i &lt; len; i++) &#123; edge &amp;e = edges[G[x][i] ^ 1]; if (!vis[e.from] &amp;&amp; e.cap &gt; e.flow) &#123; vis[e.from] = 1; d[e.from] = d[x] + 1; q.push(e.from); &#125; &#125; &#125;&#125;int maxflow() &#123; int flow = 0; bfs(); memset(num, 0, sizeof(num)); for (int i = 0; i &lt;= t; i++)num[d[i]]++; int x = s; memset(cur, 0, sizeof(cur)); while (d[s] &lt;= t) &#123; if (x == t) &#123; flow += augmemt(); x = s;//增广后回到源点 &#125; int ok = 0; for (int i = cur[x]; i &lt; G[x].size(); i++) &#123; edge &amp;e = edges[G[x][i]]; if (e.cap &gt; e.flow &amp;&amp; d[x] == d[e.to] + 1) &#123; ok = 1; p[e.to] = G[x][i];//记录来的时候走的边，即父边 cur[x] = i; x = e.to;//前进 break; &#125; &#125; if (!ok) &#123; int m = t;//如果没有弧，那么m+1就是t，即d[i]=t for (int i = 0; i &lt; G[x].size(); i++) &#123; edge &amp;e = edges[G[x][i]]; if (e.cap &gt; e.flow) m = min(m, d[e.to]); &#125; if (--num[d[x]] == 0)break;//如果走不动了，且这个距离值原来只有一个，那么s-t不通，这就是所谓的“gap优化” num[d[x] = m + 1]++; cur[x] = 0; if (x != s) x = edges[p[x]].from;//退一步，沿着父边返回 &#125; &#125; return flow;&#125;int v[1100];int main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); while(cin &gt;&gt; n &gt;&gt; m)&#123; init(); memset(v, 0, sizeof(v)); s = 0, t = (1 &lt;&lt; m) + m + 1; for(int i = 1; i &lt;= n; i++)&#123; int c = 0; for(int j = 0; j &lt; m; j++)&#123; int x; cin &gt;&gt; x; c += (x &lt;&lt; j); &#125; v[c]++; &#125; for(int i = 0; i &lt; (1 &lt;&lt; m); i++)&#123; if(!v[i])continue; addedge(s, i + 1, v[i]); for(int j = 0; j &lt; m; j++)&#123; if(i &amp; (1 &lt;&lt; j))&#123; addedge(i + 1, (1 &lt;&lt; m) + j + 1, INF); &#125; &#125; &#125; for(int i = 0; i &lt; m; i++)&#123; int x; cin &gt;&gt; x; addedge((1 &lt;&lt; m) + i + 1, t, x); &#125; int res = maxflow(); if(res == n)cout &lt;&lt; "YES\n"; else cout &lt;&lt; "NO\n"; &#125; return 0;&#125;]]></content>
      <categories>
        <category>网络流</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[HDU-4280(Island Transport)]]></title>
    <url>%2F2019%2F03%2F26%2FHDU-4280-Island-Transport%2F</url>
    <content type="text"><![CDATA[链接：https://vjudge.net/problem/HDU-4280思路：这个题如果现场看到了真的不敢写网络流啊，1e5的点也是真的敢出十分佩服。这个题而且Dinic被卡掉了，所以趁机check了一波ISAP的板子，果然板子又出锅了，赶紧改了，题目倒没什么难的。代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144#include&lt;bits/stdc++.h&gt;using namespace std;int n, m;const int maxn = 100005;const int INF = 1e9;struct edge&#123; int from,to,cap,flow;&#125;;int tot,s,t;vector&lt;edge&gt; edges;vector&lt;int&gt; G[maxn];bool vis[maxn];int d[maxn];int cur[maxn];int p[maxn];int num[maxn];//比Dinic算法多了这两个数组，p数组标记父亲结点，num数组标记距离d[i]存在几个int T;void init()&#123; edges.clear(); for(int i = 0; i &lt;= t; i++)G[i].clear();&#125;void addedge(int from, int to, int cap) &#123; edges.push_back(edge&#123;from, to, cap, 0&#125;); edges.push_back(edge&#123;to, from, 0, 0&#125;); tot = edges.size(); G[from].push_back(tot - 2); G[to].push_back(tot - 1);&#125;int augmemt() &#123; int x = t, a = INF; while (x != s) &#123; edge &amp;e = edges[p[x]]; a = min(a, e.cap - e.flow); x = edges[p[x]].from; &#125; x = t; while (x != s) &#123; edges[p[x]].flow += a; edges[p[x] ^ 1].flow -= a;//更新反向边。 x = edges[p[x]].from; &#125; return a;&#125;void bfs() &#123; for(int i = 0; i &lt;= t; i++)d[i] = t; memset(vis, 0, sizeof(vis)); queue&lt;int&gt; q; q.push(t); d[t] = 0; vis[t] = 1; while (!q.empty()) &#123; int x = q.front(); q.pop(); int len = G[x].size(); for (int i = 0; i &lt; len; i++) &#123; edge &amp;e = edges[G[x][i] ^ 1]; if (!vis[e.from] &amp;&amp; e.cap &gt; e.flow) &#123; vis[e.from] = 1; d[e.from] = d[x] + 1; q.push(e.from); &#125; &#125; &#125;&#125;int maxflow() &#123; int flow = 0; bfs(); memset(num, 0, sizeof(num)); for (int i = 0; i &lt;= t; i++)num[d[i]]++; int x = s; memset(cur, 0, sizeof(cur)); while (d[s] &lt;= t) &#123; if (x == t) &#123; flow += augmemt(); x = s;//增广后回到源点 &#125; int ok = 0; for (int i = cur[x]; i &lt; G[x].size(); i++) &#123; edge &amp;e = edges[G[x][i]]; if (e.cap &gt; e.flow &amp;&amp; d[x] == d[e.to] + 1) &#123; ok = 1; p[e.to] = G[x][i];//记录来的时候走的边，即父边 cur[x] = i; x = e.to;//前进 break; &#125; &#125; if (!ok) &#123; int m = t;//如果没有弧，那么m+1就是t，即d[i]=t for (int i = 0; i &lt; G[x].size(); i++) &#123; edge &amp;e = edges[G[x][i]]; if (e.cap &gt; e.flow) m = min(m, d[e.to]); &#125; if (--num[d[x]] == 0)break;//如果走不动了，且这个距离值原来只有一个，那么s-t不通，这就是所谓的“gap优化” num[d[x] = m + 1]++; cur[x] = 0; if (x != s) x = edges[p[x]].from;//退一步，沿着父边返回 &#125; &#125; return flow;&#125;int main()&#123; scanf("%d", &amp;T); while(T--)&#123; init(); scanf("%d %d", &amp;n, &amp;m); int mx, mn; int wm = INF, em = -INF; for (int i = 1; i &lt;= n; i++) &#123; int x, y; scanf("%d%d", &amp;x, &amp;y); if (x &lt; wm) &#123; mn = i; wm = x; &#125; if (x &gt; em) &#123; mx = i; em = x; &#125; &#125; for(int i = 1; i &lt;= m; i++)&#123; int u, v, w; scanf("%d %d %d", &amp;u, &amp;v, &amp;w); addedge(u, v, w); addedge(v, u, w); &#125; s = n + 1, t = n + 2; addedge(s, mn, INF); addedge(mx, t, INF); printf("%d\n", maxflow()); &#125; return 0;&#125;]]></content>
      <categories>
        <category>网络流</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Codeforces-Round-545-(Div.1)-C(Museums Tour)]]></title>
    <url>%2F2019%2F03%2F26%2FCodeforces-Round-545-Div-1-C-Museums-Tour%2F</url>
    <content type="text"><![CDATA[链接：https://codeforces.com/contest/1137/problem/C思路：很好思路的一个题，最简单的做法就是拆点，对于拆后的所有点进行tarjan求强连通分量，然后缩点重新建图后变为DAG，在DAG上dp即可。这样的话需要卡空间 + 手动开栈(点太多递归要爆栈)，还有一种做法就是只对原图进行tarjan，然后讨论每个连通块的循环节的情况，我自己想不清楚就没写了。学到了一点就是tarjan出来的强连通分量是按照逆拓扑序排列的，所以dp的时候直接按照缩点后从前到后(逆拓扑序)进行dp即可，最后看缩点后的最后一个点(就是原来的1号起始点)的dp值就是答案。代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e5 + 1;int n ,m, d;vector&lt;int&gt; G[maxn], g[maxn * 50];int dfn[maxn][50];int low[maxn][50];int sccno[maxn][50];int scount[maxn * 50];int ntime;bool ta[maxn][50];int bcc_cnt;//连通块数量typedef pair&lt;int, int&gt; pii;pii P[maxn * 50];int dp[maxn * 50];int sz;int seen[maxn];void tarjan(int u, int t) &#123; dfn[u][t] = low[u][t] = ++ntime; P[sz++] = pii(u, t); for (int i = 0; i &lt; G[u].size(); i++) &#123; int v = G[u][i]; if (!dfn[v][(t + 1) % d]) &#123; tarjan(v, (t + 1) % d); low[u][t] = min(low[u][t], low[v][(t + 1) % d]); &#125; else if (!sccno[v][(t + 1) % d]) &#123; low[u][t] = min(low[u][t], dfn[v][(t + 1) % d]); &#125; &#125; if (low[u][t] == dfn[u][t]) &#123; bcc_cnt++; pii tmp; do &#123; --sz; tmp = P[sz]; sccno[tmp.first][tmp.second] = bcc_cnt; //可以给访问数组赋第几次访问的值，这样就不用清空访问数组，并且知道在这一个强连通分量中是否已经访问过某个城市对应的点了 if(seen[tmp.first] != bcc_cnt &amp;&amp; ta[tmp.first][tmp.second])scount[bcc_cnt]++, seen[tmp.first] = bcc_cnt; &#125; while (tmp != pii(u, t)); &#125;&#125;int main()&#123; //freopen("in.txt", "r", stdin); //手动开栈 int size = 64 &lt;&lt; 20; char *p = (char*)malloc(size) + size; __asm__("movl %0, %%esp\n" :: "r"(p)); scanf("%d %d %d", &amp;n, &amp;m, &amp;d); for(int i = 1; i &lt;= m; i++)&#123; int u, v; scanf("%d %d", &amp;u, &amp;v); G[u].emplace_back(v); &#125; for(int i = 1; i &lt;= n; i++)&#123; for(int j = 0; j &lt; d; j++)&#123; scanf("%1d", &amp;ta[i][j]); &#125; &#125; tarjan(1, 0); //缩点重新建图 for(int i = 1; i &lt;= n; i++)&#123; for(int j = 0; j &lt; d; j++) &#123; for (auto &amp;v : G[i]) &#123; if (sccno[i][j] == sccno[v][(j + 1) % d])continue; g[sccno[i][j]].emplace_back(sccno[v][(j + 1) % d]); &#125; &#125; &#125; g[0].emplace_back(sccno[1][0]); //因为tarjan后是逆拓扑序排列，所以直接按照新图从前向后dp即可。 for(int i = 1; i &lt;= bcc_cnt; i++)&#123; for(auto &amp;j : g[i]) dp[i] = max(dp[i], dp[j]); dp[i] += scount[i]; &#125; printf("%d\n", dp[bcc_cnt]); return 0;&#125;]]></content>
      <categories>
        <category>tarjan强连通分量</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Andrew-Stankevich-Contest-47-A(Ambitious Plan)]]></title>
    <url>%2F2019%2F03%2F22%2FAndrew-Stankevich-Contest-47-A-Ambitious-Plan%2F</url>
    <content type="text"><![CDATA[链接：https://codeforces.com/gym/100608/attachments思路：枚举堡垒点，然后以该点为中心对敌机和塔的点进行极角排序(要用atan2，叉积又T又wa)，然后破环为链，双指针维护。我们需要维护两个塔点间的贡献和，也就是遇到一个塔点，两点之间的贡献就要加敌在这个塔点前的敌机点数，然后旋转时如果遇到塔点，就把贡献计入总的答案中，如果遇到敌机点，就删掉这个敌机点的贡献，最终统计一遍即可。代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include&lt;bits/stdc++.h&gt;using namespace std;typedef double db;typedef long long ll;ll ans;const db eps = 1e-10;const db pi = acos(-1);int dcmp(db x) &#123; return x&lt;-eps?-1:x&gt;eps;&#125;typedef struct P &#123; db x, y; P(db x = 0, db y = 0) : x(x), y(y) &#123;&#125; P operator+(P r)&#123;return P(x+r.x,y+r.y);&#125; P operator-(P r)&#123;return P(x-r.x,y-r.y);&#125; P operator*(db r)&#123;return P(x*r,y*r);&#125; P operator/(db r)&#123;return P(x/r,y/r);&#125; bool operator&lt;(const P &amp;r)const&#123;return x&lt;r.x||(x==r.x&amp;&amp;y&lt;r.y);&#125; bool operator==(const P &amp;r)const&#123;return dcmp(x-r.x)==0&amp;&amp;dcmp(y-r.y)==0;&#125; void read()&#123; scanf("%lf %lf", &amp;x, &amp;y); &#125; void print()&#123; printf("%.2f %.2f ", x, y);&#125;;&#125;V;db Cross(V A, V B) &#123; return A.x*B.y - A.y*B.x; &#125;int n, m, t;P a[8000], b[8000];int idx[8000];db rad[8000];bool cmp(int x, int y) &#123; return rad[x] &lt; rad[y];&#125;void solve(P r)&#123; for(int i = 1; i &lt;= n + t; i++)&#123; rad[i] = atan2((a[i] - r).y, (a[i] - r).x); idx[i] = i; &#125; //极角排序 sort(idx + 1, idx + n + t + 1, cmp); copy(idx + 1, idx + n + t + 1, idx + n + t + 1); ll sum = 0; int cnt1 = 0, cnt2 = 0; for(int i = 1, j = 1; i &lt;= n + t; i++)&#123; P ti = a[idx[i]], tj = a[idx[j]]; while(j &lt; i + n + t &amp;&amp; Cross(ti - r, tj - r) &gt;= 0)&#123; //如果遇到塔点，则总贡献 + 当前统计的敌机数，塔点++ if(idx[j] &gt; n)cnt2++, sum += cnt1; //否则敌机点++ else cnt1++; tj = a[idx[++j]]; &#125; //如果是敌机点，敌机点--，总贡献-当前塔点数量 if(idx[i] &lt;= n)--cnt1, sum -= cnt2; //如果是塔点，总贡献计入答案中，塔点-- else ans += sum, cnt2--; &#125;&#125;int main()&#123; freopen("ambitious.in", "r", stdin); freopen("ambitious.out", "w", stdout); while(~scanf("%d", &amp;n) &amp;&amp; n) &#123; ans = 0; for (int i = 1; i &lt;= n; i++)a[i].read(); scanf("%d", &amp;m); for (int i = 1; i &lt;= m; i++)b[i].read(); scanf("%d", &amp;t); for (int i = n + 1; i &lt;= n + t; i++)a[i].read(); for(int i = 1; i &lt;= m; i++)solve(b[i]); printf("%lld\n", ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>计算几何</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[HDU-4352(XHXJ's-LIS)]]></title>
    <url>%2F2019%2F03%2F15%2FHDU-4352-XHXJ-s-LIS%2F</url>
    <content type="text"><![CDATA[链接：https://vjudge.net/problem/HDU-4352思路：一直在想怎么状压表示最长上升子序列，还是对nlogn的那种替换的方法不熟悉啊，对于每一个当前数字，我们找到目前最长上升子序列中第一个比他大的位置，然后替换掉，最后统计数字的个数即可知道最长上升子序列长度是多少了，那么这样的话我们就可以状压了。因为最多k只有10，然后每次转移我们更新按照nlogn的那个方法求一下最新的状压结果，转移即可。代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;ll dp[20][1 &lt;&lt; 10][12];int num[20];ll l, r;int k;//替换掉第一个比当前值大的位置，如果没有则直接放在对应位置上即可。int get(int x, int y)&#123; if(x &amp; (1 &lt;&lt; y)) return x; for(int i = y + 1; i &lt; 10; i++)&#123; if(!((1 &lt;&lt; i) &amp; x))continue; x -= (1 &lt;&lt; i); x += (1 &lt;&lt; y); return x; &#125; x += (1 &lt;&lt; y); return x;&#125;int count(int x)&#123; int res = 0; for(int i = 0; i &lt; 10; i++)&#123; if(x &amp; (1 &lt;&lt; i))res++; &#125; return res;&#125;ll dfs(int pos, int p, bool limit, bool lead)&#123; if(pos &lt; 0)return count(p) == k; if(!limit &amp;&amp; !lead &amp;&amp; dp[pos][p][k] != -1) return dp[pos][p][k]; ll ans = 0; int e = !limit ? 9 : num[pos]; if(lead)&#123; ans += dfs(pos - 1, p, limit &amp;&amp; num[pos] == 0, true); &#125; else&#123; ans += dfs(pos - 1, get(p, 0), limit &amp;&amp; num[pos] == 0, false); &#125; for(int i = 1; i &lt;= e; i++)&#123; ans += dfs(pos - 1, get(p, i), limit &amp;&amp; num[pos] == i, false); &#125; if(!limit &amp;&amp; !lead) dp[pos][p][k] = ans; return ans;&#125;ll solve(ll x)&#123; int pos = 0; while(x)&#123; num[pos++] = x % 10; x /= 10; &#125; return dfs(pos - 1, 0, 1, 1);&#125;int T;int main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); cin &gt;&gt; T; memset(dp, -1, sizeof(dp)); for(int i = 1; i &lt;= T; i++)&#123; cin &gt;&gt; l &gt;&gt; r &gt;&gt; k; cout &lt;&lt; "Case #" &lt;&lt; i &lt;&lt; ": " &lt;&lt; solve(r) - solve(l - 1) &lt;&lt; '\n'; &#125; return 0;&#125;]]></content>
      <categories>
        <category>数位dp</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[HDU-4507(吉哥系列故事――恨7不成妻)]]></title>
    <url>%2F2019%2F03%2F15%2FHDU-4507-%E5%90%89%E5%93%A5%E7%B3%BB%E5%88%97%E6%95%85%E4%BA%8B%E2%80%95%E2%80%95%E6%81%A87%E4%B8%8D%E6%88%90%E5%A6%BB%2F</url>
    <content type="text"><![CDATA[链接：https://vjudge.net/contest/287300#problem/J思路：这个题算是很巧妙了，因为一直以来dp做惯了只维护一个值的题目，对于这种需要维护几个值的信息的题就完全束手无策了。我们先考虑平方和怎么统计，很容易想到平方公式展开，那么如果我们按位dp时，假设后面的位已经计算过了，现在我要把当前这一位加入贡献中，贡献就是跟之前每一种存在的解都要做一次平方和展开，整理一下发现跟之前解的个数，解的和以及解的平方和有关，所以我们dp就要维护这几个量，然后按照数位dp正常转移即可。代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const ll mod = 1e9 + 7;void add(ll &amp;x, ll y)&#123; x += y; if(x &gt;= mod) x -= mod;&#125;struct node&#123; ll cnt, sum, mul; node(ll c = -1, ll s = -1, ll m = -1)&#123; cnt = c; sum = s; mul = m; &#125;&#125;dp[20][7][7];int num[20];ll fac[20];node dfs(int pos, int p, int q, bool limit)&#123; if(pos &lt; 0) &#123; if(p &amp;&amp; q) return node&#123;1, 0, 0&#125;; return node&#123;0, 0, 0&#125;; &#125; if(!limit &amp;&amp; dp[pos][p][q].cnt != -1) return dp[pos][p][q]; int e = !limit ? 9 : num[pos]; node ans = &#123;0, 0, 0&#125;; for(int i = 0; i &lt;= e; i++)&#123; if(i == 7)continue; ll x = i * fac[pos] % mod; node tmp = dfs(pos - 1, (p + i) % 7, (q + fac[pos] % 7 * i) % 7, limit &amp;&amp; num[pos] == i); add(ans.cnt, tmp.cnt); ans.sum = (ans.sum + tmp.sum + x * tmp.cnt % mod) % mod; ans.mul = (ans.mul + 2 * tmp.sum * x % mod + x * x % mod * tmp.cnt % mod + tmp.mul) % mod; &#125; if(!limit) dp[pos][p][q] = ans; return ans;&#125;ll solve(ll x)&#123; int pos = 0; while(x)&#123; num[pos++] = x % 10; x /= 10; &#125; return dfs(pos - 1, 0, 0, 1).mul;&#125;int T;int main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); cin &gt;&gt; T; fac[0] = 1; for(int i = 1; i &lt;= 18; i++)fac[i] = fac[i - 1] * 10; while(T--)&#123; ll l, r; cin &gt;&gt; l &gt;&gt; r; cout &lt;&lt; ((solve(r) - solve(l - 1)) % mod + mod) % mod &lt;&lt; '\n'; &#125; return 0;&#125;]]></content>
      <categories>
        <category>数位dp</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[SPOJ-BALNUM(Balanced-Numbers)]]></title>
    <url>%2F2019%2F03%2F12%2FSPOJ-BALNUM-Balanced-Numbers%2F</url>
    <content type="text"><![CDATA[链接：https://vjudge.net/problem/SPOJ-BALNUM思路：我第一次写的时候用了两个二进制数来表示，一个表示是否出现过，一个表示出现次数的奇偶性，结果卡着时限的三分之一过去了，后来看网上题解，可以用三进制来维护，0表示没出现，1表示出现奇数次，2表示出现偶数次，剩下的都差不多了。可能没有二进制好写，但是时间复杂度降了很多。要习惯一下三进制状压的写法。二进制状压：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;ll dp[20][1024][1024];int num[20];ull l, r;int T;bool check(int x, int y)&#123; for(int i = 0; i &lt; 10; i++)&#123; if((y &amp; (1 &lt;&lt; i)) == 0)continue; if(i % 2 &amp;&amp; (x &amp; (1 &lt;&lt; i)))return false; if(i % 2 == 0 &amp;&amp; (x &amp; (1 &lt;&lt; i)) == 0)return false; &#125; return true;&#125;ll dfs(int pos, int p, int q, bool limit, bool lead)&#123; if(pos &lt; 0) return check(p, q); if(!limit &amp;&amp; !lead &amp;&amp; dp[pos][p][q] != -1) return dp[pos][p][q]; int e = !limit ? 9 : num[pos]; ll ans = 0; if(lead)&#123; ans += dfs(pos - 1, p, q, limit &amp;&amp; num[pos] == 0, true); &#125; else&#123; ans += dfs(pos - 1, p ^ 1, q | 1, limit &amp;&amp; num[pos] == 0, false); &#125; for(int i = 1; i &lt;= e; i++)&#123; ans += dfs(pos - 1, p ^ (1 &lt;&lt; i), q | (1 &lt;&lt; i), limit &amp;&amp; num[pos] == i, false); &#125; if(!limit &amp;&amp; !lead) dp[pos][p][q] = ans; return ans;&#125;ll solve(ll x)&#123; int pos = 0; while(x)&#123; num[pos++] = x % 10; x /= 10; &#125; return dfs(pos - 1, 0, 0, 1, 1);&#125;int main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); cin &gt;&gt; T; memset(dp, -1, sizeof(dp)); while(T--)&#123; cin &gt;&gt; l &gt;&gt; r; cout &lt;&lt; solve(r) - solve(l - 1) &lt;&lt; '\n'; &#125; return 0;&#125; 三进制状压：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;ll dp[20][60000];int num[20];int fac[20];ull l, r;int T;bool check(int x)&#123; for(int i = 0; i &lt; 10; i++)&#123; int s = x % 3; x /= 3; if(s == 0)continue; if(s == 1 &amp;&amp; i % 2)return false; if(s == 2 &amp;&amp; i % 2 == 0)return false; &#125; return true;&#125;ll dfs(int pos, int p, bool limit, bool lead)&#123; if(pos &lt; 0) return check(p); if(!limit &amp;&amp; !lead &amp;&amp; dp[pos][p] != -1) return dp[pos][p]; int e = !limit ? 9 : num[pos]; ll ans = 0; if(lead)&#123; ans += dfs(pos - 1, p, limit &amp;&amp; num[pos] == 0, true); &#125; else&#123; int x = p % 3; if(x == 0 || x == 1)x = 1; else x = -1; ans += dfs(pos - 1, p + x, limit &amp;&amp; num[pos] == 0, false); &#125; for(int i = 1; i &lt;= e; i++)&#123; int x = p / fac[i] % 3; if(x == 0 || x == 1) x = 1; else x = -1; ans += dfs(pos - 1, p + x * fac[i], limit &amp;&amp; num[pos] == i, false); &#125; if(!limit &amp;&amp; !lead) dp[pos][p] = ans; return ans;&#125;ll solve(ll x)&#123; int pos = 0; while(x)&#123; num[pos++] = x % 10; x /= 10; &#125; return dfs(pos - 1, 0, 1, 1);&#125;int main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); fac[0] = 1; for(int i = 1; i &lt;= 10; i++)fac[i] = fac[i - 1] * 3; cin &gt;&gt; T; memset(dp, -1, sizeof(dp)); while(T--)&#123; cin &gt;&gt; l &gt;&gt; r; cout &lt;&lt; solve(r) - solve(l - 1) &lt;&lt; '\n'; &#125; return 0;&#125;]]></content>
      <categories>
        <category>数位dp</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[POJ-3252(Round-Numbers)]]></title>
    <url>%2F2019%2F03%2F11%2FPOJ-3252-Round-Numbers%2F</url>
    <content type="text"><![CDATA[链接：https://vjudge.net/problem/POJ-3252思路：求区间内二进制下0大于等于1个数的数的数量，考虑在二进制下面做数位dp，因为前导0有影响，所以我们dfs还要多一维考虑前导0的情况，只有当没有前导0和严格小于的时候我们才记录状态(虽然前导0不严格记录也能过这个题，但想了下总感觉不太对。。。。还是严格时记录比较好)代码：12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;typedef long long ll;ll s, t;ll dp[40][40][40]; //dp[i][j][k]表示枚举到第i位，有j个1，总共k个有效数字int num[40];int cnt;ll dfs(int pos, int k, int len, bool limit, bool lead)&#123; if(pos &lt; 0) return 2 * k &lt;= len; if(!limit &amp;&amp; !lead &amp;&amp; dp[pos][k][len] != -1) return dp[pos][k][len]; int e = !limit ? 1 : num[pos]; ll ans = 0; if(lead) ans += dfs(pos - 1, k, len, limit &amp;&amp; num[pos] == 0, true); else ans += dfs(pos - 1, k, len + 1, limit &amp;&amp; num[pos] == 0, false); for(int i = 1; i &lt;= e; i++)&#123; ans += dfs(pos - 1, k + 1, len + 1, limit &amp;&amp; num[pos] == 1, false); &#125; if(!limit &amp;&amp; !lead)dp[pos][k][len] = ans; return ans;&#125;ll solve(ll x)&#123; cnt = 0; while(x)&#123; num[cnt++] = x % 2; x /= 2; &#125; return dfs(cnt - 1, 0, 0, 1, 1);&#125;int main()&#123; scanf("%lld %lld", &amp;s, &amp;t); memset(dp, -1, sizeof(dp)); printf("%lld\n", solve(t) - solve(s - 1)); return 0;&#125;]]></content>
      <categories>
        <category>数位dp</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Codeforces-Beta-Round-51-D(Beautiful-numbers)]]></title>
    <url>%2F2019%2F03%2F10%2FCodeforces-Beta-Round-51-D-Beautiful-numbers%2F</url>
    <content type="text"><![CDATA[链接：https://codeforces.com/contest/55/problem/D思路：考虑到有除法，我们知道1-9的最小公倍数是2520， 我们考虑dp过程中维护一个对2520的余数，然后维护一下当前的lcm，对于最后我们看余数 % lcm == 0是否为真，为真的话就返回1否则为0，转移的时候注意0特殊转移一下就行。注意lcm需要hash处理一下，减小一些不存在的状态。代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;ll dp[20][50][2550];int num[20];ll fac[20];vector&lt;int&gt; h;int hh[2550];ll l, r;ll dfs(int pos, int lcm, int k, bool limit)&#123; if(pos &lt; 0) return k % h[lcm] == 0; if(dp[pos][lcm][k] != -1 &amp;&amp; !limit) return dp[pos][lcm][k]; int e = !limit ? 9 : num[pos]; ll ans = 0; for(int i = 0; i &lt;= e; i++)&#123; int x = h[lcm] * i / __gcd(h[lcm], i); x = hh[x]; ans += dfs(pos - 1, i == 0 ? lcm : x, (k + i * fac[pos]) % 2520, limit &amp;&amp; i == num[pos]); &#125; if(!limit)dp[pos][lcm][k] = ans; return ans;&#125;ll solve(ll x)&#123; int pos = 0; while(x)&#123; num[pos++] = x % 10; x /= 10; &#125; return dfs(pos - 1, 0, 0, 1);&#125;int T;int main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); fac[0] = 1; for(int i = 1; i &lt;= 18; i++)fac[i] = fac[i - 1] * 10; for(int i = 0; i &lt; (1 &lt;&lt; 9); i++)&#123; int x = 1; for(int j = 0; (1 &lt;&lt; j) &lt;= i; j++)&#123; if(i &amp; (1 &lt;&lt; j))x = x * (j + 1) / __gcd(x, j + 1); &#125; h.emplace_back(x); &#125; sort(h.begin(), h.end()); h.resize(unique(h.begin(), h.end()) - h.begin()); for(int i = 0; i &lt; h.size(); i++)hh[h[i]] = i; cin &gt;&gt; T; while(T--)&#123; cin &gt;&gt; l &gt;&gt; r; memset(dp, -1, sizeof(dp)); cout &lt;&lt; solve(r) - solve(l - 1) &lt;&lt; '\n'; &#125; return 0;&#125;]]></content>
      <categories>
        <category>数位dp</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[HDU-2089(不要62)]]></title>
    <url>%2F2019%2F03%2F10%2FHDU-2089-%E4%B8%8D%E8%A6%8162%2F</url>
    <content type="text"><![CDATA[链接：https://vjudge.net/problem/HDU-2089思路：数位dp入门题，dp[pos][sta]表示枚举到第len位，sta表示前面是否为6，然后dfs时还有一个limit表示是否严格小于，然后根据limit决定枚举结束的位置，然后转移即可，最后我们只保留严格小于时的答案。代码：12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;ll dp[7][2];int num[10];ll dfs(int pos, bool limit, bool sta)&#123; if(pos &lt; 0) return 1; //严格小于并且已经搜索过，直接返回答案 if(dp[pos][sta] != -1 &amp;&amp; !limit)return dp[pos][sta]; //决定结束位置 int e = !limit ? 9 : num[pos]; ll ans = 0; for(int i = 0; i &lt;= e; i++)&#123; if(sta &amp;&amp; i == 2)continue; if(i == 4)continue; ans += dfs(pos - 1, limit &amp;&amp; i == num[pos], i == 6); &#125; //如果严格小于，就保存答案 if(!limit) dp[pos][sta] = ans; return ans;&#125;ll solve(int x)&#123; int pos = 0; while(x)&#123; num[pos++] = x % 10; x /= 10; &#125; return dfs(pos - 1, true, false);&#125;int main()&#123; int l, r; while(cin &gt;&gt; l &gt;&gt; r &amp;&amp; (l || r)) &#123; memset(dp, -1, sizeof(dp)); cout &lt;&lt; solve(r) - solve(l - 1) &lt;&lt; '\n'; &#125; return 0;&#125;]]></content>
      <categories>
        <category>数位dp</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2018-2019-ACM-ICPC-Asia-Seoul-Regional-Contest-A(Circuits)]]></title>
    <url>%2F2019%2F03%2F10%2F2018-2019-ACM-ICPC-Asia-Seoul-Regional-Contest-A-Circuits%2F</url>
    <content type="text"><![CDATA[链接：https://codeforces.com/gym/101987/attachments思路：考虑到答案肯定是在不重叠的两个边界上选得，我们考虑离散化排序，并且差分维护每个边界被多少个矩形覆盖，然后枚举所有的右边界，然后找一个前面的最大值维护答案，然后把该矩形加入线段树中，边扫边维护即可。（又发现线段树板子出锅了。。。）代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 2e5 + 5;int sum[maxn &lt;&lt; 2], maxv[maxn &lt;&lt; 2], tag[maxn &lt;&lt; 2];typedef pair&lt;int, int&gt; P;P a[maxn];int b[maxn * 2];int n;int s[maxn];void pushup(int o)&#123; sum[o] = sum[o &lt;&lt; 1] + sum[o &lt;&lt; 1 | 1]; maxv[o] = max(maxv[o &lt;&lt; 1], maxv[o &lt;&lt; 1 | 1]);&#125;void pushdown(int o, int m)&#123; if(tag[o])&#123; tag[o &lt;&lt; 1] += tag[o]; tag[o &lt;&lt; 1 | 1] += tag[o]; sum[o &lt;&lt; 1] += tag[o] * (m - (m &gt;&gt; 1)); sum[o &lt;&lt; 1 | 1] += tag[o] * (m &gt;&gt; 1); maxv[o &lt;&lt; 1] += tag[o]; maxv[o &lt;&lt; 1 | 1] += tag[o]; tag[o] = 0; &#125;&#125;void update(int o, int tl, int tr, int l, int r, int v)&#123; if(tr &lt; l || r &lt; tl)return; if(l &lt;= tl &amp;&amp; tr &lt;= r)&#123; tag[o] += v; sum[o] += (tr - tl + 1) * v; maxv[o] += v; return ; &#125; pushdown(o, tr - tl + 1); int mid = tl + tr &gt;&gt; 1; update(o &lt;&lt; 1, tl, mid, l, r, v); update(o &lt;&lt; 1 | 1, mid + 1, tr, l, r, v); pushup(o);&#125;int query(int o,int tl,int tr,int l,int r) &#123; if (tr &lt; l || r &lt; tl)return 0; if (l &lt;= tl &amp;&amp; tr &lt;= r)return maxv[o]; pushdown(o, tr - tl + 1); int mid = (tl + tr) &gt;&gt; 1; int ret = query(o &lt;&lt; 1, tl, mid, l, r); ret = max(ret, query(o &lt;&lt; 1 | 1, mid + 1, tr, l, r)); return ret;&#125;int main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); cin &gt;&gt; n; int len = 0; for(int i = 1; i &lt;= n; i++)&#123; int c, d, e, f; cin &gt;&gt; c &gt;&gt; d &gt;&gt; e &gt;&gt; f; a[i].first = d; a[i].second = f; b[++len] = f; b[++len] = d; &#125; sort(a + 1, a + n + 1); sort(b + 1, b + len + 1); len = unique(b + 1, b + len + 1) - b; for(int i = 1; i &lt;= n; i++)&#123; int x = lower_bound(b + 1, b + len + 1, a[i].second) - b; s[x]++; x = lower_bound(b + 1, b + len + 1, a[i].first) - b; s[x + 1]--; &#125; for(int i = 1; i &lt;= len; i++)&#123; s[i] += s[i - 1]; &#125; int res = 0; int j = 1; for(int i = 1; i &lt;= len; i++)&#123; res = max(res, s[i] + query(1, 1, len, 1, i - 1)); for(; j &lt;= n; j++)&#123; if(a[j].first &gt; b[i])break; int l = lower_bound(b + 1, b + len + 1, a[j].second) - b; int r = lower_bound(b + 1, b + len + 1, a[j].first) - b; update(1, 1, len, l, r, 1); &#125; &#125; cout &lt;&lt; res &lt;&lt; '\n'; return 0;&#125;]]></content>
      <categories>
        <category>线段树</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2018-2019-ACM-ICPC-Asia-Seoul-Regional-Contest-K(TV-Show-Game)]]></title>
    <url>%2F2019%2F03%2F10%2F2018-2019-ACM-ICPC-Asia-Seoul-Regional-Contest-K-TV-Show-Game%2F</url>
    <content type="text"><![CDATA[链接：https://codeforces.com/gym/101987/attachments思路：每个人猜三个，至少要对两个，求给出一种构造方案。这是很典型的一个2-SAT问题，对于三个中的任意两个，都至少要对一个，然后跑一遍2-SAT就行了，最后输出一种方案。代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 20003;int n, m;vector&lt;int&gt; G[maxn];bool mark[maxn * 2];int S[maxn * 2];int c;int idx(char c)&#123; return c == 'R';&#125;bool dfs(int x) &#123; if (mark[x ^ 1])return false; if (mark[x])return true; mark[x] = true; S[c++] = x; for (int i = 0; i &lt; G[x].size(); i++) if (!dfs(G[x][i]))return false; return true;&#125;void init() &#123; for (int i = 0; i &lt; n * 2; i++)G[i].clear(); memset(mark, 0, sizeof(mark)); //mark[0]= 1; 注意需不需要初始化&#125;// x的xval或者y的yval有一个成立void addedge(int x,int xval,int y,int yval) &#123; x = x * 2 + xval; y = y * 2 + yval; G[x ^ 1].push_back(y); G[y ^ 1].push_back(x);&#125;//临时加了马上减去的时候才能使用，一次性加多条不能用该函数void deledge(int x,int xval,int y,int yval) &#123; x = x * 2 + xval; y = y * 2 + yval; G[x ^ 1].pop_back(); G[y ^ 1].pop_back();&#125;bool solve() &#123; for (int i = 0; i &lt; n * 2; i += 2) &#123; if (!mark[i] &amp;&amp; !mark[i + 1]) &#123; c = 0; if (!dfs(i)) &#123; while (c &gt; 0)mark[S[--c]] = false; if (!dfs(i + 1))return false; &#125; &#125; &#125; return true;&#125;int main()&#123; scanf("%d %d", &amp;n, &amp;m); for(int i = 1; i &lt;= m; i++)&#123; int x[3], y[3]; char s[3]; for(int j = 0; j &lt; 3; j++)&#123; scanf("%d %s", &amp;x[j], s); y[j] = idx(s[0]); &#125; for(int i = 0; i &lt; 3; i++)&#123; for(int j = i + 1; j &lt; 3; j++)&#123; addedge(x[i], y[i], x[j], y[j]); &#125; &#125; &#125; if(!solve())puts("-1"); else&#123; for(int i = 2; i &lt;= 2 * n; i += 2)&#123; if(mark[i])putchar('B'); else putchar('R'); &#125; puts(""); &#125; return 0;&#125;]]></content>
      <categories>
        <category>2-SAT</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2018-2019-ACM-ICPC-Asia-Seoul-Regional-Contest-B(Cosmetic Survey)]]></title>
    <url>%2F2019%2F03%2F10%2F2018-2019-ACM-ICPC-Asia-Seoul-Regional-Contest-B-Cosmetic-Survey%2F</url>
    <content type="text"><![CDATA[链接：https://codeforces.com/gym/101987/attachments思路：题目对于所有选x人数大于选y的，连一条边权为选x人数的边，然后对于某个点到其他所有点的所有路径上的边权最小值都大于其他点到该点所有路径上边权的最小值，就输出这个点。对于这个题，我们先处理所有点之间的边的关系，然后我们比较两个点，把大的那一边保留，小的设为0，如果相等则都设为0，然后跑一边类似floyd的算法即可，把加法换成取min，这样就可以求出所有路径上某条边的最小值，最后check一下每个点即可。代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;bits/stdc++.h&gt;using namespace std;const int inf = 1e9;const int maxn = 501;int dp[maxn][maxn];int w[maxn][maxn];int n, m;int main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); cin &gt;&gt; m &gt;&gt; n; for(int i = 1; i &lt;= n; i++)&#123; for(int j = 1; j &lt;= m; j++)&#123; cin &gt;&gt; w[i][j]; if(!w[i][j])w[i][j] = inf; &#125; &#125; for(int i = 1; i &lt;= m; i++)&#123; for(int j = i + 1; j &lt;= m; j++)&#123; for(int k = 1; k &lt;= n; k++)&#123; if(w[k][i] &lt; w[k][j])dp[i][j]++; else if(w[k][i] &gt; w[k][j]) dp[j][i]++; &#125; &#125; &#125; for(int i = 1; i &lt;= m; i++)&#123; for(int j = 1; j &lt;= m; j++)&#123; if(dp[i][j] == dp[j][i]) dp[i][j] = dp[j][i] = 0; else if(dp[i][j] &lt; dp[j][i])dp[i][j] = 0; else dp[j][i] = 0; &#125; &#125; for(int i = 1; i &lt;= m; i++)dp[i][i] = inf; for(int k = 1; k &lt;= m; k++)&#123; for(int i = 1; i &lt;= m; i++)&#123; for(int j = 1; j &lt;= m; j++)&#123; dp[i][j] = max(dp[i][j], min(dp[i][k], dp[k][j])); &#125; &#125; &#125; for(int i = 1; i &lt;= m; i++)&#123; bool flag = true; for(int j = 1; j &lt;= m; j++)&#123; if(i == j)continue; if(dp[i][j] &lt; dp[j][i])&#123; flag = false; break; &#125; &#125; if(flag) cout &lt;&lt; i &lt;&lt; ' '; &#125; cout &lt;&lt; '\n'; return 0;&#125;]]></content>
      <categories>
        <category>基础dp</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[POJ-1584(A-Round-Peg-in-a-Ground-Hole)]]></title>
    <url>%2F2019%2F03%2F04%2FPOJ-1584-A-Round-Peg-in-a-Ground-Hole%2F</url>
    <content type="text"><![CDATA[链接：https://vjudge.net/problem/POJ-1584思路：判断是否为凸包，如果不为则判断圆是否在多边形内。对于是否为凸包，我们只用看是否全部在往顺时针或者逆时针转即可，先找到第一个叉积不为0的地方作为基准，然后看其他所有的是否跟它同号或者等于0，否则不为凸包。对于第二个我们先判断点是否在多边形内，如果在看它到每一个线段的距离是否大于等于它的半径，如果都满足说明在里面，反之不在。代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140#include&lt;cstdio&gt;#include &lt;cmath&gt;using namespace std;typedef double db;const db eps = 1e-10;const db pi = acos(-1.0);int dcmp(db x) &#123; return x&lt;-eps?-1:x&gt;eps;&#125;db myacos(db x)&#123; if(x&lt;-1) x = -1; if(x&gt;1) x = 1; return acos(x);&#125;db myasin(db x)&#123; if(x&lt;-1) x = -1; if(x&gt;1) x = 1; return asin(x);&#125;db mysqrt(db x)&#123; return x&lt;0?0:sqrt(x);&#125;typedef struct P &#123; db x, y; P(db x = 0, db y = 0) : x(x), y(y) &#123;&#125; P operator+(P r)&#123;return P(x+r.x,y+r.y);&#125; P operator-(P r)&#123;return P(x-r.x,y-r.y);&#125; P operator*(db r)&#123;return P(x*r,y*r);&#125; P operator/(db r)&#123;return P(x/r,y/r);&#125; bool operator&lt;(const P &amp;r)const&#123;return x&lt;r.x||(x==r.x&amp;&amp;y&lt;r.y);&#125; bool operator==(const P &amp;r)const&#123;return dcmp(x-r.x)==0&amp;&amp;dcmp(y-r.y)==0;&#125; void read()&#123; scanf("%lf %lf", &amp;x, &amp;y); &#125;&#125;V;int n;P a[200];P t;db r;db v;//向量a的极角db Angle(const V&amp; v) &#123; return atan2(v.y, v.x);&#125;//向量点积db Dot(V A, V B) &#123; return A.x*B.x + A.y*B.y; &#125;//向量长度db Length(V A) &#123; return mysqrt(Dot(A, A)); &#125;//向量夹角db Angle(V A, V B) &#123; return myacos(Dot(A, B) / Length(A) / Length(B)); &#125;//向量叉积db Cross(V A, V B) &#123; return A.x*B.y - A.y*B.x; &#125;db DistanceToSegmentS(P p, P A, P B) &#123; if(A == B) return Length(p-A); V v1 = B-A, v2 = p-A, v3 = p-B; if(dcmp(Dot(v1, v2)) &lt; 0) return Length(v2); else if(dcmp(Dot(v1, v3)) &gt; 0) return Length(v3); else return fabs(Cross(v1, v2)) / Length(v1);&#125;bool OnSegment(P p, P a1, P a2) &#123; return dcmp(Cross(a1-p, a2-p) == 0 &amp;&amp; dcmp((Dot(a1-p, a2-p)) &lt; 0));&#125;bool isPointInPolygon(P p) &#123; int wn = 0; for (int i = 0; i &lt; n; i++) &#123; if (OnSegment(p, a[i], a[(i + 1) % n])) return true; //在边界上 int k = dcmp(Cross(a[(i + 1) % n] - a[i], p - a[i])); int d1 = dcmp(a[i].y - p.y); int d2 = dcmp(a[(i + 1) % n].y - p.y); if (k &gt; 0 &amp;&amp; d1 &lt;= 0 &amp;&amp; d2 &gt; 0) wn++; if (k &lt; 0 &amp;&amp; d2 &lt;= 0 &amp;&amp; d1 &gt; 0) wn--; &#125; if (wn != 0) return true; //内部 return false; //外部&#125;bool check()&#123; for(int i = 1; i &lt;= n; i++)&#123; V t1 = a[i - 1] - a[i]; V t2 = a[i + 1] - a[i]; db tmp = Cross(t1, t2); if(dcmp(tmp) * dcmp(v) &lt; 0)return false; &#125; return true;&#125;bool judge()&#123; if(!isPointInPolygon(t))return false; for(int i = 1; i &lt;= n; i++)&#123; db d = DistanceToSegmentS(t, a[i - 1], a[i]); if(dcmp(d - r) &gt;= 0)continue; return false; &#125; return true;&#125;int main()&#123; //freopen("in.txt", "r", stdin); while(~scanf("%d", &amp;n) &amp;&amp; n &gt;= 3)&#123; scanf("%lf", &amp;r); t.read(); for(int i = 0; i &lt; n; i++)a[i].read(); a[n] = a[0]; a[n + 1] = a[1]; for(int i = 1; i &lt;= n; i++)&#123; V t1 = a[i - 1] - a[i]; V t2 = a[i + 1] - a[i]; db tmp = Cross(t1, t2); if(dcmp(tmp))&#123; v = tmp; break; &#125; &#125; if(!check())&#123; puts("HOLE IS ILL-FORMED"); continue; &#125; if(!judge())&#123; puts("PEG WILL NOT FIT"); &#125; else puts("PEG WILL FIT"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>计算几何</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[POJ-3449(Geometric-Shapes)]]></title>
    <url>%2F2019%2F03%2F04%2FPOJ-3449-Geometric-Shapes%2F</url>
    <content type="text"><![CDATA[链接：https://vjudge.net/problem/POJ-3449思路：真是对作文题绝望，但是1A的感觉好爽，这个题太多细节了，包括输入括号前的空格要考虑，输入读入方法，以及正方形长方形剩余点的计算，其实真正的判断反而不难，枚举所有边看是否不规范相交就行了，输出还要排序输出，反正就是翻译题，不过确实很锻炼码量啊。。。。。代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198#include&lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;queue&gt;#include &lt;algorithm&gt;using namespace std;typedef double db;const db eps = 1e-10;const db pi = acos(-1.0);int dcmp(db x) &#123; return x&lt;-eps?-1:x&gt;eps;&#125;db myacos(db x)&#123; if(x&lt;-1) x = -1; if(x&gt;1) x = 1; return acos(x);&#125;db myasin(db x)&#123; if(x&lt;-1) x = -1; if(x&gt;1) x = 1; return asin(x);&#125;db mysqrt(db x)&#123; return x&lt;0?0:sqrt(x);&#125;typedef struct P &#123; db x, y; P(db x = 0, db y = 0) : x(x), y(y) &#123;&#125; P operator+(P r)&#123;return P(x+r.x,y+r.y);&#125; P operator-(P r)&#123;return P(x-r.x,y-r.y);&#125; P operator*(db r)&#123;return P(x*r,y*r);&#125; P operator/(db r)&#123;return P(x/r,y/r);&#125; bool operator&lt;(const P &amp;r)const&#123;return x&lt;r.x||(x==r.x&amp;&amp;y&lt;r.y);&#125; bool operator==(const P &amp;r)const&#123;return dcmp(x-r.x)==0&amp;&amp;dcmp(y-r.y)==0;&#125; //注意读入 void read()&#123; scanf(" (%lf,%lf)", &amp;x, &amp;y); &#125;&#125;V;//向量a的极角db Angle(const V&amp; v) &#123; return atan2(v.y, v.x);&#125;//向量点积db Dot(V A, V B) &#123; return A.x*B.x + A.y*B.y; &#125;//向量长度db Length(V A) &#123; return mysqrt(Dot(A, A)); &#125;//向量夹角db Angle(V A, V B) &#123; return myacos(Dot(A, B) / Length(A) / Length(B)); &#125;//向量叉积db Cross(V A, V B) &#123; return A.x*B.y - A.y*B.x; &#125;char s[20];int n;P GetLineIntersection(P p, V v, P q, V w) &#123; V u = p - q; db t = Cross(w, u)/Cross(v, w); return p+v*t;&#125;//判断点是否在点段上，不包含端点bool OnSegment(P p, P a1, P a2) &#123; return dcmp(Cross(a1-p, a2-p) == 0 &amp;&amp; dcmp((Dot(a1-p, a2-p)) &lt; 0));&#125;//向量逆时针旋转rad度(弧度)V Rotate(V A, db rad) &#123; return V(A.x*cos(rad)-A.y*sin(rad), A.x*sin(rad)+A.y*cos(rad));&#125;struct node&#123; P a[25]; int n; char ch;&#125;r[200];bool SegmentProperIntersection(P a1, P a2, P b1, P b2) &#123; db c1 = Cross(a2-a1, b1-a1), c2 = Cross(a2-a1, b2-a1); db c3 = Cross(b2-b1, a1-b1), c4 = Cross(b2-b1, a2-b1); return dcmp(c1)*dcmp(c2) &lt; 0 &amp;&amp; dcmp(c3)*dcmp(c4) &lt; 0;&#125;//不规范相交bool on(P a1, P a2, P b1, P b2)&#123; if(OnSegment(a1, b1, b2))return true; if(OnSegment(a2, b1, b2))return true; if(OnSegment(b1, a1, a2))return true; if(OnSegment(b2, a1, a2))return true; if(a1 == b1 || a1 == b2 || a2 == b1 || a2 == b2)return true; return SegmentProperIntersection(a1, a2, b1, b2);&#125;bool check(int x, int y)&#123; for(int i = 1; i &lt;= r[x].n; i++)&#123; for(int j = 1; j &lt;= r[y].n; j++)&#123; if(on(r[x].a[i], r[x].a[i - 1], r[y].a[j], r[y].a[j - 1]))&#123; // if(x == 0 &amp;&amp; y == 2)printf("%.2f %.2f %.2f %.2f %.2f %.2f %.2f %.2f\n", r[x].a[i].x, r[x].a[i].y,r[x].a[i - 1].x, r[x].a[i - 1].y, r[y].a[j].x, r[y].a[j].y, r[y].a[j - 1].x, r[y].a[j - 1].y); return true; &#125; &#125; &#125; return false;&#125;bool cmp(node &amp;x, node &amp;y)&#123; return x.ch &lt; y.ch;&#125;bool cmp1(int x, int y)&#123; return r[x].ch &lt; r[y].ch;&#125;int main()&#123; //freopen("in.txt", "r", stdin); //freopen("out.txt", "w", stdout); while(1)&#123; n = 0; while(scanf("%s", s) &amp;&amp; s[0] != '-' &amp;&amp; s[0] != '.')&#123; r[n].ch = s[0]; scanf("%s", s); if(s[0] == 's')&#123; r[n].a[0].read(); r[n].a[2].read(); V v1 = r[n].a[2] - r[n].a[0]; V v2 = Rotate(v1, pi / 2); V v3 = Rotate(v1, -pi / 2); P mid = (r[n].a[0] + r[n].a[2]) / 2; r[n].a[1] = mid + (v2) / 2; r[n].a[3] = mid + (v3) / 2; r[n].n = 4; n++; &#125; else if(s[0] == 't')&#123; r[n].n = 3; for(int i = 0; i &lt; 3; i++)r[n].a[i].read(); n++; &#125; else if(s[0] == 'l')&#123; r[n].n = 2; for(int i = 0; i &lt; 2; i++)&#123; r[n].a[i].read(); &#125; n++; &#125; else if(s[0] == 'p')&#123; scanf("%d", &amp;r[n].n); for(int i = 0; i &lt; r[n].n; i++)r[n].a[i].read(); n++; &#125; else&#123; r[n].n = 4; for(int i = 0; i &lt; 3; i++)r[n].a[i].read(); r[n].a[3] = r[n].a[2] + r[n].a[0] - r[n].a[1]; n++; &#125; &#125; for(int i = 0; i &lt; n; i++)r[i].a[r[i].n] = r[i].a[0]; sort(r, r + n, cmp); for(int i = 0; i &lt; n; i++)&#123; vector&lt;int&gt; res; for(int j = 0; j &lt; n; j++)&#123; if(i == j)continue; if(check(i, j))res.push_back(j); &#125; if(!res.size())&#123; printf("%c has no intersections\n", r[i].ch); continue; &#125; sort(res.begin(), res.end(), cmp1); printf("%c intersects with", r[i].ch); if(res.size() == 1)printf(" %c\n", r[res[0]].ch); else if(res.size() == 2) printf(" %c and %c\n", r[res[0]].ch, r[res[1]].ch); else&#123; for(int j = 0; j &lt; res.size() - 1; j++)&#123; printf(" %c,", r[res[j]].ch); &#125; printf(" and %c\n", r[res[res.size() - 1]].ch); &#125; &#125; puts(""); if(s[0] == '.')break; &#125; return 0;&#125;]]></content>
      <categories>
        <category>计算几何</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[WF-2017-A(Airport-Construction)]]></title>
    <url>%2F2019%2F03%2F04%2FWF-2017-A-Airport-Construction%2F</url>
    <content type="text"><![CDATA[链接：https://vjudge.net/problem/Kattis-airport思路：想了个O(n^3)的，但是特殊情况有点多就没敢写，还是写的O(n^4)的，需要稍微优化一下，首先枚举两个端点，然后和其他所有线段求交，然后将交点拿出来排序，看两两交点的中点在多边形内还是在多边形外，然后贪心找这当中都在多边形内最长的即可。代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104#include&lt;bits/stdc++.h&gt;using namespace std;typedef double db;const db eps = 1e-8;int n;inline int dcmp(db x) &#123; return x &lt; -eps ? -1 : x &gt; eps;&#125;typedef struct P &#123; db x, y; P(db x = 0, db y = 0) : x(x), y(y) &#123;&#125; P operator+(P r) &#123; return P(x + r.x, y + r.y); &#125; P operator-(P r) &#123; return P(x - r.x, y - r.y); &#125; P operator*(db r) &#123; return P(x * r, y * r); &#125; P operator/(db r) &#123; return P(x / r, y / r); &#125; bool operator&lt;(const P &amp;r) const &#123; return dcmp(x - r.x) &lt; 0 || (dcmp(x - r.x) == 0 &amp;&amp; dcmp(y - r.y) &lt; 0); &#125; bool operator==(const P &amp;r) const &#123; return dcmp(x - r.x) == 0 &amp;&amp; dcmp(y - r.y) == 0; &#125;&#125;V;//向量点积inline db Dot(V A, V B) &#123; return A.x*B.x + A.y*B.y; &#125;//向量长度inline db Length(V A) &#123; return sqrt(Dot(A, A)); &#125;inline db Cross(V A, V B) &#123; return A.x*B.y - A.y*B.x; &#125;//直线交点,须确保两直线有唯一交点。inline P GetLineIntersection(P p, V v, P q, V w) &#123; V u = p - q; db t = Cross(w, u)/Cross(v, w); return p+v*t;&#125;inline bool OnSegment(P p, P a1, P a2) &#123; return dcmp(Cross(a1-p, a2-p) == 0 &amp;&amp; dcmp((Dot(a1-p, a2-p)) &lt; 0));&#125;P r[300];P t[300];bool isPointInPolygon(P p) &#123; int wn = 0; for (int i = 0; i &lt; n; i++) &#123; if (OnSegment(p, r[i], r[(i + 1) % n])) return true; //在边界上 int k = dcmp(Cross(r[(i + 1) % n] - r[i], p - r[i])); int d1 = dcmp(r[i].y - p.y); int d2 = dcmp(r[(i + 1) % n].y - p.y); if (k &gt; 0 &amp;&amp; d1 &lt;= 0 &amp;&amp; d2 &gt; 0) wn++; if (k &lt; 0 &amp;&amp; d2 &lt;= 0 &amp;&amp; d1 &gt; 0) wn--; &#125; if (wn != 0) return true; //内部 return false; //外部&#125;int main()&#123; //freopen("in.txt", "r", stdin); scanf("%d", &amp;n); for(int i = 0; i &lt; n; i++)&#123; scanf("%lf %lf", &amp;r[i].x, &amp;r[i].y); &#125; r[n] = r[0]; r[n + 1] = r[1]; db ans = 0; for(int i = 0; i &lt; n; i++)&#123; for(int j = i + 1; j &lt; n; j++)&#123; int len = 0; V v1 = r[j] - r[i]; t[len++] = r[j]; t[len++] = r[i]; for(int k = 0; k &lt; n; k++)&#123; V v2 = r[k + 1] - r[k]; if(dcmp(Cross(v1, v2)) == 0)&#123; continue; &#125; P tmp = GetLineIntersection(r[i], v1, r[k], v2); if(tmp &lt; min(r[k], r[k + 1]) || max(r[k], r[k + 1]) &lt; tmp)continue; if(tmp == r[k] &amp;&amp; dcmp(Cross(v1, r[k + 1] - r[k]) * Cross(v1, r[(k - 1 + n) % n] - r[k]) &gt; 0) &gt; 0)continue; if(tmp == r[k + 1] &amp;&amp; dcmp(Cross(v1, r[k + 2] - r[k + 1]) * Cross(v1, r[k] - r[k + 1]) &gt; 0) &gt; 0)continue; t[len++] = tmp; &#125; sort(t, t + len); len = unique(t, t + len) - t; db res = 0; for(int k = 1; k &lt; len; k++)&#123; P tmp = (t[k] + t[k - 1]) / 2; if(isPointInPolygon(tmp)) res += Length(t[k] - t[k - 1]); else&#123; res = 0; if(Length(t[len - 1] - t[k]) &lt;= ans)break; &#125; ans = max(ans, res); &#125; &#125; &#125; printf("%.10f\n", ans); return 0;&#125;]]></content>
      <categories>
        <category>计算几何</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[POJ-1039(Pipe)]]></title>
    <url>%2F2019%2F03%2F03%2FPOJ-1039-Pipe%2F</url>
    <content type="text"><![CDATA[链接：https://vjudge.net/problem/POJ-1039思路：写了两个多小时啊，一开始读错题了，思路大概是对的但是细节没考虑好，写完觉得巨麻烦但一看网上好像我的还算短的。说下思路，最远的一定是要经过上面一个点和下面一个点，那么我们考虑枚举两个点，剩下的要判断的就是能否从左边射过来以及右边遇到的第一个阻碍点，有可能会在端点相交，这时就要分两种情况，一种阻碍一种不阻碍，用叉积就可以判断了，最后如果能贯通整个通道，那么一定是左右都没有交点的，否则如果左边有交点说明射不过来不合法，右边有交点就更新最远距离即可。代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include&lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;typedef double db;const db eps = 1e-10;int dcmp(db x) &#123; return x&lt;-eps?-1:x&gt;eps;&#125;typedef struct P &#123; db x, y; P(db x = 0, db y = 0) : x(x), y(y) &#123;&#125; P operator+(P r)&#123;return P(x+r.x,y+r.y);&#125; P operator-(P r)&#123;return P(x-r.x,y-r.y);&#125; P operator*(db r)&#123;return P(x*r,y*r);&#125; P operator/(db r)&#123;return P(x/r,y/r);&#125; bool operator&lt;(P r)&#123;return x&lt;r.x||(x==r.x&amp;&amp;y&lt;r.y);&#125; bool operator==(P r)&#123;return dcmp(x-r.x)==0&amp;&amp;dcmp(y-r.y)==0;&#125;&#125;V;db Cross(V A, V B) &#123; return A.x*B.y - A.y*B.x; &#125;P GetLineIntersection(P p, V v, P q, V w) &#123; V u = p - q; db t = Cross(w, u)/Cross(v, w); return p+v*t;&#125;P r1[50], r2[50];int n;int main()&#123; while(~scanf("%d", &amp;n) &amp;&amp; n)&#123; for(int i = 0; i &lt; n; i++)&#123; scanf("%lf %lf", &amp;r1[i].x, &amp;r1[i].y); r2[i] = r1[i]; r2[i].y -= 1; &#125; db ans = -1e18; for(int i = 0; i &lt; n; i++)&#123; for(int j = 0; j &lt; n; j++)&#123; if(i == j)continue; db t = 1e18; V v1 = r2[j] - r1[i]; int flag = 0; for(int k = 1; k &lt; n; k++)&#123; V v2 = r1[k] - r1[k - 1]; if(dcmp(Cross(v1, v2)) == 0)continue; P tmp = GetLineIntersection(r1[i], v1, r1[k - 1], v2); //交点不在线段上 if(dcmp(tmp.x - r1[k - 1].x) &lt; 0 || dcmp(tmp.x - r1[k].x) &gt; 0)continue; //交点在前一个端点且不为阻碍点 if(dcmp(tmp.x - r1[k - 1].x) == 0 &amp;&amp; k &gt; 1 &amp;&amp; dcmp(Cross(v1, r1[k - 2] - r1[k - 1]) * Cross(v1, r1[k] - r1[k - 1])) &gt;= 0)continue; //头特判 if(dcmp(tmp.x - r1[k - 1].x) == 0 &amp;&amp; k == 1)continue; //交点在后一个端点且不为阻碍点 if(dcmp(tmp.x - r1[k].x) == 0 &amp;&amp; k &lt; n - 1 &amp;&amp; dcmp(Cross(v1, r1[k + 1] - r1[k]) * Cross(v1, r1[k - 1] - r1[k])) &gt;= 0)continue; //尾特判 if(dcmp(tmp.x - r1[k].x) == 0 &amp;&amp; k == n - 1)continue; //交点不在线段上 if(dcmp(tmp.y - min(r1[k - 1].y, r1[k].y)) &lt; 0 || dcmp(tmp.y - max(r1[k - 1].y, r1[k].y)) &gt; 0)continue; //交点在枚举两个点之间，说明不合法 if(tmp.x &lt; max(r1[i].x, r2[j].x))&#123; flag = 2; break; &#125; //更新最远点 else t = min(t, tmp.x), flag = 1; &#125; if(flag == 2)continue; for(int k = 1; k &lt; n; k++)&#123; V v2 = r2[k] - r2[k - 1]; if(dcmp(Cross(v1, v2)) == 0)continue; P tmp = GetLineIntersection(r1[i], v1, r2[k - 1], v2); if(dcmp(tmp.x - r2[k - 1].x) &lt; 0 || dcmp(tmp.x - r2[k].x) &gt; 0)continue; if(dcmp(tmp.x - r2[k - 1].x) == 0 &amp;&amp; k &gt; 1 &amp;&amp; dcmp(Cross(v1, r2[k - 2] - r2[k - 1]) * Cross(v1, r2[k] - r2[k - 1])) &gt;= 0)continue; if(dcmp(tmp.x - r2[k - 1].x) == 0 &amp;&amp; k == 1)continue; if(dcmp(tmp.x - r2[k].x) == 0 &amp;&amp; k &lt; n - 1 &amp;&amp; dcmp(Cross(v1, r2[k + 1] - r2[k]) * Cross(v1, r2[k - 1] - r2[k])) &gt;= 0)continue; if(dcmp(tmp.x - r2[k].x) == 0 &amp;&amp; k == n - 1)continue; if(dcmp(tmp.y - min(r2[k - 1].y, r2[k].y)) &lt; 0 || dcmp(tmp.y - max(r2[k - 1].y, r2[k].y)) &gt; 0)continue; if(tmp.x &lt; max(r1[i].x, r2[j].x))&#123; flag = 2; break; &#125; else t = min(t, tmp.x), flag = 1; &#125; if(flag == 0) ans = 1e18; else if(flag == 2)continue; else ans = max(ans, t); &#125; &#125; if(ans &gt; 1e12)puts("Through all the pipe."); else printf("%.2f\n", ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>计算几何</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[ZOJ-3494(BCD-Code)]]></title>
    <url>%2F2019%2F03%2F03%2FZOJ-3494-BCD-Code%2F</url>
    <content type="text"><![CDATA[链接：https://vjudge.net/problem/ZOJ-3494思路：AC自动机 + 数位dp，真是服了模数写成1e9 + 7了wa了一个多小时，建立自动机，然后我们考虑这个题在二进制下不太好因为处理不了前导0，我们就在十进制下数位dp，主要是考虑是否有前导0以及是否严格小于，然后0的填法单独拿出来讨论即可。注意对于l - r我们都是考虑0 - x最后相减，这里需要用一下高精度减法，可以有前导0存在不会影响结果。代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const ll mod = 1e9 + 9;const int maxnode = 2010;const int sigma_size = 2;int n;char tmp[220];int len;int ch[maxnode][sigma_size];int val[maxnode];int f[maxnode];int last[maxnode];int bcd[maxnode][10];int bit[maxnode];int sz;void add(ll &amp;x, ll y)&#123; x += y; if(x &gt;= mod) x -= mod;&#125;void init() &#123; sz = 1; memset(ch[0], 0, sizeof(ch[0]));&#125;int idx(char c) &#123; return c - '0';&#125;void insert(char *s,int v = 1) &#123; int n = strlen(s); int u = 0; for (int i = 0; i &lt; n; i++) &#123; int c = idx(s[i]); if (!ch[u][c]) &#123; ch[u][c] = sz; memset(ch[sz], 0, sizeof(ch[sz])); val[sz++] = 0; &#125; u = ch[u][c]; &#125; val[u] = v;&#125;void getfail() &#123; queue&lt;int&gt; q; f[0] = 0; for (int i = 0; i &lt; sigma_size; i++) &#123; int u = ch[0][i]; if (u) &#123; f[u] = last[u] = 0; q.push(u); &#125; &#125; while (!q.empty()) &#123; int r = q.front(); q.pop(); val[r] |= val[f[r]]; //AC自动机 + dp时会用 for (int c = 0; c &lt; sigma_size; c++) &#123; int u = ch[r][c]; if (!u) &#123; ch[r][c] = ch[f[r]][c]; continue; &#125; q.push(u); int v = f[r]; while (v &amp;&amp; !ch[v][c])v = f[v]; f[u] = ch[v][c]; last[u] = val[f[u]] ? f[u] : last[f[u]]; &#125; &#125;&#125;int T;ll dp[210][maxnode];int change(int pre, int num) &#123; if (val[pre]) return -1; int cur = pre; for (int i = 3; i &gt;= 0; i--) &#123; if (val[ch[cur][(num &gt;&gt; i) &amp; 1]]) return -1; cur = ch[cur][(num &gt;&gt; i) &amp; 1]; &#125; return cur;&#125;void pre() &#123; for (int i = 0; i &lt; sz; i++) for (int j = 0; j &lt; 10; j++) &#123; bcd[i][j] = change(i, j); &#125;&#125;ll dfs(int x, int u, bool flag, bool z)&#123; if(x == -1) return 1; if(!flag &amp;&amp; dp[x][u] != -1)return dp[x][u]; ll ans = 0; if(z)&#123; add(ans, dfs(x - 1, u, flag &amp;&amp; bit[x] == 0, true)); &#125; else&#123; if(bcd[u][0] != -1) add(ans, dfs(x - 1, bcd[u][0], flag &amp;&amp; bit[x] == 0, false)); &#125; int e = (flag ? bit[x] : 9); for(int i = 1; i &lt;= e; i++)&#123; if(bcd[u][i] != -1)add(ans, dfs(x - 1, bcd[u][i], flag &amp;&amp; i == e, false)); &#125; if(!flag &amp;&amp; !z)dp[x][u] = ans; return ans;&#125;ll work()&#123; for(int i = 0; i &lt; len; i++)bit[i] = tmp[len - i - 1] - '0'; return dfs(len - 1, 0, 1, 1);&#125;int main()&#123; scanf("%d", &amp;T); while(T--)&#123; scanf("%d", &amp;n); init(); for(int i = 1; i &lt;= n; i++)&#123; scanf("%s", tmp); insert(tmp); &#125; getfail(); pre(); memset(dp, -1, sizeof(dp)); scanf("%s", tmp); len = strlen(tmp); for(int i = len - 1; i &gt;= 0; i--)&#123; if(tmp[i] &gt; '0')&#123; tmp[i]--; break; &#125; else tmp[i] = '9'; &#125; ll ans = 0; ans -= work(); scanf("%s", tmp); len = strlen(tmp); ans += work(); ans = (ans % mod + mod) % mod; printf("%lld\n", ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>AC自动机</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[bzoj-1010(玩具装箱toy)]]></title>
    <url>%2F2019%2F03%2F03%2Fbzoj-1010-%E7%8E%A9%E5%85%B7%E8%A3%85%E7%AE%B1toy%2F</url>
    <content type="text"><![CDATA[链接：https://www.lydsy.com/JudgeOnline/problem.php?id=1010思路：与入门题差不多，把式子展开，注意展开前把所有i的合并，j的合并再展开会省事很多，因为可能会爆掉long long，可以用int128比较也可以转换成double,当然bzoj好像不支持int128所以只能用double了，注意转移的时候需要-1，因为是从j + 1开始算的，注意细节即可。至于不单调的斜率优化dp之后再学吧。。。先入个门。代码：1234567891011121314151617181920212223242526272829303132333435#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef double db;const int maxn = 5e4 + 5;ll dp[maxn];int head, tail;int Q[maxn];ll s[maxn];int n, l;db slope(int x, int y)&#123; return (dp[y] - dp[x] + 1.0 * (s[y] + y + l) * (s[y] + y + l) - 1.0 * (s[x] + x + l) * (s[x] + x + l)) / (2.0 * (s[y] + y - s[x] - x));&#125;int main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); cin &gt;&gt; n &gt;&gt; l; for(int i = 1; i &lt;= n; i++)&#123; int a; cin &gt;&gt; a; s[i] = s[i - 1] + a; &#125; head = 1, tail = 1; for(int i = 1; i &lt;= n; i++)&#123; while(head &lt; tail &amp;&amp; slope(Q[head], Q[head + 1]) &lt;= (i + s[i]))head++; int now = Q[head]; dp[i] = dp[now] + (i - now + s[i] - s[now] - l - 1) * (i - now + s[i] - s[now] - l - 1); while(head &lt; tail &amp;&amp; 1.0 * slope(Q[tail - 1], Q[tail]) &gt; slope(Q[tail], i))tail--; Q[++tail] = i; &#125; cout &lt;&lt; dp[n] &lt;&lt; '\n'; return 0;&#125;]]></content>
      <categories>
        <category>斜率优化dp</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[HDU-3507(Print-Article)]]></title>
    <url>%2F2019%2F03%2F03%2FHDU-3507-Print-Article%2F</url>
    <content type="text"><![CDATA[链接：http://acm.hdu.edu.cn/showproblem.php?pid=3507思路：假期让队友学学斜率优化，结果队友已经学得差不多博客都出了我还没开始，然后只有蹭一蹭博客学了，事实上斜率优化还挺简单的，总结一下求最小值维护下凸包，求最大值维护上凸包，因为我们可以证明出斜率随着i增加时单调增加的，然后根据式子可以看出上凸包的点一定不满足，并且最优解也一定是单调向右走的，所以我们维护一个单调队列即可。注意有几个易错的点，第一个是单调队列存的是最优解的下标，弱智了好一会儿，第二个是单调队列初始的时候和平时不太一样，head = tail = 1，因为一开始0也是一个转移状态，有些状态从0转移过来是更优的，如果按照原来的写法head = 1, tail = 0, 就把0的这种转移给忽略掉了，就会出现错误。代码：123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 5e5 + 5;int n, m;typedef long long ll;int head, tail;ll Q[maxn];ll s[maxn];int a[maxn];ll dp[maxn];ll up(int x, int y)&#123; return dp[y] - dp[x] + s[y] * s[y] - s[x] * s[x];&#125;ll down(int x, int y)&#123; return s[y] - s[x];&#125;int main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); while(cin &gt;&gt; n &gt;&gt; m) &#123; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; a[i]; s[i] = s[i - 1] + a[i]; dp[i] = 0; &#125; head = 1, tail = 1; for(int i = 1; i &lt;= n; i++)&#123; while(head &lt; tail &amp;&amp; up(Q[head], Q[head + 1]) &lt;= 2 * s[i] * down(Q[head], Q[head + 1]))head++; int now = Q[head]; dp[i] = dp[now] + (s[i] - s[now]) * (s[i] - s[now]) + m; while(head &lt; tail &amp;&amp; up(Q[tail - 1], Q[tail]) * down(Q[tail], i) &gt;= up(Q[tail], i) * down(Q[tail - 1], Q[tail]))tail--; Q[++tail] = i; &#125; cout &lt;&lt; dp[n] &lt;&lt; '\n'; &#125; return 0;&#125;]]></content>
      <categories>
        <category>斜率优化dp</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[POJ-2826(An-Easy-Problem)]]></title>
    <url>%2F2019%2F02%2F28%2FPOJ-2826-An-Easy-Problem%2F</url>
    <content type="text"><![CDATA[链接：https://vjudge.net/problem/POJ-2826#author=0思路：一开始做考虑漏了一种情况，就是有一个板子把另一个完全挡住，这样为0，事实上我们可以先把重合的和水平的给判掉，这样无论如何都为0，剩下的我们判断是不是相交，不相交为0，相交求交点，根据交点求出水平过来的那个交点，然后就需要判断一下是否存在一个把另一个挡住，也就是两个板子的y的较高的那个点要在交点的同一侧并且上面的那一个横坐标与交点的距离差要比下面那一个大，最后注意一下输出的时候加上一个eps，继之前的acos，asin，dcmp后又一个可能出现精度误差的地方，可能会出现-0.00这种情况，所以补一个eps防止。代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;using namespace std;typedef double db;const db eps = 1e-8;int dcmp(db x) &#123; return x&lt;-eps?-1:x&gt;eps;&#125;db myacos(db x)&#123; if(x&lt;-1) x = -1; if(x&gt;1) x = 1; return acos(x);&#125;db myasin(db x)&#123; if(x&lt;-1) x = -1; if(x&gt;1) x = 1; return asin(x);&#125;db mysqrt(db x)&#123; return x&lt;0?0:sqrt(x);&#125;typedef struct P &#123; db x, y; P(db x = 0, db y = 0) : x(x), y(y) &#123;&#125; P operator+(P r)&#123;return P(x+r.x,y+r.y);&#125; P operator-(P r)&#123;return P(x-r.x,y-r.y);&#125; P operator*(db r)&#123;return P(x*r,y*r);&#125; P operator/(db r)&#123;return P(x/r,y/r);&#125; bool operator&lt;(P r)&#123;return x&lt;r.x||(x==r.x&amp;&amp;y&lt;r.y);&#125; bool operator==(P r)&#123;return dcmp(x-r.x)==0&amp;&amp;dcmp(y-r.y)==0;&#125;&#125;V;//向量点积db Dot(V A, V B) &#123; return A.x*B.x + A.y*B.y; &#125;//向量长度db Length(V A) &#123; return mysqrt(Dot(A, A)); &#125;db Cross(V A, V B) &#123; return A.x*B.y - A.y*B.x; &#125;P GetSegmentIntersection(P a1, P a2, P b1, P b2)&#123; V t = b2 - b1; db d1 = fabs(Cross(t, a1 - b1)); db d2 = fabs(Cross(t, a2 - b1)); db c = d1 / (d1 + d2); return a1 + (a2 - a1) * c;&#125;bool SegmentProperIntersection(P a1, P a2, P b1, P b2) &#123; db c1 = Cross(a2-a1, b1-a1), c2 = Cross(a2-a1, b2-a1); db c3 = Cross(b2-b1, a1-b1), c4 = Cross(b2-b1, a2-b1); return dcmp(c1)*dcmp(c2) &lt; 0 &amp;&amp; dcmp(c3)*dcmp(c4) &lt; 0;&#125;//判断点是否在点段上，不包含端点bool OnSegment(P p, P a1, P a2) &#123; return dcmp(Cross(a1-p, a2-p) == 0 &amp;&amp; dcmp((Dot(a1-p, a2-p)) &lt; 0));&#125;bool check(P a1, P a2, P b1, P b2)&#123; if(OnSegment(a1, b1, b2))return true; if(OnSegment(a2, b1, b2))return true; if(OnSegment(b1, a1, a2))return true; if(OnSegment(b2, a1, a2))return true; if(a1 == b1 || a1 == b2 || a2 == b1 || a2 == b2)return true; return SegmentProperIntersection(a1, a2, b1, b2);&#125;P get(P a1, P a2, P b1, P b2)&#123; if(OnSegment(a1, b1, b2))return a1; if(OnSegment(a2, b1, b2))return a2; if(OnSegment(b1, a1, a2))return b1; if(OnSegment(b2, a1, a2))return b2; if(a1 == b1 || a1 == b2)return a1; if(a2 == b1 || a2 == b2) return a2; return GetSegmentIntersection(a1, a2, b1, b2);&#125;int T;P r[4];int Max(int x, int y)&#123; return r[x].y &gt; r[y].y ? x : y;&#125;int main()&#123; scanf("%d", &amp;T); while(T--)&#123; for(int i = 0; i &lt; 4; i++)scanf("%lf%lf", &amp;r[i].x, &amp;r[i].y); if(dcmp(Cross(r[1] - r[0], r[3] - r[2])) == 0 || dcmp(r[1].y - r[0].y) == 0 || dcmp(r[3].y - r[2].y) == 0)&#123; printf("0.00\n"); continue; &#125; if(!check(r[0], r[1], r[2], r[3]))&#123; printf("0.00\n"); continue; &#125; P t = get(r[0], r[1], r[2], r[3]); db t1 = max(r[0].y, r[1].y); db t2 = max(r[2].y, r[3].y); if(dcmp(t.y - min(t1, t2)) &gt;= 0)&#123; printf("0.00\n"); continue; &#125; if(dcmp(t1 - t2) &gt;= 0)&#123; db xx = r[1].x - r[0].x; db yy = r[1].y - r[0].y; db tt = t2 - t.y; db dx = xx * tt / yy; db x = dx + t.x; P res = P&#123;x, t2&#125;; if(dcmp(fabs(r[Max(2, 3)].x - x) - fabs(r[Max(0, 1)].x - x)) &lt;= 0 &amp;&amp; (r[Max(2, 3)].x - x) * (r[Max(0, 1)].x - x) &gt;= 0)&#123; printf("0.00\n"); continue; &#125; printf("%.2f\n", fabs(Cross(r[Max(2, 3)] - t, res - t) / 2) + eps); &#125; else&#123; db xx = r[3].x - r[2].x; db yy = r[3].y - r[2].y; db tt = t1 - t.y; db dx = xx * tt / yy; db x = dx + t.x; P res = P&#123;x, t1&#125;; if(dcmp(fabs(r[Max(0, 1)].x - x) - fabs(r[Max(2, 3)].x - x)) &lt;= 0 &amp;&amp; (r[Max(2, 3)].x - x) * (r[Max(0, 1)].x - x) &gt;= 0)&#123; printf("0.00\n"); continue; &#125; printf("%.2f\n", fabs(Cross(r[Max(0, 1)] - t, res - t) / 2) + eps); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>计算几何</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[HDU-3247(Resource-Archiver)]]></title>
    <url>%2F2019%2F02%2F28%2FHDU-3247-Resource-Archiver%2F</url>
    <content type="text"><![CDATA[链接：https://vjudge.net/problem/HDU-3247思路：果然自动机上不是玩dp，矩阵就是玩图论，我想到了状压，但是由于节点太多感觉会炸空间就不知道怎么做了。。。事实上只有单词节点是有用的，中间节点忽略掉，我们可以用bfs预处理出每两个节点之间的距离，然后处理出起初点到各个点之间的距离，中间不能走过危险节点，把他们拿出来单独建图，剩下的就是跑一个TSP就行了。。。果然智商又被碾压了呢。。。。代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156#include&lt;bits/stdc++.h&gt;using namespace std;const int maxnode = 6e4 + 5;const int sigma_size = 2;int n, m;char s[maxnode];bool vis[maxnode];int dp[1 &lt;&lt; 11][20];int id[20];int ch[maxnode][sigma_size];int val[maxnode];int f[maxnode];int last[maxnode];int sz;void init() &#123; sz = 1; memset(ch[0], 0, sizeof(ch[0]));&#125;int idx(char c) &#123; return c - '0';&#125;void insert(char *s,int v = 1) &#123; int n = strlen(s); int u = 0; for (int i = 0; i &lt; n; i++) &#123; int c = idx(s[i]); if (!ch[u][c]) &#123; ch[u][c] = sz; memset(ch[sz], 0, sizeof(ch[sz])); val[sz++] = 0; &#125; u = ch[u][c]; &#125; if(v == -1) val[u] = v; else if(val[u] != -1) val[u] |= (1 &lt;&lt; v); if(v != -1) id[v] = u;&#125;void getfail() &#123; queue&lt;int&gt; q; f[0] = 0; for (int i = 0; i &lt; sigma_size; i++) &#123; int u = ch[0][i]; if (u) &#123; f[u] = last[u] = 0; q.push(u); &#125; &#125; while (!q.empty()) &#123; int r = q.front(); q.pop(); if(val[r] == -1 || val[f[r]] == -1) val[r] = -1; else val[r] |= val[f[r]]; for (int c = 0; c &lt; sigma_size; c++) &#123; int u = ch[r][c]; if (!u) &#123; ch[r][c] = ch[f[r]][c]; continue; &#125; q.push(u); int v = f[r]; while (v &amp;&amp; !ch[v][c])v = f[v]; f[u] = ch[v][c]; last[u] = val[f[u]] ? f[u] : last[f[u]]; &#125; &#125;&#125;typedef pair&lt;int, int&gt; P;int G[20][20];int bfs(int s, int t)&#123; memset(vis, 0, sizeof(vis)); queue&lt;P&gt; q; q.emplace(s, 0); while(!q.empty())&#123; int u = q.front().first; int d = q.front().second; q.pop(); vis[u] = 1; if(u == t)return d; for(int i = 0; i &lt; 2; i++)&#123; int v = ch[u][i]; if(val[v] == -1 || vis[v])continue; q.emplace(v, d + 1); &#125; &#125; return 1e9;&#125;int main()&#123; while(~scanf("%d %d", &amp;n, &amp;m) &amp;&amp; (n || m))&#123; init(); for(int i = 0; i &lt; n; i++)&#123; scanf("%s", s); insert(s, i); &#125; for(int i = 0; i &lt; m; i++)&#123; scanf("%s", s); insert(s, -1); &#125; getfail(); for(int i = 0; i &lt;= n; i++)&#123; for(int j = 0; j &lt;= n; j++)&#123; G[i][j] = 1e9; &#125; G[i][i] = 0; &#125; for(int i = 0; i &lt; n; i++)&#123; for(int j = 0; j &lt; n; j++)&#123; if(i == j)continue; G[i + 1][j + 1] = min(G[i + 1][j + 1], bfs(id[i], id[j])); &#125; &#125; for(int i = 0; i &lt; n; i++)&#123; G[0][i + 1] = min(G[0][i + 1], bfs(0, id[i])); &#125; for(int i = 0; i &lt; (1 &lt;&lt; (n + 1)); i++)&#123; for(int j = 0; j &lt;= n; j++)&#123; dp[i][j] = 1e9; &#125; &#125; dp[1][0] = 0; for(int i = 1; i &lt; (1 &lt;&lt; (n + 1)); i++)&#123; for(int j = 0; j &lt;= n; j++)&#123; if((i &amp; (1 &lt;&lt; j)) == 0)&#123; continue; &#125; for(int k = 0; k &lt;= n; k++)&#123; if(j == k)continue; dp[i | (1 &lt;&lt; k)][k] = min(dp[i | (1 &lt;&lt; k)][k], dp[i][j] + G[j][k]); &#125; &#125; &#125; int ans = 1e9; for(int i = 0; i &lt;= n; i++)&#123; ans = min(ans, dp[(1 &lt;&lt; (n + 1)) - 1][i]); &#125; printf("%d\n", ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>AC自动机</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[HDU-3341(Lost's-revenge)]]></title>
    <url>%2F2019%2F02%2F27%2FHDU-3341-Lost-s-revenge%2F</url>
    <content type="text"><![CDATA[链接：https://vjudge.net/problem/HDU-3341思路：一开始想的dp方程是对的，但空间不够，后面又没忍住看了下题解，发现可以用一种技巧把空间卡下去，首先状态最多的情况肯定是大家都是10的情况，也就最多11 11 11 11种状态，我们考虑用A (num[1] + 1) (num[2] + 1) (num[3]) + 1 + B (num[2] + 1) (num[3] + 1) + C * (num[3] + 1) + D来表示状态(有点类似于进制)，然后枚举值，还原出各个的数量，正常转移即可。代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122#include&lt;bits/stdc++.h&gt;using namespace std;const int maxnode = 505;const int sigma_size = 4;int n;char s[50];int ch[maxnode][sigma_size];int val[maxnode];int f[maxnode];int last[maxnode];int sz;void init() &#123; sz = 1; memset(ch[0], 0, sizeof(ch[0]));&#125;int idx(char c) &#123; if(c == 'A')return 0; if(c == 'G')return 1; if(c == 'C')return 2; return 3;&#125;void insert(char *s) &#123; int n = strlen(s); int u = 0; for (int i = 0; i &lt; n; i++) &#123; int c = idx(s[i]); if (!ch[u][c]) &#123; ch[u][c] = sz; memset(ch[sz], 0, sizeof(ch[sz])); val[sz++] = 0; &#125; u = ch[u][c]; &#125; val[u]++;&#125;void getfail() &#123; queue&lt;int&gt; q; f[0] = 0; for (int i = 0; i &lt; sigma_size; i++) &#123; int u = ch[0][i]; if (u) &#123; f[u] = last[u] = 0; q.push(u); &#125; &#125; while (!q.empty()) &#123; int r = q.front(); q.pop(); val[r] += val[f[r]]; //AC自动机 + dp时会用 for (int c = 0; c &lt; sigma_size; c++) &#123; int u = ch[r][c]; if (!u) &#123; ch[r][c] = ch[f[r]][c]; continue; &#125; q.push(u); int v = f[r]; while (v &amp;&amp; !ch[v][c])v = f[v]; f[u] = ch[v][c]; last[u] = val[f[u]] ? f[u] : last[f[u]]; &#125; &#125;&#125;int dp[11 * 11 * 11 * 11 + 10][maxnode];int num[4];int mul[4];int main()&#123; int kase = 0; while(~scanf("%d", &amp;n) &amp;&amp; n)&#123; init(); for(int i = 0; i &lt; n; i++)&#123; scanf("%s", s); insert(s); &#125; scanf("%s", s); getfail(); memset(num ,0, sizeof(num)); int x = strlen(s); for(int i = 0; i &lt; x; i++)&#123; num[idx(s[i])]++; &#125; int m = (num[0] + 1) * (num[1] + 1) * (num[2] + 1) * (num[3] + 1); mul[0] = (num[1] + 1) * (num[2] + 1) * (num[3] + 1); mul[1] = (num[2] + 1) * (num[3] + 1); mul[2] = num[3] + 1; mul[3] = 1; for(int i = 0; i &lt;= m; i++)&#123; for(int j = 0; j &lt; sz; j++)&#123; dp[i][j] = -1e9; &#125; &#125; dp[0][0] = 0; int ans = 0; for(int i = 0; i &lt; m; i++)&#123; int a[4]; a[0] = i / ((num[1] + 1) * (num[2] + 1) * (num[3] + 1)); a[1] = i % ((num[1] + 1) * (num[2] + 1) * (num[3] + 1)) / ((num[2] + 1) * (num[3] + 1)); a[2] = i % ((num[2] + 1) * (num[3] + 1)) / (num[3] + 1); a[3] = i % (num[3] + 1); for(int j = 0; j &lt; sz; j++)&#123; for(int k = 0; k &lt; sigma_size; k++)&#123; if(a[k] &lt; num[k])&#123; if(!val[ch[j][k]]) dp[i + mul[k]][ch[j][k]] = max(dp[i + mul[k]][ch[j][k]], dp[i][j]); else dp[i + mul[k]][ch[j][k]] = max(dp[i + mul[k]][ch[j][k]], dp[i][j] + val[ch[j][k]]); if(i + mul[k] == m - 1)ans = max(ans, dp[i + mul[k]][ch[j][k]]); &#125; &#125; &#125; &#125; printf("Case %d: %d\n", ++kase, ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>AC自动机</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[HDU-2457(DNA-repair)]]></title>
    <url>%2F2019%2F02%2F27%2FHDU-2457-DNA-repair%2F</url>
    <content type="text"><![CDATA[链接：https://vjudge.net/problem/HDU-2457思路：知道是个dp，但一开始卡住了没想出状态，事实上我们换一下角度，不要想哪些地方要更换，我们用dp[i][j]表示当前长度为i，在j节点时最少需要多少次更改次数，然后转移到非单词结点，转移边上字符如果跟原来相等就直接取最小值，否则就最小值 + 1，最后看所有dp[n][j]中的最小值是多少即可。代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include&lt;bits/stdc++.h&gt;using namespace std;const int maxnode = 1010;const int sigma_size = 4;int n;char s[maxnode];int ch[maxnode][sigma_size];int val[maxnode];int f[maxnode];int last[maxnode];int sz;void init() &#123; sz = 1; memset(ch[0], 0, sizeof(ch[0]));&#125;int idx(char c) &#123; if(c == 'A')return 0; if(c == 'G')return 1; if(c == 'C')return 2; return 3;&#125;void insert(char *s,int v = 1) &#123; int n = strlen(s); int u = 0; for (int i = 0; i &lt; n; i++) &#123; int c = idx(s[i]); if (!ch[u][c]) &#123; ch[u][c] = sz; memset(ch[sz], 0, sizeof(ch[sz])); val[sz++] = 0; &#125; u = ch[u][c]; &#125; val[u] = v;&#125;void getfail() &#123; queue&lt;int&gt; q; f[0] = 0; for (int i = 0; i &lt; sigma_size; i++) &#123; int u = ch[0][i]; if (u) &#123; f[u] = last[u] = 0; q.push(u); &#125; &#125; while (!q.empty()) &#123; int r = q.front(); q.pop(); val[r] |= val[f[r]]; //AC自动机 + dp时会用 for (int c = 0; c &lt; sigma_size; c++) &#123; int u = ch[r][c]; if (!u) &#123; ch[r][c] = ch[f[r]][c]; continue; &#125; q.push(u); int v = f[r]; while (v &amp;&amp; !ch[v][c])v = f[v]; f[u] = ch[v][c]; last[u] = val[f[u]] ? f[u] : last[f[u]]; &#125; &#125;&#125;int dp[maxnode][maxnode];int main()&#123; int kase = 0; while(~scanf("%d", &amp;n) &amp;&amp; n)&#123; init(); for(int i = 0; i &lt;= 1000; i++) for(int j = 0; j &lt;= 1000; j++)dp[i][j] = 1e9; dp[0][0] = 0; for(int i = 0; i &lt; n; i++)&#123; scanf("%s", s); insert(s); &#125; scanf("%s", s); int x = strlen(s); getfail(); int ans = 1e9; for(int i = 0; i &lt; x; i++)&#123; for(int j = 0; j &lt; sz; j++)&#123; for(int k = 0; k &lt; sigma_size; k++)&#123; if(val[ch[j][k]])continue; if(idx(s[i]) == k)dp[i + 1][ch[j][k]] = min(dp[i + 1][ch[j][k]], dp[i][j]); else dp[i + 1][ch[j][k]] = min(dp[i + 1][ch[j][k]], dp[i][j] + 1); if(i + 1 == x) ans = min(ans, dp[i + 1][ch[j][k]]); &#125; &#125; &#125; printf("Case %d: %d\n", ++kase, ans == 1e9 ? -1 : ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>AC自动机</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[HDU-2825(Wireless-Password)]]></title>
    <url>%2F2019%2F02%2F26%2FHDU-2825-Wireless-Password%2F</url>
    <content type="text"><![CDATA[链接：https://vjudge.net/problem/HDU-2825思路：从出正解思路到AC真的还有很长的距离啊，这个题思路很简单，用状压dp[i][j][k]表示当前走了i的长度，到j号节点，此时单词收集情况为k的方案数，然后转移即可。最初我是把val的值表示是哪个字符串，后来发现可以多个串重和的话就没法表示了，就这里有点没想清楚。事实上我们可以把val表示成一个二进制数，表示它包含哪些字符串，这次每次插入更新就是用|运算更新，后面getfail也可以完美用|运算了。。。最后还发现了一个一直以来的模板上的弱智错题，出错的概率特别低但是这次终于出现了，还好不是在比赛场上不然背血锅，吓得我把以前的都赶紧改掉。。。。代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115#include&lt;bits/stdc++.h&gt;using namespace std;const int maxnode = 101;const int sigma_size = 26;int n, m, p;char s[12][12];typedef long long ll;const ll mod = 20090717;int dp[27][maxnode][1 &lt;&lt; 10];int ch[maxnode][sigma_size];int val[maxnode];int f[maxnode];int last[maxnode];int sz;void init() &#123; sz = 1; memset(ch[0], 0, sizeof(ch[0]));&#125;int idx(char c) &#123; return c - 'a';&#125;void insert(char *s, int v) &#123; int n = strlen(s); int u = 0; for (int i = 0; i &lt; n; i++) &#123; int c = idx(s[i]); if (!ch[u][c]) &#123; ch[u][c] = sz; memset(ch[sz], 0, sizeof(ch[sz])); val[sz++] = 0; &#125; u = ch[u][c]; &#125; val[u] |= (1 &lt;&lt; v);&#125;void getfail() &#123; queue&lt;int&gt; q; f[0] = 0; for (int i = 0; i &lt; sigma_size; i++) &#123; int u = ch[0][i]; if (u) &#123; f[u] = last[u] = 0; q.push(u); &#125; &#125; while (!q.empty()) &#123; int r = q.front(); q.pop(); val[r] |= val[f[r]];//一直这里放到下面去了，有可能会更新不到，而且完美没有必要重复sigma_size次。。。 for (int c = 0; c &lt; sigma_size; c++) &#123; int u = ch[r][c]; if (!u) &#123; ch[r][c] = ch[f[r]][c]; continue; &#125; q.push(u); int v = f[r]; while (v &amp;&amp; !ch[v][c])v = f[v]; f[u] = ch[v][c]; last[u] = val[f[u]] ? f[u] : last[f[u]]; &#125; &#125;&#125;void add(int &amp;x, int y)&#123; x += y; if(x &gt;= mod) x -= mod;&#125;int main()&#123; while(~scanf("%d %d %d", &amp;n, &amp;m, &amp;p) &amp;&amp; (n || m || p))&#123; init(); for(int i = 0; i &lt; m; i++)&#123; scanf("%s", s[i]); insert(s[i], i); &#125; getfail(); for(int i = 0; i &lt;= n; i++)&#123; for(int j = 0; j &lt; sz; j++)&#123; for(int k = 0; k &lt; (1 &lt;&lt; m); k++)&#123; dp[i][j][k] = 0; &#125; &#125; &#125; dp[0][0][0] = 1; for(int i = 0; i &lt; n; i++)&#123; for(int j = 0; j &lt; sz; j++) &#123; for(int q = 0; q &lt; (1 &lt;&lt; m); q++)&#123; if(dp[i][j][q] == 0)continue; for(int k = 0; k &lt; sigma_size; k++)&#123; add(dp[i + 1][ch[j][k]][q | val[ch[j][k]]], dp[i][j][q]); &#125; &#125; &#125; &#125; int ans = 0; for(int i = 0; i &lt; (1 &lt;&lt; m); i++)&#123; int num = 0; for(int j = 0; (1 &lt;&lt; j) &lt;= i; j++)&#123; if(i &amp; (1 &lt;&lt; j))num++; &#125; if(num &gt;= p)&#123; for(int j = 0; j &lt; sz; j++) add(ans, dp[n][j][i]); &#125; &#125; printf("%d\n", ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>AC自动机</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[HDU-2243(考研路茫茫――单词情结)]]></title>
    <url>%2F2019%2F02%2F26%2FHDU-2243-%E8%80%83%E7%A0%94%E8%B7%AF%E8%8C%AB%E8%8C%AB%E2%80%95%E2%80%95%E5%8D%95%E8%AF%8D%E6%83%85%E7%BB%93%2F</url>
    <content type="text"><![CDATA[链接：https://vjudge.net/problem/HDU-2243思路：我其实已经很想把这个题放在矩阵里了，因为这个dp真的没啥难的了，这个题难点在求的是小于等于的总和，朴素的想法就是一个一个加起来，那这样显然不行，然后容易观察得知不管幂还是矩阵都是个等比数列，根据求和公式下面有个除法，数的除法还好，矩阵的除法（求逆矩阵）就比较麻烦了，比较容易搞错，搞不好还可能没有逆矩阵（不知道会不会没有）。后来看了题解，其实可以在矩阵多开一列，全为1，我们思考矩阵是用横 * 竖，那么这一列是不是就相当于对一行元素求和，而最后一个1又是加上上一次的求和结果，所以多次乘法后最后一列的元素就是维护的在这之前这一行的和，关于26的幂我们也可以把他变成矩阵的形似这样搞，多开一维就可以避免求逆，最后我们把第一行求和即可。代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130#include&lt;bits/stdc++.h&gt;using namespace std;const int maxnode = 1000;const int sigma_size = 26;typedef unsigned long long ull;int n, m;char s[maxnode];int ch[maxnode][sigma_size];int val[maxnode];int f[maxnode];int last[maxnode];int sz;void init() &#123; sz = 1; memset(ch[0], 0, sizeof(ch[0]));&#125;int idx(char c) &#123; return c - 'a';&#125;void insert(char *s,int v = 1) &#123; int n = strlen(s); int u = 0; for (int i = 0; i &lt; n; i++) &#123; int c = idx(s[i]); if (!ch[u][c]) &#123; ch[u][c] = sz; memset(ch[sz], 0, sizeof(ch[sz])); val[sz++] = 0; &#125; u = ch[u][c]; &#125; val[u] = v;&#125;void getfail() &#123; queue&lt;int&gt; q; f[0] = 0; for (int i = 0; i &lt; sigma_size; i++) &#123; int u = ch[0][i]; if (u) &#123; f[u] = last[u] = 0; q.push(u); &#125; &#125; while (!q.empty()) &#123; int r = q.front(); q.pop(); val[r] |= val[f[r]]; for (int c = 0; c &lt; sigma_size; c++) &#123; int u = ch[r][c]; if (!u) &#123; ch[r][c] = ch[f[r]][c]; continue; &#125; q.push(u); int v = f[r]; while (v &amp;&amp; !ch[v][c])v = f[v]; f[u] = ch[v][c]; last[u] = val[f[u]] ? f[u] : last[f[u]]; &#125; &#125;&#125;struct Martix&#123; ull v[30][30]; Martix()&#123; memset(v, 0, sizeof(v)); &#125;&#125;;Martix operator *(const Martix &amp;a, const Martix &amp;b)&#123; Martix c; for(int i = 0; i &lt;= sz; i++)&#123; for(int j = 0; j &lt;= sz; j++)&#123; for(int k = 0; k &lt;= sz; k++)&#123; c.v[i][j] += a.v[i][k] * b.v[k][j]; &#125; &#125; &#125; return c;&#125;Martix pow_mod(Martix &amp;q, ull w)&#123; Martix ret = q; w--; while(w)&#123; if(w &amp; 1)ret = ret * q; q = q * q; w &gt;&gt;= 1; &#125; return ret;&#125;int main()&#123; while(~scanf("%d %d", &amp;n, &amp;m)) &#123; init(); for(int i = 0; i &lt; n; i++)&#123; scanf("%s", s); insert(s); &#125; getfail(); Martix t; for (int i = 0; i &lt; sz; i++) &#123; if (val[i])continue; for(int j = 0; j &lt; sigma_size; j++)&#123; if(!val[ch[i][j]])t.v[i][ch[i][j]]++; &#125; &#125; for(int i = 0; i &lt;= sz; i++)t.v[i][sz] = 1; t = pow_mod(t, m); ull r2 = 0ull; for(int i = 0; i &lt;= sz; i++)r2 += t.v[0][i]; Martix r; r.v[0][0] = 26; r.v[0][1] = 1; r.v[1][1] = 1; r = pow_mod(r, m); ull r1 = r.v[0][0] + r.v[0][1]; printf("%llu\n", r1 - r2); &#125; return 0;&#125;]]></content>
      <categories>
        <category>AC自动机</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[POJ-1625(Censored)]]></title>
    <url>%2F2019%2F02%2F26%2FPOJ-1625-Censored%2F</url>
    <content type="text"><![CDATA[链接：https://vjudge.net/problem/POJ-1625思路：跟北京站dp一样，不过就是坑很多就是了，首先读进来的字符可能是负数，需要映射一下变成正的，第二就是dp要用大整数，我以为他没说取模答案就一定在范围内，结果后来想了下很容易就要爆long long啊，结果果然还要大数，就在网上找了一个看起来比较简单和漂亮的模板。再说说这个题，就是自动机上dp的题，原来用矩阵加速，这个题因为比较小就不用加速了，直接dp就好，最后直接把所有节点的值加起来就是答案，实在不会看之前北京站的那个dp，那个是取模的就简单多了。代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164#include&lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;queue&gt;using namespace std;const int maxnode = 120;const int sigma_size = 300;int n, m, p;char s[15][15];char str[60];int id[300];int ch[maxnode][sigma_size];int val[maxnode];int f[maxnode];int last[maxnode];int sz;struct BigInteger &#123; int A[25]; enum &#123; MOD = 10000 &#125;; BigInteger() &#123; memset(A, 0, sizeof(A)); A[0] = 1; &#125; void set(int x) &#123; memset(A, 0, sizeof(A)); A[0] = 1; A[1] = x; &#125; void print() &#123; printf("%d", A[A[0]]); for (int i = A[0] - 1; i &gt; 0; i--) &#123; if (A[i] == 0) &#123; printf("0000"); continue; &#125; for (int k = 10; k * A[i] &lt; MOD; k *= 10) printf("0"); printf("%d", A[i]); &#125; printf("\n"); &#125; int &amp;operator[](int p) &#123; return A[p]; &#125; const int &amp;operator[](int p) const &#123; return A[p]; &#125; BigInteger operator+(const BigInteger &amp;B) &#123; BigInteger C; C[0] = max(A[0], B[0]); for (int i = 1; i &lt;= C[0]; i++) C[i] += A[i] + B[i], C[i + 1] += C[i] / MOD, C[i] %= MOD; if (C[C[0] + 1] &gt; 0) C[0]++; return C; &#125; BigInteger operator*(const BigInteger &amp;B) &#123; BigInteger C; C[0] = A[0] + B[0]; for (int i = 1; i &lt;= A[0]; i++) for (int j = 1; j &lt;= B[0]; j++) &#123; C[i + j - 1] += A[i] * B[j], C[i + j] += C[i + j - 1] / MOD, C[i + j - 1] %= MOD; &#125; if (C[C[0]] == 0) C[0]--; return C; &#125;&#125;dp[maxnode][100];void init() &#123; sz = 1; memset(ch[0], 0, sizeof(ch[0]));&#125;int idx(char c) &#123; return id[c + 100];&#125;void insert(char *s,int v = 1) &#123; int n = strlen(s); int u = 0; for (int i = 0; i &lt; n; i++) &#123; int c = idx(s[i]); if (!ch[u][c]) &#123; ch[u][c] = sz; memset(ch[sz], 0, sizeof(ch[sz])); val[sz++] = 0; &#125; u = ch[u][c]; &#125; val[u] = v;&#125;void getfail() &#123; queue&lt;int&gt; q; f[0] = 0; for (int i = 0; i &lt; sigma_size; i++) &#123; int u = ch[0][i]; if (u) &#123; f[u] = last[u] = 0; q.push(u); &#125; &#125; while (!q.empty()) &#123; int r = q.front(); q.pop(); val[r] |= val[f[r]]; for (int c = 0; c &lt; sigma_size; c++) &#123; int u = ch[r][c]; if (!u) &#123; ch[r][c] = ch[f[r]][c]; continue; &#125; q.push(u); int v = f[r]; while (v &amp;&amp; !ch[v][c])v = f[v]; f[u] = ch[v][c]; last[u] = val[f[u]] ? f[u] : last[f[u]]; &#125; &#125;&#125;int main()&#123; while(~scanf("%d %d %d", &amp;n, &amp;m, &amp;p)) &#123; scanf("%s", str); memset(id, 0, sizeof(id)); for (int i = 0; i &lt; n; i++) id[str[i] + 100] = i; init(); for (int i = 0; i &lt; p; i++) &#123; scanf("%s", s[i]); insert(s[i]); &#125; getfail(); for(int i = 0; i &lt;= m; i++)&#123; for(int j = 0; j &lt; sz; j++)&#123; dp[j][i].set(0); &#125; &#125; dp[0][0].set(1); for (int i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt; sz; j++) &#123; if (val[j])continue; for (int k = 0; k &lt; n; k++) &#123; if (!val[ch[j][k]])dp[ch[j][k]][i + 1] = dp[ch[j][k]][i + 1] + dp[j][i]; &#125; &#125; &#125; BigInteger r; r.set(0); for (int i = 0; i &lt; sz; i++) &#123; if (!val[i]) r = r + dp[i][m]; &#125; r.print(); &#125; return 0;&#125;]]></content>
      <categories>
        <category>AC自动机</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Codeforces-Round-542-(Div.1)-C(Morse-Code)]]></title>
    <url>%2F2019%2F02%2F25%2FCodeforces-Round-542-Div-1-C-Morse-Code%2F</url>
    <content type="text"><![CDATA[链接：https://codeforces.com/contest/1129/problem/C思路：想了想还是开个计数dp分类，毕竟自己计数实在是很垃圾，这个题其实真没什么难的，我们令f[l][r]为l到r可以产生的答案，考虑每次加入，新增的一定是包含最后一个字符的，那么就可能由四个位置转移过来，排除掉不符合的就行。我们考虑最后的答案，维护一个前缀和，表示已经计算了l到r - 1的答案，那么如果包含r处的字符那么r字符一定会包含进去，但是有可能有一段后缀我们已经计算过了，计算过的就是与前面某个前缀的最长公共后缀，我们可以直接dp一下求出最大的，然后从这个点左边开始统计的就是更新的答案。代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 3010;ll f[maxn][maxn];int lcp[maxn][maxn];const ll mod = 1e9 + 7;int n;int s[maxn];int b[maxn];void add(ll &amp;x, ll y)&#123; x += y; if(x &gt;= mod) x -= mod;&#125;int main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); cin &gt;&gt; n; for(int i = 1; i &lt;= n; i++) cin &gt;&gt; s[i]; for(int i = 1; i &lt;= n; i++)&#123; for(int j = 1; j &lt;= n; j++)&#123; if(s[i] == s[j]) lcp[i][j] = lcp[i - 1][j - 1] + 1; &#125; &#125; for(int i = 4; i &lt;= n; i++)&#123; for(int j = i - 3; j &lt;= i; j++)&#123; b[i] = b[i] &lt;&lt; 1 | s[j]; &#125; &#125; for(int i = 1; i &lt;= n; i++)&#123; f[i][i - 1] = 1; for(int j = i; j &lt;= n; j++)&#123; for(int k = 1; k &lt;= 3; k++)&#123; if(j - k &gt;= i - 1)add(f[i][j], f[i][j - k]); &#125; if(i + 2 &lt; j &amp;&amp; b[j] != 3 &amp;&amp; b[j] != 5 &amp;&amp; b[j] != 14 &amp;&amp; b[j] != 15)add(f[i][j], f[i][j - 4]); &#125; &#125; ll ans = 0; for(int i = 1; i &lt;= n; i++) &#123; int t = 0; for (int j = 1; j &lt; i; j++)t = max(t, lcp[i][j]); for (int k = t; k &lt; i; k++)add(ans, f[i - k][i]); cout &lt;&lt; ans &lt;&lt; '\n'; &#125; return 0;&#125;]]></content>
      <categories>
        <category>计数dp</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[bzoj-4310(跳蚤)]]></title>
    <url>%2F2019%2F02%2F24%2Fbzoj-4310-%E8%B7%B3%E8%9A%A4%2F</url>
    <content type="text"><![CDATA[链接：https://www.lydsy.com/JudgeOnline/problem.php?id=4310思路：这个题感觉SAM明显麻烦很多啊，SA感觉简单一点，首先很明显我们要二分答案是第几大的字符串，然后我们从原串的后面往前面贪心，对于每一个点我们和答案比较一下lcp，如果为0且二分的小于当前则无解，否则需要查看枚举串是否被切开，以及lcp之前是否已经切开过，如果没切开过我们看一下lcp处谁大，如果当前大则需要加一个切割点，那么我们在尽量靠前的位置切就行，然后最后看一下是不是切的次数 &lt;= k即可。注意求lcp需要特判一下l和r是否相同，如果相同则返回当前后缀的值。代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e5 + 5;typedef long long ll;char s[maxn];int sa[maxn],t[maxn],t2[maxn],c[maxn],n,m,k;int r[maxn],h[maxn];int d[maxn][20];int nowl, nowr;ll lb, ub; //n为原字符长度，放于s[]的0-n-1位置，s[n]为0，build_sa传入的参数为（n+1，字符范围） void build_sa(int n,int m) &#123;//n为原串长度+1，字符值在0-m-1 int i, *x = t, *y = t2; for (i = 0; i &lt; m; i++)c[i] = 0; for (i = 0; i &lt; n; i++)c[x[i] = s[i]]++; for (i = 1; i &lt; m; i++)c[i] += c[i - 1]; for (i = n - 1; i &gt;= 0; i--)sa[--c[x[i]]] = i; for (int k = 1; k &lt;= n; k &lt;&lt;= 1) &#123; int p = 0; for (i = n - k; i &lt; n; i++)y[p++] = i; for (i = 0; i &lt; n; i++)if (sa[i] &gt;= k)y[p++] = sa[i] - k; for (i = 0; i &lt; m; i++)c[i] = 0; for (i = 0; i &lt; n; i++)c[x[y[i]]]++; for (i = 0; i &lt; m; i++)c[i] += c[i - 1]; for (i = n - 1; i &gt;= 0; i--)sa[--c[x[y[i]]]] = y[i]; swap(x, y); p = 1; x[sa[0]] = 0; for (i = 1; i &lt; n; i++) x[sa[i]] = y[sa[i - 1]] == y[sa[i]] &amp;&amp; y[sa[i - 1] + k] == y[sa[i] + k] ? p - 1 : p++; if (p &gt;= n)break; m = p; &#125;&#125; //最好从0开始，这样sa[n-1] = 0,可以把上一次的数据清空void getheight() &#123; int i, j, k = 0; for (i = 1; i &lt;= n; i++) r[sa[i]] = i; for (i = 0; i &lt; n; h[r[i++]] = k) for (k ? k-- : 0, j = sa[r[i] - 1]; s[i + k] == s[j + k]; k++);&#125; void RMQ_init()&#123; for(int i = 1; i &lt;= n; i++)d[i][0] = h[i]; for(int j = 1; (1 &lt;&lt; j) &lt;= n; j++)&#123; for(int i = 1; i + (1 &lt;&lt; j) - 1 &lt;= n; i++)&#123; d[i][j] = min(d[i][j - 1], d[i + (1 &lt;&lt; (j - 1))][j - 1]); &#125; &#125;&#125; int RMQ(int l,int r) &#123; if (l &gt; r)swap(l, r); int k = 0; while (1 &lt;&lt; (k + 1) &lt;= r - l + 1)k++; return min(d[l][k], d[r - (1 &lt;&lt; k) + 1][k]);&#125; void get(ll x)&#123; for(int i = 1; i &lt;= n; i++)&#123; if(n - sa[i] - h[i] &lt; x) x -= (n - sa[i] - h[i]); else&#123; nowl = sa[i]; nowr = sa[i] + h[i] + x - 1; return; &#125; &#125;&#125; void init()&#123; for(int i = 1; i &lt;= n; i++)&#123; ub += n - sa[i] - h[i]; &#125;&#125; int query(int L, int R)&#123; if(L == R)return n - sa[L]; if(L &gt; R)swap(L, R); return RMQ(L + 1, R);&#125; int compare(int x1, int y1,int x2,int y2) &#123; int l1 = y1 - x1 + 1, l2 = y2 - x2 + 1; int lcp = query(r[x1], r[x2]); if (lcp &gt;= l1) return l1 &lt;= l2; else if (lcp &gt;= l2) return 0; else return s[x1 + lcp] &lt;= s[x2 + lcp];&#125; int check() &#123; int last = n - 1, p = 1; for (int i = n - 1; i &gt;= 0; i--) &#123; if (s[i] &gt; s[nowl]) return 0; else if (!compare(i, last, nowl, nowr)) &#123; p++; last = i; if (p &gt; k) return 0; &#125; &#125; return 1;&#125; int main() &#123; scanf("%d %s", &amp;k, s); n = strlen(s); s[n] = 0; build_sa(n + 1, 130); getheight(); init(); RMQ_init(); int ansl = 0, ansr = 0; lb = 1; while(ub &gt;= lb)&#123; ll mid = ub + lb &gt;&gt; 1; get(mid); if(check())&#123; ansl = nowl; ansr = nowr; ub = mid - 1; &#125; else lb = mid + 1; &#125; for(int i = ansl; i &lt;= ansr; i++)putchar(s[i]); puts(""); return 0;&#125;]]></content>
      <categories>
        <category>后缀数组</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Codeforces-Round-541-(Div.2)-E(String-Multiplication)]]></title>
    <url>%2F2019%2F02%2F24%2FCodeforces-Round-541-Div-2-E-String-Multiplication%2F</url>
    <content type="text"><![CDATA[链接：https://codeforces.com/contest/1131/problem/E思路：考虑到每次拼接操作的性质，我们需要维护每次每种字母的最大结果，然后对于下一次合并，我们查找他们的前缀和后缀，如果全部都是那么答案就是上一个最大连续的长度 * （l + 1） + l，否则如果上一次存在该字母，就更新为前缀 + 后缀 + 1，否则为本次输入字符串的最大连续值。其实很简单但是需要考虑清楚再写。代码：123456789101112131415161718192021222324252627282930313233343536#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e6 + 5;int f[maxn][26];string s;int n;int t[26], r[26];int main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); cin &gt;&gt; n; int ans = 0; for(int i = 1; i &lt;= n; i++)&#123; cin &gt;&gt; s; int l = s.size(); memset(t, 0, sizeof(t)); memset(r, 0, sizeof(r)); for(int j = 0; j &lt; l; j++)&#123; if(j &amp;&amp; s[j] == s[j - 1]) t[s[j] - 'a']++; else t[s[j] - 'a'] = 1; r[s[j] - 'a'] = max(r[s[j] - 'a'], t[s[j] - 'a']); &#125; for(int j = 0; j &lt; 26; j++)&#123; int t1 = 0, t2 = l - 1; f[i][j] = r[j]; while(t1 &lt; l &amp;&amp; s[t1] == 'a' + j)t1++; while(t2 &gt; t1 &amp;&amp; s[t2] == 'a' + j)t2--; if(t1 == l) f[i][j] = max(f[i][j], l * f[i - 1][j] + f[i - 1][j] + l); else if(f[i - 1][j]) f[i][j] = max(f[i][j], t1 + l - t2); if(i == n)ans = max(ans, f[i][j]); &#125; &#125; cout &lt;&lt; ans &lt;&lt; '\n'; return 0;&#125;]]></content>
      <categories>
        <category>贪心</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Codeforces-Round-541-(Div.2)-D(Gourmet-choice)]]></title>
    <url>%2F2019%2F02%2F24%2FCodeforces-Round-541-Div-2-D-Gourmet-choice%2F</url>
    <content type="text"><![CDATA[链接：https://codeforces.com/contest/1131/problem/D思路：这个并查集其实就很明显了，首先相等的都弄入并查集中，然后是不是就是北京的A题签到题了，我们只需要把所有小于号的左边指向右边，然后跑一边拓扑排序，如果存在环的话就说明无解，否则按照拓扑序给每个集合分配大小就行了。代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 2 * 1010;int par[maxn];int n, m;char s[maxn][maxn];vector&lt;int&gt; G[maxn];bool vis[maxn];int deg[maxn];int d[maxn];int getroot(int a)&#123; if(par[a] == a) return a; return par[a] = getroot(par[a]);&#125;void merge(int a, int b)&#123; int u = getroot(a); int v = getroot(b); par[v] = u;&#125;int main()&#123; scanf("%d %d", &amp;n, &amp;m); for(int i = 1; i &lt;= n; i++)scanf("%s", s[i] + 1); for(int i = 0; i &lt;= m + n; i++) par[i] = i; for(int i = 1; i &lt;= n; i++)&#123; for(int j = 1; j &lt;= m; j++)&#123; if(s[i][j] == '=')merge(i, j + n); &#125; &#125; for(int i = 1; i &lt;= n; i++)&#123; for(int j = 1; j &lt;= m; j++)&#123; int u = getroot(i); int v = getroot(j + n); if(s[i][j] == '&lt;')&#123; G[u].emplace_back(v); deg[v]++; &#125; else if(s[i][j] == '&gt;')&#123; G[v].emplace_back(u); deg[u]++; &#125; &#125; &#125; queue&lt;int&gt; q; for(int i = 1; i &lt;= n + m; i++)&#123; if(!deg[par[i]])q.emplace(i); &#125; while(!q.empty())&#123; int u = q.front(); q.pop(); vis[u] = 1; for(auto &amp;v : G[u])&#123; d[v] = max(d[v], d[u] + 1); deg[v]--; if(!deg[v])q.emplace(v); &#125; &#125; bool flag = true; for(int i = 1; i &lt;= n + m; i++)&#123; if(!vis[par[i]])&#123; flag = false; puts("No"); break; &#125; &#125; if(flag)&#123; puts("Yes"); for(int i = 1; i &lt;= n; i++)printf("%d%c", d[par[i]] + 1, i == n ? '\n' : ' '); for(int i = n + 1; i &lt;= n + m; i++)printf("%d%c", d[par[i]] + 1, i == n + m ? '\n' : ' '); &#125; return 0;&#125;]]></content>
      <categories>
        <category>并查集</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Codeforces-Round-541-(Div.2)-F(Asya-And-Kittens)]]></title>
    <url>%2F2019%2F02%2F24%2FCodeforces-Round-541-Div-2-F-Asya-And-Kittens%2F</url>
    <content type="text"><![CDATA[链接：https://codeforces.com/contest/1131/problem/F思路：看到集合就想到了并查集，但是一个集合里面的元素合并有先后关系，如果普通的建好后就不知道谁需要先合并谁需要后合并，这时候就用新建节点合并的办法就很简单（还记不记得吉老师的那个并查集题目，后面的battle是要与前面的人打，但如果普通的并查集你后面加入battle后前面的都要变，就不好维护了，听说按秩合并可以解决，但想想新建节点，每次合并都是沿着树合并，新建节点就可以很好的表示出又打了一次的关系），而这个题新建节点就把树的形状保存下来了，如果你要完成当前节点的合并，左右的你必须先完成，如果普通的一旦路径压缩就破坏了树的结构。所以我们只用保存树的信息，然后继续路径压缩，最后在保留树的信息上走一步后续遍历即可。如果是按秩合并就需要前序遍历，总之这种需要保存树的结构的并查集题目要吗路径压缩 + 新建父节点，要吗按秩合并。代码：新建节点版本12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 3e5 + 5;vector&lt;int&gt; G[maxn];int n;int par[maxn];int num[maxn];int getroot(int a)&#123; if(par[a] == a)return a; return par[a] = getroot(par[a]);&#125;void dfs(int u, int f)&#123; for(int i = 0; i &lt; G[u].size(); i++)&#123; int v = G[u][i]; if(v == f)continue; dfs(v, u); &#125; if(u &lt;= n) cout &lt;&lt; u &lt;&lt; ' ';&#125;int main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); cin &gt;&gt; n; for(int i = 1; i &lt;= n; i++)par[i] = i, num[i] = 1; for(int i = 1; i &lt; n; i++)&#123; int u, v; cin &gt;&gt; u &gt;&gt; v; int a = getroot(u); int b = getroot(v); G[i + n].push_back(a); G[i + n].push_back(b); par[i + n] = i + n; par[a] = i + n; par[b] = i + n; &#125; dfs(2 * n - 1, 0); cout &lt;&lt; '\n'; return 0;&#125; 按秩合并版本12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 3e5 + 5;int par[maxn], r[maxn];vector&lt;int&gt; G[maxn];int n;int getroot(int a)&#123; return par[a] == a ? a : getroot(par[a]);&#125;void merge(int a, int b)&#123; int u = getroot(a); int v = getroot(b); if(u == v)return; if(r[u] &lt; r[v])&#123; par[u] = v; G[v].emplace_back(u); &#125; else&#123; par[v] = u; G[u].emplace_back(v); if(r[u] == r[v])r[u]++; &#125;&#125;void dfs(int u, int f)&#123; printf("%d ", u); for(auto &amp;v : G[u])&#123; if(v == f)continue; dfs(v, u); &#125;&#125;int main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); cin &gt;&gt; n; for(int i = 1; i &lt;= n; i++) par[i] = i; for(int i = 1; i &lt; n; i++)&#123; int u, v; cin &gt;&gt; u &gt;&gt; v; merge(u, v); &#125; int now = par[1]; while(now != par[now])now = par[now]; dfs(now, 0); return 0;&#125;]]></content>
      <categories>
        <category>并查集</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[EOJ-Monthly-2019.2-E(中位数)]]></title>
    <url>%2F2019%2F02%2F24%2FEOJ-Monthly-2019-2-E-%E4%B8%AD%E4%BD%8D%E6%95%B0%2F</url>
    <content type="text"><![CDATA[链接：https://acm.ecnu.edu.cn/contest/140/problem/E/思路：这种套路感觉很多次了，求中位数，不管怎么变，百分之八十都是二分，然后把原权值变为0 1或者-1 1，然后求和，我们可以看出如果一个中位数的值大于等于当前枚举的值，那么它存在一条路径上的路径之和大于等于0（大于等于二分值为1，否则为-1），这样其实我们相当于是在求最长路，但是其实不用多个log，因为是个DAG图所以我们走一次拓扑排序就好了，排序过程中dp保存最大值就行。感觉这种题真不应该做不出来啊，多思考一下记住这个套路很容易就有了。代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e6 + 5;vector&lt;int&gt; G[maxn];int a[maxn];int b[maxn];int c[maxn];int dp[maxn];int deg[maxn];int dx[maxn];int n, m;void bfs()&#123; queue&lt;int&gt; q; for(int i = 1; i &lt;= n; i++)&#123; if(!deg[i])q.push(i); &#125; while(!q.empty())&#123; int u = q.front(); q.pop(); for(auto &amp;v : G[u])&#123; dp[v] = max(dp[v], dp[u] + c[v]); deg[v]--; if(!deg[v]) q.push(v); &#125; &#125;&#125;bool check(int x)&#123; for(int i = 1; i &lt;= n; i++)&#123; c[i] = b[i] &gt;= a[x] ? 1 : -1; deg[i] = dx[i]; dp[i] = -1e9; &#125; dp[1] = c[1]; bfs(); return dp[n] &gt;= 0;&#125;int main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); cin &gt;&gt; n &gt;&gt; m; for(int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i], b[i] = a[i]; for(int i = 1; i &lt;= m; i++)&#123; int u, v; cin &gt;&gt; u &gt;&gt; v; G[u].emplace_back(v); dx[v]++; &#125; a[0] = b[0] = -1; sort(a + 1, a + n + 1); int lb = 1; int ub = n; int ans = 0; while(ub &gt;= lb)&#123; int mid = ub + lb &gt;&gt; 1; if(check(mid))&#123; lb = mid + 1; ans = mid; &#125; else ub = mid - 1; &#125; printf("%d\n", a[ans]); return 0;&#125;]]></content>
      <categories>
        <category>二分</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[EOJ-Monthly-2019.2-B(解题)]]></title>
    <url>%2F2019%2F02%2F22%2FEOJ-Monthly-2019-2-B-%E8%A7%A3%E9%A2%98%2F</url>
    <content type="text"><![CDATA[链接：https://acm.ecnu.edu.cn/contest/140/problem/B/思路：感觉有点傻逼了啊看漏了条件，我们知道对于一个连续区间的数，我们可以看成左端点开始的后缀 - 右端点开始的后缀，如果这个数能被m整除，那么这两个端点肯定是同余的，所以问题就很简单了，找到最先开始的某个出现了两次的余数即可，又因为保证了m的和在5e7以内(就是看漏了这个条件，真的傻逼)，根据鸽巢原理，最多取m + 1个数就可以得到答案，所以从右往左扫一遍即可。代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 5e7 + 5;int vis[maxn];vector&lt;int&gt; c;char s[1000010];int q;int m;int main()&#123; scanf("%s", s + 1); int n = strlen(s + 1); scanf("%d", &amp;q); while(q--)&#123; scanf("%d", &amp;m); int x = 0; int now = 1; bool flag = true; for(int i = n; i; i--)&#123; x = ((s[i] - '0') * now + x) % m; //printf("%d\n", x); if(vis[x])&#123; printf("%d %d\n", i, vis[x] - 1); flag = false; break; &#125; if(!x)&#123; printf("%d %d\n", i, n); flag = false; break; &#125; vis[x] = i; c.push_back(x); now *= 10; now %= m; &#125; if(flag)puts("-1"); for(auto &amp;it : c)&#123; vis[it] = 0; &#125; c.clear(); &#125; return 0;&#125;]]></content>
      <categories>
        <category>数论</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[bzoj-4199(品酒大会)]]></title>
    <url>%2F2019%2F02%2F22%2Fbzoj-4199-%E5%93%81%E9%85%92%E5%A4%A7%E4%BC%9A%2F</url>
    <content type="text"><![CDATA[链接：https://www.lydsy.com/JudgeOnline/problem.php?id=4199思路：考虑求不同前缀相似度的方案数以及最大值，还是老技巧，SAM的fail树上的LCA表示的是一段最长公共后缀，我们把串倒过来建SAM就变成了前缀，然后拓扑排序，每个节点维护最大最小值以及节点数，由于相似度可以向下传递，所以我们可以先求出每个相似度的答案，然后从大到小更新答案即可。维护最大最小值的时候想清楚哪些节点有初始值，所有复制节点都是没有初始值的(或者说为无穷)，因为它完全由子树的信息合并而来，如果有初值就会算重，最大值就不对，而所有新建节点都是有新建节点的初值的，因为这个不能由子树得来，只存在该串中，然后从大到小更新答案即可。然后听说SA也可以做这个题，看了下思路，按height数组排序然后用并查集合并，每次个数贡献就是两个合并集合相乘，最大最小值在合并的时候更新即可，感觉也是一个套路吧但是不太想写了。代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include&lt;bits/stdc++.h&gt;#define sigma_size 28using namespace std;const int maxn = 3e5 + 5;const int mod = 1e9 + 7;typedef long long ll;int len[maxn * 2]; //最长子串的长度(该节点字串数量=len[x]-len[f[x]])int f[maxn * 2]; //后缀链接(最短串前部减少一个字符所到达的状态)int cnt[maxn * 2]; //被后缀连接的数int ch[maxn * 2][sigma_size]; //状态转移(尾部加一个字符的下一个状态)(图)int idx; //节点编号int last; //最后节点ll epos[maxn * 2]; // enpos数（该状态子串出现数量）char s[maxn];int c[maxn * 2],a[maxn * 2];int n;ll w[maxn * 2];ll mx[maxn * 2], mn[maxn * 2];ll ans[maxn * 2];ll res[maxn * 2];int pos[maxn * 2];bool vis[maxn * 2]; void init() &#123; //初始化 last = idx = 1; //1表示root起始点 空集 f[1] = len[1] = 0; memset(ch[1], 0, sizeof(ch[1]));&#125; //SAM建图void add(int c, int r) &#123; //插入字符，为字符ascll码值 int x = ++idx; //创建一个新节点x; len[x] = len[last] + 1; // 长度等于最后一个节点+1 epos[x] = 1; //接受节点子串除后缀连接还需加一 pos[x] = r; vis[x] = true; int p; //第一个有C转移的节点; for (p = last; p &amp;&amp; !ch[p][c]; p = f[p])ch[p][c] = x;//沿着后缀连接 将所有没有字符c转移的节点直接指向新节点 if (!p)f[x] = 1, cnt[1]++; //全部都没有c的转移 直接将新节点后缀连接到起点 else &#123; int q = ch[p][c]; //p通过c转移到的节点 if (len[p] + 1 == len[q]) //pq是连续的 f[x] = q, cnt[q]++; //将新节点后缀连接指向q即可,q节点的被后缀连接数+1 else &#123; int nq = ++idx; //不连续 需要复制一份q节点 len[nq] = len[p] + 1; //令nq与p连续 f[nq] = f[q]; //因后面link[q]改变此处不加cnt memcpy(ch[nq], ch[q], sizeof(ch[q])); //复制q的信息给nq for (; p &amp;&amp; ch[p][c] == q; p = f[p]) ch[p][c] = nq; //沿着后缀连接 将所有通过c转移为q的改为nq f[q] = f[x] = nq; //将x和q后缀连接改为nq cnt[nq] += 2; // nq增加两个后缀连接 &#125; &#125; last = x; //更新最后处理的节点&#125; void getpos()&#123; for(int i = 1; i &lt;= idx; i++)&#123; if(vis[i]) mx[i] = mn[i] = w[pos[i]]; else mx[i] = -(1e9 + 7), mn[i] = 1e9 + 7; ans[i] = -1e18; &#125; for(int i = 1; i &lt;= idx; i++)c[len[i]]++; for(int i = 1; i &lt;= idx; i++)c[i] += c[i - 1]; for(int i = idx; i; i--)a[c[len[i]]--] = i; for(int i = idx; i; i--)&#123; int p = a[i]; if(mx[f[p]] != -1e9 - 7 &amp;&amp; mx[p] != -1e9 - 7) ans[len[f[p]]] = max(ans[len[f[p]]], mx[f[p]] * mx[p]); if(mn[f[p]] != 1e9 + 7 &amp;&amp; mn[p] != 1e9 + 7) ans[len[f[p]]] = max(ans[len[f[p]]], mn[f[p]] * mn[p]); res[len[f[p]]] += 1ll * epos[p] * epos[f[p]]; epos[f[p]] += epos[p]; mx[f[p]] = max(mx[f[p]], mx[p]); mn[f[p]] = min(mn[f[p]], mn[p]); &#125; for(int i = n - 1; i &gt;= 0; i--)&#123; ans[i] = max(ans[i], ans[i + 1]); res[i] += res[i + 1]; &#125; for(int i = 0; i &lt; n; i++)&#123; printf("%lld %lld\n", res[i], res[i] ? ans[i] : 0LL); &#125;&#125; int main() &#123; scanf("%d", &amp;n); scanf("%s", s); for(int i = 0; i &lt; n / 2; i++)swap(s[i], s[n - 1 - i]); for(int i = 0; i &lt; n; i++)scanf("%lld", &amp;w[n - 1 - i]); init(); for(int i = 0; i &lt; n; i++)add(s[i] - 'a', i); getpos(); return 0;&#125;]]></content>
      <categories>
        <category>后缀自动机</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[bzoj-3676(回文串)]]></title>
    <url>%2F2019%2F02%2F22%2Fbzoj-3676-%E5%9B%9E%E6%96%87%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[链接：https://www.lydsy.com/JudgeOnline/problem.php?id=3676思路：这是回文自动机的模板题，但还是用后缀自动机做一做。考虑答案只会出现在每种回文串中，由manacher证明我们知道本质不同的回文串一共有O(n)种，且肯定是位于右端点更新的地方，那么我们考虑我们能找到右端点建立的时候的状态，如果沿着fail树一直往上走，左端点会越来越靠近右端点，我们考虑只要找到左端点比当前回文串小且最接近的状态，那么该回文串肯定包含在内，这个时候就想到了求LCA的树上倍增，考虑该节点到目标节点的数一定能由二进制数写成，我们考虑树上倍增即可，找到状态更新答案，差点MLE这个题。代码：SAM123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126#include&lt;bits/stdc++.h&gt;#define sigma_size 28using namespace std;const int maxn = 3e5 + 5;const int mod = 1e9 + 7;typedef long long ll;int len[maxn * 2]; //最长子串的长度(该节点字串数量=len[x]-len[f[x]])int f[maxn * 2]; //后缀链接(最短串前部减少一个字符所到达的状态)int ch[maxn * 2][sigma_size]; //状态转移(尾部加一个字符的下一个状态)(图)int idx; //节点编号int last; //最后节点int epos[maxn * 2]; // enpos数（该状态子串出现数量）char s[maxn];int pos[maxn];int par[maxn * 2][20], a[maxn * 2], c[maxn * 2];ll res;void init() &#123; //初始化 last = idx = 1; //1表示root起始点 空集 f[1] = len[1] = 0; memset(ch[1], 0, sizeof(ch[1]));&#125;//SAM建图void add(int c) &#123; //插入字符，为字符ascll码值 int x = ++idx; //创建一个新节点x; len[x] = len[last] + 1; // 长度等于最后一个节点+1 epos[x] = 1; //接受节点子串除后缀连接还需加一 int p; //第一个有C转移的节点; for (p = last; p &amp;&amp; !ch[p][c]; p = f[p])ch[p][c] = x;//沿着后缀连接 将所有没有字符c转移的节点直接指向新节点 if (!p)f[x] = 1; //全部都没有c的转移 直接将新节点后缀连接到起点 else &#123; int q = ch[p][c]; //p通过c转移到的节点 if (len[p] + 1 == len[q]) //pq是连续的 f[x] = q; //将新节点后缀连接指向q即可,q节点的被后缀连接数+1 else &#123; int nq = ++idx; //不连续 需要复制一份q节点 len[nq] = len[p] + 1; //令nq与p连续 f[nq] = f[q]; //因后面link[q]改变此处不加cnt memcpy(ch[nq], ch[q], sizeof(ch[q])); //复制q的信息给nq for (; p &amp;&amp; ch[p][c] == q; p = f[p]) ch[p][c] = nq; //沿着后缀连接 将所有通过c转移为q的改为nq f[q] = f[x] = nq; //将x和q后缀连接改为nq // nq增加两个后缀连接 &#125; &#125; last = x; //更新最后处理的节点&#125;int num, ans = 0;char ss[maxn * 2];int p[maxn * 2];void getpos()&#123; for(int i = 1; i &lt;= idx; i++)c[len[i]]++; for(int i = 1; i &lt;= idx; i++)c[i] += c[i - 1]; for(int i = idx; i; i--)a[c[len[i]]--] = i; for(int i = idx; i; i--)&#123; epos[f[a[i]]] += epos[a[i]]; par[a[i]][0] = f[a[i]]; &#125; for(int j = 1; j &lt; 20; j++)&#123; for(int i = 1; i &lt;= idx; i++)&#123; //树上倍增的递推式 par[i][j] = par[par[i][j - 1]][j - 1]; &#125; &#125;&#125;//树上倍增找到最终状态，更新答案。void query(int l, int r)&#123; if(l &gt; r)return; int x = pos[r]; for(int i = 19; i &gt;= 0; i--)if(len[par[x][i]] &gt;= r - l + 1) x = par[x][i]; res = max(res, 1LL * (r - l + 1) * epos[x]);&#125;void pre()&#123;//将每两个字符中插入一个字符 ans = 0; int len = strlen(s + 1); num = 1; ss[0] = '!'; ss[num] = '#'; for(int i = 1; i &lt;= len; i++) ss[++num] = s[i], ss[++num] = '#'; ss[++num] = '\0';&#125;void manacher()&#123; pre(); int pos = 0, mx = 0; for(int i = 1; i &lt;= num; i++)&#123; if(i &lt; mx) p[i] = min(p[pos * 2 - i], mx - i); else p[i] = 1; //本质不同的回文串都会出现在右端点改变的时候 while(ss[i + p[i]] == ss[i - p[i]]) &#123; p[i]++; int l = i - p[i] + 1; if(ss[l] == '#')l++; l /= 2; int r = i + p[i] - 1; if(ss[r] == '#')r--; r /= 2; query(l, r); &#125; if(mx &lt; i + p[i]) mx = i + p[i], pos = i; ans = max(ans, p[i] - 1); &#125;&#125;int main() &#123; scanf("%s", s + 1); int n = strlen(s + 1); init(); for(int i = 1; i &lt;= n; i++)&#123; add(s[i] - 'a'); pos[i] = last; &#125; getpos(); manacher(); printf("%lld\n", res); return 0;&#125; 回文自动机123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include&lt;bits/stdc++.h&gt;using namespace std;const int maxnode = 3e5 + 5;const int sigma_size = 26;int ch[maxnode][sigma_size];int f[maxnode];int cnt[maxnode]; // 节点i表示的回文串在S中出现的次数（建树时求出的不是完全的，count()加上子节点以后才是正确的）int num[maxnode]; //以节点i回文串的末尾字符结尾的但不包含本条路径上的回文串的数目。(也就是fail指针路径的深度)int len[maxnode]; //节点i的回文串的长度int s[maxnode]; //表示第i次添加的字符int last; //指向最新添加的回文结点int n;int p; //节点个数（节点从2开始）char str[maxnode];int newnode(int w) &#123; for(int i = 0; i &lt; sigma_size; i++)ch[p][i] = 0; cnt[p] = 0; num[p] = 0; len[p] = w; return p++;&#125;void init() &#123; p = 0; newnode(0); newnode(-1); last = 0; n = 0; s[n] = -1; f[0] = 1;&#125;int getfail(int x) &#123; while (s[n - len[x] - 1] != s[n])x = f[x]; return x;&#125;void add(int c) &#123; s[++n] = c; int cur = getfail(last); if (!ch[cur][c]) &#123; int now = newnode(len[cur] + 2); f[now] = ch[getfail(f[cur])][c]; ch[cur][c] = now; num[now] = num[f[now]] + 1; &#125; last = ch[cur][c]; cnt[last]++;&#125;void count()&#123; for(int i = p-1; i &gt;= 0; i--) cnt[f[i]] += cnt[i];&#125;int main()&#123; scanf("%s", str); init(); int t = strlen(str); for(int i = 0; i &lt; t; i++)&#123; add(str[i] - 'a'); &#125; count(); long long ans = 0; for(int i = 2; i &lt;= p; i++)&#123; ans = max(ans, 1LL * len[i] * cnt[i]); &#125; printf("%lld\n", ans); return 0;&#125;]]></content>
      <categories>
        <category>后缀自动机</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[POJ-2778(DNA-Sequence)]]></title>
    <url>%2F2019%2F02%2F21%2FPOJ-2778-DNA-Sequence%2F</url>
    <content type="text"><![CDATA[链接：https://vjudge.net/problem/POJ-2778思路：看到数据范围就大概知道是个矩阵的题目了，联想到camp里面吃豆豆那个用矩阵倍增加速的题目，其实这个题简单多了，原因是因为起点固定了且算的是总方案数，那么我们考虑自动机上每个状态能走到哪些状态，然后在矩阵上把这些值变为1，然后矩阵快速幂一下，得到的就是从一个点到另一个点走n步的总方案数（离散数学中的邻接矩阵的应用讲过）。因为起点从0开始，所以只用把那一行全部加起来即可得到答案。代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133#include&lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;queue&gt;using namespace std;const int maxnode = 120;const int sigma_size = 4;typedef long long ll;const ll mod = 1e5;int n, m;char str[20][50];int ch[maxnode][sigma_size];int val[maxnode];int f[maxnode];int last[maxnode];int sz;struct Martix&#123; ll v[110][110]; Martix()&#123; memset(v, 0, sizeof(v)); &#125;&#125;;Martix operator*(const Martix &amp;a ,const Martix &amp;b)&#123; Martix c; for(int i = 0; i &lt; sz; i++)&#123; for(int j = 0; j &lt; sz; j++)&#123; for(int k = 0; k &lt; sz; k++)&#123; c.v[i][j] = (c.v[i][j] + a.v[i][k] * b.v[k][j]) % mod; &#125; &#125; &#125; return c;&#125;void init()&#123; sz = 1; memset(ch[0], 0, sizeof(ch[0]));&#125;int idx(char c) &#123; if(c == 'A')return 0; if(c == 'G')return 1; if(c == 'C')return 2; return 3;&#125;void insert(char *s,int v = 1)&#123; int n = strlen(s); int u = 0; for (int i = 0; i &lt; n; i++)&#123; int c = idx(s[i]); if (!ch[u][c])&#123; ch[u][c] = sz; memset(ch[sz], 0, sizeof(ch[sz])); val[sz++] = 0; &#125; u = ch[u][c]; &#125; val[u] = v;&#125;void getfail() &#123; queue&lt;int&gt; q; f[0] = 0; for (int i = 0; i &lt; sigma_size; i++) &#123; int u = ch[0][i]; if (u) &#123; f[u] = last[u] = 0; q.push(u); &#125; &#125; while (!q.empty()) &#123; int r = q.front(); q.pop(); val[r] |= val[f[r]]; //AC自动机 + dp时会用 for (int c = 0; c &lt; sigma_size; c++) &#123; int u = ch[r][c]; if (!u) &#123; ch[r][c] = ch[f[r]][c]; continue; &#125; q.push(u); int v = f[r]; while (v &amp;&amp; !ch[v][c])v = f[v]; f[u] = ch[v][c]; last[u] = val[f[u]] ? f[u] : last[f[u]]; &#125; &#125;&#125;Martix pow_mod(Martix &amp;q, ll w)&#123; Martix ret = q; w--; while(w)&#123; if(w &amp; 1)ret = ret * q; q = q * q; w &gt;&gt;= 1; &#125; return ret;&#125;int main()&#123; while(~scanf("%d %d", &amp;m, &amp;n)) &#123; init(); for (int i = 1; i &lt;= m; i++) &#123; scanf("%s", str[i]); insert(str[i]); &#125; getfail(); Martix x; for (int i = 0; i &lt; sz; i++) &#123; if(val[i])continue; for(int j = 0; j &lt; sigma_size; j++)&#123; if(!val[ch[i][j]])x.v[i][ch[i][j]]++; &#125; &#125; x = pow_mod(x, n); ll ans = 0; for(int i = 0; i &lt; sz; i++)&#123; ans += x.v[0][i]; if(ans &gt;= mod) ans -= mod; &#125; printf("%lld\n", ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>AC自动机</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[bzoj-3228(差异)]]></title>
    <url>%2F2019%2F02%2F19%2Fbzoj-3228-%E5%B7%AE%E5%BC%82%2F</url>
    <content type="text"><![CDATA[链接：https://www.lydsy.com/JudgeOnline/problem.php?id=3238思路：又是一个感觉SA很好想思路但SAM很好写的题，SA的话又是维护一个单调栈求前缀和即可。SAM的话我们考虑fail树上，一个lca代表两个后缀的最长公共后缀，所以我们考虑倒着建立SAM，这样就变成lcp了，然后拓扑排序，按照逆序考虑每一个点作为lca的贡献，那么就是他某一个子节点的数量*(其他子节点的数量的和)求和，这样我们逆序统计贡献，并把节点数依次向上加上去。注意一点，这个和既可以代表一个状态的串出现的次数，在这里就表示一共有多少本质不同的lcp(即lcp的位置不同)，所以不是先求和再乘而是边求和边统计，这个说着确实不太清楚要自己慢慢想。总结一下性质：fail树上两个点的lca是两个后缀的最长公共后缀，所以倒着建立SAM就变成了lcp，这是一个非常重要的技巧！代码：SAM12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include&lt;bits/stdc++.h&gt;#define sigma_size 28using namespace std;const int maxn = 5e5 + 5;const int mod = 1e9 + 7;typedef long long ll;int len[maxn * 2]; //最长子串的长度(该节点字串数量=len[x]-len[f[x]])int f[maxn * 2]; //后缀链接(最短串前部减少一个字符所到达的状态)int cnt[maxn * 2]; //被后缀连接的数int ch[maxn * 2][sigma_size]; //状态转移(尾部加一个字符的下一个状态)(图)int idx; //节点编号int last; //最后节点ll epos[maxn * 2]; // enpos数（该状态子串出现数量）char s[maxn];int a[maxn * 2], c[maxn * 2];int n;void init() &#123; //初始化 last = idx = 1; //1表示root起始点 空集 f[1] = len[1] = 0; memset(ch[1], 0, sizeof(ch[1]));&#125;//SAM建图void add(int c) &#123; //插入字符，为字符ascll码值 int x = ++idx; //创建一个新节点x; len[x] = len[last] + 1; // 长度等于最后一个节点+1 epos[x] = 1; //接受节点子串除后缀连接还需加一 int p; //第一个有C转移的节点; for (p = last; p &amp;&amp; !ch[p][c]; p = f[p])ch[p][c] = x;//沿着后缀连接 将所有没有字符c转移的节点直接指向新节点 if (!p)f[x] = 1, cnt[1]++; //全部都没有c的转移 直接将新节点后缀连接到起点 else &#123; int q = ch[p][c]; //p通过c转移到的节点 if (len[p] + 1 == len[q]) //pq是连续的 f[x] = q, cnt[q]++; //将新节点后缀连接指向q即可,q节点的被后缀连接数+1 else &#123; int nq = ++idx; //不连续 需要复制一份q节点 len[nq] = len[p] + 1; //令nq与p连续 f[nq] = f[q]; //因后面link[q]改变此处不加cnt memcpy(ch[nq], ch[q], sizeof(ch[q])); //复制q的信息给nq for (; p &amp;&amp; ch[p][c] == q; p = f[p]) ch[p][c] = nq; //沿着后缀连接 将所有通过c转移为q的改为nq f[q] = f[x] = nq; //将x和q后缀连接改为nq cnt[nq] += 2; // nq增加两个后缀连接 &#125; &#125; last = x; //更新最后处理的节点&#125;void solve()&#123; for(int i = 1; i &lt;= idx; i++)c[len[i]]++; for(int i = 1; i &lt;= idx; i++)c[i] += c[i - 1]; for(int i = idx; i; i--)a[c[len[i]]--] = i; ll ans1 = 0, ans2 = 0; for(int i = 1; i &lt;= n; i++)ans1 += 1ll * i * (n - 1); for(int i = idx; i; i--)&#123; ans2 += 1ll * len[f[a[i]]] * epos[f[a[i]]] * epos[a[i]]; epos[f[a[i]]] += epos[a[i]]; &#125; printf("%lld\n",ans1 - 2 * ans2);&#125;int main() &#123; scanf("%s", s); n = strlen(s); init(); for(int i = n - 1; i &gt;= 0; i--)add(s[i] - 'a'); solve(); return 0;&#125; SA123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include &lt;bits/stdc++.h&gt;#define F(x) ((x) / 3 + ((x) % 3 == 1 ? 0 : tb))#define G(x) ((x) &lt; tb ? (x) * 3 + 1 : ((x) - tb) * 3 + 2)using namespace std;const int maxn = 500005;int wa[maxn], wb[maxn], wc[maxn], wv[maxn], sa[3 * maxn];int r[maxn], h[maxn], s[3 * maxn];char ch[maxn];typedef pair&lt;int, int&gt; P;typedef long long ll;int n;ll ans;int c0(int *s, int a, int b) &#123; return s[a] == s[b] &amp;&amp; s[a + 1] == s[b + 1] &amp;&amp; s[a + 2] == s[b + 2];&#125;int c12(int k, int *s, int a, int b) &#123; if (k == 2) return s[a] &lt; s[b] || s[a] == s[b] &amp;&amp; c12(1, s, a + 1, b + 1); return s[a] &lt; s[b] || s[a] == s[b] &amp;&amp; wv[a + 1] &lt; wv[b + 1];&#125;void sort(int *s, int *a, int *b, int n, int m) &#123; for (int i = 0; i &lt; n; i++) wv[i] = s[a[i]]; for (int i = 0; i &lt; m; i++) wc[i] = 0; for (int i = 0; i &lt; n; i++) wc[wv[i]]++; for (int i = 1; i &lt; m; i++) wc[i] += wc[i - 1]; for (int i = n - 1; i &gt;= 0; i--) b[--wc[wv[i]]] = a[i];&#125;void dc3(int *s, int *sa, int n, int m) &#123; int i, j, *sn = s + n, *san = sa + n, ta = 0, tb = (n + 1) / 3, tbc = 0, p; s[n] = s[n + 1] = 0; for (i = 0; i &lt; n; i++) if (i % 3 != 0) wa[tbc++] = i; sort(s + 2, wa, wb, tbc, m); sort(s + 1, wb, wa, tbc, m); sort(s, wa, wb, tbc, m); for (p = 1, sn[F(wb[0])] = 0, i = 1; i &lt; tbc; i++) sn[F(wb[i])] = c0(s, wb[i - 1], wb[i]) ? p - 1 : p++; if (p &lt; tbc) dc3(sn, san, tbc, p); else for (i = 0; i &lt; tbc; i++) san[sn[i]] = i; for (i = 0; i &lt; tbc; i++) if (san[i] &lt; tb) wb[ta++] = san[i] * 3; if (n % 3 == 1) wb[ta++] = n - 1; sort(s, wb, wa, ta, m); for (i = 0; i &lt; tbc; i++) wv[wb[i] = G(san[i])] = i; for (i = 0, j = 0, p = 0; i &lt; ta &amp;&amp; j &lt; tbc; p++) sa[p] = c12(wb[j] % 3, s, wa[i], wb[j]) ? wa[i++] : wb[j++]; for (; i &lt; ta; p++) sa[p] = wa[i++]; for (; j &lt; tbc; p++) sa[p] = wb[j++];&#125;void getheight() &#123; int i, j, k = 0; for (i = 1; i &lt;= n; i++) r[sa[i]] = i; for (i = 0; i &lt; n; h[r[i++]] = k) for (k ? k-- : 0, j = sa[r[i] - 1]; s[i + k] == s[j + k]; k++);&#125;void solve()&#123; stack&lt;P&gt; S; ll sum = 0; for(int i = 1; i &lt;= n; i++)&#123; //printf("%d %d %lld\n", i, sa[i], sum); int num = 0; while(!S.empty() &amp;&amp; S.top().first &gt;= h[i]) num += S.top().second, sum -= 1ll * S.top().first * S.top().second, S.pop(); if(num) S.push(P&#123;h[i], num&#125;), sum += 1ll * h[i] * num; ans -= 2 * sum; S.push(P&#123;n - sa[i], 1&#125;), sum += n - sa[i]; &#125;&#125;int main()&#123; scanf("%s", ch); n = strlen(ch); for(int i = 0; i &lt; n; i++)s[i] = ch[i] - 'a' + 1; s[n] = 0; dc3(s, sa, n + 1, 30); getheight(); solve(); for(int i = 1; i &lt;= n; i++) ans += 1ll * i * (n - 1); printf("%lld\n", ans); return 0;&#125;]]></content>
      <categories>
        <category>后缀自动机</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[ACM-ICPC-Jiaozuo-Onsite-2018(String-and-Times)]]></title>
    <url>%2F2019%2F02%2F19%2FACM-ICPC-Jiaozuo-Onsite-2018-String-and-Times%2F</url>
    <content type="text"><![CDATA[链接：https://nanti.jisuanke.com/t/A2018思路：发现一般字符串题SA和SAM都能做的时候，总有一个会显得比较简单，这个题就是典型的SAM弱智题，直接建立状态统计一下每个状态的size，然后对所有满足条件的状态求和就行了，但SA这个题就稍微麻烦一点，所以我写一写SA的思想。还是建立SA，然后考虑在height数组上操作，我们把区间转换为大于等于左区间 - 大于等于（右区间 + 1），那么问题转换为了求出现次数大于等于k次的，考虑每次统计一个连续k个的区间，那么我们要减去相邻重复计算的部分，同理右区间也是，把多减的部分加回来，注意RMQ上当l = r的时候，我们实际上是需要出现一次的串的个数，那么我们其实要的是原串长，而height至少都是两两比较，所以这里需要特判比较一下。代码：SA1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 2e5 + 100;char s[maxn];int sa[maxn],t[maxn],t2[maxn],c[maxn],n,m,k;int r[maxn],h[maxn];int d[maxn][20];int a,b;//n为原字符长度，放于s[]的0-n-1位置，s[n]为0，build_sa传入的参数为（n+1，字符范围）void build_sa(int n,int m) &#123;//n为原串长度+1，字符值在0-m-1 int i, *x = t, *y = t2; for (i = 0; i &lt; m; i++)c[i] = 0; for (i = 0; i &lt; n; i++)c[x[i] = s[i]]++; for (i = 1; i &lt; m; i++)c[i] += c[i - 1]; for (i = n - 1; i &gt;= 0; i--)sa[--c[x[i]]] = i; for (int k = 1; k &lt;= n; k &lt;&lt;= 1) &#123; int p = 0; for (i = n - k; i &lt; n; i++)y[p++] = i; for (i = 0; i &lt; n; i++)if (sa[i] &gt;= k)y[p++] = sa[i] - k; for (i = 0; i &lt; m; i++)c[i] = 0; for (i = 0; i &lt; n; i++)c[x[y[i]]]++; for (i = 0; i &lt; m; i++)c[i] += c[i - 1]; for (i = n - 1; i &gt;= 0; i--)sa[--c[x[y[i]]]] = y[i]; swap(x, y); p = 1; x[sa[0]] = 0; for (i = 1; i &lt; n; i++) x[sa[i]] = y[sa[i - 1]] == y[sa[i]] &amp;&amp; y[sa[i - 1] + k] == y[sa[i] + k] ? p - 1 : p++; if (p &gt;= n)break; m = p; &#125;&#125;//最好从0开始，这样sa[n-1] = 0,可以把上一次的数据清空void getheight() &#123; int i, j, k = 0; for (i = 1; i &lt;= n; i++) r[sa[i]] = i; for (i = 0; i &lt; n; h[r[i++]] = k) for (k ? k-- : 0, j = sa[r[i] - 1]; s[i + k] == s[j + k]; k++);&#125;void RMQ_init()&#123; for(int i = 1; i &lt;= n; i++)d[i][0] = h[i]; for(int j = 1; (1 &lt;&lt; j) &lt;= n; j++)&#123; for(int i = 1; i + (1 &lt;&lt; j) &lt;= n + 1; i++)&#123; d[i][j] = min(d[i][j - 1], d[i + (1 &lt;&lt; (j - 1))][j - 1]); &#125; &#125;&#125;int RMQ(int l, int r)&#123; if(l &gt; r) swap(l, r); int k = 0; while((1 &lt;&lt; (k + 1)) &lt;= r - l + 1) k++; return min(d[l][k], d[r - (1 &lt;&lt; k) + 1][k]);&#125;int query(int L, int R)&#123; if(L == R) return n - sa[L]; if(L &gt; R)swap(L, R); L++; return RMQ(L, R);&#125;int main() &#123; while(~scanf("%s %d %d", s, &amp;a, &amp;b))&#123; n = strlen(s); s[n] = 0; build_sa(n + 1, 130); getheight(); ll ans = 0; RMQ_init(); for(int i = 1; i + a - 1 &lt;= n; i++)&#123; ans += query(i, i + a - 1); if(i &gt; 1) ans -= query(i - 1, i + a - 1); if(i + b &lt;= n) ans -= query(i, i + b); if(i &gt; 1 &amp;&amp; i + b &lt;= n) ans += query(i - 1, i + b); &#125; printf("%lld\n", ans); &#125; return 0;&#125; SAM12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include&lt;bits/stdc++.h&gt;#define sigma_size 28using namespace std;const int maxn = 2e5 + 5;const int mod = 1e9 + 7;typedef long long ll;int len[maxn * 2]; //最长子串的长度(该节点字串数量=len[x]-len[f[x]])int f[maxn * 2]; //后缀链接(最短串前部减少一个字符所到达的状态)int cnt[maxn * 2]; //被后缀连接的数int ch[maxn * 2][sigma_size]; //状态转移(尾部加一个字符的下一个状态)(图)int idx; //节点编号int last; //最后节点int epos[maxn * 2]; // enpos数（该状态子串出现数量）char s[maxn];void init() &#123; //初始化 memset(ch, 0, sizeof(ch)); memset(epos, 0, sizeof(epos)); memset(f, 0, sizeof(f)); last = idx = 1; //1表示root起始点 空集 f[1] = len[1] = 0;&#125;//SAM建图void add(int c) &#123; //插入字符，为字符ascll码值 int x = ++idx; //创建一个新节点x; len[x] = len[last] + 1; // 长度等于最后一个节点+1 epos[x] = 1; //接受节点子串除后缀连接还需加一 int p; //第一个有C转移的节点; for (p = last; p &amp;&amp; !ch[p][c]; p = f[p])ch[p][c] = x;//沿着后缀连接 将所有没有字符c转移的节点直接指向新节点 if (!p)f[x] = 1, cnt[1]++; //全部都没有c的转移 直接将新节点后缀连接到起点 else &#123; int q = ch[p][c]; //p通过c转移到的节点 if (len[p] + 1 == len[q]) //pq是连续的 f[x] = q, cnt[q]++; //将新节点后缀连接指向q即可,q节点的被后缀连接数+1 else &#123; int nq = ++idx; //不连续 需要复制一份q节点 len[nq] = len[p] + 1; //令nq与p连续 epos[nq] = 0; f[nq] = f[q]; //因后面link[q]改变此处不加cnt memcpy(ch[nq], ch[q], sizeof(ch[q])); //复制q的信息给nq for (; p &amp;&amp; ch[p][c] == q; p = f[p]) ch[p][c] = nq; //沿着后缀连接 将所有通过c转移为q的改为nq f[q] = f[x] = nq; //将x和q后缀连接改为nq cnt[nq] += 2; // nq增加两个后缀连接 &#125; &#125; last = x; //更新最后处理的节点&#125;void getpos() &#123; //求npos数，即该节点字串出现次数 queue&lt;int&gt; q; for (int i = 1; i &lt;= idx; i++) if (!cnt[i])q.push(i); //将所有没被后缀连接指向的节点入队 while (!q.empty()) &#123; int x = q.front(); q.pop(); epos[f[x]] += epos[x]; //子串数量等于所有后缀连接指向该节点的子串数量和+是否为接受节点 if (--cnt[f[x]] == 0)q.push(f[x]); //当所有后缀连接指向该节点的处理完毕后再入队 &#125;&#125;int main() &#123; while(~scanf("%s", s))&#123; int a, b; scanf("%d %d", &amp;a, &amp;b); init(); int x = strlen(s); for(int i = 0; i &lt; x; i++)add(s[i] - 'A'); getpos(); ll ans = 0; for(int i = 1; i &lt;= idx; i++)if(epos[i] &gt;= a &amp;&amp; epos[i] &lt;= b)ans += (len[i] - len[f[i]]); printf("%lld\n", ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>后缀数组</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[bzoj-4566(找相同字符)]]></title>
    <url>%2F2019%2F02%2F19%2Fbzoj-4566-%E6%89%BE%E7%9B%B8%E5%90%8C%E5%AD%97%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[链接：https://www.lydsy.com/JudgeOnline/problem.php?id=4566思路：众所周知可以用sa + 单调栈维护前缀和来算。后缀自动机的话用第一个串建SAM，用第二个串去上面跑，我们考虑到某一个状态的方案数等于他前面已经匹配的方案数 + 重复次数 该状态串个数，所以我们拓扑排序先预处理出每个状态的和，然后跑的时候跟求最长公共子串是一样的，每一个匹配成功对答案的贡献是之前的父节点的答案 + （当前匹配长度 - 最短串长度 + 1） 出现次数，统计答案即可。代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081 #include&lt;bits/stdc++.h&gt;#define sigma_size 28using namespace std;const int maxn = 2e5 + 5;const int mod = 1e9 + 7;typedef long long ll;int len[maxn * 2]; //最长子串的长度(该节点字串数量=len[x]-len[f[x]])int f[maxn * 2]; //后缀链接(最短串前部减少一个字符所到达的状态)int cnt[maxn * 2]; //被后缀连接的数int ch[maxn * 2][sigma_size]; //状态转移(尾部加一个字符的下一个状态)(图)int idx; //节点编号int last; //最后节点ll epos[maxn * 2]; // enpos数（该状态子串出现数量）char s[maxn];int c[maxn * 2], a[maxn * 2];ll sum[maxn * 2]; void init() &#123; //初始化 last = idx = 1; //1表示root起始点 空集 f[1] = len[1] = 0; memset(ch[1], 0, sizeof(ch[1]));&#125; //SAM建图void add(int c) &#123; //插入字符，为字符ascll码值 int x = ++idx; //创建一个新节点x; len[x] = len[last] + 1; // 长度等于最后一个节点+1 epos[x] = 1; //接受节点子串除后缀连接还需加一 int p; //第一个有C转移的节点; for (p = last; p &amp;&amp; !ch[p][c]; p = f[p])ch[p][c] = x;//沿着后缀连接 将所有没有字符c转移的节点直接指向新节点 if (!p)f[x] = 1, cnt[1]++; //全部都没有c的转移 直接将新节点后缀连接到起点 else &#123; int q = ch[p][c]; //p通过c转移到的节点 if (len[p] + 1 == len[q]) //pq是连续的 f[x] = q, cnt[q]++; //将新节点后缀连接指向q即可,q节点的被后缀连接数+1 else &#123; int nq = ++idx; //不连续 需要复制一份q节点 len[nq] = len[p] + 1; //令nq与p连续 f[nq] = f[q]; //因后面link[q]改变此处不加cnt memcpy(ch[nq], ch[q], sizeof(ch[q])); //复制q的信息给nq for (; p &amp;&amp; ch[p][c] == q; p = f[p]) ch[p][c] = nq; //沿着后缀连接 将所有通过c转移为q的改为nq f[q] = f[x] = nq; //将x和q后缀连接改为nq cnt[nq] += 2; // nq增加两个后缀连接 &#125; &#125; last = x; //更新最后处理的节点&#125; void solve()&#123; for(int i = 1; i &lt;= idx; i++)c[len[i]]++; for(int i = 1; i &lt;= idx; i++)c[i] += c[i - 1]; for(int i = idx; i; i--)a[c[len[i]]--] = i; for(int i = idx; i; i--)epos[f[a[i]]] += epos[a[i]]; for(int i = 1; i &lt;= idx; i++)sum[a[i]] = sum[f[a[i]]] + epos[a[i]] * (len[a[i]] - len[f[a[i]]]);&#125; int main() &#123; scanf("%s", s); init(); int x = strlen(s); for(int i = 0; i &lt; x; i++)add(s[i] - 'a'); solve(); scanf("%s", s); x = strlen(s); int p = 1, l = 0; ll ans = 0; for(int i = 0; i &lt; x; i++)&#123; int ne = s[i] - 'a'; if(ch[p][ne])l++, p = ch[p][ne]; else&#123; while(p &amp;&amp; !ch[p][ne]) p = f[p]; if(!p) p = 1, l = 0; else l = len[p] + 1, p = ch[p][ne]; &#125; ans += sum[f[p]] + epos[p] * (l - len[f[p]]); &#125; printf("%lld\n", ans); return 0;&#125; 顺手附上SA的做法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include &lt;bits/stdc++.h&gt;#define F(x) ((x) / 3 + ((x) % 3 == 1 ? 0 : tb))#define G(x) ((x) &lt; tb ? (x) * 3 + 1 : ((x) - tb) * 3 + 2)using namespace std;const int maxn = 2000005;typedef pair&lt;int, int&gt; P;typedef long long ll;int wa[maxn], wb[maxn], wc[maxn], wv[maxn], sa[3 * maxn];int r[maxn], h[maxn], s[3 * maxn];char ch[maxn];int n;int t; int c0(int *s, int a, int b) &#123; return s[a] == s[b] &amp;&amp; s[a + 1] == s[b + 1] &amp;&amp; s[a + 2] == s[b + 2];&#125; int c12(int k, int *s, int a, int b) &#123; if (k == 2) return s[a] &lt; s[b] || s[a] == s[b] &amp;&amp; c12(1, s, a + 1, b + 1); return s[a] &lt; s[b] || s[a] == s[b] &amp;&amp; wv[a + 1] &lt; wv[b + 1];&#125; void sort(int *s, int *a, int *b, int n, int m) &#123; for (int i = 0; i &lt; n; i++) wv[i] = s[a[i]]; for (int i = 0; i &lt; m; i++) wc[i] = 0; for (int i = 0; i &lt; n; i++) wc[wv[i]]++; for (int i = 1; i &lt; m; i++) wc[i] += wc[i - 1]; for (int i = n - 1; i &gt;= 0; i--) b[--wc[wv[i]]] = a[i];&#125; void dc3(int *s, int *sa, int n, int m) &#123; int i, j, *sn = s + n, *san = sa + n, ta = 0, tb = (n + 1) / 3, tbc = 0, p; s[n] = s[n + 1] = 0; for (i = 0; i &lt; n; i++) if (i % 3 != 0) wa[tbc++] = i; sort(s + 2, wa, wb, tbc, m); sort(s + 1, wb, wa, tbc, m); sort(s, wa, wb, tbc, m); for (p = 1, sn[F(wb[0])] = 0, i = 1; i &lt; tbc; i++) sn[F(wb[i])] = c0(s, wb[i - 1], wb[i]) ? p - 1 : p++; if (p &lt; tbc) dc3(sn, san, tbc, p); else for (i = 0; i &lt; tbc; i++) san[sn[i]] = i; for (i = 0; i &lt; tbc; i++) if (san[i] &lt; tb) wb[ta++] = san[i] * 3; if (n % 3 == 1) wb[ta++] = n - 1; sort(s, wb, wa, ta, m); for (i = 0; i &lt; tbc; i++) wv[wb[i] = G(san[i])] = i; for (i = 0, j = 0, p = 0; i &lt; ta &amp;&amp; j &lt; tbc; p++) sa[p] = c12(wb[j] % 3, s, wa[i], wb[j]) ? wa[i++] : wb[j++]; for (; i &lt; ta; p++) sa[p] = wa[i++]; for (; j &lt; tbc; p++) sa[p] = wb[j++];&#125; void getheight() &#123; int i, j, k = 0; for (i = 1; i &lt;= n; i++) r[sa[i]] = i; for (i = 0; i &lt; n; h[r[i++]] = k) for (k ? k-- : 0, j = sa[r[i] - 1]; s[i + k] == s[j + k]; k++);&#125; void solve()&#123; stack&lt;P&gt; S; ll ans = 0; ll sum = 0; for(int i = 1; i &lt;= n; i++)&#123; int num = 0; while(!S.empty() &amp;&amp; h[i] &lt;= S.top().first) num += S.top().second, sum -= 1LL * S.top().first * S.top().second, S.pop(); if(num) S.push(P&#123;h[i], num&#125;), sum += 1LL * num * h[i]; if(sa[i] &gt; t) S.push(P&#123;n - sa[i], 1&#125;), sum += n - sa[i]; if(sa[i] &lt; t) ans += sum; &#125; while(!S.empty())S.pop(); sum = 0; for(int i = 1; i &lt;= n; i++)&#123; int num = 0; while(!S.empty() &amp;&amp; h[i] &lt;= S.top().first) num += S.top().second, sum -= 1LL * S.top().first * S.top().second, S.pop(); if(num) S.push(P&#123;h[i], num&#125;), sum += 1LL * num * h[i]; if(sa[i] &lt; t) S.push(P&#123;n - sa[i], 1&#125;), sum += n - sa[i]; if(sa[i] &gt; t) ans += sum; &#125; printf("%lld\n", ans);&#125; int main()&#123; scanf("%s", ch); int x = strlen(ch); for(int i = 0; i &lt; x; i++)s[n++] = ch[i] - 'a' + 1; t = n; s[n++] = 30; scanf("%s", ch); x = strlen(ch); for(int i = 0; i &lt; x; i++)s[n++] = ch[i] - 'a' + 1; s[n] = 0; dc3(s, sa, n + 1, 40); getheight(); solve(); return 0;&#125; 补一个广义SAM的做法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include&lt;bits/stdc++.h&gt;using namespace std; #define sigma_size 26 const int maxn = 5e5 + 5;typedef long long ll;int len[maxn * 2]; //最长子串的长度(该节点字串数量=len[x]-len[f[x]])int f[maxn * 2]; //后缀链接(最短串前部减少一个字符所到达的状态)int cnt[maxn * 2]; //被后缀连接的数int ch[maxn * 2][sigma_size]; //状态转移(尾部加一个字符的下一个状态)(图)int idx; //节点编号int epos[2][maxn * 2]; // enpos数（该状态子串出现数量）int n;char s[maxn];int last;ll res; void init() &#123; //初始化 idx = last = 1; //1表示root起始点 空集 f[1] = len[1] = 0; memset(ch[1], 0, sizeof(ch[1]));&#125; //SAM建图int add(int c, int t) &#123; //插入字符，为字符ascll码值 int x = ++idx; //创建一个新节点x; len[x] = len[last] + 1; // 长度等于最后一个节点+1 epos[t][x] = 1; //接受节点子串除后缀连接还需加一 int p; //第一个有C转移的节点; for (p = last; p &amp;&amp; !ch[p][c]; p = f[p])ch[p][c] = x;//沿着后缀连接 将所有没有字符c转移的节点直接指向新节点 if (!p)f[x] = 1, cnt[1]++; //全部都没有c的转移 直接将新节点后缀连接到起点 else &#123; int q = ch[p][c]; //p通过c转移到的节点 if (len[p] + 1 == len[q]) //pq是连续的 f[x] = q, cnt[q]++; //将新节点后缀连接指向q即可,q节点的被后缀连接数+1 else &#123; int nq = ++idx; //不连续 需要复制一份q节点 len[nq] = len[p] + 1; //令nq与p连续 f[nq] = f[q]; //因后面link[q]改变此处不加cnt memcpy(ch[nq], ch[q], sizeof(ch[q])); //复制q的信息给nq for (; p &amp;&amp; ch[p][c] == q; p = f[p]) ch[p][c] = nq; //沿着后缀连接 将所有通过c转移为q的改为nq f[q] = f[x] = nq; //将x和q后缀连接改为nq cnt[nq] += 2; // nq增加两个后缀连接 &#125; &#125; last = x; //更新最后处理的节点 return last;&#125; void getpos() &#123; //求npos数，即该节点字串出现次数 queue&lt;int&gt; q; for (int i = 1; i &lt;= idx; i++) if (!cnt[i])q.push(i); //将所有没被后缀连接指向的节点入队 while (!q.empty()) &#123; int x = q.front(); q.pop(); epos[0][f[x]] += epos[0][x];//子串数量等于所有后缀连接指向该节点的子串数量和+是否为接受节点 epos[1][f[x]] += epos[1][x]; res += 1ll * epos[0][x] * epos[1][x] * (len[x] - len[f[x]]); if (--cnt[f[x]] == 0)q.push(f[x]); //当所有后缀连接指向该节点的处理完毕后再入队 &#125;&#125; int main()&#123; init(); scanf("%s", s); n = strlen(s); for(int i = 0; i &lt; n; i++) add(s[i] - 'a', 0); scanf("%s", s); n = strlen(s); last = 1; for(int i = 0; i &lt; n; i++) add(s[i] - 'a', 1); getpos(); printf("%lld\n", res); return 0;&#125;]]></content>
      <categories>
        <category>后缀自动机</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[洛谷-P1368(工艺)]]></title>
    <url>%2F2019%2F02%2F18%2F%E6%B4%9B%E8%B0%B7-P1368-%E5%B7%A5%E8%89%BA%2F</url>
    <content type="text"><![CDATA[链接：https://www.luogu.org/problemnew/show/P1368思路：最大最小表示法我们在字符串中已经知道有一种求法了，其实用后缀自动机也可以做，我们考虑其实循环表示是一个环，而环最常用的套路就是破环为链，我们把串复制一遍然后建自动机，只用在后缀自动机上贪心走就行了。注意要开四倍空间代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 6e5 + 100;const int mod = 1e9 + 7;typedef long long ll;int len[maxn * 2]; //最长子串的长度(该节点字串数量=len[x]-len[f[x]])int f[maxn * 2]; //后缀链接(最短串前部减少一个字符所到达的状态)int cnt[maxn * 2]; //被后缀连接的数map&lt;int, int&gt; ch[maxn * 2]; //状态转移(尾部加一个字符的下一个状态)(图)int idx; //节点编号int last; //最后节点int n;int a[maxn];void init() &#123; //初始化 last = idx = 1; //1表示root起始点 空集 f[1] = len[1] = 0; ch-&gt;clear();&#125;//SAM建图void add(int c) &#123; //插入字符，为字符ascll码值 int x = ++idx; //创建一个新节点x; len[x] = len[last] + 1; // 长度等于最后一个节点+1 int p; //第一个有C转移的节点; for (p = last; p &amp;&amp; !ch[p][c]; p = f[p])ch[p][c] = x;//沿着后缀连接 将所有没有字符c转移的节点直接指向新节点 if (!p)f[x] = 1, cnt[1]++; //全部都没有c的转移 直接将新节点后缀连接到起点 else &#123; int q = ch[p][c]; //p通过c转移到的节点 if (len[p] + 1 == len[q]) //pq是连续的 f[x] = q, cnt[q]++; //将新节点后缀连接指向q即可,q节点的被后缀连接数+1 else &#123; int nq = ++idx; //不连续 需要复制一份q节点 len[nq] = len[p] + 1; //令nq与p连续 f[nq] = f[q]; //因后面link[q]改变此处不加cnt ch[nq] = ch[q]; for (; p &amp;&amp; ch[p][c] == q; p = f[p]) ch[p][c] = nq; //沿着后缀连接 将所有通过c转移为q的改为nq f[q] = f[x] = nq; //将x和q后缀连接改为nq cnt[nq] += 2; // nq增加两个后缀连接 &#125; &#125; last = x; //更新最后处理的节点&#125;int main() &#123; init(); scanf("%d", &amp;n); for(int i = 1; i &lt;= n; i++)&#123; scanf("%d", &amp;a[i]); add(a[i]); &#125; for(int i = 1; i &lt;= n; i++)&#123; add(a[i]); &#125; int p = 1; map&lt;int, int&gt;::iterator it; for(int i = 1; i &lt;= n; i++)&#123; it = ch[p].begin(); p = it-&gt;second; printf("%d%c", it-&gt;first, i == n ? '\n' : ' '); &#125; return 0;&#125;]]></content>
      <categories>
        <category>后缀自动机</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[hihocoder-1457(后缀自动机四·重复旋律7)]]></title>
    <url>%2F2019%2F02%2F18%2Fhihocoder-1457-%E5%90%8E%E7%BC%80%E8%87%AA%E5%8A%A8%E6%9C%BA%E5%9B%9B%C2%B7%E9%87%8D%E5%A4%8D%E6%97%8B%E5%BE%8B7%2F</url>
    <content type="text"><![CDATA[链接：http://hihocoder.com/problemset/problem/1457思路：不得不感慨hihocoder上后缀自动机的讲解真的还挺到位的，这个题又是对转移的应用。考虑后缀自动机本身就是个DAG，且上面每一条路径都代表一个字串，这种多字符串问题一般都是要把字符串串起来，然后我们考虑在后缀自动机上面走，因为一个状态由其他状态转移过来，计算答案就等于Σ（之前答案 10 + 当前状态串的个数 转移字符），但是由于中间有间隔字符，间隔字符我们不转移，所以当前串的个数还要减去有间隔字符不合法的，所以我们考虑维护一个合法的转移数，那么又是一个典型的拓扑排序问题了，从所有入度为0的点开始沿着非间隔字符转移，并且统计每个点的合法转移数，再根据公式求最后答案即可。代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122#include&lt;bits/stdc++.h&gt;#define sigma_size 15using namespace std;const int maxn = 1e6 + 10000;const int mod = 1e9 + 7;typedef long long ll;int len[maxn * 2]; //最长子串的长度(该节点字串数量=len[x]-len[f[x]])int f[maxn * 2]; //后缀链接(最短串前部减少一个字符所到达的状态)int cnt[maxn * 2]; //被后缀连接的数int ch[maxn * 2][sigma_size]; //状态转移(尾部加一个字符的下一个状态)(图)int idx; //节点编号int last; //最后节点ll epos[maxn * 2]; // enpos数（该状态子串出现数量）char s[maxn];ll a[maxn]; //长度为i的子串出现最大次数int n;int deg[maxn * 2];ll val[maxn * 2];int sum[maxn * 2];void init() &#123; //初始化 last = idx = 1; //1表示root起始点 空集 f[1] = len[1] = 0; memset(ch[1], 0, sizeof(ch[1]));&#125;//SAM建图void add(int c) &#123; //插入字符，为字符ascll码值 int x = ++idx; //创建一个新节点x; len[x] = len[last] + 1; // 长度等于最后一个节点+1 epos[x] = 1; //接受节点子串除后缀连接还需加一 int p; //第一个有C转移的节点; for (p = last; p &amp;&amp; !ch[p][c]; p = f[p])ch[p][c] = x;//沿着后缀连接 将所有没有字符c转移的节点直接指向新节点 if (!p)f[x] = 1, cnt[1]++; //全部都没有c的转移 直接将新节点后缀连接到起点 else &#123; int q = ch[p][c]; //p通过c转移到的节点 if (len[p] + 1 == len[q]) //pq是连续的 f[x] = q, cnt[q]++; //将新节点后缀连接指向q即可,q节点的被后缀连接数+1 else &#123; int nq = ++idx; //不连续 需要复制一份q节点 len[nq] = len[p] + 1; //令nq与p连续 f[nq] = f[q]; //因后面link[q]改变此处不加cnt memcpy(ch[nq], ch[q], sizeof(ch[q])); //复制q的信息给nq for (; p &amp;&amp; ch[p][c] == q; p = f[p]) ch[p][c] = nq; //沿着后缀连接 将所有通过c转移为q的改为nq f[q] = f[x] = nq; //将x和q后缀连接改为nq cnt[nq] += 2; // nq增加两个后缀连接 &#125; &#125; last = x; //更新最后处理的节点&#125;void getpos() &#123; //求npos数，即该节点字串出现次数 queue&lt;int&gt; q; for (int i = 1; i &lt;= idx; i++) if (!cnt[i])q.push(i); //将所有没被后缀连接指向的节点入队 while (!q.empty()) &#123; int x = q.front(); q.pop(); epos[f[x]] += epos[x]; //子串数量等于所有后缀连接指向该节点的子串数量和+是否为接受节点 if (--cnt[f[x]] == 0)q.push(f[x]); //当所有后缀连接指向该节点的处理完毕后再入队 &#125;&#125;void getsubnum() &#123; //求不相同字串数量 ll ans = 0; for (int i = 2; i &lt;= idx; i++)ans += len[i] - len[f[i]]; //一状态子串数量等于len[i]-len[f[i]] printf("%lld\n", ans);&#125;void getsubmax() &#123; //求出所有长度为k的子串中出现次数最多的子串出现次数 getpos(); int n = strlen(s); for (int i = 1; i &lt;= idx; i++)a[len[i]] = max(a[len[i]], epos[i]); //长度≤k的子串中出现次数最多的子串出现次数的最小值 for (int i = n - 1; i &gt;= 1; i--)a[i] = max(a[i], a[i + 1]); //求一遍后缀最大值就是答案 for (int i = 1; i &lt;= n; i++)printf("%lld\n", a[i]);&#125;void getdeg()&#123; for(int i = 1; i &lt;= idx; i++)&#123; for(int j = 0; j &lt; sigma_size; j++)&#123; int v = ch[i][j]; if(v)deg[v]++; &#125; &#125;&#125;ll bfs()&#123; getdeg(); queue&lt;int&gt; q; for(int i = 1; i &lt;= idx; i++)if(!deg[i])q.push(i); sum[1] = 1; while(!q.empty())&#123; int u = q.front(); q.pop(); for(int i = 0; i &lt; sigma_size; i++)&#123; int v = ch[u][i]; if(!v)continue; deg[v]--; if(!deg[v])q.push(v); if(i == 10)continue; val[v] = (val[v] + val[u] * 10 + 1LL * sum[u] * i) % mod; sum[v] += sum[u]; &#125; &#125; ll ans = 0; for(int i = 1; i &lt;= idx; i++)ans = (ans + val[i]) % mod; return ans;&#125;int main() &#123; scanf("%d", &amp;n); init(); while(n--)&#123; scanf("%s", s); int x = strlen(s); for(int i = 0; i &lt; x; i++)add(s[i] - '0'); if(n)add(10); &#125; printf("%lld\n", bfs()); return 0;&#125;]]></content>
      <categories>
        <category>后缀自动机</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[hihocoder-1449(后缀自动机三·重复旋律6)]]></title>
    <url>%2F2019%2F02%2F18%2Fhihocoder-1449-%E5%90%8E%E7%BC%80%E8%87%AA%E5%8A%A8%E6%9C%BA%E4%B8%89%C2%B7%E9%87%8D%E5%A4%8D%E6%97%8B%E5%BE%8B6%2F</url>
    <content type="text"><![CDATA[链接：http://hihocoder.com/problemset/problem/1449思路：这个题也是充分利用了后缀自动机的性质，后缀自动机的后缀链接表示的是最短串前部减少一个字符能到达的状态，也就是说对于一个状态中的最长串，一定是由一些后缀链接连过来的，那么该子串的出现次数就等于后缀链接的数量 + 是否为新建的结点，然后我们用后缀链接来一次拓扑排序，求出所有状态最长串的出现次数，接着我们只用更新每个状态最长串的出现的重复次数就行了，然后从大到小跟前面求最大就行了（因为比如一个长度为k的串出现了x次，那么长度为k-1的串至少出现k次，所以我们倒着求最大值即可）。代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include&lt;bits/stdc++.h&gt;#define sigma_size 28using namespace std;const int maxn = 1e6 + 5;const int mod = 1e9 + 7;typedef long long ll;int len[maxn * 2]; //最长子串的长度(该节点字串数量=len[x]-len[f[x]])int f[maxn * 2]; //后缀链接(最短串前部减少一个字符所到达的状态)int cnt[maxn * 2]; //被后缀连接的数int ch[maxn * 2][sigma_size]; //状态转移(尾部加一个字符的下一个状态)(图)int idx; //节点编号int last; //最后节点ll epos[maxn * 2]; // enpos数（该状态子串出现数量）char s[maxn];ll a[maxn]; //长度为i的子串出现最大次数void init() &#123; //初始化 last = idx = 1; //1表示root起始点 空集 f[1] = len[1] = 0; memset(ch[1], 0, sizeof(ch[1]));&#125;//SAM建图void add(int c) &#123; //插入字符，为字符ascll码值 int x = ++idx; //创建一个新节点x; len[x] = len[last] + 1; // 长度等于最后一个节点+1 epos[x] = 1; //接受节点子串除后缀连接还需加一 int p; //第一个有C转移的节点; for (p = last; p &amp;&amp; !ch[p][c]; p = f[p])ch[p][c] = x;//沿着后缀连接 将所有没有字符c转移的节点直接指向新节点 if (!p)f[x] = 1, cnt[1]++; //全部都没有c的转移 直接将新节点后缀连接到起点 else &#123; int q = ch[p][c]; //p通过c转移到的节点 if (len[p] + 1 == len[q]) //pq是连续的 f[x] = q, cnt[q]++; //将新节点后缀连接指向q即可,q节点的被后缀连接数+1 else &#123; int nq = ++idx; //不连续 需要复制一份q节点 len[nq] = len[p] + 1; //令nq与p连续 f[nq] = f[q]; //因后面link[q]改变此处不加cnt memcpy(ch[nq], ch[q], sizeof(ch[q])); //复制q的信息给nq for (; p &amp;&amp; ch[p][c] == q; p = f[p]) ch[p][c] = nq; //沿着后缀连接 将所有通过c转移为q的改为nq f[q] = f[x] = nq; //将x和q后缀连接改为nq cnt[nq] += 2; // nq增加两个后缀连接 &#125; &#125; last = x; //更新最后处理的节点&#125;void getpos() &#123; //求npos数，即该节点字串出现次数 queue&lt;int&gt; q; for (int i = 1; i &lt;= idx; i++) if (!cnt[i])q.push(i); //将所有没被后缀连接指向的节点入队 while (!q.empty()) &#123; int x = q.front(); q.pop(); epos[f[x]] += epos[x]; //子串数量等于所有后缀连接指向该节点的子串数量和+是否为接受节点 if (--cnt[f[x]] == 0)q.push(f[x]); //当所有后缀连接指向该节点的处理完毕后再入队 &#125;&#125;void getsubnum() &#123; //求不相同字串数量 ll ans = 0; for (int i = 2; i &lt;= idx; i++)ans += len[i] - len[f[i]]; //一状态子串数量等于len[i]-len[f[i]] printf("%lld\n", ans);&#125;void getsubmax() &#123; //求出所有长度为k的子串中出现次数最多的子串出现次数 getpos(); int n = strlen(s); for (int i = 1; i &lt;= idx; i++)a[len[i]] = max(a[len[i]], epos[i]); //长度≤k的子串中出现次数最多的子串出现次数的最小值 for (int i = n - 1; i &gt;= 1; i--)a[i] = max(a[i], a[i + 1]); //求一遍后缀最大值就是答案 for (int i = 1; i &lt;= n; i++)printf("%lld\n", a[i]);&#125;int main() &#123; scanf("%s", s); int n = strlen(s); init(); for(int i = 0; i &lt; n; i++)add(s[i] - 'a'); getsubmax(); return 0;&#125;]]></content>
      <categories>
        <category>后缀自动机</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[hihocode-1445(后缀自动机二·重复旋律5)]]></title>
    <url>%2F2019%2F02%2F18%2Fhihocode-1445-%E5%90%8E%E7%BC%80%E8%87%AA%E5%8A%A8%E6%9C%BA%E4%BA%8C%C2%B7%E9%87%8D%E5%A4%8D%E6%97%8B%E5%BE%8B5%2F</url>
    <content type="text"><![CDATA[链接：http://hihocoder.com/problemset/problem/1445思路：题目求本质不同的子串数目，我们知道可以用后缀数组做，求一下所有的n - sa[i] - h[i]的和就行了，但我们现在考虑用后缀自动机去做这个题。我们知道每一个状态表示的是所有endpos相同的子串的集合，如果是相同的子串肯定属于同一个endpos，如果属于同一个endpos且是本质不同的子串那么他们的长度一定不同，所以我们想到只用统计每一个状态的字符串总数即可。又因为每一个状态是一段连续的后缀，我们只用用其中最大的长度-最小长度就可以得到一个状态的字符串数量，即len[v] - len[f[v]]，求和即可代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include&lt;bits/stdc++.h&gt;#define sigma_size 28using namespace std;const int maxn = 1e6 + 5;const int mod = 1e9 + 7;typedef long long ll;int len[maxn * 2]; //最长子串的长度(该节点字串数量=len[x]-len[f[x]])int f[maxn * 2]; //后缀链接(最短串前部减少一个字符所到达的状态)int cnt[maxn * 2]; //被后缀连接的数int ch[maxn * 2][sigma_size]; //状态转移(尾部加一个字符的下一个状态)(图)int idx; //节点编号int last; //最后节点ll epos[maxn * 2]; // enpos数（该状态子串出现数量）char s[maxn];ll a[maxn]; //长度为i的子串出现最大次数void init() &#123; //初始化 last = idx = 1; //1表示root起始点 空集 f[1] = len[1] = 0; memset(ch[1], 0, sizeof(ch[1]));&#125;//SAM建图void add(int c) &#123; //插入字符，为字符ascll码值 int x = ++idx; //创建一个新节点x; len[x] = len[last] + 1; // 长度等于最后一个节点+1 epos[x] = 1; //接受节点子串除后缀连接还需加一 int p; //第一个有C转移的节点; for (p = last; p &amp;&amp; !ch[p][c]; p = f[p])ch[p][c] = x;//沿着后缀连接 将所有没有字符c转移的节点直接指向新节点 if (!p)f[x] = 1, cnt[1]++; //全部都没有c的转移 直接将新节点后缀连接到起点 else &#123; int q = ch[p][c]; //p通过c转移到的节点 if (len[p] + 1 == len[q]) //pq是连续的 f[x] = q, cnt[q]++; //将新节点后缀连接指向q即可,q节点的被后缀连接数+1 else &#123; int nq = ++idx; //不连续 需要复制一份q节点 len[nq] = len[p] + 1; //令nq与p连续 f[nq] = f[q]; //因后面link[q]改变此处不加cnt memcpy(ch[nq], ch[q], sizeof(ch[q])); //复制q的信息给nq for (; p &amp;&amp; ch[p][c] == q; p = f[p]) ch[p][c] = nq; //沿着后缀连接 将所有通过c转移为q的改为nq f[q] = f[x] = nq; //将x和q后缀连接改为nq cnt[nq] += 2; // nq增加两个后缀连接 &#125; &#125; last = x; //更新最后处理的节点&#125;void getpos() &#123; //求npos数，即该节点字串出现次数 queue&lt;int&gt; q; for (int i = 1; i &lt;= idx; i++) if (!cnt[i])q.push(i); //将所有没被后缀连接指向的节点入队 while (!q.empty()) &#123; int x = q.front(); q.pop(); epos[f[x]] += epos[x]; //子串数量等于所有后缀连接指向该节点的子串数量和+是否为接受节点 if (--cnt[f[x]] == 0)q.push(f[x]); //当所有后缀连接指向该节点的处理完毕后再入队 &#125;&#125;void getsubnum() &#123; //求不相同字串数量 ll ans = 0; for (int i = 2; i &lt;= idx; i++)ans += len[i] - len[f[i]]; //一状态子串数量等于len[i]-len[f[i]] printf("%lld\n", ans);&#125;void getsubmax() &#123; //求出所有长度为k的子串中出现次数最多的子串出现次数 getpos(); int n = strlen(s); for (int i = 1; i &lt;= idx; i++)a[len[i]] = max(a[len[i]], epos[i]); //长度≤k的子串中出现次数最多的子串出现次数的最小值 for (int i = n - 1; i &gt;= 1; i--)a[i] = max(a[i], a[i + 1]); //求一遍后缀最大值就是答案 for (int i = 1; i &lt;= n; i++)printf("%lld\n", a[i]);&#125;int main() &#123; scanf("%s", s); int n = strlen(s); init(); for(int i = 0; i &lt; n; i++)add(s[i] - 'a'); getsubnum(); return 0;&#125;]]></content>
      <categories>
        <category>后缀自动机</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2018-2019-ACM-ICPC-Asia-Jiaozuo-Regional-Contest-J(Carpets-Removal)]]></title>
    <url>%2F2019%2F02%2F17%2F2018-2019-ACM-ICPC-Asia-Jiaozuo-Regional-Contest-J-Carpets-Removal%2F</url>
    <content type="text"><![CDATA[链接：https://codeforces.com/gym/102028/problem/J思路：mm的正方形中有n个毯子，拿走2个问最小覆盖面积是多少，我们转换为能拿走的最大面积是多少。我们注意到mm比较小，我们考虑到，覆盖0和2次以上的地砖不用考虑，不会因为毯子拿走而改变覆盖状态，我们只用考虑覆盖1次和覆盖2次的，但我们又不能直接去查询是哪个毯子覆盖的，我们考虑二维的差分了，维护一个覆盖此数，维护一个毯子编号的和，这时候我们可以得出覆盖1次的是被哪个毯子覆盖了，但两次的还是不行，我们这时候就需要玩点技巧了，再维护一个平方和，这样我们可以由和与平方和得出覆盖两次毯子的编号，那么我们再开一个map维护一下覆盖两次的次数，最终答案要吗是有重叠的要吗是覆盖一次中覆盖最多的两个毯子，最后计算出结果即可。代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 1510;int cnt[maxn][maxn];ll sum[maxn][maxn], mul[maxn][maxn];int id[300010];int num[300010];map&lt;pair&lt;int, int&gt;, int&gt; n2;int idx;int n, m;void init()&#123; for(int i = 1; i &lt;= m + 1; i++) for(int j = 1; j &lt;= m + 1; j++) cnt[i][j] = sum[i][j] = mul[i][j] = 0; n2.clear(); for(int i = 1; i &lt;= n + 1; i++)id[i] = 0; for(int i = 1; i &lt;= idx + 1; i++)num[i] = 0; idx = 0;&#125;//二维差分void change(int xl, int xr, int yl, int yr, ll d)&#123; ++cnt[xl][yl], --cnt[xl][yr + 1], --cnt[xr + 1][yl], ++cnt[xr + 1][yr + 1]; sum[xl][yl] += d, sum[xl][yr + 1] -= d, sum[xr + 1][yl] -= d, sum[xr + 1][yr + 1] += d; mul[xl][yl] += d * d, mul[xl][yr + 1] -= d * d, mul[xr + 1][yl] -= d * d, mul[xr + 1][yr + 1] += d * d;&#125;int T;int main()&#123; scanf("%d", &amp;T); while(T--) &#123; init(); scanf("%d %d", &amp;n, &amp;m); for (int i = 1; i &lt;= n; i++)&#123; int a, b, c, d; scanf("%d %d %d %d", &amp;a, &amp;b, &amp;c, &amp;d); change(a, b, c, d, i); &#125; int pre = 0; int ans = 0; for(int i = 1; i &lt;= m; i++) &#123; for (int j = 1; j &lt;= m; j++) &#123; //二维前缀和 cnt[i][j] += cnt[i - 1][j] + cnt[i][j - 1] - cnt[i - 1][j - 1]; sum[i][j] += sum[i - 1][j] + sum[i][j - 1] - sum[i - 1][j - 1]; mul[i][j] += mul[i - 1][j] + mul[i][j - 1] - mul[i - 1][j - 1]; if(cnt[i][j])pre++; if(cnt[i][j] == 1)&#123; if(!id[sum[i][j]])id[sum[i][j]] = ++idx; num[id[sum[i][j]]]++; continue; &#125; &#125; &#125; for(int i = 1; i &lt;= m; i++)&#123; for(int j = 1; j &lt;= m; j++)&#123; if(cnt[i][j] == 2)&#123; ll d = sqrt(2 * mul[i][j] - sum[i][j] * sum[i][j] + 0.5); ll id1 = d + sum[i][j] &gt;&gt; 1; ll id2 = sum[i][j] - d &gt;&gt; 1; if(!id[id1])id[id1] = ++idx; if(!id[id2])id[id2] = ++idx; int x1 = id[id1]; int x2 = id[id2]; if(x1 &gt; x2)swap(x1, x2); int r = ++n2[make_pair(x1, x2)]; //边算边统计不然最后不好统计。 ans = max(ans, num[x1] + num[x2] + r); continue; &#125; &#125; &#125; sort(num + 1, num + 1 + idx); ans = max(ans, num[idx] + num[idx - 1]); printf("%d\n", pre - ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>差分</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[POJ-2758(Checking-the-Text)]]></title>
    <url>%2F2019%2F02%2F16%2FPOJ-2758-Checking-the-Text%2F</url>
    <content type="text"><![CDATA[链接：https://vjudge.net/problem/POJ-2758思路：本来是个后缀数组的题，但这个题用后缀数组实在是没太大意义，就顺手用hash练练手吧。反正每次就暴力重算hash函数，然后更新一下下标位置，每次询问二分答案即可。代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;typedef unsigned long long ull;const int maxn = 1e5;ull h[maxn];ull bin[maxn];const int base = 131;char s[maxn];int pos[maxn];int n, m;void init()&#123; h[0] = 0; bin[0] = 1; n = strlen(s + 1); for(int i = 1; i &lt;= n; i++)h[i] = h[i - 1] * base + s[i]; for(int i = 1; i &lt; maxn; i++)bin[i] = bin[i - 1] * base, pos[i] = i;&#125;void change(char c, int x)&#123; for(int i = n + 1; i &gt; x; i--)s[i] = s[i - 1]; s[x] = c; n++; for(int i = x; i &lt;= n; i++)h[i] = h[i - 1] * base + s[i]; for(int i = n; i &gt;= 1; i--)if(pos[i] &gt;= x)pos[i]++; else break;&#125;ull get(int l, int r)&#123; return h[r] - h[l - 1] * bin[r - l + 1];&#125;int solve(int l, int r)&#123; if(l &gt; r)swap(l, r); int lb = 0; int ub = n - r + 1; int ans = 0; while(ub &gt;= lb)&#123; int mid = ub + lb &gt;&gt; 1; if(get(l, l + mid - 1) == get(r, r + mid - 1))&#123; ans = max(ans, mid); lb = mid + 1; &#125; else ub = mid - 1; &#125; return ans;&#125;int main()&#123; scanf("%s", s + 1); init(); scanf("%d", &amp;m); while(m--)&#123; char ch[2]; scanf("%s", ch); if(ch[0] == 'Q')&#123; int l, r; scanf("%d %d", &amp;l, &amp;r); printf("%d\n", solve(pos[l], pos[r])); &#125; else&#123; char c[2]; int a; scanf("%s %d", c, &amp;a); if(a &gt; n) a = n + 1; change(c[0], a); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>hash</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[POJ-3581(Sequence)]]></title>
    <url>%2F2019%2F02%2F16%2FPOJ-3581-Sequence%2F</url>
    <content type="text"><![CDATA[链接：https://vjudge.net/problem/POJ-3581思路：题目要求把序列划分为三段，然后每一段倒置，求字典序最小的操作。我们考虑把原串倒置然后后缀数组，那么把排在最前面的一个后缀倒置一定是最优的，接下来我们考虑第二段，肯定是剩下的前缀中的某个后缀，此时我们如果仍然按照上面的求就会出错，比如 4 3 2 2，求出来2应该是第二段，但实际上2 2是第二段会更小，为什么会出现这种情况呢，这是因为此时第三段是强制必须要翻的，如果前面有一样的，可能翻过去后导致结果反而不是最优，怎么解决这个问题呢，我们考虑对于翻2海事翻2 2其实是跟4 3…这个前缀有关，就是说补上去后比谁字典序小，所以我们考虑把串复制一遍，再做一次sa，然后选最小的前一半中的后缀作为第二段即可。代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#define F(x) ((x) / 3 + ((x) % 3 == 1 ? 0 : tb))#define G(x) ((x) &lt; tb ? (x) * 3 + 1 : ((x) - tb) * 3 + 2)using namespace std;const int maxn = 400005;int wa[maxn], wb[maxn], wc[maxn], wv[maxn], sa[3 * maxn];int r[maxn], h[maxn], s[3 * maxn];int n;int a[maxn], b[maxn];int c0(int *s, int a, int b) &#123; return s[a] == s[b] &amp;&amp; s[a + 1] == s[b + 1] &amp;&amp; s[a + 2] == s[b + 2];&#125;int c12(int k, int *s, int a, int b) &#123; if (k == 2) return s[a] &lt; s[b] || s[a] == s[b] &amp;&amp; c12(1, s, a + 1, b + 1); return s[a] &lt; s[b] || s[a] == s[b] &amp;&amp; wv[a + 1] &lt; wv[b + 1];&#125;void sort(int *s, int *a, int *b, int n, int m) &#123; for (int i = 0; i &lt; n; i++) wv[i] = s[a[i]]; for (int i = 0; i &lt; m; i++) wc[i] = 0; for (int i = 0; i &lt; n; i++) wc[wv[i]]++; for (int i = 1; i &lt; m; i++) wc[i] += wc[i - 1]; for (int i = n - 1; i &gt;= 0; i--) b[--wc[wv[i]]] = a[i];&#125;void dc3(int *s, int *sa, int n, int m) &#123; int i, j, *sn = s + n, *san = sa + n, ta = 0, tb = (n + 1) / 3, tbc = 0, p; s[n] = s[n + 1] = 0; for (i = 0; i &lt; n; i++) if (i % 3 != 0) wa[tbc++] = i; sort(s + 2, wa, wb, tbc, m); sort(s + 1, wb, wa, tbc, m); sort(s, wa, wb, tbc, m); for (p = 1, sn[F(wb[0])] = 0, i = 1; i &lt; tbc; i++) sn[F(wb[i])] = c0(s, wb[i - 1], wb[i]) ? p - 1 : p++; if (p &lt; tbc) dc3(sn, san, tbc, p); else for (i = 0; i &lt; tbc; i++) san[sn[i]] = i; for (i = 0; i &lt; tbc; i++) if (san[i] &lt; tb) wb[ta++] = san[i] * 3; if (n % 3 == 1) wb[ta++] = n - 1; sort(s, wb, wa, ta, m); for (i = 0; i &lt; tbc; i++) wv[wb[i] = G(san[i])] = i; for (i = 0, j = 0, p = 0; i &lt; ta &amp;&amp; j &lt; tbc; p++) sa[p] = c12(wb[j] % 3, s, wa[i], wb[j]) ? wa[i++] : wb[j++]; for (; i &lt; ta; p++) sa[p] = wa[i++]; for (; j &lt; tbc; p++) sa[p] = wb[j++];&#125;void getheight() &#123; int i, j, k = 0; for (i = 1; i &lt;= n; i++) r[sa[i]] = i; for (i = 0; i &lt; n; h[r[i++]] = k) for (k ? k-- : 0, j = sa[r[i] - 1]; s[i + k] == s[j + k]; k++);&#125;int main()&#123; scanf("%d", &amp;n); for(int i = 0; i &lt; n; i++)scanf("%d", &amp;a[i]), b[i] = a[i]; sort(b, b + n); int len = unique(b, b + n) - b; for(int i = 0; i &lt; n; i++)&#123; s[i] = lower_bound(b, b + len, a[n - i - 1]) - b + 1; &#125; s[n] = 0; dc3(s, sa, n + 1, len + 10); getheight(); int now; for(int i = 1; i &lt;= n; i++)&#123; if(sa[i] &gt;= 2)&#123; for(int j = sa[i]; j &lt; n; j++)printf("%d\n", b[s[j] - 1]); now = sa[i]; break; &#125; &#125; n = now; for(int i = 0; i &lt; now; i++)&#123; s[n++] = s[i]; &#125; s[n] = 0; dc3(s, sa, n + 1, len + 10); getheight(); for(int i = 1; i &lt;= n; i++)&#123; if(sa[i] &lt; now &amp;&amp; sa[i])&#123; for(int j = sa[i]; j &lt; now; j++)printf("%d\n", b[s[j] - 1]); for(int j = 0; j &lt; sa[i]; j++)printf("%d\n", b[s[j] - 1]); break; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>后缀数组</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[HDU-3870(Catch-the-Theves)]]></title>
    <url>%2F2019%2F02%2F13%2FHDU-3870-Catch-the-Theves%2F</url>
    <content type="text"><![CDATA[链接：http://acm.hdu.edu.cn/viewcode.php?rid=28162392思路：这道题本来应该放到最短路里面，因为平面图最小割 = 对偶图最短路，题目要求从左上到右下的最小割，我们先建立一个S位于外面的左下方，再建立一个T位于外面的右上方，然后建立对偶图，我们可以看到从S到T的任意一条路径都把原来的网格图给分隔开来，成为如果我们把路径权值对应为原来的权值，那么最短路就为原来的最小割，那么我们只需要对应权值建边即可。具体图见https://blog.csdn.net/qq_34731703/article/details/54864712 ，注意转换过去后网格内的点是双向边，事实上最好全部都建双向边跑无向图肯定不会错，跑个最短路就可以求出答案了。代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include &lt;bits/stdc++.h&gt;using namespace std;struct edge&#123; int from, to, dist;&#125;;typedef pair&lt;int, int&gt; P;const int maxn = 500 * 500;const int inf = 1e9;vector&lt;int&gt; G[maxn];vector&lt;edge&gt; edges;int n, m, tot;int x;int d[maxn];int w[500][500];void init()&#123; for(int i = 0; i &lt;= n + 10; i++)G[i].clear(); edges.clear();&#125;//双向边void addedge(int from, int to, int dist)&#123; edges.push_back(edge&#123;from, to, dist&#125;); tot = edges.size(); G[from].push_back(tot - 1); edges.push_back(edge&#123;to, from, dist&#125;); tot = edges.size(); G[to].push_back(tot - 1);&#125;void dij()&#123; priority_queue&lt;P, vector&lt;P&gt;, greater&lt;P&gt; &gt; q; for(int i = 0; i &lt;= n + 10; i++) d[i] = inf; d[0] = 0; q.push(P&#123;0, 0&#125;); while(!q.empty())&#123; P p = q.top(); q.pop(); int u = p.second; if(d[u] &lt; p.first)continue; for(int i = 0; i &lt; G[u].size(); i++)&#123; edge &amp;e = edges[G[u][i]]; if(d[e.to] &gt; d[e.from] + e.dist)&#123; d[e.to] = d[e.from] + e.dist; q.push(P&#123;d[e.to], e.to&#125;); &#125; &#125; &#125;&#125;int T;int main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); cin &gt;&gt; T; while(T--)&#123; cin &gt;&gt; x; n = x * x; int s = x * x + 1; init(); for(int i = 1; i &lt;= x; i++)&#123; for(int j = 1; j &lt;= x; j++)&#123; cin &gt;&gt; w[i][j]; &#125; &#125; for(int i = 1; i &lt; x; i++)addedge(0, (i - 1) * (x - 1) + 1, w[i][1]); for(int i = 1; i &lt; x; i++)addedge(0, (x - 2) * (x - 1) + i, w[x][i]); for(int i = 1; i &lt; x; i++)addedge((i - 1) * (x - 1) + x - 1, s, w[i][x]); for(int i = 1; i &lt; x; i++)addedge(i, s, w[1][i]); for(int i = 1; i &lt; x; i++)&#123; for(int j = 1; j &lt; x; j++)&#123; if(j != x - 1) addedge((i - 1) * (x - 1) + j, (i - 1) * (x - 1) + j + 1, w[i][j + 1]); if(i != x - 1) addedge((i - 1) * (x - 1) + j, i * (x - 1) + j, w[i + 1][j]); &#125; &#125; dij(); cout &lt;&lt; d[s] &lt;&lt; '\n'; &#125; return 0;&#125;]]></content>
      <categories>
        <category>网络流</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[POJ-3415(Common-Substrings)]]></title>
    <url>%2F2019%2F02%2F13%2FPOJ-3415-Common-Substrings%2F</url>
    <content type="text"><![CDATA[链接：https://vjudge.net/problem/POJ-3415思路：统计大于等于k的公共子串的个数（可以重复），我们考虑一个问题，在后缀数组上，我们可以用lcp来看出大于等于k的最长公共子串有多少，但我们要统计贡献，我们考虑在height数组上，对于一个串B，要统计的A分布在他的两侧，先考虑前侧，串B与每一个串A的贡献跟他们的lcp有关，而lcp又与区间最小值有关，自然想起了焦作的那个题，我们考虑用单调栈来维护，对于每一个当前的h[i]，我们先把栈中比它大的出栈，并且统计一下数量，然后把h[i]和数量入栈，在此过程中我们再维护一个A串lcp的前缀和，然后如果当前串是B串，我们把前缀和统计入贡献中，否则将A串入栈，这样我们可以在线性求出B前面的A与B的贡献，后面的怎么办呢，你看B在A后，那A不就在B前了吗，那么反过来对A来一次统计不就完了吗？代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;stack&gt;using namespace std;typedef long long ll;typedef pair&lt;int, int&gt; P;ll ans;const int maxn = 4e5 + 100;int s[maxn];int sa[maxn],t[maxn],t2[maxn],c[maxn],n,m,k;int r[maxn],h[maxn];char ch1[maxn], ch2[maxn];int x;stack&lt;P&gt; S;//n为原字符长度，放于s[]的0-n-1位置，s[n]为0，build_sa传入的参数为（n+1，字符范围）void build_sa(int n, int m) &#123;//n为原串长度+1，字符值在0-m-1 int i, *x = t, *y = t2; for (i = 0; i &lt; m; i++)c[i] = 0; for (i = 0; i &lt; n; i++)c[x[i] = s[i]]++; for (i = 1; i &lt; m; i++)c[i] += c[i - 1]; for (i = n - 1; i &gt;= 0; i--)sa[--c[x[i]]] = i; for (int k = 1; k &lt;= n; k &lt;&lt;= 1) &#123; int p = 0; for (i = n - k; i &lt; n; i++)y[p++] = i; for (i = 0; i &lt; n; i++)if (sa[i] &gt;= k)y[p++] = sa[i] - k; for (i = 0; i &lt; m; i++)c[i] = 0; for (i = 0; i &lt; n; i++)c[x[y[i]]]++; for (i = 0; i &lt; m; i++)c[i] += c[i - 1]; for (i = n - 1; i &gt;= 0; i--)sa[--c[x[y[i]]]] = y[i]; swap(x, y); p = 1; x[sa[0]] = 0; for (i = 1; i &lt; n; i++) x[sa[i]] = y[sa[i - 1]] == y[sa[i]] &amp;&amp; y[sa[i - 1] + k] == y[sa[i] + k] ? p - 1 : p++; if (p &gt;= n)break; m = p; &#125;&#125;//最好从0开始，这样sa[n-1] = 0,可以把上一次的数据清空void getheight() &#123; int i, j, k = 0; for (i = 1; i &lt;= n; i++) r[sa[i]] = i; for (i = 0; i &lt; n; h[r[i++]] = k) for (k ? k-- : 0, j = sa[r[i] - 1]; s[i + k] == s[j + k]; k++);&#125;void solve()&#123; while(!S.empty())S.pop(); ll sum = 0; for(int i = 1; i &lt;= n; i++)&#123; int num = 0; while(!S.empty() &amp;&amp; S.top().first &gt; h[i])num += S.top().second, sum -= 1LL * (S.top().first - k + 1) * S.top().second, S.pop(); if(num &amp;&amp; h[i] &gt;= k) S.push(P&#123;h[i], num&#125;), sum += 1LL * num * (h[i] - k + 1); if(sa[i] &lt; x &amp;&amp; n - sa[i] &gt;= k)sum += (n - sa[i] - k + 1), S.push(P&#123;n - sa[i], 1&#125;); if(sa[i] &gt; x) ans += sum; &#125; while(!S.empty()) S.pop(); sum = 0; for(int i = 1; i &lt;= n; i++)&#123; int num = 0; while(!S.empty() &amp;&amp; S.top().first &gt; h[i])num += S.top().second, sum -= 1LL * (S.top().first - k + 1) * S.top().second, S.pop(); if(num &amp;&amp; h[i] &gt;= k) S.push(P&#123;h[i], num&#125;), sum += 1LL * num * (h[i] - k + 1); if(sa[i] &gt; x &amp;&amp; n - sa[i] &gt;= k) sum += (n - sa[i] - k + 1), S.push(P&#123;n - sa[i], 1&#125;); if(sa[i] &lt; x) ans += sum; &#125;&#125;int main() &#123; while(~scanf("%d", &amp;k) &amp;&amp; k)&#123; ans = 0; scanf("%s %s", ch1, ch2); x = strlen(ch1); n = 0; //注意下本题还有大写字母，且大写字母ASCLL码在小写字母前面，这里被坑了好久。。。。。 for(int i = 0; i &lt; x; i++)s[n++] = ch1[i] - 'A' + 3; s[n++] = 120; x = strlen(ch2); for(int i = 0; i &lt; x; i++)s[n++] = ch2[i] - 'A' + 3; s[n] = 0; build_sa(n + 1, 150); getheight(); x = strlen(ch1); solve(); printf("%lld\n", ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>后缀数组</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[POJ-3693(Maximum-repetition-substring)]]></title>
    <url>%2F2019%2F02%2F13%2FPOJ-3693-Maximum-repetition-substring%2F</url>
    <content type="text"><![CDATA[链接：https://vjudge.net/problem/POJ-3693思路：求最长重复的子串，多解的话输出字典序最小的解。这个题就算是一个论文题了，我们不可避免要枚举一个区间，求区间内的重复次数从而更新重复次数的答案，但如果单纯枚举左右端点是n方的，我们考虑枚举区间长度和左端点，每次跳长度那么多个单位，这样根据调和级数来看复杂度是nlogn，然后我们在这个区间内求lcp来更新答案，但注意可能后面会多出来一部分，所以我们要考虑后面多出来的这一部分能不能用前面来弥补使得答案更优，所以我们只用判断前面差的那部分的lcp是否匹配即可，最后我们考虑输出答案，因为要字典序最小，我们没办法在过程中确定哪个是最小的，所以最后我们根据sa数组直接枚举看是否能成为答案即可(sa已经按字典序排好序了)。代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;vector&gt;#define F(x) ((x) / 3 + ((x) % 3 == 1 ? 0 : tb))#define G(x) ((x) &lt; tb ? (x) * 3 + 1 : ((x) - tb) * 3 + 2)using namespace std;const int maxn = 100005;int wa[maxn], wb[maxn], wc[maxn], wv[maxn], sa[3 * maxn];int r[maxn], h[maxn], s[3 * maxn];int n;char ch[maxn];int d[maxn][30];vector&lt;int&gt; res;int c0(int *s, int a, int b) &#123; return s[a] == s[b] &amp;&amp; s[a + 1] == s[b + 1] &amp;&amp; s[a + 2] == s[b + 2];&#125;int c12(int k, int *s, int a, int b) &#123; if (k == 2) return s[a] &lt; s[b] || s[a] == s[b] &amp;&amp; c12(1, s, a + 1, b + 1); return s[a] &lt; s[b] || s[a] == s[b] &amp;&amp; wv[a + 1] &lt; wv[b + 1];&#125;void sort(int *s, int *a, int *b, int n, int m) &#123; for (int i = 0; i &lt; n; i++) wv[i] = s[a[i]]; for (int i = 0; i &lt; m; i++) wc[i] = 0; for (int i = 0; i &lt; n; i++) wc[wv[i]]++; for (int i = 1; i &lt; m; i++) wc[i] += wc[i - 1]; for (int i = n - 1; i &gt;= 0; i--) b[--wc[wv[i]]] = a[i];&#125;void dc3(int *s, int *sa, int n, int m) &#123; int i, j, *sn = s + n, *san = sa + n, ta = 0, tb = (n + 1) / 3, tbc = 0, p; s[n] = s[n + 1] = 0; for (i = 0; i &lt; n; i++) if (i % 3 != 0) wa[tbc++] = i; sort(s + 2, wa, wb, tbc, m); sort(s + 1, wb, wa, tbc, m); sort(s, wa, wb, tbc, m); for (p = 1, sn[F(wb[0])] = 0, i = 1; i &lt; tbc; i++) sn[F(wb[i])] = c0(s, wb[i - 1], wb[i]) ? p - 1 : p++; if (p &lt; tbc) dc3(sn, san, tbc, p); else for (i = 0; i &lt; tbc; i++) san[sn[i]] = i; for (i = 0; i &lt; tbc; i++) if (san[i] &lt; tb) wb[ta++] = san[i] * 3; if (n % 3 == 1) wb[ta++] = n - 1; sort(s, wb, wa, ta, m); for (i = 0; i &lt; tbc; i++) wv[wb[i] = G(san[i])] = i; for (i = 0, j = 0, p = 0; i &lt; ta &amp;&amp; j &lt; tbc; p++) sa[p] = c12(wb[j] % 3, s, wa[i], wb[j]) ? wa[i++] : wb[j++]; for (; i &lt; ta; p++) sa[p] = wa[i++]; for (; j &lt; tbc; p++) sa[p] = wb[j++];&#125;void getheight() &#123; int i, j, k = 0; for (i = 1; i &lt;= n; i++) r[sa[i]] = i; for (i = 0; i &lt; n; h[r[i++]] = k) for (k ? k-- : 0, j = sa[r[i] - 1]; s[i + k] == s[j + k]; k++);&#125;void RMQ_init()&#123; for(int i = 1; i &lt;= n; i++)d[i][0] = h[i]; for(int j = 1; (1 &lt;&lt; j) &lt;= n; j++)&#123; for(int i = 1; i + (1 &lt;&lt; j) - 1 &lt;= n; i++)&#123; d[i][j] = min(d[i][j - 1], d[i + (1 &lt;&lt; (j - 1))][j - 1]); &#125; &#125;&#125;int RMQ(int l, int r)&#123; if(l &gt; r) swap(l, r); int k = 0; while((1 &lt;&lt; (k + 1)) &lt;= r - l + 1)k++; return min(d[l][k], d[r - (1 &lt;&lt; k) + 1][k]);&#125;int query(int L, int R)&#123; int x = r[L], y = r[R]; if(x &gt; y) swap(x, y); x++; return RMQ(x, y);&#125;int main()&#123; int kase = 0; while(~scanf("%s", ch) &amp;&amp; ch[0] != '#')&#123; n = strlen(ch); for(int i = 0; i &lt; n; i++)s[i] = ch[i] - 'a' + 1; s[n] = 0; dc3(s, sa, n + 1, 40); getheight(); RMQ_init(); int ans = 1; for(int len = 1; len &lt;= n; len++)&#123; for(int j = 0; j + len &lt; n; j += len)&#123; int lcp = query(j, j + len); int t = lcp / len + 1; int k = j - (len - lcp % len); if(k &gt;= 0 &amp;&amp; query(k, k + len) &gt;= len)t++; if(ans &lt; t)&#123; ans = t; res.clear(); res.push_back(len); &#125; else if(ans == t)&#123; res.push_back(len); &#125; &#125; &#125; printf("Case %d: ", ++kase); for(int i = 1; i &lt;= n; i++)&#123; bool flag = false; for(int j = 0; j &lt; res.size(); j++)&#123; //printf("%d\n", res[j]); if(query(sa[i], sa[i] + res[j]) &gt;= (ans - 1) * res[j])&#123; flag = true; for(int k = sa[i]; k &lt; sa[i] + res[j] * ans; k++)&#123; putchar(ch[k]); &#125; puts(""); break; &#125; &#125; if(flag)break; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>后缀数组</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[POJ-3376(Finding-Palindromes)]]></title>
    <url>%2F2019%2F02%2F13%2FPOJ-3376-Finding-Palindromes%2F</url>
    <content type="text"><![CDATA[链接：https://vjudge.net/problem/POJ-3376思路：虽然是poj的题，但我在spoj上交的过的，poj这个题好像有点卡常，确实卡的不太合理就没在意了，说下做法，我们考虑两个字符串拼接，我们以短的来看，那么短的可以拼前面或者拼后面，拼前面就是跟长的串倒置后前缀匹配，且长串剩下部分是个回文。拼后面就是短串导致后跟长串前缀匹配，且长串剩下的是个回文，那么我们考虑对于输入的字符串，先按照长度排序，然后依次插入trie中，对于每一个碰到的单词结点，统计一下这里有多少个词，看下剩下部分是不是回文，统计贡献，这样的话我们就正着来一次，再倒着来一次，就可以算完了，注意自身跟自身只算一次，所以只用在正着或者倒着其中一种统计贡献中先加入自身再统计贡献即可。代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cstdio&gt;using namespace std;const int maxnode = 2000005;const int sigma_size = 26;typedef long long ll;ll sum;int n;int ch[maxnode][sigma_size];int val[maxnode];int sz;int cnt;char s[maxnode], ss[maxnode * 2];int p[maxnode * 2];int h[maxnode];int x;inline void pre()&#123; sz = 1; memset(ch[0], 0, sizeof(ch[0]));&#125;inline int idx(char c) &#123; return c - 'a';&#125;void insert(char *s) &#123; int u = 0; for (int i = 0; i &lt; x; i++) &#123; int c = idx(s[i]); if (!ch[u][c]) &#123; memset(ch[sz], 0, sizeof(ch[sz])); val[sz] = 0; ch[u][c] = sz++; &#125; u = ch[u][c]; &#125; val[u]++;&#125;int check(char *s)&#123; int u = 0; int ans = 0; for(int i = 0; i &lt; x; i++)&#123; int c = idx(s[i]); if(!ch[u][c])return ans; u = ch[u][c]; if(val[u])&#123; if(h[x - i - 1]) ans += val[u]; &#125; &#125; return ans;&#125;void init()&#123;//将每两个字符中插入一个字符 cnt = 1; ss[0] = '!'; ss[cnt] = '#'; h[0] = 1; for(int i = 0; i &lt; x; i++) ss[++cnt] = s[i], ss[++cnt] = '#', h[i] = 0; h[x] = 0; ss[++cnt] = '\0';&#125;void manacher()&#123; init(); int pos = 0, mx = 0; for(int i = 1; i &lt;= cnt; i++)&#123; if(i &lt; mx) p[i] = min(p[pos * 2 - i], mx - i); else p[i] = 1; while(ss[i + p[i]] == ss[i - p[i]]) p[i]++; if(mx &lt; i + p[i]) mx = i + p[i], pos = i; if(i + p[i] == 2 * x + 2)h[p[i] - 1] = 1;//维护后缀哪些地方是回文 &#125;&#125;bool cmp(const string &amp;a, const string &amp;b)&#123; return a.size() &lt; b.size();&#125;int main()&#123; while(~scanf("%d", &amp;n))&#123; sum = 0; pre(); vector&lt;string&gt; in; for(int i = 0; i &lt; n; i++)&#123; int x; string xs; scanf("%d", &amp;x); cin &gt;&gt; xs; in.push_back(xs); &#125; sort(in.begin(), in.end(), cmp); //短串在长串前面 for(int i = 0; i &lt; in.size(); i++)&#123; x = in[i].size(); for(int j = 0; j &lt; x; j++) s[j] = in[i][j]; s[x] = '\0'; insert(s); for(int j = 0; j &lt; x / 2; j++)swap(s[j], s[x - j - 1]); manacher(); sum += check(s); &#125; //短串在长传后面 pre(); for(int i = 0; i &lt; in.size(); i++)&#123; x = in[i].size(); for(int j = 0; j &lt; in[i].size(); j++)s[j] = in[i][j]; s[x] = '\0'; manacher(); sum += check(s); for(int j = 0; j &lt; x / 2; j++)swap(s[j], s[x - j - 1]); insert(s); &#125; printf("%lld\n", sum); &#125; return 0;&#125;]]></content>
      <categories>
        <category>trie</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Codeforces-Round-538-(Div2)-F(Please-another-Queries-on-Array)]]></title>
    <url>%2F2019%2F02%2F11%2FCodeforces-Round-538-Div2-F-(Please-another-Queries-on-Array)%2F</url>
    <content type="text"><![CDATA[链接：https://codeforces.com/contest/1114/problem/F思路：考虑欧拉函数的计算方式，跟它乘积中的素因子是否出现有关，又因为所有因子都在300以内，我们考虑维护一个区间积，然后维护一个集合表示哪些素因子出现过，那么每次更新的时候就更新区间积分，以及集合，由于空间有限我们就用bitset来维护，预处理300以内所有的素因子，以及300以内所有数的由哪些素因子组成，然后每次更新到线段树上，最后询问时我们只用询问一下区间积，并且看一下哪些素因子出现过，出现就按照欧拉函数的求法乘一个(1 - 1 / p)，这个也可以全部先预处理处理，所以只要这个题思路想清楚了就很简单了。代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 4e5 + 10;typedef long long ll;const ll mod = 1e9 + 7;bitset&lt;65&gt; fac[maxn &lt;&lt; 2], tag[maxn &lt;&lt; 2];bitset&lt;65&gt; pr[310];ll mul[maxn &lt;&lt; 2], po[maxn &lt;&lt; 2];ll inv[maxn];bool vis[310];vector&lt;int&gt; prime;int a[maxn];int n, q;ll pow_mod(ll q, ll w)&#123; ll ret = 1; while(w)&#123; if(w &amp; 1) ret = ret * q % mod; q = q * q % mod; w &gt;&gt;= 1; &#125; return ret;&#125;void init()&#123; for(int i = 2; i &lt;= 300; i++)&#123; if(vis[i])continue; prime.push_back(i); for(int j = i; j &lt;= 300; j += i)vis[j] = true; &#125; for(int i = 0; i &lt; prime.size(); i++)inv[i] = pow_mod(prime[i], mod - 2); for(int i = 1; i &lt;= 300; i++)&#123; for(int j = 0; j &lt; prime.size(); j++)&#123; if(i % prime[j] == 0) pr[i][j] = 1; &#125; &#125;&#125;void pushup(int o)&#123; mul[o] = mul[o &lt;&lt; 1] * mul[o &lt;&lt; 1 | 1] % mod; fac[o] = fac[o &lt;&lt; 1] | fac[o &lt;&lt; 1 | 1];&#125;void pushdown(int o, int m)&#123; if(po[o] != 1)&#123; mul[o &lt;&lt; 1] = mul[o &lt;&lt; 1] * pow_mod(po[o], (m - (m &gt;&gt; 1))) % mod; mul[o &lt;&lt; 1 | 1] = mul[o &lt;&lt; 1 | 1] * pow_mod(po[o], m &gt;&gt; 1) % mod; po[o &lt;&lt; 1] = po[o &lt;&lt; 1] * po[o] % mod; po[o &lt;&lt; 1 | 1] = po[o &lt;&lt; 1 | 1] * po[o] % mod; po[o] = 1; &#125; if(tag[o].any())&#123; fac[o &lt;&lt; 1] |= tag[o]; fac[o &lt;&lt; 1 | 1] |= tag[o]; tag[o &lt;&lt; 1] |= tag[o]; tag[o &lt;&lt; 1 | 1] |= tag[o]; tag[o].reset(); &#125;&#125;void build(int o, int l, int r)&#123; mul[o] = po[o] = 1; fac[o].reset(); tag[o].reset(); if(l &lt; r)&#123; int mid = l + r &gt;&gt; 1; build(o &lt;&lt; 1, l, mid); build(o &lt;&lt; 1 | 1, mid + 1, r); pushup(o); return; &#125; mul[o] = a[l]; fac[o] |= pr[a[l]];&#125;void update(int o, int tl, int tr, int l, int r, ll v)&#123; if(tl &gt; r || tr &lt; l)return; if(l &lt;= tl &amp;&amp; r &gt;= tr)&#123; mul[o] = mul[o] * pow_mod(v, tr - tl + 1) % mod; po[o] = po[o] * v % mod; return; &#125; pushdown(o, tr - tl + 1); int mid = tl + tr &gt;&gt; 1; update(o &lt;&lt; 1, tl, mid, l, r, v); update(o &lt;&lt; 1 | 1, mid + 1, tr, l, r, v); pushup(o);&#125;void change(int o, int tl, int tr, int l, int r, bitset&lt;65&gt; v)&#123; if(tl &gt; r || tr &lt; l)return; if(l &lt;= tl &amp;&amp; r &gt;= tr)&#123; fac[o] |= v; tag[o] |= v; return; &#125; pushdown(o, tr - tl + 1); int mid = tr + tl &gt;&gt; 1; change(o &lt;&lt; 1, tl, mid, l, r, v); change(o &lt;&lt; 1 | 1, mid + 1, tr, l, r, v); pushup(o);&#125;ll query(int o, int tl, int tr, int l, int r)&#123; if(tl &gt; r || tr &lt; l)return 1LL; if(l &lt;= tl &amp;&amp; r &gt;= tr) return mul[o]; pushdown(o, tr - tl + 1); int mid = tl + tr &gt;&gt; 1; return query(o &lt;&lt; 1, tl, mid, l, r) * query(o &lt;&lt; 1 | 1, mid + 1, tr, l, r) % mod;&#125;bitset&lt;65&gt; ask(int o, int tl, int tr, int l, int r)&#123; if(tl &gt; r || tr &lt; l)&#123; bitset&lt;65&gt; tmp; tmp.reset(); return tmp; &#125; if(l &lt;= tl &amp;&amp; r &gt;= tr)return fac[o]; pushdown(o, tr - tl + 1); int mid = tl + tr &gt;&gt; 1; return ask(o &lt;&lt; 1, tl, mid, l, r) | ask(o &lt;&lt; 1 | 1, mid + 1, tr, l, r);&#125;int main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); init(); cin &gt;&gt; n &gt;&gt; q; for(int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i]; build(1, 1, n); for(int i = 1; i &lt;= q; i++)&#123; string s; int x, l, r; cin &gt;&gt; s &gt;&gt; l &gt;&gt; r; if(s[0] == 'M')&#123; cin &gt;&gt; x; change(1, 1, n, l, r, pr[x]); update(1, 1, n, l, r, x); &#125; else&#123; ll ans = query(1, 1, n, l, r); bitset&lt;65&gt; tmp = ask(1, 1, n, l, r); for(int j = 0; j &lt; 65; j++)&#123; if(tmp[j]) ans = ans * (prime[j] - 1) % mod * inv[j] % mod; &#125; cout &lt;&lt; ans &lt;&lt; '\n'; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>线段树</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Codeforces-Round-538-(Div2)-D(Flood-Fill)]]></title>
    <url>%2F2019%2F02%2F11%2FCodeforces-Round-538-Div2-D-Flood-Fill%2F</url>
    <content type="text"><![CDATA[链接：https://codeforces.com/contest/1114/problem/D思路：读错两次题 + 贪心凭感觉，导致这个题直接崩盘，我们考虑每次可以向左或者向右变，如果存在左右相同时就可以同时变，那么后面的分布会影响我们的操作策略的，所以不是简单的贪心，我们要想次数最少，就要尽可能多的同时变，那是不是就是求左右两个字串的lcs，能想到这里这个题就瞬间简单了(思考一下之前是不是有好些题都是枚举中间分界点，然后左右用dp解决)。代码：12345678910111213141516171819202122232425262728293031323334#include &lt;bits/stdc++.h&gt;using namespace std;int n;const int maxn = 5010;int r1[maxn], r2[maxn];int f[maxn][maxn];int main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); cin &gt;&gt; n; int len = 0; for(int i = 1; i &lt;= n; i++)&#123; int a; cin &gt;&gt; a; if(a != r1[len])r1[++len] = a; &#125; for(int i = 1; i &lt;= len; i++) r2[i] = r1[len - i + 1]; for(int i = 1; i &lt;= len; i++)&#123; for(int j = 1; j &lt;= len; j++)&#123; f[i][j] = max(f[i - 1][j], f[i][j - 1]); if(r1[i] == r2[j])f[i][j] = max(f[i][j], f[i - 1][j - 1] + 1); &#125; &#125; int res = 1e9; for(int i = 1; i &lt;= len; i++)&#123; res = min(res, len - 1 - f[i - 1][len - i]); &#125; cout &lt;&lt; res &lt;&lt; '\n'; return 0;&#125;]]></content>
      <categories>
        <category>基础dp</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[HDU-3374(String-Problem)]]></title>
    <url>%2F2019%2F02%2F09%2FHDU-3374-String-Problem%2F</url>
    <content type="text"><![CDATA[链接：https://vjudge.net/problem/HDU-3374思路：这个题其实最重要的是了解一下最大最小表示法(会个板子就好，没什么改的空间)，有了最大最小表示法后我们就可以搞出最大和最小字符串的位置，然后我们观察得知出现次数相同跟它是完整循环几次有关，所以我们用kmp算一下循环节长度并判断一下就可以得出了代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e6 + 100;char s[maxn];char tmp[maxn];int f[maxn];int getmin(char *s, int len) &#123; int i = 0, j = 1, k; while (i &lt; len &amp;&amp; j &lt; len) &#123; for (k = 0; k &lt; len; k++) if (s[(i + k) % len] != s[(j + k) % len]) break; if (k &gt;= len) break; if (s[(i + k) % len] &gt; s[(j + k) % len]) i = max(i + k + 1, j + 1); else j = max(j + k + 1, i + 1); &#125; return min(i, j);&#125;int getmax(char *s, int len) &#123; int i = 0, j = 1, k; while (i &lt; len &amp;&amp; j &lt; len) &#123; for (k = 0; k &lt; len; k++) if (s[(i + k) % len] != s[(j + k) % len]) break; if (k &gt;= len) break; if (s[(i + k) % len] &lt; s[(j + k) % len]) i = max(i + k + 1, j + 1); else j = max(j + k + 1, i + 1); &#125; return min(i, j);&#125;void getfail(char *P)&#123; f[0] = f[1] = 0; int m = strlen(P); for(int i = 1; i &lt; m; i++)&#123; int j = f[i]; while(j &amp;&amp; P[i] != P[j]) j = f[j]; f[i + 1] = P[i] == P[j] ? j + 1 : 0; &#125;&#125;int main()&#123; while(~scanf("%s", s))&#123; int n = strlen(s); int x = getmin(s, n); tmp[0] = s[x]; int len = 0; for(int i = x + 1; i != x; i = (i + 1) % n)&#123; tmp[++len] = s[i]; &#125; tmp[++len] = '\0'; getfail(tmp); int r1; if(n % (n - f[n]) == 0) r1 = n / (n - f[n]); else r1 = 0; printf("%d %d ", x + 1, r1); x = getmax(s, n); tmp[0] = s[x]; len = 0; for(int i = x + 1; i != x; i = (i + 1) % n)&#123; tmp[++len] = s[i]; &#125; tmp[++len] = '\0'; getfail(tmp); int r2; if(n % (n - f[n]) == 0) r2 = n / (n - f[n]); else r2 = 0; printf("%d %d\n", x + 1, r2); &#125; return 0;&#125;]]></content>
      <categories>
        <category>kmp</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Codeforces-Round-106-(Div2)-E(Martian-Strings)]]></title>
    <url>%2F2019%2F02%2F09%2FCodeforces-Round-106-Div2-E-Martian-Strings%2F</url>
    <content type="text"><![CDATA[链接：https://codeforces.com/contest/149/problem/E思路：kmp第二发，这个题跟之前做的一个dp在思路上一模一样，正着来一遍倒着来一遍，枚举中间断开的点。这个题就是正着来一次kmp，把两个串倒过来再来一次，然后枚举中间点，前面最大匹配长度 + 后面最大匹配长度 &gt;= 串长就可以找到，注意要特判串长为1的情况，这个直接就是不合法的。代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e5 + 100;char s[maxn], ss[maxn];char ch[1010];int m;int f1[1010], f2[1010];int m1[maxn], m2[maxn];void getfail(char *P, int *f)&#123; f[0] = f[1] = 0; int n = strlen(P); for(int i = 1; i &lt; n; i++)&#123; int j = f[i]; while(j &amp;&amp; P[i] != P[j]) j = f[j]; f[i + 1] = P[i] == P[j] ? j + 1 : 0; &#125;&#125;void find(char *T, char *P, int *f, int *w)&#123; int n = strlen(T); int m = strlen(P); getfail(P, f); int j = 0; for(int i = 0; i &lt; n; i++)&#123; while(j &amp;&amp; T[i] != P[j]) j = f[j]; if(T[i] == P[j]) j++; w[i + 1] = max(w[i], j); &#125;&#125;int main()&#123; scanf("%s", s); int n = strlen(s); for(int i = 0; i &lt; n; i++)ss[i] = s[n - i - 1]; ss[n] = '\0'; scanf("%d", &amp;m); int res = 0; for(int i = 0; i &lt; m; i++)&#123; scanf("%s", ch); memset(m1, 0, sizeof(m1)); memset(m2, 0, sizeof(m2)); int x = strlen(ch); if(x == 1)continue; find(s, ch, f1, m1); for(int j = 0; j &lt; x / 2; j++)swap(ch[j], ch[x - j - 1]); find(ss, ch, f2, m2); for(int j = 1; j &lt;= n / 2; j++)swap(m2[j], m2[n + 1 - j]); for(int j = 0; j &lt;= n; j++)&#123; if(m1[j] + m2[j + 1] &gt;= x)&#123; res++; break; &#125; &#125; &#125; printf("%d\n", res); return 0;&#125;]]></content>
      <categories>
        <category>kmp</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[ZeptoLab-Code-Rush-D(Om-Nom-and-Necklace)]]></title>
    <url>%2F2019%2F02%2F09%2FZeptoLab-Code-Rush-D-Om-Nom-and-Necklace%2F</url>
    <content type="text"><![CDATA[链接：https://codeforces.com/contest/526/problem/D思路：明明点的后缀数组题，为什么要给我来kmp二连啊。。。这个题我们可以分情况讨论一下，如果包含空串，那么那个前缀串就是某个子串的k或者k+1倍，否则的话，就是某个前缀串k倍 + 一部分，前者非常好处理，用循环节就可以处理了，后者我们要考虑一下，其实只要保证k的完整部分比后面长就行了(因为求这个过程中已经保证了是一个循环的)，其实这个题就做完了，算是一个kmp思维好题。链接：12345678910111213141516171819202122232425262728293031323334#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e6 + 100;int f[maxn];char s[maxn];int n, k;void getfail(char *P)&#123; f[0] = f[1] = 0; for(int i = 1; i &lt; n; i++)&#123; int j = f[i]; while(j &amp;&amp; P[i] != P[j]) j = f[j]; f[i + 1] = P[i] == P[j] ? j + 1 : 0; &#125;&#125;bool check(int x)&#123; if(x % (x - f[x]) == 0 &amp;&amp; ((x / (x - f[x]) % k == 0) || x / (x - f[x]) % (k + 1) == 0 || x / (x - f[x]) == 2 * k + 1)) return true; //x / (x - f[x]) / k 是求前面循环节是最小循环节的几倍，这个只要比余数(拼在最后面的)大就可以满足了，画一画就非常清楚了！ if (x / (x - f[x]) / k &gt; x / (x - f[x]) % k)return true; return false;&#125;int main()&#123; scanf("%d %d %s", &amp;n, &amp;k, s); getfail(s); for(int i = 1; i &lt;= n; i++)&#123; if(check(i))putchar('1'); else putchar('0'); &#125; puts(""); return 0;&#125;]]></content>
      <categories>
        <category>kmp</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Codeforces-Global-Round-1-D(Jongmah)]]></title>
    <url>%2F2019%2F02%2F08%2FCodeforces-Global-Round-1-D-Jongmah%2F</url>
    <content type="text"><![CDATA[链接：https://codeforces.com/contest/1110/problem/D思路：dp确实是很看思维的啊，特别这种如果把问题转化一下就变得特别简单的，我们考虑如果存在3个及以上同样的顺子，我们可以把它变成3个对子，所以我们只用考虑顺子在3个以内的情况，对于一个点，组成顺子可能来自三个方向，但它作为末尾的那一种情况，我们可以直接在递推的时候去掉，那么状态就出来了,dp[i][j][k]表示第i个点，以它为中心的顺子有j个，以它为起点的顺子有k个的最大tuple数，那它可能来自于dp[i - 1][x][j] + k，我们枚举所有状态转移过去即可，最后dp[m][0][0]就是答案。对于杭电http://acm.hdu.edu.cn/showproblem.php?pid=6188 这个题也完全一样，状态改一改就行了。代码：1234567891011121314151617181920212223242526#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e6 + 100;int dp[maxn][3][3];int cnt[maxn];int n, m;int main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); cin &gt;&gt; n &gt;&gt; m; int a; for(int i = 1; i &lt;= n; i++) cin &gt;&gt; a, cnt[a]++; for(int i = 1; i &lt;= m; i++)&#123; for(int j = 0; j &lt; 3; j++)&#123; for(int k = 0; k &lt; 3; k++)&#123; for(int z = 0; z &lt; 3; z++)&#123; if(j + k + z &lt;= cnt[i]) dp[i][j][k] = max(dp[i][j][k], dp[i - 1][z][j] + k + (cnt[i] - j - k - z) / 3); &#125; &#125; &#125; &#125; cout &lt;&lt; dp[m][0][0] &lt;&lt; endl; return 0;&#125;]]></content>
      <categories>
        <category>基础dp</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Codeforces-Round-244-(Div2)-D(Match-&-Catch)]]></title>
    <url>%2F2019%2F02%2F08%2FCodeforces-Round-244-Div2-D-Match-Catch%2F</url>
    <content type="text"><![CDATA[链接：https://codeforces.com/contest/427/problem/D思路：考虑把两个串中间拿个字符隔开，然后后缀数组一波，对于每一个h[i]，如果他比相邻两个都要大且两个前缀出现在两个串中，那么我们可以取它相邻两个中的最小值+1更新答案即可(首先如果比相邻两个的某一个小，说明有连续当前这个lcp至少出现3次，肯定不满足题意，当比两边都大时，我们取最小的那一个+1，这样肯定他们只出现两次)代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e5;char s[maxn], s1[maxn], s2[maxn];int sa[maxn],t[maxn],t2[maxn],c[maxn],n,m,k;int r[maxn],h[maxn];int ans;//n为原字符长度，放于s[]的0-n-1位置，s[n]为0，build_sa传入的参数为（n+1，字符范围）void build_sa(int n,int m)&#123;//n为原串长度+1，字符值在0-m-1 int i,*x = t,*y = t2; for(i=0;i&lt;m;i++)c[i] = 0; for(i=0;i&lt;n;i++)c[x[i]=s[i]]++; for(i=1;i&lt;m;i++)c[i]+=c[i-1]; for(i=n-1;i&gt;=0;i--)sa[--c[x[i]]] = i; for(int k=1;k&lt;=n;k&lt;&lt;=1)&#123; int p = 0; for(i=n-k;i&lt;n;i++)y[p++] = i; for(i=0;i&lt;n;i++)if(sa[i]&gt;=k)y[p++] = sa[i]-k; for(i=0;i&lt;m;i++)c[i] = 0; for(i=0;i&lt;n;i++)c[x[y[i]]]++; for(i=0;i&lt;m;i++)c[i]+=c[i-1]; for(i=n-1;i&gt;=0;i--)sa[--c[x[y[i]]]] = y[i]; swap(x,y); p = 1;x[sa[0]] = 0; for(i=1;i&lt;n;i++) x[sa[i]] = y[sa[i-1]]==y[sa[i]]&amp;&amp;y[sa[i-1]+k]==y[sa[i]+k]?p-1:p++; if(p&gt;=n)break; m = p; &#125;&#125;//最好从0开始，这样sa[n-1] = 0,可以把上一次的数据清空void getheight()&#123; int i,j,k = 0; for(i=0;i&lt;=n;i++)r[sa[i]] = i; for(i=0;i&lt;n;i++)&#123; if(k)k--; if(!r[i])continue; int j = sa[r[i]-1]; while(s[i+k]==s[j+k])k++; h[r[i]] = k; &#125;&#125;void solve()&#123; ans = 1e9; for(int i = 1; i &lt;= n; i++)&#123; if(!h[i])continue; if((sa[i] &gt; m &amp;&amp; sa[i - 1] &lt; m) || (sa[i] &lt; m &amp;&amp; sa[i - 1] &gt; m)); else continue; if(i == 1 &amp;&amp; h[i + 1] &lt; h[i])ans = min(ans, h[i + 1] + 1); else if(i == n &amp;&amp; h[i - 1] &lt; h[i]) ans = min(ans, h[i - 1] + 1); else if(h[i - 1] &lt; h[i] &amp;&amp; h[i] &gt; h[i + 1])ans = min(ans, max(h[i - 1], h[i + 1]) + 1); &#125;&#125;int main()&#123; scanf("%s%s", s1, s2); n = strlen(s1) + strlen(s2) + 1; m = strlen(s1); strcpy(s, s1); s[m] = '#'; s[m + 1] = '\0'; strcat(s, s2); s[n] = 0; build_sa(n + 1, 130); getheight(); solve(); if(ans == 1e9)puts("-1"); else printf("%d\n", ans); return 0;&#125;]]></content>
      <categories>
        <category>后缀数组</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Codeforces-Round-344-(Div2)-D(Messenger)]]></title>
    <url>%2F2019%2F02%2F08%2FCodeforces-Round-344-Div2-D-Messenger%2F</url>
    <content type="text"><![CDATA[链接：https://codeforces.com/contest/631/problem/D思路：好题！感觉自己已经快想到正解了，但是还是忍不住看了下题解。首先我们可以先把相邻相同的先合并了，那么除了头和尾，中间必须要求完全相同，这时候我们就可以用kmp了(之前是将首尾拿进来一起匹配，重新定义一下等于号，结果发现并不行，这样有些在最后匹配的然后跳转后其实是不匹配了，但还是计算入匹配中(吐槽一下这个假的居然是挂在了最后一个点)，说明kmp中间的等于是不能乱重新定义的)，对于中间匹配的我们看两端是否满足匹配即可。对于t只有1或者2的情况我们暴力计算就好，注意细节我这份代码写的有点丑。。。。代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 2e5 + 100;int n, m;char s1[maxn], s2[maxn];char s3[maxn];ll n1[maxn], n2[maxn], n3[maxn];int len1, len2, len3;int f[maxn];bool check(char *T, char *P, int i, int j)&#123; if(T[i] != P[j])return false; return n1[i] == n3[j];&#125;void getfail(char *P)&#123; f[0] = f[1] = 0; int m = strlen(P); for(int i = 1; i &lt; m; i++)&#123; int j = f[i]; while(j &amp;&amp; !(P[i] == P[j] &amp;&amp; n3[i] == n3[j])) j = f[j]; f[i + 1] = (P[i] == P[j] &amp;&amp; n3[i] == n3[j]) ? j + 1 : 0; &#125;&#125;ll find(char *T, char *P)&#123; getfail(P); int j = 0; ll res = 0; for(int i = 1; i &lt; len1 - 1; i++)&#123; while(j &amp;&amp; !check(T, P, i, j)) j = f[j]; if(check(T, P, i, j)) j++; if(j == len3) &#123; //特判首尾 if(s2[0] == s1[i - len3] &amp;&amp; s2[len2 - 1] == s1[i + 1] &amp;&amp; n2[0] &lt;= n1[i - len3] &amp;&amp; n2[len2 - 1] &lt;= n1[i + 1]) res++; &#125; &#125; return res;&#125;int main()&#123; len1 = len2 = -1; scanf("%d %d", &amp;n, &amp;m); for(int i = 1; i &lt;= n; i++)&#123; char ch; int c; scanf("%d-%c", &amp;c, &amp;ch); s1[i] = ch; if(s1[i] != s1[i - 1])s1[++len1] = ch; n1[len1] += c; &#125; for(int i = 1; i &lt;= m; i++)&#123; char ch; int c; scanf("%d-%c", &amp;c, &amp;ch); s2[i] = ch; if(s2[i] != s2[i - 1])s2[++len2] = ch; n2[len2] += c; &#125; len1++; len2++; s1[len1] = s2[len2] = '\0'; //提处t串除了首尾的部分进行kmp for(int i = 1; i &lt; len2 - 1; i++)&#123; s3[len3] = s2[i]; n3[len3++] = n2[i]; &#125; s3[len3] = '\0'; //t串只有1和2的情况特判 if(len2 == 1)&#123; ll res = 0; for(int i = 0; i &lt; len1; i++)&#123; if(s1[i] == s2[0] &amp;&amp; n1[i] &gt;= n2[0])res += n1[i] - n2[0] + 1; &#125; printf("%lld\n", res); &#125; else if(len2 == 2)&#123; ll res = 0; for(int i = 1; i &lt; len1; i++)&#123; if(s1[i] == s2[1] &amp;&amp; s1[i - 1] == s2[0] &amp;&amp; n1[i] &gt;= n2[1] &amp;&amp; n1[i - 1] &gt;= n2[0])res++; &#125; printf("%lld\n", res); &#125; else printf("%lld\n", find(s1, s3)); return 0;&#125;]]></content>
      <categories>
        <category>kmp</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Manthan-Codefest-16-C(Spy-Syndrome-2)]]></title>
    <url>%2F2019%2F02%2F07%2FManthan-Codefest-16-C-Spy-Syndrome-2%2F</url>
    <content type="text"><![CDATA[链接：https://codeforces.com/contest/633/problem/C思路：好像有dp的方法，我直接建一个trie树然后上面跑dfs，对于非单词结点直接往下跑，如果是单词结点可以考虑回到0点(开始一个新单词)，或者继续向下跑(另一个单词)，最后用一个栈保存结果输出即可。代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include &lt;bits/stdc++.h&gt;using namespace std;const int maxnode = 1e6 + 100;const int sigma_size = 26;int ch[maxnode][sigma_size];int val[maxnode];int sz;int n, m;char s1[10010], s2[1010];vector&lt;char&gt; r[100010];stack&lt;int&gt; s;void init()&#123; sz = 1; memset(ch[0], 0, sizeof(ch[0]));&#125;int idx(char c)&#123; return c - 'a';&#125;void insert(char *s, int v)&#123; int u = 0; int n = strlen(s); for(int i = 0; i &lt; n; i++)&#123; int c = idx(s[i]); if(!ch[u][c])&#123; memset(ch[sz], 0, sizeof(ch[sz])); val[sz] = 0; ch[u][c] = sz++; &#125; u = ch[u][c]; &#125; val[u] = v;&#125;void print(int x)&#123; for(int i = 0; i &lt; r[x].size(); i++)&#123; putchar(r[x][i]); &#125; putchar(' ');&#125;bool dfs(int x, int d)&#123; if(d == n &amp;&amp; val[x])&#123; s.push(val[x]); return true; &#125; else if(d == n) return false; int c = idx(s1[d]); if(val[x])&#123; if(dfs(0, d))&#123; s.push(val[x]); return true; &#125; &#125; //注意顺序，不要先dfs然后破坏了栈中的内容 if(ch[x][c] &amp;&amp; dfs(ch[x][c], d + 1))&#123; return true; &#125; return false;&#125;int main()&#123; init(); scanf("%d %s", &amp;n, s1); scanf("%d", &amp;m); for(int i = 1; i &lt;= m; i++)&#123; scanf("%s", s2); int x = strlen(s2); for(int j = 0; j &lt; x; j++)r[i].push_back(s2[j]); for(int j = 0; j &lt; x / 2; j++)swap(s2[j], s2[x - j - 1]); for(int j = 0; j &lt; x; j++)s2[j] = tolower(s2[j]); insert(s2, i); &#125; dfs(0, 0); while(!s.empty())&#123; int x = s.top(); s.pop(); print(x); &#125; puts(""); return 0;&#125;]]></content>
      <categories>
        <category>trie</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2018-2019-ACM-ICPC-Asia-Nanjing-Regional-Contest-E(Eva-and-Euro-coins)]]></title>
    <url>%2F2019%2F02%2F06%2F2018-2019-ACM-ICPC-Asia-Nanjing-Regional-Contest-E-Eva-and-Euro-coins%2F</url>
    <content type="text"><![CDATA[链接：https://codeforces.com/gym/101981/attachments思路：容易观察得知，如果有k个连续相同我们可以删除它(换句话说他后面的可以任意前后移动)，所以这个题就变成了一个类似消消乐的题目，只要存在k个一样的就可以消，比较两个序列消完的最终态是否相同即可，如果不相同可以证明一定不能变成相同的。代码：1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;bits/stdc++.h&gt;using namespace std;string s1, s2;const int maxn = 1e6 + 100;int n, k;int cnt[maxn], st[maxn];string solve(string s)&#123; if(k == 1)return ""; int top = 0; for(int i = 0; i &lt; n; i++)&#123; if(top &amp;&amp; st[top] == s[i] - '0')&#123; cnt[top]++; if(cnt[top] == k)top--; &#125; else&#123; top++; st[top] = s[i] - '0'; cnt[top] = 1; &#125; &#125; s = ""; for(int i = 1; i &lt;= top; i++)&#123; while(cnt[i])&#123; s += st[i]; cnt[i]--; &#125; &#125; return s;&#125;int main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); cin &gt;&gt; n &gt;&gt; k; cin &gt;&gt; s1 &gt;&gt; s2; if(solve(s1) == solve(s2)) cout &lt;&lt; "Yes" &lt;&lt; endl; else cout &lt;&lt; "No" &lt;&lt; endl; return 0;&#125;]]></content>
      <categories>
        <category>构造</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2018-2019-ACM-ICPC-Asia-Nanjing-Regional-Contest-M(Mediocre-String-Problem)]]></title>
    <url>%2F2019%2F02%2F06%2F2018-2019-ACM-ICPC-Asia-Nanjing-Regional-Contest-M-Mediocre-String-Problem%2F</url>
    <content type="text"><![CDATA[链接：https://codeforces.com/gym/101981/attachments思路：题目求s1串取一个子串，s2取一个前缀串，要求前者比后者长，求能组成回文串的数目。因为有前者比后者长的限制，我们考虑把回文串可以看作前者与后者对称的一部分和一个短的回文组成的，那么我们考虑把s1倒过来，每个后缀跟s2求lcp，然后以当前点结束的回文的个数 * lcp长度就是当前点的答案，最后所有点加起来即可。那么我们可以用manacher预处理每个点的回文，然后差分一下，在回文中心++，右端点+1处—，最后合并一下就可以得到每个点前面有多少个以它前面那个点结束的回文，然后我们用exkmp求出每个后缀与s2的lcp，最后统计一下答案即可。代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e6 + 5;typedef long long ll;ll res, sum[maxn];int ans, cnt;char ch1[maxn], ch2[maxn], ss[maxn * 2];int f[maxn], ex[maxn];int p[maxn * 2];void init()&#123;//将每两个字符中插入一个字符 int len = strlen(ch1); cnt = 1; ss[0] = '!'; ss[cnt] = '#'; for(int i = 0; i &lt; len; i++) ss[++cnt] = ch1[i], ss[++cnt] = '#'; ss[++cnt] = '\0';&#125;void manacher()&#123; init(); int pos = 0, mx = 0; for(int i = 1; i &lt;= cnt; i++)&#123; if(i &lt; mx) p[i] = min(p[pos * 2 - i], mx - i); else p[i] = 1; while(ss[i + p[i]] == ss[i - p[i]]) p[i]++; if(mx &lt; i + p[i]) mx = i + p[i], pos = i; ans = max(ans, p[i] - 1); &#125;&#125;void getfail(char *s)&#123; int i=0,j,po,len1=strlen(s); f[0]=len1; //初始化next[0] while(s[i]==s[i+1] &amp;&amp; i+1&lt;len1) i++; f[1]=i; //计算next[1] po=1; //初始化po的位置 for(i=2;i&lt;len1;i++) &#123; if(f[i-po]+i &lt; f[po]+po) //第一种情况，可以直接得到next[i]的值 f[i]=f[i-po]; else //第二种情况，要继续匹配才能得到next[i]的值 &#123; j = f[po]+po-i; if(j&lt;0) j=0; //如果i&gt;po+f[po],则要从头开始匹配 while(i+j&lt;len1 &amp;&amp; s[j]==s[j+i]) j++; f[i]=j; po=i; //更新po的位置 &#125; &#125;&#125;//计算extend数组void exkmp(char *s1,char *s2)&#123; int i=0,j,po,len1=strlen(s1),len2=strlen(s2); getfail(s2); //计算子串的next数组 while(s1[i]==s2[i] &amp;&amp; i&lt;len2 &amp;&amp; i&lt;len1) i++; ex[0]=i; po=0; //初始化po的位置 for(i=1;i&lt;len1;i++) &#123; if(f[i-po]+i &lt; ex[po]+po) //第一种情况，直接可以得到extend[i]的值 ex[i]=f[i-po]; else //第二种情况，要继续匹配才能得到extend[i]的值 &#123; j = ex[po]+po-i; if(j&lt;0) j=0; //如果i&gt;ex[po]+po则要从头开始匹配 while(i+j&lt;len1 &amp;&amp; j&lt;len2 &amp;&amp; s1[j+i]==s2[j]) j++; ex[i]=j; po=i; //更新po的位置 &#125; &#125;&#125;void solve()&#123; int len = strlen(ch1); //差分 for(int i = 2; i &lt;= cnt; i++)&#123; sum[(i - 1) / 2]++; sum[(i + (p[i] - 1) - 1) / 2]--; &#125; for(int i = 1; i &lt; len; i++)sum[i] += sum[i - 1]; for(int i = 1; i &lt; len; i++)&#123; res += 1LL * ex[i] * sum[i - 1]; &#125;&#125;void reverse(char *s)&#123; int len = strlen(s); for(int i = 0; i &lt; len / 2; i++)swap(s[i], s[len - i - 1]);&#125;int main()&#123; scanf("%s %s", ch1, ch2); reverse(ch1); manacher(); exkmp(ch1, ch2); solve(); printf("%lld\n", res); return 0;&#125;]]></content>
      <categories>
        <category>exkmp</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Codeforces-Round-324-(Div2)-E(Anton-and-Ira)]]></title>
    <url>%2F2019%2F02%2F05%2FCodeforces-Round-324-Div2-E-Anton-and-Ira%2F</url>
    <content type="text"><![CDATA[链接：https://codeforces.com/contest/584/problem/E思路：我们考虑从左到右枚举，然后找当前点需要放的位置到当前点区间范围内，需要放的位置在交换元素右边的点，让他们交换，一直交换到不可交换位置，复杂度O(n^2)代码：1234567891011121314151617181920212223242526272829#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 2010;int a[maxn], b[maxn], c[maxn];int n;typedef pair&lt;int, int&gt; P;int ans;vector&lt;P&gt; res;int main()&#123; scanf("%d", &amp;n); for(int i = 1; i &lt;= n; i++) scanf("%d", &amp;a[i]); for(int i = 1; i &lt;= n; i++) scanf("%d", &amp;b[i]), c[b[i]] = i; for(int i = 1; i &lt;= n; i++)&#123; for(int j = i - 1, nowi = i; j &gt;= c[a[nowi]]; j--)&#123; if(c[a[j]] &gt;= nowi)&#123; ans += nowi - j; res.push_back(P&#123;nowi, j&#125;); swap(a[nowi], a[j]); nowi = j; &#125; &#125; &#125; printf("%d\n%d\n", ans, res.size()); for(auto &amp;it : res) printf("%d %d\n", it.first, it.second); return 0;&#125;]]></content>
      <categories>
        <category>贪心</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Codeforces-Round-277-(Div2)-E(LIS-of-Sequence)]]></title>
    <url>%2F2019%2F02%2F05%2FCodeforces-Round-277-Div2-E-LIS-of-Sequence%2F</url>
    <content type="text"><![CDATA[链接：https://codeforces.com/contest/486/problem/E思路：算是见识了一个新套路吧，首先我们考虑一个位置是哪种情况，我们把它拆开，拆成刚好包含它的前缀的LIS-f1和刚好包含它后缀的LIS-f2，我们只用比较一下f1 + f2 - 1 是否等于l，如果等于，说明f1，f2中都包含了当前点，那么他就肯定处在一个LIS的情况中，否则就一定不在。那么怎么判断是否必需呢，如果必需，说明它不可替换，那么它前缀的LIS和后缀的LIS的组合一定只有一种，如果有多种就可以用另外的替换，就不是必需的了，所以我们只需要对整个统计一下组合，然后先判断是否满足f1 + f2 - 1 == l，如果不满足则一定没有，否则再看它的组合是否只有一种，如果只有一种则是必需的，否则不是必需的。代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e5 + 100;int f1[maxn], f2[maxn], a[maxn], b[maxn], g[maxn];vector&lt;int&gt; res;int n;const int inf = 1e9;map&lt;pair&lt;int, int&gt;, int&gt; check;int main()&#123; ios::sync_with_stdio(false), cin.tie(0); cin &gt;&gt; n; for(int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i], g[i] = inf; int ans = 0; for(int i = 1; i &lt;= n; i++)&#123; int k = lower_bound(g + 1, g + n + 1, a[i]) - g; f1[i] = k; g[k] = a[i]; ans = max(ans, f1[i]); &#125; for(int i = 1; i &lt;= n; i++)b[n - i + 1] = -a[i], g[i] = inf; for(int i = 1; i &lt;= n; i++)&#123; int k = lower_bound(g + 1, g + n + 1, b[i]) - g; f2[i] = k; g[k] = b[i]; &#125; for(int i = 1; i &lt;= n / 2; i++)swap(f2[i], f2[n - i + 1]); for(int i = 1; i &lt;= n; i++)&#123; if(f1[i] + f2[i] - 1 &lt; ans)&#123; continue; &#125; else check[make_pair(f1[i], f2[i])]++; &#125; for(int i = 1; i &lt;= n; i++)&#123; if(f1[i] + f2[i] - 1 &lt; ans)res.push_back(1); else if(check[make_pair(f1[i], f2[i])] == 1)res.push_back(3); else res.push_back(2); &#125; for(auto &amp;it : res)printf("%d", it); puts(""); return 0;&#125;]]></content>
      <categories>
        <category>基础dp</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Codeforces-Round-266-(Div.2)-E(Information-Graph)]]></title>
    <url>%2F2019%2F02%2F04%2FCodeforces-Round-266-Div-2-E-Information-Graph%2F</url>
    <content type="text"><![CDATA[链接：https://codeforces.com/problemset/problem/466/E思路：我们考虑，一封信会被送到B手上，当且仅在在关系下A是B的子孙，那么这个题我们可以离线做，把所有关于一封信的询问一起处理。我们考虑怎么确定当前关系下A是B的子孙，首先他们必须在一个集合中，但这不够，我们又想到，如果B是A的父亲后，B一直都会是A的父亲，不再改变，所以我们可以在最终森林上进行一边dfs，用clock确定最终森林上的父子关系，然后对于当前树上的询问，我们只需要满足他们俩在一个集合中，且最终森林上B是A的父亲即可，我们用并查集来维护集合关系，先建森林dfs用in和out的time来确定祖孙关系。代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include&lt;bits/stdc++.h&gt;using namespace std;typedef pair&lt;int,int&gt; P;const int maxn = 1e5 + 100;int n, m;int par[maxn];struct node&#123; int f, x, y;&#125;b[maxn];vector&lt;P&gt; r[maxn];int ans[maxn];vector&lt;int&gt; G[maxn];int deg[maxn];int in[maxn], out[maxn];int _t;int getroot(int a)&#123; if(a == par[a]) return a; return par[a] = getroot(par[a]);&#125;void merge(int a, int b)&#123; int p1 = getroot(a); int p2 = getroot(b); if(p1 == p2) return; par[p2] = p1;&#125;void dfs(int u, int f)&#123; in[u] = ++_t; for(auto &amp;i : G[u])&#123; dfs(i, u); &#125; out[u] = ++_t;&#125;int main()&#123; ios::sync_with_stdio(false); cin.tie(0); cin &gt;&gt; n &gt;&gt; m; for(int i = 1; i &lt;= n; i++)par[i] = i; for(int i = 1; i &lt;= m; i++)&#123; cin &gt;&gt; b[i].f; if(b[i].f == 2) cin &gt;&gt; b[i].x; else cin &gt;&gt; b[i].x &gt;&gt; b[i].y; if(b[i].f == 3)r[b[i].y].push_back(P&#123;b[i].x, i&#125;); else if(b[i].f == 1)&#123; G[b[i].y].push_back(b[i].x); deg[b[i].x]++; &#125; &#125; for(int i = 1; i &lt;= n; i++)&#123; if(!deg[i])dfs(i, 0); &#125; int len = 0; for(int i = 1; i &lt;= m; i++)&#123; if(b[i].f == 1)&#123; merge(b[i].y, b[i].x); &#125; else if(b[i].f == 2)&#123; ++len; for(auto &amp;j : r[len])&#123; if(getroot(j.first) == getroot(b[i].x) &amp;&amp; in[j.first] &lt;= in[b[i].x] &amp;&amp; out[j.first] &gt;= out[b[i].x])ans[j.second] = 1; else ans[j.second] = -1; &#125; &#125; &#125; for(int i = 1; i &lt;= m; i++)&#123; if(ans[i] == 1)cout &lt;&lt; "YES" &lt;&lt; endl; else if(ans[i] == -1)cout &lt;&lt; "NO" &lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>并查集</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[CCPC-Wannafly-Winter-Camp-Day3-J(子序列)]]></title>
    <url>%2F2019%2F02%2F04%2FCCPC-Wannafly-Winter-Camp-Day3-J-%E5%AD%90%E5%BA%8F%E5%88%97%2F</url>
    <content type="text"><![CDATA[链接：https://www.zhixincode.com/contest/12/problem/J?problem_id=192思路：一开始觉得这个题真的很难，但是后来做了loj6074之后，明白了单个字符的dp矩阵转移思想后，这个题其实就变得很简单了。当然还有一个难点就是需要将操作变化一下，我们需要将原来的cs[1]cs[2]cs[3]….cs[n]c操作更改，变成倒过来，那么就是把当前字符串变为scs(可以自行书写一下，需要看出这点非常重要)，这样我们就可以线性用矩阵递推，用s的转移矩阵 字符c的转移矩阵 s的转移矩阵，一直转移即可完成这道题，关于具体转移矩阵的推道以及运用答案向量提取答案可见上一道loj6074的题解，或者见https://www.cnblogs.com/milky-w/p/8438718.html ，感谢吉老师的好题，让我学到了不同子序列的求法。这里总结一下全部思路：首先我们可以以每个字符向后向不同的字符连边，然后不同子序列的个数问题转换为了图的路径问题，那两个字符串合并时的路径合并可以看为邻接矩阵的合并，用矩阵乘法完成。 还有一种想法是用dp去递推，然后发现dp递推可以用矩阵优化加速，那么我们保留中间的转换矩阵即可，最后用初始状态 转移矩阵 提取答案的向量，即可得到答案！代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const ll mod = 998244353;const int maxn = 2010;int n;char s[maxn];struct Martix&#123; ll v[27][27]; Martix()&#123; memset(v, 0, sizeof(v)); &#125;&#125;in, res, fac[26], ga;Martix operator *(const Martix &amp;a, const Martix &amp;b)&#123; Martix c; for(int i = 0; i &lt;= 26; i++)&#123; for(int j = 0; j &lt;= 26; j++)&#123; for(int k = 0; k &lt;= 26; k++)&#123; c.v[i][j] = (c.v[i][j] + a.v[i][k] * b.v[k][j]) % mod; &#125; &#125; &#125; return c;&#125;void init()&#123; for(int i = 0; i &lt; 26; i++)&#123; for(int j = 0; j &lt;= 26; j++)fac[i].v[j][j] = fac[i].v[j][i] = 1; &#125; for(int i = 0; i &lt;= 26; i++)res.v[i][i] = 1; //初始状态 in.v[0][26] = 1; //答案向量 for(int i = 0; i &lt; 26; i++)ga.v[i][0] = 1;&#125;int main()&#123; scanf("%d %s", &amp;n, s + 1); init(); //得到最终的转移矩阵 for(int i = n; i; i--)&#123; res = res * fac[s[i] - 'a'] * res; &#125; res = in * res * ga; printf("%lld\n", res.v[0][0]); return 0;&#125;]]></content>
      <categories>
        <category>矩阵</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[LOJ6074-2017山东一轮集训Day6(子序列)]]></title>
    <url>%2F2019%2F02%2F04%2FLOJ6074-2017%E5%B1%B1%E4%B8%9C%E4%B8%80%E8%BD%AE%E9%9B%86%E8%AE%ADDay6-%E5%AD%90%E5%BA%8F%E5%88%97%2F</url>
    <content type="text"><![CDATA[链接：https://loj.ac/problem/6074思路：本来是要做吉老师的一个字符串上求不同子序列的题，因为那个难一点，就找了一个简单的版本来练习，发现其实也不简单。吉老师当时讲课说不同子序列题可以转换为图的问题，向后连边，进而转化为邻接矩阵的问题，进而可以转化到矩阵乘法上来，一直不懂怎么转化成矩阵，想了一天终于想明白了，关于转移方程请看https://www.cnblogs.com/milky-w/p/8438718.html ，基本上是一模一样的转移方程。dp[i][j]表示前i个字符，最后以j字符结尾的方案数，只是这个题需要维护一个逆矩阵和矩阵的前缀积（注意逆矩阵的乘法顺序！！！矩阵乘法不满足交换律），这个题的逆矩阵我们很容易推出来是把原来那一列除了中间的位置都变为-1，但由于是取模运算，所以还需要加上一个mod(都是细节，要多注意)，最后我们可以用一个向量来把答案提出来，我们考虑最后答案是把所有字符的dp[n]求个和，那么我们可以用一个列向量来提答案（记住最后一个元素要为0，因为最后一个元素表示增量，具体请看转移方程），这种操作可以大大方便操作。代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e5 + 100;typedef long long ll;int n, q;const ll mod = 1e9 + 7;char s[maxn];struct Martix&#123; ll v[10][10]; Martix()&#123; memset(v, 0, sizeof(v)); &#125;&#125;fac[10], inv[10], a[maxn], b[maxn], g1, g2;Martix operator *(const Martix &amp;a, const Martix &amp;b)&#123; Martix c; for(int i = 0; i &lt;= 9; i++)&#123; for(int j = 0; j &lt;= 9; j++)&#123; for(int k = 0; k &lt;= 9; k++)&#123; c.v[i][j] = (c.v[i][j] + a.v[i][k] * b.v[k][j]) % mod; &#125; &#125; &#125; return c;&#125;void init()&#123; for(int i = 0; i &lt; 9; i++)&#123; for(int j = 0; j &lt;= 9; j++)fac[i].v[j][j] = 1, fac[i].v[j][i] = 1; for(int j = 0; j &lt;= 9; j++)inv[i].v[j][i] = mod - 1, inv[i].v[j][j] = 1;//注意逆矩阵要把-1变为mod - 1 &#125; for(int i = 0; i &lt;= 9; i++)a[0].v[i][i] = b[0].v[i][i] = 1; for(int i = 1; i &lt;= n; i++)&#123; a[i] = a[i - 1] * fac[s[i] - 'a']; b[i] = inv[s[i] - 'a'] * b[i - 1];//一定要注意逆矩阵的乘法顺序！！！！！，这样乘才可以相互抵消 &#125; //g1为初始状态，0-9位置为各个字符初始值为0，10为增量1 g1.v[0][9] = 1; //g2为提取答案的向量，注意最后一个不要设为0，因为10位置为增量 for(int i = 0; i &lt; 9; i++)g2.v[i][0] = 1;&#125;int main()&#123; scanf("%s", s + 1); n = strlen(s + 1); init(); scanf("%d", &amp;q); while(q--) &#123; int l, r; scanf("%d %d", &amp;l, &amp;r); Martix res = g1 * b[l - 1] * a[r] * g2;//注意乘法顺序！！！ printf("%lld\n", res.v[0][0]); &#125; return 0;&#125;]]></content>
      <categories>
        <category>矩阵</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[CCPC-Wannafly-Winter-Camp-Day3-E(最大独立集)]]></title>
    <url>%2F2019%2F02%2F02%2FCCPC-Wannafly-Winter-Camp-Day3-E-%E6%9C%80%E5%A4%A7%E7%8B%AC%E7%AB%8B%E9%9B%86%2F</url>
    <content type="text"><![CDATA[链接：https://www.zhixincode.com/contest/12/problem/E思路：首先考虑最简单的，最初的应该怎么做，其实就跟每个点是否是最大独立集中的必需点有关。再考虑加了很多次之后的情况，其实最后还是只跟原形态有关，如果上一次用到了最外面的原形态，并且接的根节点是必需点时，这时候就是上一次的答案*n，否则还要加上一个原形态的答案（自行理解一下），所以推出这个性质后，问题回到了最初，求树上每个点是否是最大独立集中的必需点。我们考虑首先做一遍dfs，表示只考虑子树时，这个点选不选，然后我们可以得到一个最大独立集。我们还要考虑父亲对他选或者不选的影响，如果这个点考虑父节点的情况下不选，肯定是他父节点考虑之前节点必须选，并且他的父节点只有他一个在独立集中的子结点(不然父节点就肯定不会选，那么这个点就可选)。代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const ll mod = 998244353;const int maxn = 1e5 + 100;int n, m;vector&lt;int&gt; G[maxn];bool ok[maxn];int cnt[maxn];int par[maxn];ll res;//先找到一个最大独立集的解void dfs1(int x)&#123; for(auto &amp;v :G[x])&#123; if(v == par[x])continue; par[v] = x; dfs1(v); if(cnt[v] == 0)cnt[x]++; &#125; if(cnt[x] == 0) ++res;&#125;//看他父节点是否必须选且父节点没有其他子节点在最大独立集中，如果是，则这个点必然不选void dfs2(int x)&#123; if(x != 1)&#123; if(ok[par[x]] == 0 &amp;&amp; cnt[par[x]] - (cnt[x] == 0) == 0)ok[x] = 1; else ok[x] = 0; for(auto &amp;v :G[x])&#123; if(v != par[x])dfs2(v); &#125;&#125;int main()&#123; ios::sync_with_stdio(false); cin &gt;&gt; n &gt;&gt; m; for(int i = 1; i &lt; n; i++)&#123; int u, v; cin &gt;&gt; u &gt;&gt; v; G[u].push_back(v); G[v].push_back(u); &#125; dfs1(1); ok[1] = false; dfs2(1); for(int i = 1; i &lt;= n; i++)&#123; if(!ok[i] &amp;&amp; !cnt[i])ok[i] = 1; else ok[i] = 0; &#125; bool flag = true; int now = 1; ll ans = res % mod; cout &lt;&lt; ans &lt;&lt; endl; for(int i = 1; i &lt;= m; i++)&#123; int u; cin &gt;&gt; u; if(ok[now] &amp;&amp; flag)&#123; ans = ans * n % mod; flag = false; &#125; else&#123; flag = true; ans = (ans * n + res) % mod; &#125; now = u; cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>树形dp</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[CCPC-Wannafly-Winter-Camp-Day3-D(精简改良)]]></title>
    <url>%2F2019%2F02%2F02%2FCCPC-Wannafly-Winter-Camp-Day3-D-%E7%B2%BE%E7%AE%80%E6%94%B9%E8%89%AF%2F</url>
    <content type="text"><![CDATA[链接：https://www.zhixincode.com/contest/12/problem/D?problem_id=186思路：还是自己没有想出来，但是已经无限接近了。首先树上统计任意两点贡献的总和我们一般都是转换为统计边的贡献，一条边的贡献就是边两边的点数相乘。我想的是枚举两个集合，然后合并，但这样没有限制怎么样合并，所以无法统计贡献。后来才想起吉老师上课讲过这个，说这个是一个非常经典的dp套路(貌似叫生成树dp？)，dp[S][u]表示集合S，以u为根节点的子树的距离和，我们考虑对一个集合，我们枚举其子集T，并且枚举子集的根节点为v，那么将从子集到当前状态的转移便是dp[S][u] = dp[S - T][u] + dp[T][v] + dist[u][v] num[T] (n - num[T])。因为连接只会发生在根节点，所以之前算过的贡献后续不会再因为其他加边而改变(经典套路需要领悟一下)。关于复杂度，枚举集合加上子集的复杂度总的为3^n(用一个二项式定理就可以证明)，再加上u，v，总复杂度为O(3^n * n^2)，算一下已经接近1e9了，所以我们要把一些无效的状态优化一下，预处理每个集合中有那些点以及点的个数，存起来，枚举的时候只枚举他们即可。代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;ll dp[1 &lt;&lt; 15][15];vector&lt;int&gt; p[1 &lt;&lt; 15];int n, m;int G[20][20];int num[1 &lt;&lt; 15];int main()&#123; ios::sync_with_stdio(false); cin &gt;&gt; n &gt;&gt; m; for(int i = 1; i &lt;= m; i++)&#123; int u, v, w; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; u--, v--; G[u][v] = G[v][u] = w; &#125; //预处理 for(int i = 0; i &lt; (1 &lt;&lt; n); i++)&#123; int f = 0; for(int j = 0; j &lt; n; j++)&#123; if(i &amp; (1 &lt;&lt; j))f++,p[i].push_back(j); &#125; num[i] = f; &#125; for(int i = 0; i &lt; (1 &lt;&lt; n); i++)&#123; for(int j = 0; j &lt; n; j++)&#123; dp[i][j] = -1e18; &#125; &#125; for(int i = 0; i &lt; n; i++)dp[1 &lt;&lt; i][i] = 0LL; //经典的生成树dp for(int i = 0; i &lt; (1 &lt;&lt; n); i++)&#123; for(auto &amp;j : p[i])&#123; for(int s = (i - 1) &amp; i; s; s = (s - 1) &amp; i)&#123; for(auto &amp;k : p[s]) &#123; if(!G[j][k])continue; dp[i][j] = max(dp[i][j], dp[s][k] + dp[i - s][j] + 1LL * num[s] * (n - num[s]) * G[j][k]); &#125; &#125; &#125; &#125; ll ans = 0; for(int i = 0; i &lt; n; i++)&#123; ans = max(ans, dp[(1 &lt;&lt; n) - 1][i]); &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125;]]></content>
      <categories>
        <category>状压dp</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[CCPC-Wannafly-Winter-Camp-Day1-B(吃豆豆)]]></title>
    <url>%2F2019%2F02%2F01%2FCCPC-Wannafly-Winter-Camp-Day1-B-%E5%90%83%E8%B1%86%E8%B1%86%2F</url>
    <content type="text"><![CDATA[链接：https://www.zhixincode.com/contest/2/problem/B?problem_id=24思路：做过了div2的版本，直接简单倍增一下即可，div1版本我们考虑豆子出现的周期最多是2520，所以我们在2520步内dp，然后开始用矩阵倍增，dp[i][j][k][z]表示从(i,j)到(k,z)在周期内能获得豆子的最大值，我们重新定义矩阵的乘法，将原来的乘法变为加法，将原来的加法变为取max(想一想这是为什么)，这样我们一直倍增，直到dp[sx][sy][ex][ey]刚好大于c，我们再反向倍增回来，然后可以到达一个能在2520步内到达的状态，最后我们最后再暴力一下就可以得到答案了。(叙述起来不是很难但是写起来超级烦，需要非常细心，注意答案可能会爆ll，还有就是如果一个周期都走不到的情况需要特判一下)。代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;const ll inf = 1e18;ll dp[11][11][11][11][2530];int t[11][11];int sx, sy, ex, ey;int n, m;ll c;int gox[5] = &#123;1, -1, 0, 0, 0&#125;;int goy[5] = &#123;0, 0, 1, -1, 0&#125;;struct Martix&#123; ull v[11][11][11][11];&#125;tmp[70];void mul(const Martix &amp;a, const Martix &amp;b, Martix &amp;c)&#123; for(int i = 1; i &lt;= n; i++)&#123; for(int j = 1; j &lt;= m; j++)&#123; for(int k = 1; k &lt;= n; k++)&#123; for(int z = 1; z &lt;= m; z++) &#123; c.v[i][j][k][z] = 0; for (int q = 1; q &lt;= n; q++) &#123; for (int w = 1; w &lt;= m; w++) &#123; c.v[i][j][k][z] = max(c.v[i][j][k][z], a.v[i][j][q][w] + b.v[q][w][k][z]); &#125; &#125; &#125; &#125; &#125; &#125;&#125;void cal(int x, int y) &#123; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= m; j++) &#123; for (int k = 0; k &lt;= 2520; k++) &#123; dp[x][y][i][j][k] = -inf; &#125; &#125; &#125; dp[x][y][x][y][0] = 0; for (int k = 0; k &lt; 2520; k++) &#123; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= m; j++) &#123; for (int z = 0; z &lt; 5; z++) &#123; int xx = i + gox[z]; int yy = j + goy[z]; if (xx &gt;= 1 &amp;&amp; xx &lt;= n &amp;&amp; yy &gt;= 1 &amp;&amp; yy &lt;= m) &#123; if ((k + 1) % t[xx][yy] == 0) dp[x][y][xx][yy][k + 1] = max(dp[x][y][xx][yy][k + 1], dp[x][y][i][j][k] + 1); else dp[x][y][xx][yy][k + 1] = max(dp[x][y][xx][yy][k + 1], dp[x][y][i][j][k]); &#125; &#125; &#125; &#125; &#125; for(int i = 1; i &lt;= n; i++)&#123; for(int j = 1; j &lt;= m; j++)&#123; tmp[1].v[x][y][i][j] = dp[x][y][i][j][2520]; tmp[0].v[x][y][i][j] = 0; &#125; &#125;&#125;int main()&#123; ios::sync_with_stdio(false); cin &gt;&gt; n &gt;&gt; m &gt;&gt; c; for(int i = 1; i &lt;= n; i++)&#123; for(int j = 1; j &lt;= m; j++)&#123; cin &gt;&gt; t[i][j]; &#125; &#125; cin &gt;&gt; sx &gt;&gt; sy &gt;&gt; ex &gt;&gt; ey; for(int i = 1; i &lt;= n; i++)&#123; for(int j = 1; j &lt;= m; j++)&#123; cal(i, j); &#125; &#125; int now = 1; ull p; while(tmp[now].v[sx][sy][ex][ey] &lt; c)&#123; mul(tmp[now], tmp[now], tmp[now + 1]); now++; &#125; now--; if(now) p = 1ULL &lt;&lt; (now - 1); else p = 0; Martix r = tmp[now]; while(now &gt; 1)&#123; now--; Martix x; mul(r, tmp[now], x); if(x.v[sx][sy][ex][ey] &lt;= c) r = x, p += (1ULL &lt;&lt; (now - 1)); &#125; ull res = ULLONG_MAX; if(p)&#123; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= m; j++) &#123; ll le = c - r.v[sx][sy][i][j]; for (int k = 1; k &lt;= n; k++) &#123; for (int z = 1; z &lt;= m; z++) &#123; if (le &gt; dp[i][j][k][z][2520])continue; int x = lower_bound(dp[i][j][k][z], dp[i][j][k][z] + 2521, le) - dp[i][j][k][z]; ull rx = (ull) p * 2520 + x + abs(ex - k) + abs(ey - z); res = res &lt; rx ? res : rx; &#125; &#125; &#125; &#125; &#125; else&#123; for(int i = 1; i &lt;= n; i++)&#123; for(int j = 1; j &lt;= m; j++)&#123; if(c &gt; dp[sx][sy][i][j][2520])continue; int x = lower_bound(dp[sx][sy][i][j], dp[sx][sy][i][j] + 2521, c) - dp[sx][sy][i][j]; ull rx = x + abs(ex - i) + abs(ey - j); res = res &lt; rx ? res : rx; &#125; &#125; &#125; cout &lt;&lt; res &lt;&lt; endl; return 0;&#125;]]></content>
      <categories>
        <category>矩阵快速幂</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Codeforces-Round-536-(Div.2)-E(Lunar-New-Year-and-Red-Envelopes)]]></title>
    <url>%2F2019%2F02%2F01%2FCodeforces-Round-536-Div-2-E-Lunar-New-Year-and-Red-Envelopes%2F</url>
    <content type="text"><![CDATA[链接：https://codeforces.com/contest/1106/problem/E思路：看到有时间线想着肯定跟时间线有关，又因为m最大为200所以想到对时间线dp，状态就很简单出来了dp[i][j]表示i时刻结束时，已经打扰了j次时Bob所能获得红包的最小值。那我们怎么知道当前会得到哪个红包呢，这时候我们就要根据Bob的策略预处理出所有时间点Bob会抢哪个红包，这一定是确定的，所以不用记录Bob抢过哪个红包，最后进行状态转移即可。转移后一定要在所有满足的答案中寻找一个最大值（切记切记，一直wa在这里，因为m次不一定能够用完）代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include&lt;bits/stdc++.h&gt;using namespace std;int n, m, k;const int maxn = 100100;struct node&#123; int s,e,d,w,id; bool operator&lt;(const node &amp;r)const&#123; return w &lt; r.w || (w == r.w &amp;&amp; d &lt; r.d); &#125;&#125;r[maxn];bool cmp(node &amp;a, node &amp;b)&#123; return a.s &lt; b.s;&#125;typedef long long ll;ll dp[maxn][310];int t[maxn];int main()&#123; scanf("%d%d%d", &amp;n, &amp;m, &amp;k); for(int i = 1; i &lt;= k; i++)&#123; scanf("%d %d %d %d",&amp;r[i].s, &amp;r[i].e, &amp;r[i].d, &amp;r[i].w); &#125; sort(r + 1, r + k + 1, cmp); for(int i = 1; i &lt;= k; i++)r[i].id = i; int j = 1; priority_queue&lt;node&gt; q; for(int i = 1; i &lt;= n; i++)&#123; for(; j &lt;= k; j++)&#123; if(r[j].s &gt; i)break; q.push(r[j]); &#125; while(!q.empty())&#123; if(q.top().e &gt;= i)&#123; t[i] = q.top().id; break; &#125; else q.pop(); &#125; &#125; for(int i = 0; i &lt;= n + 10; i++)&#123; for(int j = 0; j &lt;= 300; j++)&#123; dp[i][j] = 1e18; &#125; &#125; dp[0][0] = 0; for(int i = 0; i &lt; n; i++)&#123; for(int j = 0; j &lt;= m; j++)&#123; if(!t[i + 1])&#123; dp[i + 1][j] = min(dp[i + 1][j], dp[i][j]); dp[i + 1][j + 1] = min(dp[i + 1][j + 1], dp[i][j]); &#125; else&#123; dp[r[t[i + 1]].d][j] = min(dp[r[t[i + 1]].d][j], dp[i][j] + r[t[i + 1]].w); dp[i + 1][j + 1] = min(dp[i + 1][j + 1], dp[i][j]); &#125; &#125; &#125; ll ans = 1e18; //记得要找一下最大值 for(int i = 0; i &lt;= m; i++)&#123; ans = min(ans, dp[n][i]); &#125; printf("%lld\n", ans); return 0;&#125;]]></content>
      <categories>
        <category>基础dp</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[CCPC-Wannafly-Winter-Camp-Day1-G(双重矩阵)]]></title>
    <url>%2F2019%2F01%2F29%2FCCPC-Wannafly-Winter-Camp-Day1-G-%E5%8F%8C%E9%87%8D%E7%9F%A9%E9%98%B5%2F</url>
    <content type="text"><![CDATA[链接：https://www.zhixincode.com/contest/2/problem/G?problem_id=29思路：这个题最后我用了两种方法做，一种线段树维护，复杂度O(n^3lognlogA)，一种悬线法，复杂度O(n^2logA)，都挺有启发的所以准备都写写。 线段树就是枚举上下边界，然后把上下边界之间的所有1数按竖列求gcd，然后横着建立线段树，枚举左起点，比较左到右刚好为当前最大值区间长度的区间的gcd是否为1，不为就往右移动并且更新最大值，这也所有的右边界点最多只会被求一次，整个左到右复杂度是nlognlogA的，比较好想但常数有点大，如果写的不好容易超时。 还有一种就是悬线法，悬线法最奇妙的地方就是复杂度只跟矩阵中1的个数有关，所以如果事先知道1的个数就好了。我们考虑对每个元素枚举其素因子，整个矩阵最多有n^2logA个素因子，也就是最多有n^2logA个1，我们对每个素因子记录其对应元素的位置，每次枚举素因子，然后找到这些对应的位置，用悬线法求一次最大全1子矩阵即可，然后再把这些位置清空即可。枚举素因子的时候注意一下细节。代码：线段树123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139#include&lt;bits/stdc++.h&gt;using namespace std;int a[210][210];int b[210];int n, m, x, y;typedef long long ll;int g[210 &lt;&lt; 2];int r[210];int c[210];void pushup(int o)&#123; g[o] = __gcd(g[o &lt;&lt; 1], g[o &lt;&lt; 1 | 1]);&#125;void build(int o, int l, int r)&#123; if(l &lt; r)&#123; int mid = l + r &gt;&gt; 1; build(o &lt;&lt; 1, l, mid); build(o &lt;&lt; 1 | 1, mid + 1, r); pushup(o); return; &#125; g[o] = b[l];&#125;int query(int o, int tl, int tr, int l, int r)&#123; if(tr &lt; l || tl &gt; r)return 0; if(tl &gt;= l &amp;&amp; tr &lt;= r)&#123; return g[o]; &#125; int mid = tl + tr &gt;&gt; 1; return __gcd(query(o &lt;&lt; 1 | 1,mid + 1 ,tr ,l, r), query(o &lt;&lt; 1, tl, mid, l, r));&#125;ll check1(int xx, int yy)&#123; build(1, 1, 2 * m); int maxv = 0; for(int i = 1; i &lt;= m; i++)&#123; if(i + maxv &gt;= 2 * m)break; //滑动求最长gcd不为1的区间 while(i + maxv &lt;= 2 * m &amp;&amp; query(1, 1, 2 * m, i, i + maxv) != 1)maxv++; &#125; return 1LL * (yy - xx + 1) * maxv;&#125;ll check2(int xx, int yy)&#123; build(1, 1, 2 * m); int maxv = 0; for(int i = 1; i &lt;= m; i++)&#123; if(i + maxv &gt;= 2 * m) break; while(i + maxv + 1 &lt;= 2 * m &amp;&amp; query(1, 1, 2 * m, i, i + maxv) != 1)maxv++; &#125; return 1LL * (yy - xx + 1 + 1LL * (x - 2) * n ) * maxv;&#125;ll check3(int xx, int yy)&#123; build(1, 1, 2 * n); int maxv = 0; for(int i = 1; i &lt;= n; i++)&#123; if(i + maxv &gt;= 2 * n)break; while(i + maxv + 1 &lt;= 2 * n &amp;&amp; query(1, 1, 2 * n, i, i + maxv) != 1)maxv++; &#125; return 1LL * (yy - xx + 1 + 1LL * (y - 2) * m) * maxv;&#125;int main()&#123; ios::sync_with_stdio(false); cin &gt;&gt; n &gt;&gt; m &gt;&gt; x &gt;&gt; y; int ch; for(int i = 1; i &lt;= n; i++)&#123; for(int j = 1; j &lt;= m; j++)&#123; cin &gt;&gt; a[i][j]; a[i + n][j + m] = a[i][j]; a[i + n][j] = a[i][j]; a[i][j + m] = a[i][j]; if(i == 1 &amp;&amp; j == 1)ch = a[1][1]; else ch = __gcd(ch, a[i][j]); &#125; &#125; if(ch != 1)&#123; cout &lt;&lt; 1LL * n * m * x * y &lt;&lt; endl; return 0; &#125; ll res = 0; for(int i = 1; i &lt;= 2 * m; i++)&#123; c[i] = a[1][i]; for(int j = 1; j &lt;= 2 * n; j++)&#123; c[i] = __gcd(c[i], a[j][i]); &#125; &#125; for(int i = 1; i &lt;= 2 * n; i++)&#123; r[i] = a[i][1]; for(int j = 1; j &lt;= 2 * m; j++)&#123; r[i] = __gcd(r[i], a[i][j]); &#125; &#125; for(int i = 1; i &lt;= n; i++)&#123; for(int j = i; j &lt;= 2 * n; j++)&#123; if(j == i)&#123; for(int k = 1; k &lt;= 2 * m; k++)&#123; b[k] = a[j][k]; &#125; &#125; else&#123; for(int k = 1; k &lt;= 2 * m; k++)&#123; b[k] = __gcd(b[k], a[j][k]); &#125; &#125; res = max(res, check1(i, j)); &#125; &#125; if(x &gt; 2) &#123; for (int i = 1; i &lt;= n; i++) &#123; for (int j = i; j &lt;= 2 * n; j++) &#123; for (int k = 1; k &lt;= 2 * m; k++) b[k] = c[k]; res = max(res, check2(i, j)); &#125; &#125; &#125; if(y &gt; 2)&#123; for(int i = 1; i &lt;= m; i++)&#123; for(int j = i; j &lt;= 2 * m; j++)&#123; for(int k = 1; k &lt;= 2 * n; k++)b[k] = r[k]; res = max(res, check3(i, j)); &#125; &#125; &#125; cout &lt;&lt; res &lt;&lt; endl; return 0;&#125; 悬线法：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longbool vis[100010];vector&lt;int&gt; prime;vector&lt;int&gt; pr;int n, m, x, y;int a[210][210];int b[210][210];int h[210][210], l[210][210], r[210][210];map&lt;int, vector&lt;pair&lt;int,int &gt; &gt; &gt;wh;map&lt;int, bool&gt; check;ll res;void getprime(int w, int p, int q)&#123; for(int i = 0; i &lt; prime.size(); i++)&#123; if(w == 1)break; if(1LL * prime[i] * prime[i] &gt; w)break;//注意要有这句话，不然复杂度不对，素因子枚举可能退化为n/logn if(w % prime[i] == 0)&#123; if(!check[prime[i]]) &#123; check[prime[i]] = true; pr.push_back(prime[i]); &#125; wh[prime[i]].push_back(make_pair(p, q)); &#125; while(w % prime[i] == 0) w /= prime[i]; &#125; if(w &gt; 1) &#123; if(!check[w])&#123; pr.push_back(w); check[w] = true; &#125; wh[w].push_back(make_pair(p, q)); &#125;&#125;void work(int p)&#123; auto &amp;it = wh[p];//注意细节 for(int i = 0; i &lt; it.size(); i++)&#123; int xx = it[i].first; int yy = it[i].second; h[xx][yy] = h[xx - 1][yy] + 1; l[xx][yy] = l[xx][yy - 1] + 1; &#125; for(int i = it.size() - 1; i &gt;= 0; i--)&#123; int xx = it[i].first; int yy = it[i].second; r[xx][yy] = r[xx][yy + 1] + 1; &#125; for(int i = 0; i &lt; it.size(); i++)&#123; int xx = it[i].first; int yy = it[i].second; if(h[xx][yy] &gt; 1)&#123; l[xx][yy] = min(l[xx][yy], l[xx - 1][yy]); r[xx][yy] = min(r[xx][yy], r[xx - 1][yy]); &#125; &#125; for(int i = 0; i &lt; it.size();i++)&#123; int xx = it[i].first; int yy = it[i].second; ll x1 = h[xx][yy]; ll x2 = r[xx][yy] + l[xx][yy] - 1; if(x1 &gt;= n) x1 += 1LL * (x - 2) * n; if(x2 &gt;= m) x2 += 1LL * (y - 2) * m; res = max(res, x1 * x2); l[xx][yy] = 0; h[xx][yy] = 0; r[xx][yy] = 0; &#125;&#125;int main()&#123; ios::sync_with_stdio(false); for(int i = 2; i &lt; 100010; i++)&#123; if(vis[i])continue; vis[i] = true; prime.push_back(i); for(int j = 2 * i; j &lt; 100010; j += i)vis[j] = true; &#125; cin &gt;&gt; n &gt;&gt; m &gt;&gt; x &gt;&gt; y; for(int i = 1; i &lt;= n; i++)&#123; for(int j = 1; j &lt;= m; j++)&#123; cin &gt;&gt; a[i][j]; a[i + n][j] = a[i][j + m] = a[i + n][j + m] = a[i][j]; &#125; &#125; for(int i = 1; i &lt;= 2 * n; i++)&#123; for(int j = 1; j &lt;= 2 * m; j++)&#123; getprime(a[i][j], i, j); &#125; &#125; for(auto &amp;it : pr)&#123; work(it); &#125; cout &lt;&lt; res &lt;&lt; endl; return 0;&#125;]]></content>
      <categories>
        <category>悬线法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Educational-Codeforces-Round-59-(Div.2)-E(Vasya-and-Binary-String)]]></title>
    <url>%2F2019%2F01%2F28%2FEducational-Codeforces-Round-59-Div-2-E-Vasya-and-Binary-String%2F</url>
    <content type="text"><![CDATA[链接：https://codeforces.com/contest/1107/problem/E思路：这个题感觉跟在北大上课时讲的消方块的题基本一样，然后和陈松杨在camp时讲的zuma题也有类似的地方，我们考虑对于一个区间l到r，考虑最右边的一个块我们应该怎么消除，有可能是跟左边的合并有可能自己消，为了表示和左边合并的情况我们需要多开一维表示右边之后有多少块，那么我们枚举跟最后一块位置相同的点，把最后一块给并上去，同时或者消除最后一块，向这两个方向转移即可。代码：12345678910111213141516171819202122232425262728293031323334#include&lt;bits/stdc++.h&gt;using namespace std;#define maxn 110#define ll long longll dp[maxn][maxn][maxn];//dp[l][r][len]表示从l到r，r右边还有len长度相同的结果ll a[maxn];int n;string s;ll solve(int l, int r, int len)&#123; if(l &gt; r) return 0; if(l == r)return a[len + 1]; if(dp[l][r][len])return dp[l][r][len]; int now = s[r - 1]; ll &amp;r1 = dp[l][r][len] = 0; //枚举一下最后一块跟左边的哪一块进行合并 for(int i = l; i &lt; r; i++)&#123; if(s[i - 1] == now)r1 = max(r1, solve(l, i, len + 1) + solve(i + 1, r - 1, 0)); &#125; //消除最后一块 r1 = max(r1, solve(l, r - 1, 0) + a[len + 1]); return r1;&#125;int main()&#123; ios::sync_with_stdio(false); cin &gt;&gt; n; cin &gt;&gt; s; memset(dp, 0, sizeof(dp)); for(int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i]; cout &lt;&lt; solve(1, n, 0) &lt;&lt; endl; return 0;&#125;]]></content>
      <categories>
        <category>基础dp</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[洛谷P1169[ZJOI2007]棋盘制作]]></title>
    <url>%2F2019%2F01%2F28%2F%E6%B4%9B%E8%B0%B7P1169-ZJOI2007-%E6%A3%8B%E7%9B%98%E5%88%B6%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[链接：https://www.luogu.org/problemnew/show/P1169思路：悬线法具体讲解见https://www.cnblogs.com/Absolute-Zero/p/5862577.html ，主要是用于求最大子矩阵，用dp可以优化到矩阵大小的复杂度代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;bits/stdc++.h&gt;using namespace std;#define maxn 2010int c[maxn][maxn], l[maxn][maxn], r[maxn][maxn], a[maxn][maxn];int n, m;int main()&#123; ios::sync_with_stdio(false); cin &gt;&gt; n &gt;&gt; m; for(int i = 1; i &lt;= n; i++)&#123; for(int j = 1; j &lt;= m; j++)&#123; cin &gt;&gt; a[i][j]; &#125; &#125; for(int i = 1; i &lt;= n; i++)&#123; for(int j = 1; j &lt;= m; j++)&#123; if(a[i][j] != a[i - 1][j] &amp;&amp; i &gt; 1)c[i][j] = c[i - 1][j] + 1; if(a[i][j] != a[i][j - 1] &amp;&amp; j &gt; 1)l[i][j] = l[i][j - 1] + 1; if(a[i][m - j + 1] != a[i][m - j + 2] &amp;&amp; j &gt; 1)r[i][m - j + 1] = r[i][m - j + 2] + 1; &#125; &#125; //记得取min for(int i = 2; i &lt;= n; i++)&#123; for(int j = 1; j &lt;= m; j++)&#123; if(a[i][j] != a[i - 1][j])&#123; l[i][j] = min(l[i][j], l[i - 1][j]); r[i][j] = min(r[i][j], r[i - 1][j]); &#125; &#125; &#125; int r1 = 0, r2 = 0; for(int i = 1; i &lt;= n; i++)&#123; for(int j = 1; j &lt;= m; j++)&#123; int x1 = min(c[i][j] + 1, l[i][j] + r[i][j] + 1); r1 = max(r1, x1 * x1); r2 = max(r2, (c[i][j] + 1) * (r[i][j] + l[i][j] + 1)); &#125; &#125; cout &lt;&lt; r1 &lt;&lt; endl &lt;&lt; r2 &lt;&lt; endl; return 0;&#125;]]></content>
      <categories>
        <category>悬线法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[CCPC-Wannafly-Winter-Camp-Day1-H(我爱割葱)]]></title>
    <url>%2F2019%2F01%2F28%2FCCPC-Wannafly-Winter-Camp-Day1-H-%E6%88%91%E7%88%B1%E5%89%B2%E8%91%B1%2F</url>
    <content type="text"><![CDATA[链接：https://www.zhixincode.com/contest/2/problem/H?problem_id=30思路：这道题就是一道很典型利用笛卡尔树结构的题，虽然并不用将笛卡尔树构建出来。我们建立dp[cur][p][k]表示当前在笛卡尔树上的cur结点，最近的祖先节点割到了p，还剩k刀要割的情况。我们考虑状态怎么转移，首先我们找到cur子树中最小的节点（因为没有构树所以需要手动找一下），那么就转移到他的左右子树上进行切割，我们枚举切x刀，并且还要考虑当前切或者不切，向两棵子树上转移即可。 思考一下本题与区间dp的相似处和不同处在哪，区间dp最后的状态一定是一个，即每一个子区间都会被用到，但这个题不太一样，有些子区间可以不用切，所以本题要利用笛卡尔树来解决。学了笛卡尔树来补一下新的想法：如果建树出来，我们可以发现，我们如果给定要让这个树里面割x刀，我们得分配到两边去，并且还要决定该区间是否割，该区间割的收益就是这个（节点的值 - 最近割过祖先的值） * 区间长度，然后就可以递归到两边去做，在这个过程中，当前节点需要记录，当前节点割几刀需要记录，它在笛卡尔树的祖先上最近割过的是哪一个祖先节点需要记录，然后还需要枚举一下给两边子树怎么分配割的刀数，n4的dp，可以除一个比较大的常数，所以跑的飞快。。。。代码：1234567891011121314151617181920212223242526272829303132333435363738#include&lt;bits/stdc++.h&gt;using namespace std;int dp[110][110][110]; //dp[i][j][k]表示当前在笛卡尔树上i节点，祖先割到了j节点，还剩k刀要割int id[110][110];int a[110];int n, k;int cnt;int solve(int l, int r, int p, int kk)&#123; if(l &gt; r)return 0; if(!id[l][r])id[l][r] = ++cnt; int cur = id[l][r]; if(dp[cur][p][kk] != -1)return dp[cur][p][kk]; int &amp;res = dp[cur][p][kk] = 0; int nn = l; for(int i = l + 1; i &lt;= r; i++)&#123; if(a[i] &lt; a[nn]) nn = i; &#125; //当前不切 for(int i = 0; i &lt;= kk; i++)&#123; res = max(res, solve(l, nn - 1, p, i) + solve(nn + 1, r, p, kk - i)); &#125; //当前切 for(int i = 0;i &lt; kk; i++)&#123; res = max(res, (r - l + 1) * (a[nn] - a[p]) + solve(l, nn - 1, nn, i) + solve(nn + 1, r, nn, kk - i - 1)); &#125; return res;&#125;int main()&#123; ios::sync_with_stdio(false); cin &gt;&gt; n &gt;&gt; k; for(int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i]; memset(dp, -1, sizeof(dp)); cout &lt;&lt; solve(1, n, 0, k); return 0;&#125; update:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 105;int n, k;int dp[maxn][maxn][maxn], a[maxn], ls[maxn], rs[maxn], l[maxn], r[maxn], rt;void dfs(int u)&#123; l[u] = r[u] = u; if(ls[u])&#123; dfs(ls[u]); l[u] = l[ls[u]]; &#125; if(rs[u])&#123; dfs(rs[u]); r[u] = r[rs[u]]; &#125;&#125;void build()&#123; stack&lt;int&gt; s; for(int i = 1; i &lt;= n; i++)&#123; int pre = 0; while(!s.empty() &amp;&amp; a[s.top()] &gt; a[i])&#123; pre = s.top(); s.pop(); &#125; if(s.empty()) rt = i; else rs[s.top()] = i; ls[i] = pre; s.push(i); &#125; dfs(rt);&#125;int solve(int x, int nk, int f)&#123; if(dp[x][f][nk] != -1) return dp[x][f][nk]; int &amp;res = dp[x][f][nk] = 0; for(int i = 0; i &lt; nk; i++)res = max(res, (ls[x] ? solve(ls[x], i, x) : 0) + (rs[x] ? solve(rs[x], nk - i - 1, x) : 0) + (r[x] - l[x] + 1) * (a[x] - a[f])); for(int i = 0; i &lt;= nk; i++) res = max(res, (ls[x] ? solve(ls[x], i, f) : 0) + (rs[x] ? solve(rs[x], nk - i, f) : 0)); return res;&#125;int main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); cin &gt;&gt; n &gt;&gt; k; memset(dp, -1, sizeof(dp)); for (int i = 1; i &lt;= n; ++i) &#123; cin &gt;&gt; a[i]; &#125; build(); cout &lt;&lt; solve(rt, k, 0) &lt;&lt; '\n'; return 0;&#125;]]></content>
      <categories>
        <category>笛卡尔树</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Codeforces-Round-406-(Div.1)-B(Legacy)]]></title>
    <url>%2F2019%2F01%2F27%2FCodeforces-Round-406-Div-1-B-Legacy%2F</url>
    <content type="text"><![CDATA[链接：https://codeforces.com/contest/786/problem/B思路：这是另外一种线段树优化建图，此时因为需要跑最短路，各个节点需要又上又下，此时我们就需要建两棵线段树，第一棵表示入树（节点向子节点连边），第二棵表示出树（节点向父节点连边），所有入树对应叶节点到出树对应节点连一条为0的边，然后对于询问，单点有边我们找一下对应叶节点即可；点到区间我们找到出树中对应叶节点，入树中对应区间节点，然后连边即可；区间到点在出树中找到对应区间节点，在入树中找到对应叶节点，连边即可。最后从s对应的叶节点的标号开始跑一边最短路即可完成。代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106#include&lt;bits/stdc++.h&gt;using namespace std;#define maxn 100010#define ll long long#define P pair&lt;ll, int&gt;#define inf 1e18int n, q, s;struct edge&#123; int from, to; ll dist;&#125;;vector&lt;int&gt; G[maxn&lt;&lt;3];vector&lt;edge&gt; edges;int tot, _o;int ls[maxn&lt;&lt;3], rs[maxn&lt;&lt;3];int pos[2][maxn&lt;&lt;3];ll d[maxn&lt;&lt;3];int t, t1, t2;void addedge(int from, int to, ll dist)&#123; edges.push_back(edge&#123;from, to, dist&#125;); tot = edges.size(); G[from].push_back(tot - 1);&#125;void build(int &amp;o, int l, int r, int f)&#123; o = ++_o; if(l &lt; r)&#123; int mid = l + r &gt;&gt; 1; build(ls[o], l, mid, f); build(rs[o], mid + 1, r, f); if(f) addedge(ls[o], o, 0), addedge(rs[o], o, 0); else addedge(o, ls[o], 0),addedge(o, rs[o], 0); return; &#125; pos[f][l] = o;&#125;void update(int o, int tl, int tr, int l, int r, int x, int f, ll w)&#123; if(tr &lt; l || tl &gt; r)return; if(l &lt;= tl &amp;&amp; r &gt;= tr)&#123; if(f) addedge(o, x, w); else addedge(x, o, w); return; &#125; int mid = tl + tr &gt;&gt; 1; update(ls[o], tl, mid, l, r, x, f, w); update(rs[o], mid + 1, tr, l, r, x, f, w);&#125;void dij()&#123; priority_queue&lt;P, vector&lt;P&gt;, greater&lt;P&gt; &gt; q; q.push(P&#123;0, pos[0][s]&#125;); for(int i = 0; i &lt; (maxn&lt;&lt;3); i++)d[i] = inf; d[pos[0][s]] = 0; while(!q.empty())&#123; P p = q.top(); q.pop(); int u = p.second; if(d[u] &lt; p.first)continue; for(int i = 0; i &lt; G[u].size(); i++)&#123; edge &amp;e = edges[G[u][i]]; if(d[e.to] &gt; d[e.from] + e.dist)&#123; d[e.to] = d[e.from] + e.dist; q.push(P&#123;d[e.to], e.to&#125;); &#125; &#125; &#125;&#125;int main()&#123; ios::sync_with_stdio(false); cin &gt;&gt; n &gt;&gt; q &gt;&gt; s; build(t1, 1, n, 0); build(t2, 1, n, 1); for(int i = 1; i &lt;= n; i++)&#123; addedge(pos[0][i], pos[1][i], 0); &#125; for(int i = 1; i &lt;= q; i++)&#123; cin &gt;&gt; t; if(t == 1)&#123; int u, v, w; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; addedge(pos[1][u], pos[0][v], w); &#125; else if(t == 2)&#123; int u, l, r, w; cin &gt;&gt; u &gt;&gt; l &gt;&gt; r &gt;&gt; w; update(t1, 1, n, l, r, pos[1][u], 0, w); &#125; else if(t == 3)&#123; int l, r, u, w; cin &gt;&gt; u &gt;&gt; l &gt;&gt; r &gt;&gt; w; update(t2, 1, n, l, r, pos[0][u], 1, w); &#125; &#125; dij(); for(int i = 1; i &lt;= n; i++)&#123; if(d[pos[1][i]] &lt; inf)cout &lt;&lt; d[pos[1][i]] &lt;&lt; ' '; else cout&lt;&lt; -1 &lt;&lt; ' '; &#125; cout &lt;&lt; endl; return 0;&#125;]]></content>
      <categories>
        <category>线段树</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[CCPC-Wannafly-Winter-Camp-Day7-E(线性探测法)]]></title>
    <url>%2F2019%2F01%2F27%2FCCPC-Wannafly-Winter-Camp-Day7-E-%E7%BA%BF%E6%80%A7%E6%8E%A2%E6%B5%8B%E6%B3%95%2F</url>
    <content type="text"><![CDATA[链接：https://www.zhixincode.com/contest/24/problem/E?problem_id=353思路：学习了线段树优化建图的方法，现在总结一下单树的优化。单树适用于像本题这样拓扑排序，不同于最短路，如果没有限制条件的话父区间是不需要向子区间走的(如果是最短路既需要上又需要下寻找路径，所以需要两棵树)。所以本题只用一棵向上连边的线段树即可。对于某段区间到某个点，我们只需要找到那段区间对应的结点，连向限制点的节点即可。然后我们从所有入度为0的叶节点开始走，用优先队列做一遍拓扑排序即可。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124#include&lt;bits/stdc++.h&gt;using namespace std;#define maxn 100010#define ll long longint n;struct edge&#123; int from, to, dist;&#125;;vector&lt;int&gt; G[maxn&lt;&lt;3];vector&lt;edge&gt; edges;int tot;int ls[maxn&lt;&lt;3], rs[maxn&lt;&lt;3];int _o;int t1,t2;ll deg[maxn&lt;&lt;3];vector&lt;ll&gt; res;bool vis[maxn&lt;&lt;3];ll val[maxn&lt;&lt;3];const ll inf = 1e18;int pos[maxn];void init()&#123; for(int i = 0; i &lt;= 2 * n; i++)G[i].clear(); edges.clear();&#125;void addedge(int from, int to, int dist)&#123; edges.push_back(edge&#123;from, to, dist&#125;); tot = edges.size(); G[from].push_back(tot - 1); deg[to]++;&#125;struct node &#123; ll v; int id; bool operator&lt;(const node &amp;r)const&#123; return v &gt; r.v; &#125;&#125;b[maxn];void build(int &amp;o, int l, int r)&#123; o = ++_o; if(l &lt; r) &#123; int mid = l + r &gt;&gt; 1; build(ls[o], l, mid); build(rs[o], mid + 1, r); addedge(ls[o], o, 0), addedge(rs[o], o, 0);//向上构树 return; &#125; val[o] = b[l].v; pos[l] = o;&#125;void update(int o, int tl, int tr, int l, int r, int x)&#123; if(tr &lt; l || r &lt; tl)return; if(l &lt;= tl &amp;&amp; r &gt;= tr)&#123; addedge(o, x, 0);//区间节点向叶节点连边 return; &#125; int mid = tl + tr &gt;&gt; 1; update(ls[o], tl, mid, l, r, x); update(rs[o], mid + 1, tr, l, r, x);&#125;priority_queue&lt;node&gt; q;//找到所有入度为0的叶节点void insert(int o, int l, int r)&#123; if(!deg[o]) &#123; q.push(node&#123;val[o], o&#125;); &#125; if(l == r)return; int mid = l + r &gt;&gt; 1; insert(ls[o], l, mid); insert(rs[o], mid + 1, r);&#125;int main()&#123; ios::sync_with_stdio(false); cin &gt;&gt; n; init(); for(int i = 1; i &lt;= n; i++)&#123; cin &gt;&gt; b[i].v; b[i].id = i; &#125; build(t1, 1, n); for(int i = 1; i &lt;= n; i++)&#123; int idd = b[i].id; int u = b[i].v % n; u++; if(u == idd)continue; if(u &lt; idd)&#123; update(t1, 1, n, u, idd - 1, pos[idd]); &#125; else&#123; update(t1, 1, n, 1, idd - 1, pos[idd]); update(t1, 1, n, u, n, pos[idd]); &#125; &#125; //做一遍拓扑排序即可 insert(t1, 1, n); while(!q.empty())&#123; node u = q.top(); q.pop(); if(vis[u.id])continue; vis[u.id] = true; if(u.v) res.push_back(u.v); for(int i = 0; i &lt; G[u.id].size(); i++)&#123; edge &amp;e = edges[G[u.id][i]]; int v = e.to; if(vis[v])continue; deg[v]--; if(!deg[v])q.push(node&#123;val[v], v&#125;); &#125; &#125; for(int i = 0; i &lt; res.size(); i++)&#123; cout &lt;&lt; res[i] &lt;&lt; (i == res.size() - 1 ? '\n' : ' '); &#125; return 0;&#125;]]></content>
      <categories>
        <category>线段树</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[CCPC-Wannafly-Winter-Camp-Day3-B(集合)]]></title>
    <url>%2F2019%2F01%2F25%2FCCPC-Wannafly-Winter-Camp-Day3-B-%E9%9B%86%E5%90%88%2F</url>
    <content type="text"><![CDATA[链接：https://www.zhixincode.com/contest/12/problem/B?problem_id=184思路：如果两点连线穿过圆，那么做法跟ec的一样，就是直线加一段圆弧，否则的话一定是找到一个点，使得入射角等于出射角相等的时候距离最小(证明咕咕咕了，不会，直观感受即可)，那么我们在两点与圆心连线的区间上二分即可。这个题卡了acos和asin的精度(可能会有莫名的溢出导致无穷大，所以以后要强制判定一下定义域是否满足！顺手改一下模板)。代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include&lt;bits/stdc++.h&gt;using namespace std;int T;typedef double db;db x,y,r;db sx,sy,ex,ey;const db eps = 1e-11;db d1,d2,d3,d4,d5;db all;db mycos(db x)&#123; if(x&lt;-1)x = -1; if(x&gt;1)x = 1; return acos(x);&#125;db mysin(db x)&#123; if(x&lt;-1)x = -1; if(x&gt;1)x = 1; return asin(x);&#125;db mysqrt(db x)&#123; return x&lt;0?sqrt(0):sqrt(x);&#125;int dcmp(db x)&#123; return x&lt;-eps?-1:x&gt;eps;&#125;bool check(db rat)&#123; db r1 = d1*sin(rat); db r2 = d2*sin(all-rat); db r3 = mysqrt(d1*d1+r*r-2*r*d1*cos(rat)); db r4 = mysqrt(d2*d2+r*r-2*r*d2*cos(all-rat)); db t1 = r1/r3; db t2 = r2/r4; db rat1 = mysin(t1); db rat2 = mysin(t2); return dcmp(rat1-rat2)&lt;0;&#125;int main()&#123; scanf("%d",&amp;T); while(T--)&#123; scanf("%lf%lf%lf%lf%lf%lf%lf",&amp;sx,&amp;sy,&amp;ex,&amp;ey,&amp;x,&amp;y,&amp;r); d1 = mysqrt((x-sx)*(x-sx)+(y-sy)*(y-sy)); d2 = mysqrt((x-ex)*(x-ex)+(y-ey)*(y-ey)); d3 = mysqrt(d1*d1-r*r); d4 = mysqrt(d2*d2-r*r); d5 = mysqrt((sx-ex)*(sx-ex)+(sy-ey)*(sy-ey)); if(dcmp(d3+d4-d5)&gt;0)&#123; db lb = 0; db ub = mycos((d1*d1+d2*d2-d5*d5)/2/d1/d2); all = ub; while(ub-lb&gt;eps)&#123; db mid = (ub+lb)/2; if(check(mid))lb = mid; else ub = mid; &#125; printf("%.3lf\n",mysqrt(d1*d1+r*r-2*d1*r*cos(ub))+mysqrt(d2*d2+r*r-2*d2*r*cos(all-ub))); &#125; else&#123; db rat = mycos((d1*d1+d2*d2-d5*d5)/2/d1/d2); db r1 = mycos(r/d1); db r2 = mycos(r/d2); printf("%.3lf\n",r*(rat-r1-r2)+d3+d4); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>计算几何</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[CCPC-Wannafly-Winter-Camp-Day1-J(夺宝奇兵)]]></title>
    <url>%2F2019%2F01%2F25%2FCCPC-Wannafly-Winter-Camp-Day1-J-%E5%A4%BA%E5%AE%9D%E5%A5%87%E5%85%B5%2F</url>
    <content type="text"><![CDATA[链接：https://www.zhixincode.com/contest/2/problem/J?problem_id=32思路：这个题需要考虑的东西还挺多的，首先枚举最多的人有多少个，这一维一定少不了，那么剩下的操作都必须在O(logn)内完成，我们考虑转移时，以前已经选过的一定还会继续选，然后只需要在剩下的当中选出最小的补满即可。我们考虑用线段树维护剩下的信息，且每次转移时确定要拿的我们从线段树上删除，相当于在线段树上求最小k个树的总和，我们可以在线段树上维护一个数量和，一个权值和(物品按从小到大顺序排列)，这样我们就可以在O(logn)时间内找到花费最少的情况，复杂度O(nlogn)代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e5+100;int n,m;typedef long long ll;ll num[maxn&lt;&lt;2],sum[maxn&lt;&lt;2];struct node&#123; int v; int id; bool operator&lt;(const node &amp;r)const&#123; return v&lt;r.v; &#125;&#125;s[maxn];struct S&#123; int v; int id; bool operator&lt;(const S &amp;r)const&#123; return v&gt;r.v; &#125;&#125;ss[maxn];bool cmp(S a,S b)&#123; return a.v&lt;b.v;&#125;priority_queue&lt;S&gt; q[maxn];inline void pushup(int o)&#123; sum[o] = sum[o&lt;&lt;1] + sum[o&lt;&lt;1|1]; num[o] = num[o&lt;&lt;1] + num[o&lt;&lt;1|1];&#125;void build(int o,int l,int r)&#123; if(l&lt;r)&#123; int mid = l+r&gt;&gt;1; build(o&lt;&lt;1,l,mid); build(o&lt;&lt;1|1,mid+1,r); pushup(o); &#125; else&#123; sum[o] = ss[l].v; num[o] = 1LL; &#125;&#125;void update(int o,int tl,int tr,int l,int r)&#123; if(tr&lt;l||r&lt;tl)return; if(l&lt;=tl&amp;&amp;tr&lt;=r)&#123; sum[o] = 0; num[o] = 0; return; &#125; int mid = (tl+tr)&gt;&gt;1; update(o&lt;&lt;1,tl,mid,l,r); update(o&lt;&lt;1|1,mid+1,tr,l,r); pushup(o);&#125; ll query(int o,int tl,int tr,int l,int r,int x)&#123; if(tr&lt;l||r&lt;tl)return 0; if(l&lt;=tl&amp;&amp;tr&lt;=r&amp;&amp;x==num[o])return sum[o]; int mid = (tl+tr)&gt;&gt;1; ll ret = 0; if(x&lt;=num[o&lt;&lt;1]) ret = query(o&lt;&lt;1,tl,mid,l,r,x); else ret = sum[o&lt;&lt;1] + query(o&lt;&lt;1|1,mid+1,tr,l,r,x-num[o&lt;&lt;1]); return ret;&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=m;i++)&#123; scanf("%lld%d",&amp;ss[i].v,&amp;ss[i].id); s[ss[i].id].id = ss[i].id; s[ss[i].id].v++; &#125; sort(ss+1,ss+1+m,cmp);//按物品价格排序 sort(s+1,s+1+n);//按人拥有数量排序 for(int i=1;i&lt;=m;i++)&#123; q[ss[i].id].push(S&#123;ss[i].v,i&#125;);//每个人维护一个堆，且记录一下物品在线段树上的位置 &#125; build(1,1,m); ll res = 1e18; ll p = 0; int nn = 0; for(int i=m;i&gt;=0;i--)&#123;//从大到小枚举最多的人有多少物品 for(int j=n;j;j--)&#123; int id = s[j].id; if(s[j].v&lt;=i)break; //多出的部分一定拿走且之后的枚举也肯定会拿走 while(s[j].v&gt;i)&#123; s[j].v--; S now = q[id].top(); q[id].pop(); p+=now.v; nn++; update(1,1,m,now.id,now.id);//从线段树上删除，且之后一定会一直拿 &#125; &#125; ll ans = p; if(nn&lt;=i) ans+=query(1,1,m,1,m,i-nn+1);//区间上求最小的前k的和(注意不要习惯性线段树就写n，一直卡了很久) res = min(res,ans); &#125; printf("%lld\n",res); return 0;&#125;]]></content>
      <categories>
        <category>线段树</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[CCPC-Wannafly-Winter-Camp-Day4-I(咆咆咆哮)]]></title>
    <url>%2F2019%2F01%2F25%2FCCPC-Wannafly-Winter-Camp-Day4-I-%E5%92%86%E5%92%86%E5%92%86%E5%93%AE%2F</url>
    <content type="text"><![CDATA[链接：https://www.zhixincode.com/contest/16/problem/I?problem_id=245思路：具体关于凸函数的证明挖空待填，大概可以猜想出是一个凸函数，那么我们可以三分打的怪兽的数目，那么选bi所带来的具体贡献也就确定了，我们只需要先选x个x*bi-ai较大的bi，剩下全选ai即可保证最大，最后不要忘记在答案附近震荡一下保证取到最大值或者过程中记录最大值即可。代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int n;const int maxn = 1e5+100;ll now;struct node&#123; ll a,b; bool operator&lt;(const node &amp;r)const&#123; return a-now*b&gt;r.a-now*r.b; &#125;&#125;a[maxn];ll check(ll x)&#123; ll res = 0; now = x; sort(a+1,a+n+1); for(int i=1;i&lt;=x;i++)&#123; res+=a[i].a; &#125; for(int i=x+1;i&lt;=n;i++)&#123; res+=a[i].b*now; &#125; return res;&#125;int main()&#123; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++)scanf("%lld%lld",&amp;a[i].a,&amp;a[i].b); int lb = 0; int ub = n+1; ll ans = 0; while(ub&gt;=lb)&#123; int m1 = lb+(ub-lb)/3; int m2 = lb+(ub-lb)*2/3; ll r1 = check(m1); ll r2 = check(m2); ans = max(ans,max(r1,r2)); if(r1&gt;r2)ub = m2-1; else lb = m1+1; &#125; printf("%lld\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>三分</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[CCPC-Wannafly-Winter-Camp-Day5-E(Fast-Kronecker-Transform)]]></title>
    <url>%2F2019%2F01%2F25%2FCCPC-Wannafly-Winter-Camp-Day5-E-Fast-Kronecker-Transform%2F</url>
    <content type="text"><![CDATA[链接：https://www.zhixincode.com/contest/20/problem/E?problem_id=300思路：一道比较奇特的卷积题，但比普通的卷积多了一个限制，所以我们考虑分情况讨论这个问题，如果当一个数出现次数较多，我们考虑用NTT优化乘积卷积，如果次数较少，我们考虑暴力枚举，复杂度为O(T^2+n^2logn/T),通过数学分析加上实验我们可知T^2在1e7左右比较合适，此时可以通过这道题。(顺便优化了一下NNT板子，这个题速度直接翻倍啊，少取模少用if else,多用?:表达式会更快)。代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124#include&lt;bits/stdc++.h&gt; using namespace std; const int maxn = 1&lt;&lt;18; const int mod = 998244353; typedef long long ll; ll wn[20]; ll a[maxn],b[maxn],c[maxn];int n,m;map&lt;ll,vector&lt;int&gt; &gt;r1,r2;map&lt;ll,bool&gt; vis;ll d[maxn],e[maxn];ll quick_mod(ll q, ll w)&#123; ll ret = 1; q%=mod; while(w) &#123; if(w&amp;1)ret = ret*q%mod; w&gt;&gt;=1; q = q*q%mod; &#125; return ret; &#125; void getwn() &#123; for(int i=0;i&lt;20;i++)&#123; int t = 1&lt;&lt;i; wn[i] = quick_mod(3,(mod-1)/t); &#125; &#125; void change(ll a[],int len)&#123; int j = len &gt;&gt; 1; for(int i=1;i&lt;len-1;i++)&#123; if(i&lt;j) swap(a[i],a[j]); int k = len&gt;&gt;1; while(j&gt;=k)&#123; j-=k; k&gt;&gt;=1; &#125; if(j&lt;k)j+=k; &#125; &#125; void ntt(ll a[],int len,int on)&#123; change(a,len); int id = 0; for(int h=2;h&lt;=len;h&lt;&lt;=1)&#123; id++; for(int j=0;j&lt;len;j+=h)&#123; ll w=1; for(int k=j;k&lt;j+h/2;k++)&#123; ll u = a[k]%mod; ll t = w*a[k+h/2]%mod; a[k] = u+t&lt;mod?u+t:u+t-mod;//用三目运算符会更快 a[k+h/2] = u-t&lt;0?u-t+mod:u-t; w = w*wn[id]%mod; &#125; &#125; &#125; if(on==-1)&#123; for(int i=1;i&lt;len/2;i++) swap(a[i], a[len-i]); ll inv = quick_mod(len,mod-2); for(int i=0;i&lt;len;i++) a[i] = a[i]*inv%mod; &#125; &#125; void solve(ll a[],ll b[],int len)&#123; ntt(a,len,1); ntt(b,len,1); for(int i=0;i&lt;len;i++) a[i] = a[i]*b[i]%mod; ntt(a,len,-1); for(int i=0;i&lt;=n+m;i++)&#123; c[i] = c[i]+a[i]&lt;mod?c[i]+a[i]:c[i]+a[i]-mod; &#125;&#125;int main()&#123; getwn(); scanf("%d%d",&amp;n,&amp;m); for(int i=0;i&lt;=n;i++)scanf("%lld",&amp;d[i]),r1[d[i]].push_back(i); for(int i=0;i&lt;=m;i++)scanf("%lld",&amp;e[i]),r2[e[i]].push_back(i); int len = 1; while (len&lt;=n*2)len&lt;&lt;=1; for(int i=0;i&lt;=n;i++)&#123; ll nn = d[i]; if(vis[nn])continue; vis[nn] = 1; //因为r1[nn]的访问是O(logn)的，所以学会采用引用来消除这个logn，细节啊要注意。。。。 vector&lt;int&gt; &amp;t1 = r1[nn]; vector&lt;int&gt; &amp;t2 = r2[nn]; if(1LL*t1.size()*t2.size()&lt;=(1&lt;&lt;23))&#123; for(int j=0;j&lt;t1.size();j++)&#123; for(int k=0;k&lt;t2.size();k++)&#123; //注意不要爆int c[t1[j]+t2[k]] = (c[t1[j]+t2[k]]+1LL*t1[j]*t2[k])%mod; &#125; &#125; &#125; else&#123; //要全部清空 memset(a,0,sizeof(a)); memset(b,0,sizeof(b)); for(int i=0;i&lt;=n;i++)&#123; if(d[i]==nn)a[i] = i; else a[i] = 0; &#125; for(int i=0;i&lt;=m;i++)&#123; if(e[i]==nn)b[i] = i; else b[i] = 0; &#125; solve(a,b,len); &#125; &#125; for(int i=0;i&lt;=m+n;i++)&#123; printf("%lld%c",c[i],i==m+n?'\n':' '); &#125; return 0;&#125;]]></content>
      <categories>
        <category>NTT</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[CCPC-Wannafly-Winter-Camp-Day5-I(Sorting)]]></title>
    <url>%2F2019%2F01%2F24%2FCCPC-Wannafly-Winter-Camp-Day5-I-Sorting%2F</url>
    <content type="text"><![CDATA[链接：https://www.zhixincode.com/contest/21/problem/I?problem_id=324思路：首先有一个很重要很重要的性质，就是不管怎么排序，所有小于等于x元素的相对位置不会变，所有大于x的元素的相对位置不会变，那么最妙的地方就来了。我们把所有小于等于x的数置为0，大于x的数置为1，那么操作2和3其实就是统计区间内0和1的个数并且把0和1置于两边即可，维护一个0和1对应元素的前缀和即可。代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 2e5+100;typedef long long ll;ll s1[maxn],s2[maxn];int sum[maxn&lt;&lt;2];int n,q,x;int a[maxn];int tag[maxn&lt;&lt;2];inline void pushup(int o)&#123; sum[o] = sum[o&lt;&lt;1] + sum[o&lt;&lt;1|1];&#125;void build(int o,int l,int r)&#123; tag[o] = -1; if(l&lt;r)&#123; int mid = l+r&gt;&gt;1; build(o&lt;&lt;1,l,mid); build(o&lt;&lt;1|1,mid+1,r); pushup(o); &#125; else&#123; sum[o] = a[l]; &#125;&#125;void pushdown(int o,int m)&#123; if(tag[o]!=-1)&#123; tag[o&lt;&lt;1] = tag[o]; tag[o&lt;&lt;1|1] = tag[o]; sum[o&lt;&lt;1|1] = tag[o]*(m&gt;&gt;1); sum[o&lt;&lt;1] = tag[o]*(m-(m&gt;&gt;1)); tag[o] = -1; &#125;&#125;void update(int o,int tl,int tr,int l,int r,int v)&#123; if(tr&lt;l||r&lt;tl)return; if(l&lt;=tl&amp;&amp;tr&lt;=r)&#123; sum[o] = (tr-tl+1)*v; tag[o] = v; return; &#125; pushdown(o,tr-tl+1); int mid = (tl+tr)&gt;&gt;1; update(o&lt;&lt;1,tl,mid,l,r,v); update(o&lt;&lt;1|1,mid+1,tr,l,r,v); pushup(o);&#125; int query(int o,int tl,int tr,int l,int r)&#123; if(tr&lt;l||r&lt;tl)return 0; if(l&lt;=tl&amp;&amp;tr&lt;=r)return sum[o]; pushdown(o,tr-tl+1); int mid = (tl+tr)&gt;&gt;1; int ret = query(o&lt;&lt;1,tl,mid,l,r); ret+=query(o&lt;&lt;1|1,mid+1,tr,l,r); return ret;&#125;int main()&#123; scanf("%d%d%d",&amp;n,&amp;q,&amp;x); int l1 = 0,l2 = 0; for(int i=1;i&lt;=n;i++)&#123; scanf("%d",&amp;a[i]); if(a[i]&lt;=x)s1[l1+1] = s1[l1]+a[i],l1++,a[i] = 0; else s2[l2+1] = s2[l2]+a[i],l2++,a[i] = 1; &#125; build(1,1,n); for(int i=0;i&lt;q;i++)&#123; int p,l,r; scanf("%d%d%d",&amp;p,&amp;l,&amp;r); if(p==1)&#123; int x1 = query(1,1,n,1,r); int x2 = query(1,1,n,1,l-1); printf("%lld\n",s1[r-x1]-s1[l-1-x2]+s2[x1]-s2[x2]); &#125; else if(p==2)&#123; int x1 = query(1,1,n,l,r); update(1,1,n,l,r-x1,0); update(1,1,n,r-x1+1,r,1); &#125; else if(p==3)&#123; int x1 = query(1,1,n,l,r); update(1,1,n,l,l+x1-1,1); update(1,1,n,l+x1,r,0); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>线段树</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[CCPC-Wannafly-Winter-Camp-Day3-I(石头剪刀布)]]></title>
    <url>%2F2019%2F01%2F24%2FCCPC-Wannafly-Winter-Camp-Day3-I(%E7%9F%B3%E5%A4%B4%E5%89%AA%E5%88%80%E5%B8%83)%2F</url>
    <content type="text"><![CDATA[链接：https://www.zhixincode.com/contest/12/problem/I?problem_id=191思路：我们可以看出，如果询问x的话，只跟x要打多少场pk有关（有可能是先pk转移到别的位置再pk），所以我们可以考虑每次pk建立一个新节点，并且将两个点的根节点设为新节点，然后后面都依此操作即可，最后我们考虑某个点的方案数，其实也就是总方案数*他经历所有的pk并且获胜的概率数，我们考虑在并查集里面维护一个作为1/3概率比赛打了多少次，2/3概率比赛打了多少次，这样的话维护一个距离并查集即可，乘以对应概率就是总方案数。代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 4e5+100;int par[maxn];ll l[maxn];ll r[maxn];const ll mod = 998244353;ll res;bool tag[maxn];ll pow_mod(ll q,ll w)&#123; ll ret = 1; q%=mod; while(w)&#123; if(w&amp;1)ret = ret*q%mod; q = q*q%mod; w&gt;&gt;=1; &#125; return ret;&#125;int getroot(int a)&#123; if(par[a]==a)return a; int px = getroot(par[a]); l[a]+=l[par[a]]; r[a]+=r[par[a]]; return par[a] = px;&#125;void merge(int a,int b,int c)&#123; par[a] = c; par[b] = c; r[b] = r[c] + 1; l[b] = l[c]; l[a] = l[c] + 1; r[a] = r[c]; &#125;int n,m;int main()&#123; scanf("%d%d",&amp;n,&amp;m); res = 1LL; for(int i=1;i&lt;=n+m;i++)&#123; par[i] = i; l[i] = 0; r[i] = 0; if(i&lt;=n) res = res*3%mod; &#125; int len = n; for(int i=0;i&lt;m;i++)&#123; int d; scanf("%d",&amp;d); if(d==1)&#123; int a,b; scanf("%d%d",&amp;a,&amp;b); merge(getroot(a),getroot(b),++len); &#125; else if(d==2)&#123; int a; scanf("%d",&amp;a); int f = getroot(a); ll ans = 1; //printf("%d %d %lld %lld\n",a,par[a],l[a],r[a]); ans = res*pow_mod(2,l[a])%mod*pow_mod(pow_mod(3,l[a]),mod-2)%mod; ans = ans*pow_mod(pow_mod(3,r[a]),mod-2)%mod; printf("%lld\n",ans); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>并查集</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[CCPC-Wannafly-Winter-Camp-Day1-E(流流流动)]]></title>
    <url>%2F2019%2F01%2F24%2FCCPC-Wannafly-Winter-Camp-Day1-E(%E6%B5%81%E6%B5%81%E6%B5%81%E5%8A%A8)%2F</url>
    <content type="text"><![CDATA[链接：https://www.zhixincode.com/contest/1/problem/E?problem_id=16思路：易证这是一个树，所以我们考虑树上dp即可，枚举当前点选或者不选，对子树造成不同影响，然后dp子树转移即可代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1000;int dp[maxn][2];vector&lt;int&gt; G[maxn];int n;int f[maxn],d[maxn];bool vis[maxn][2];bool ok[maxn];int dfs(int u,int ff,int k)&#123; if(vis[u][ff])return dp[u][ff]; vis[u][ff] = 1; int res = 0; if(ff)res = f[u]-d[min(u,k)]; else res = f[u]; //printf("%d %d %d\n",u,ff,res); for(int i=0;i&lt;G[u].size();i++)&#123; int v = G[u][i]; if(v==k)continue; res+=dfs(v,1,u); &#125; int ans = 0; for(int i=0;i&lt;G[u].size();i++)&#123; int v = G[u][i]; if(v==k)continue; ans+=dfs(v,0,u); &#125; ok[u] = 1; return dp[u][ff] = max(res,ans);&#125;int main()&#123; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++)scanf("%d",&amp;f[i]); for(int i=1;i&lt;=n;i++)scanf("%d",&amp;d[i]); for(int i=2;i&lt;=n;i++)&#123; if(i%2&amp;&amp;3*i+1&lt;=n)&#123; G[i].push_back(3*i+1); G[3*i+1].push_back(i); &#125; if(i%2==0)&#123; G[i].push_back(i/2); G[i/2].push_back(i); &#125; &#125; int res = 0; for(int i=1;i&lt;=n;i++)&#123; if(!ok[i])res+=dfs(i,0,i); &#125; printf("%d\n",res); return 0;&#125;]]></content>
      <categories>
        <category>树形dp</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Little Sub and his Geometry Problem]]></title>
    <url>%2F2019%2F01%2F19%2FLittle-Sub-and-his-Geometry-Problem%2F</url>
    <content type="text"><![CDATA[链接：http://acm.zju.edu.cn/onlinejudge/showContestProblem.do?problemId=5852思路：首先我们将所有点按x排序，然后枚举x，对于横坐标小于等于x的位置加入树状数组，然后y轴倒着枚举（因为随着x增大如果有解y一定在不断减少），然后用树状数组判断下当前x坐标上是否存在答案即可，复杂度O(nqlogn)代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include&lt;bits/stdc++.h&gt;using namespace std;int T;typedef long long ll;int n;const int maxn = 1e5+100;ll c[maxn];int nu[maxn];int lowbit(int x)&#123; return x&amp;(-x);&#125;void add(int x,int d)&#123; while(x&lt;maxn)&#123; c[x]+=d; x+=lowbit(x); &#125;&#125;void add1(int x,int d)&#123; while(x&lt;maxn)&#123; nu[x]+=d; x+=lowbit(x); &#125;&#125;ll sum(int x)&#123; ll ret = 0; while(x)&#123; ret+=c[x]; x-=lowbit(x); &#125; return ret;&#125;int sum1(int x)&#123; int ret = 0; while(x)&#123; ret+=nu[x]; x-=lowbit(x); &#125; return ret;&#125;typedef pair&lt;int,int&gt; P;P r[maxn];int k;int q;int num;ll s;ll check(int x,int yy)&#123; return 1LL*sum1(x)*(x+yy)-sum(x);&#125;int main()&#123; scanf("%d",&amp;T); while(T--)&#123; scanf("%d%d",&amp;n,&amp;k); for(int i=0;i&lt;k;i++)scanf("%d%d",&amp;r[i].first,&amp;r[i].second); sort(r,r+k); scanf("%d",&amp;q); while(q--)&#123; scanf("%lld",&amp;s); ll res = 0; num = 0; for(int i=0;i&lt;=n;i++)c[i] = 0,nu[i] = 0; int j = n; for(int i=1;i&lt;=n;i++)&#123; while(r[num].first&lt;=i&amp;&amp;num&lt;k)&#123; add(r[num].second,r[num].second+r[num].first);//x和y贡献一起加上去 add1(r[num].second,1);//用来统计有多少个点，计算总贡献 num++; &#125; while(check(j,i)&gt;s&amp;&amp;j)&#123; j--; &#125; if(!j)break; //如果有解，答案++ if(check(j,i)==s)res++; &#125; printf("%lld%c",res,!q?'\n':' '); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>树状数组</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Little Sub and Isomorphism Sequences]]></title>
    <url>%2F2019%2F01%2F19%2FLittle-Sub-and-Isomorphism-Sequences%2F</url>
    <content type="text"><![CDATA[链接：http://acm.zju.edu.cn/onlinejudge/showContestProblem.do?problemId=5859思路：一定要注意观察性质，如果同构表示各种元素个数都相同，一定中间会有一部分重叠因为重叠不影响同构（相当于抵消），那么两边的元素都相等，那么其实就是各种元素的最远距离取最大值即可（保证每个元素在最大同构里都恰好有x或者x一个），那么我们考虑一个用来维护同种元素的位置的数据结构，而且还要一个维护不同元素最大距离的数据结构，前者我们选择用set，先离散化，然后维护每种元素的位置，后者我们用multiset，维护不同元素的最大距离，如果更改只需要在multiset中删除原来值，set中对应更改，再在multiset中插入新的值即可。代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 3e5+100;set&lt;int&gt; s[maxn];multiset&lt;int&gt; q;int n,m,T;int a[maxn];int b[maxn];struct ask&#123; int q,w,e;&#125;as[maxn];int main()&#123; scanf("%d",&amp;T); while(T--)&#123; scanf("%d%d",&amp;n,&amp;m); q.clear(); for(int i=0;i&lt;n;i++)&#123; scanf("%d",&amp;a[i]); b[i] = a[i]; &#125; int len = n; for(int i=0;i&lt;m;i++)&#123; scanf("%d",&amp;as[i].q); if(as[i].q==1)&#123; scanf("%d%d",&amp;as[i].w,&amp;as[i].e); a[len++] = as[i].e; &#125; &#125; for(int i=0;i&lt;=len;i++)s[i].clear(); sort(a,a+len); len = unique(a,a+len)-a; for(int i=0;i&lt;n;i++)&#123; int w = lower_bound(a,a+len,b[i])-a; s[w].insert(i); &#125; for(int i=0;i&lt;len;i++)&#123; int now = 0; if(s[i].size())&#123; now = (*--s[i].end())-(*s[i].begin()); &#125; if(now) q.insert(now); &#125; for(int i=0;i&lt;m;i++)&#123; if(as[i].q==1)&#123; int now = lower_bound(a,a+len,b[as[i].w-1])-a; int pre = (*--s[now].end())-(*s[now].begin()); if(q.count(pre)) q.erase(q.find(pre)); s[now].erase(as[i].w-1); pre = 0; if(s[now].size())&#123; pre = (*--s[now].end())-(*s[now].begin()); &#125; if(pre) q.insert(pre); now = lower_bound(a,a+len,as[i].e)-a; pre = 0; if(s[now].size())&#123; pre = (*--s[now].end())-(*s[now].begin()); &#125; if(q.count(pre)) q.erase(q.find(pre)); s[now].insert(as[i].w-1); pre = 0; if(s[now].size())&#123; pre = (*--s[now].end())-(*s[now].begin()); &#125; if(pre) q.insert(pre); b[as[i].w-1] = as[i].e; &#125; else&#123; if(!q.size())printf("-1\n"); else printf("%d\n",*--q.end()); &#125; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>暴力</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[EOJ-Monthly-2019.1(B)]]></title>
    <url>%2F2019%2F01%2F19%2FEOJ-Monthly-2019-1-B%2F</url>
    <content type="text"><![CDATA[链接：https://acm.ecnu.edu.cn/contest/126/standings/思路：这个题一定要分清楚哪些是有用信息，哪些是没用信息。事实上我们对于任意一个点为根建树，然后对于所有s到t进行lca，如果lca(s,t) = t,那么说明真正的根节点可能在t子树内，也可能在外面，这样的信息就无效（但有可能会有对之后的选择有所限制，题目确保有解所以我们对于后面一个条件中选最小的就可以了），反之，如果lca(s,t) != t，那么我们就知道真正的根节点一定在t的子树内，由于前面一个无用条件可能限制，并不是子树内所有的点都可以作为根节点，所以我们选择子树内深度最小（就是t）来作为根节点，所以我们只用当lca(s,t)!=t时维护一个深度最大的t即可！代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e6+100;int n,q;struct edge&#123; int from,to,dist;&#125;;int f[maxn][25];int d[maxn];int dep[maxn];vector&lt;int&gt; G[maxn];vector&lt;edge&gt; edges;int _t,tot;void init()&#123; for(int i=0;i&lt;=n;i++)G[i].clear(),dep[i] = d[i] = 0; edges.clear();&#125;void addedge(int from,int to,int dist = 1)&#123; edges.push_back(edge&#123;from,to,dist&#125;); tot = edges.size(); G[from].push_back(tot-1);&#125;void bfs(int x)&#123; queue&lt;int&gt; q; q.push(x); for(int i=0;i&lt;=n;i++)&#123; dep[i] = d[i] = 0; for(int j=0;j&lt;25;j++)f[i][j] = 0; &#125; dep[x] = 1; while(!q.empty())&#123; int u = q.front(); q.pop(); for(int i=0;i&lt;G[u].size();i++)&#123; edge e = edges[G[u][i]]; int v = e.to; if(dep[v])continue; dep[v] = dep[u] + 1; d[v] = d[u] + e.dist; f[v][0] = u; for(int j=1;j&lt;=_t;j++)&#123; f[v][j] = f[f[v][j-1]][j-1]; q.push(v); &#125; &#125; &#125;&#125;int lca(int x,int y)&#123; if(dep[x]&gt;dep[y])swap(x,y); for(int i=_t;i&gt;=0;i--)&#123; if(dep[f[y][i]]&gt;=dep[x])y = f[y][i]; &#125; if(x==y)return x; for(int i=_t;i&gt;=0;i--)&#123; if(f[x][i]!=f[y][i])x = f[x][i],y = f[y][i]; &#125; return f[x][0];&#125;int T;typedef pair&lt;int,int&gt; P;P r[maxn];char res[maxn];int main()&#123; scanf("%d",&amp;T); while(T--)&#123; scanf("%d%d",&amp;n,&amp;q); init(); _t = log(n)/log(2)+1; for(int i=0;i&lt;n-1;i++)&#123; scanf("%d%d",&amp;r[i].first,&amp;r[i].second); addedge(r[i].first,r[i].second); addedge(r[i].second,r[i].first); &#125; bfs(1); int resi = 1; for(int i=1;i&lt;=q;i++)&#123; int s,t; scanf("%d%d",&amp;s,&amp;t); int l = lca(s,t); if(l==t)continue; if(dep[resi]&lt;dep[t])resi = t; &#125; bfs(resi); for(int i=0;i&lt;n-1;i++)&#123; if(dep[r[i].first]&lt;dep[r[i].second])res[i] = 'C'; else res[i] = 'D'; &#125; res[n-1] = '\0'; printf("%s\n",res); &#125; return 0;&#125;]]></content>
      <categories>
        <category>LCA</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[bzoj2797(Squarks)]]></title>
    <url>%2F2019%2F01%2F18%2Fbzoj2797-Squarks%2F</url>
    <content type="text"><![CDATA[链接：https://acm.ecnu.edu.cn/problem/3673/思路：通过暴力枚举a2+a3的值，算出a1,a2,a3,同时删除a1+a2,a1+a3,a2+a3，剩下的元素中最小的就是a1+a4,可以计算出a4，再删除a1+a4,a2+a4,a3+a4，剩下的最小的就是a1+a5，又可以算出a5，以此类推即可。复杂度(n^3logn)，用multiset可以很简单的写出这个题。代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#pragma GCC diagnostic error "-std=c++11" #include&lt;bits/stdc++.h&gt;using namespace std;int T;typedef long long ll;multiset&lt;ll&gt; s1,s2;int n;const int maxn = 1e6;ll a[maxn];ll b[maxn];bool check(ll sum)&#123; if((sum+a[1]-a[2])%2)return false; if((sum+a[2]-a[1])%2)return false; b[2] = (sum+a[1]-a[2])/2; b[3] = (sum+a[2]-a[1])/2; b[1] = a[1]-b[2]; s2.erase(s2.find(a[1])); s2.erase(s2.find(a[2])); s2.erase(s2.find(sum)); int nn = 3; while(nn&lt;n)&#123; ll minv = 1e18; for(auto &amp;it:s2)&#123; minv = min(minv,it); &#125; b[nn+1] = minv-b[1]; for(int i=1;i&lt;=nn;i++)&#123; if(!s2.count(b[i]+b[nn+1]))return false; s2.erase(s2.find(b[i]+b[nn+1])); &#125; nn++; &#125; return true;&#125;int main()&#123; scanf("%d",&amp;T); while(T--)&#123; s1.clear(); scanf("%d",&amp;n); for(int i=1;i&lt;=n*(n-1)/2;i++)&#123; scanf("%lld",&amp;a[i]); s1.insert(a[i]); &#125; for(int i=3;i&lt;=n*(n-1)/2;i++)&#123; s2 = s1; if(check(a[i]))&#123; for(int i=1;i&lt;=n;i++)printf("%lld ",b[i]); puts(""); break; &#125; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>暴力</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[POJ(3304)(Segments)]]></title>
    <url>%2F2019%2F01%2F16%2FPOJ-3304-Segments%2F</url>
    <content type="text"><![CDATA[链接：https://vjudge.net/problem/POJ-3304思路：所有线段在投影上交于一点，可以转换为存在一条直线与所有线段相交，事实上我们如果存在，通过旋转一定可以将其旋转到两个顶点的连线上，那么我们只用枚举任意两个端点，然后判断直线与线段是否相交即可，方法就是用叉积看线段两端点是否在直线向量的两侧。代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include&lt;cstdio&gt;#include&lt;cmath&gt;using namespace std;struct Point&#123; double x,y; Point(double xx = 0,double yy = 0)&#123; x = xx; y = yy; &#125;&#125;;typedef Point Vector;Vector operator+(Vector a,Vector b)&#123;return Vector(a.x+b.x,a.y+b.y);&#125;;Vector operator-(Vector a,Vector b)&#123;return Vector(a.x-b.x,a.y-b.y);&#125;;const double eps = 1e-10;double Cross(Point a,Point b)&#123; return a.x*b.y-a.y*b.x;&#125;int dcmp(double x)&#123; if(fabs(x)&lt;eps)return 0; return x&lt;0?-1:1;&#125;const int maxn = 110;int n;int T;Point r[2*maxn];bool check(Point a,Point b)&#123; if(dcmp(a.x-b.x)==0&amp;&amp;dcmp(a.y-b.y==0))return false;//特判直线为一个点的情况 for(int i=1;i&lt;=n;i++)&#123; if(dcmp(Cross(b-a,r[i]-a)*Cross(b-a,r[i+n]-a))&gt;0)return false; &#125; return true;&#125;int main()&#123; scanf("%d",&amp;T); while(T--)&#123; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++)&#123; scanf("%lf%lf%lf%lf",&amp;r[i].x,&amp;r[i].y,&amp;r[i+n].x,&amp;r[i+n].y); &#125; bool flag = false; //枚举端点 for(int i=1;i&lt;=2*n;i++)&#123; for(int j=i+1;j&lt;=2*n;j++)&#123; if(check(r[i],r[j]))&#123; puts("Yes!"); flag = true; break; &#125; &#125; if(flag)break; &#125; if(!flag)puts("No!"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>计算几何</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2018-2019-ACM-ICPC-Asia-Jiaozuo-Regional-Contest-H(Can You Solve the Harder Problem)]]></title>
    <url>%2F2018%2F12%2F12%2F2018-2019-ACM-ICPC-Asia-Jiaozuo-Regional-Contest-H(Can-You-Solve-the-Harder-Problem)%2F</url>
    <content type="text"><![CDATA[链接：https://codeforces.com/gym/102028/problem/H思路：考虑求不同的区间，相当于不同的子串，典型的后缀数组题，那么这个题目就相当于在sa[i]+1到sa[i]+h[i]+x这x个区间内的最值和，这个要在log的时间内求出来。我们考虑用单调栈的方法求出每个元素右边第一个比他大的元素的位置，同时维护一个后缀和，即从当前点开始到最后的区间所有点最大值的总和。对于每个h[i],我们只用找到他右边第一个比他大的元素的位置并且还要在sa[i]+h[i]+1之后即可，所以我们直接暴力跳过去就好（复杂度玄学，比nlogn要大但比nlognlogn要小），统计总和即可，注意不要爆int就好！代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 2e5+100;int s[maxn];int sa[maxn],t[maxn],t2[maxn],c[maxn],n,m,k;int r[maxn],h[maxn];int maxv[maxn&lt;&lt;2],a[maxn];//n为原字符长度，放于s[]的0-n-1位置，s[n]为0，build_sa传入的参数为（n+1，字符范围）void build_sa(int n,int m)&#123;//n为原串长度+1，字符值在0-m-1 int i,*x = t,*y = t2; for(i=0;i&lt;m;i++)c[i] = 0; for(i=0;i&lt;n;i++)c[x[i]=s[i]]++; for(i=1;i&lt;m;i++)c[i]+=c[i-1]; for(i=n-1;i&gt;=0;i--)sa[--c[x[i]]] = i; for(int k=1;k&lt;=n;k&lt;&lt;=1)&#123; int p = 0; for(i=n-k;i&lt;n;i++)y[p++] = i; for(i=0;i&lt;n;i++)if(sa[i]&gt;=k)y[p++] = sa[i]-k; for(i=0;i&lt;m;i++)c[i] = 0; for(i=0;i&lt;n;i++)c[x[y[i]]]++; for(i=0;i&lt;m;i++)c[i]+=c[i-1]; for(i=n-1;i&gt;=0;i--)sa[--c[x[y[i]]]] = y[i]; swap(x,y); p = 1;x[sa[0]] = 0; for(i=1;i&lt;n;i++) x[sa[i]] = y[sa[i-1]]==y[sa[i]]&amp;&amp;y[sa[i-1]+k]==y[sa[i]+k]?p-1:p++; if(p&gt;=n)break; m = p; &#125;&#125;//最好从0开始，这样sa[n-1] = 0,可以把上一次的数据清空void getheight()&#123; int i,j,k = 0; for(i=0;i&lt;=n;i++)r[sa[i]] = i; for(i=0;i&lt;n;i++)&#123; if(k)k--; if(!r[i])continue; int j = sa[r[i]-1]; while(s[i+k]==s[j+k])k++; h[r[i]] = k; &#125;&#125;inline void pushup(int o)&#123; maxv[o] = max(maxv[o&lt;&lt;1],maxv[o&lt;&lt;1|1]);&#125;void build(int o,int l,int r)&#123; if(l&lt;r)&#123; int mid = l+r&gt;&gt;1; build(o&lt;&lt;1,l,mid); build(o&lt;&lt;1|1,mid+1,r); pushup(o); &#125; else&#123; maxv[o] = a[l]; &#125;&#125;ll query(int o,int tl,int tr,int l,int r)&#123; if(tr&lt;l||r&lt;tl)return 0; if(l&lt;=tl&amp;&amp;tr&lt;=r)return maxv[o]; int mid = (tl+tr)&gt;&gt;1; ll ret = query(o&lt;&lt;1,tl,mid,l,r); ret = max(ret,query(o&lt;&lt;1|1,mid+1,tr,l,r)); return ret;&#125;int T;int tmp[maxn];int up[maxn];ll sum[maxn];int main()&#123; ios::sync_with_stdio(false); cin&gt;&gt;T; while(T--)&#123; stack&lt;int&gt; S; cin&gt;&gt;n; for(int i=0;i&lt;=n;i++)up[i] = 0; for(int i=1;i&lt;=n;i++)cin&gt;&gt;a[i],tmp[i] = a[i]; build(1,1,n); sum[n+1] = 0; //单调栈求每个位置右边第一个比他大的数并维护一个前缀和 for(int i=n;i&gt;0;i--)&#123; while(!S.empty()&amp;&amp;a[i]&gt;=a[S.top()])S.pop(); up[i] = !S.empty()?S.top():n+1; sum[i] = sum[up[i]] + 1LL*(up[i]-i)*a[i]; S.push(i); &#125; //离散化 sort(a+1,a+n+1); int len = unique(a+1,a+n+1)-a-1; //重新分配一下大小 for(int i=0;i&lt;n;i++)s[i] = lower_bound(a+1,a+len+1,tmp[i+1])-a; s[n] = 0; build_sa(n+1,len+2); getheight(); ll ans = 0; for(int i=1;i&lt;=n;i++)&#123; int s = sa[i]+h[i]+1; //找到lcp位置的最大值 ll m1 = query(1,1,n,sa[i]+1,s); int now = sa[i]+1; //跳到第一个大于m1且位置在lcp之后的地方 while((now&lt;=s||query(1,1,n,sa[i]+1,now)&lt;=m1)&amp;&amp;now&lt;=n)&#123; now = up[now]; &#125; //统计贡献即可 ans+=1LL*(now-s)*m1+sum[now]; &#125; cout&lt;&lt;ans&lt;&lt;endl; &#125; return 0;&#125; 补一个好写一点的，其实不用线段树，只用在单调栈后来一个倍增就行，这时候我们把每一个sa的起点倍增到h[i]之后，后面的和我们可以预处理用后缀和，前面的我们倍增跳到最后一个靠近边界且在边界左边的位置，那么这个点就是到下一个更大点之前区间的最大值，后面的后缀和已经处理出来直接加上即可。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 3e5 + 100;int s[maxn];int sa[maxn],t[maxn],t2[maxn],c[maxn], n;int r[maxn],h[maxn];int a[maxn], b[maxn], f[maxn][20];typedef long long ll;ll sum[maxn];int pr[maxn];//n为原字符长度，放于s[]的0-n-1位置，s[n]为0，build_sa传入的参数为（n+1，字符范围）void build_sa(int n,int m) &#123;//n为原串长度+1，字符值在0-m-1 int i, *x = t, *y = t2; for (i = 0; i &lt; m; i++)c[i] = 0; for (i = 0; i &lt; n; i++)c[x[i] = s[i]]++; for (i = 1; i &lt; m; i++)c[i] += c[i - 1]; for (i = n - 1; i &gt;= 0; i--)sa[--c[x[i]]] = i; for (int k = 1; k &lt;= n; k &lt;&lt;= 1) &#123; int p = 0; for (i = n - k; i &lt; n; i++)y[p++] = i; for (i = 0; i &lt; n; i++)if (sa[i] &gt;= k)y[p++] = sa[i] - k; for (i = 0; i &lt; m; i++)c[i] = 0; for (i = 0; i &lt; n; i++)c[x[y[i]]]++; for (i = 0; i &lt; m; i++)c[i] += c[i - 1]; for (i = n - 1; i &gt;= 0; i--)sa[--c[x[y[i]]]] = y[i]; swap(x, y); p = 1; x[sa[0]] = 0; for (i = 1; i &lt; n; i++) x[sa[i]] = y[sa[i - 1]] == y[sa[i]] &amp;&amp; y[sa[i - 1] + k] == y[sa[i] + k] ? p - 1 : p++; if (p &gt;= n)break; m = p; &#125;&#125;//最好从0开始，这样sa[n-1] = 0,可以把上一次的数据清空void getheight() &#123; int i, j, k = 0; for (i = 1; i &lt;= n; i++) r[sa[i]] = i; for (i = 0; i &lt; n; h[r[i++]] = k) for (k ? k-- : 0, j = sa[r[i] - 1]; s[i + k] == s[j + k]; k++);&#125;int T;int main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); cin &gt;&gt; T; while(T--)&#123; cin &gt;&gt; n; for(int i = 1; i &lt;= n + 1; i++)&#123; for(int j = 0; j &lt;= 19; j++)&#123; f[i][j] = n + 1; &#125; &#125; for(int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i], b[i] = a[i]; sort(b + 1, b + n + 1); int len = unique(b + 1, b + n + 1) - b - 1; for(int i = 0; i &lt; n; i++)&#123; s[i] = lower_bound(b + 1, b + len + 1, a[i + 1]) - b; &#125; s[n] = 0; build_sa(n + 1, len + 5); getheight(); stack&lt;int&gt; sta; for(int i = n; i; i--)&#123; while(!sta.empty() &amp;&amp; a[i] &gt;= a[sta.top()]) sta.pop(); if(sta.empty()) pr[i] = n + 1; else pr[i] = sta.top(); f[i][0] = pr[i]; sta.push(i); &#125; for(int i = n; i; i--)&#123; for(int j = 1; j &lt;= 19; j++)&#123; f[i][j] = f[f[i][j - 1]][j - 1]; &#125; &#125; sum[n + 1] = 0; for(int i = n; i; i--)&#123; sum[i] = sum[pr[i]] + 1ll * (pr[i] - i) * a[i]; &#125; ll res = 0; for(int i = 1; i &lt;= n; i++)&#123; if(h[i] == 0)&#123; res += sum[sa[i] + 1]; continue; &#125; int t = sa[i] + 1 + h[i] - 1; int x = sa[i] + 1; for(int j = 19; j &gt;= 0; j--)&#123; if(f[x][j] &lt;= t) x = f[x][j]; &#125; res += 1ll * a[x] * (pr[x] - 1 - t) + sum[pr[x]]; &#125; cout &lt;&lt; res &lt;&lt; '\n'; &#125; return 0;&#125; 再补一个SAM的写法，和SA差不多，倍增找到左右端点并记录过程中的和，求个差就可以得出这个点对应的区间的答案了。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef double db;typedef pair&lt;int, int&gt; pii;typedef vector&lt;int&gt; vi;typedef vector&lt;ll&gt; vl;typedef vector&lt;pii&gt; vp;const int inf = 1e9;const ll INF = 1e18;const db eps = 1e-10;#define fi first#define se second#define pb push_back#define eb emplace_back#define ep emplace#define mem(a) memset(a, 0, sizeof(a))#define copy(a, b) memcpy(a, b, sizeof(b))#define PA cout &lt;&lt; "pass\n"#define lowbit(x) (x &amp; -x)#define all(x) x.begin(), x.end()#define TM cout &lt;&lt; db(clock()) / CLOCKS_PER_SEC &lt;&lt; '\n'const int maxn = 2e5 + 5;int len[maxn * 2]; //最长子串的长度(该节点字串数量=len[x]-len[f[x]])int f[maxn * 2]; //后缀链接(最短串前部减少一个字符所到达的状态)map&lt;int, int&gt; ch[maxn * 2]; //状态转移(尾部加一个字符的下一个状态)(图)int idx; //节点编号int last; //最后节点int pos[maxn * 2];void init() &#123; //初始化 last = idx = 1; //1表示root起始点 空集 f[1] = len[1] = 0; ch[1].clear();&#125;//SAM建图void add(int c, int id) &#123; //插入字符，为字符ascll码值 int x = ++idx; //创建一个新节点x; len[x] = len[last] + 1; // 长度等于最后一个节点+1 pos[x] = id; int p; //第一个有C转移的节点; for (p = last; p &amp;&amp; !ch[p][c]; p = f[p])ch[p][c] = x;//沿着后缀连接 将所有没有字符c转移的节点直接指向新节点 if (!p)f[x] = 1; //全部都没有c的转移 直接将新节点后缀连接到起点 else &#123; int q = ch[p][c]; //p通过c转移到的节点 if (len[p] + 1 == len[q]) //pq是连续的 f[x] = q; //将新节点后缀连接指向q即可,q节点的被后缀连接数+1 else &#123; int nq = ++idx; //不连续 需要复制一份q节点 len[nq] = len[p] + 1; //令nq与p连续 f[nq] = f[q]; //因后面link[q]改变此处不加cnt pos[nq] = pos[q]; ch[nq] = ch[q]; for (; p &amp;&amp; ch[p][c] == q; p = f[p]) ch[p][c] = nq; //沿着后缀连接 将所有通过c转移为q的改为nq f[q] = f[x] = nq; //将x和q后缀连接改为nq &#125; &#125; last = x; //更新最后处理的节点&#125;int n, T, a[maxn];int pl[maxn];ll sum[maxn][20];int fa[maxn][20];int main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); cin &gt;&gt; T; while(T--) &#123; cin &gt;&gt; n; for (int i = 1; i &lt;= 2 * n; ++i) &#123; ch[i].clear(); f[i] = len[i] = 0; &#125; init(); for (int i = 1; i &lt;= n; ++i) &#123; cin &gt;&gt; a[i]; add(a[i], i); mem(fa[i]); mem(sum[i]); &#125; stack&lt;int&gt; s; for(int i = n; i; i--)&#123; while(s.size() &amp;&amp; a[s.top()] &lt; a[i])&#123; pl[s.top()] = i; s.pop(); &#125; s.ep(i); &#125; while(!s.empty()) pl[s.top()] = 0, s.pop(); for(int i = 1; i &lt;= n; i++)&#123; fa[i][0] = pl[i]; sum[i][0] = 1ll * (i - pl[i]) * a[i]; for(int j = 1; j &lt; 20; j++)&#123; fa[i][j] = fa[fa[i][j - 1]][j - 1]; sum[i][j] = sum[fa[i][j - 1]][j - 1] + sum[i][j - 1]; &#125; &#125; ll res = 0; for(int i = 2; i &lt;= idx; i++)&#123; int p = pos[i]; int r = pos[i] - len[f[i]]; int l = pos[i] - len[i] + 1; ll s1 = 0, s2 = 0; for(int j = 19; j &gt;= 0; j--)&#123; if(fa[p][j] &gt;= r)s1 += sum[p][j], p = fa[p][j]; &#125; s1 += 1ll * (p - r) * a[p]; p = pos[i]; for(int j = 19; j &gt;= 0; j--)&#123; if(fa[p][j] &gt;= l)s2 += sum[p][j], p = fa[p][j]; &#125; s2 += 1ll * (p - l + 1) * a[p]; res += s2 - s1; &#125; cout &lt;&lt; res &lt;&lt; '\n'; &#125; return 0;&#125;]]></content>
      <categories>
        <category>后缀数组</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2018-2019-ACM-ICPC-Asia-Jiaozuo-Regional-Contest-B(Ultraman-vs.-Aodzilla-and-Bodzilla)]]></title>
    <url>%2F2018%2F12%2F10%2F2018-2019-ACM-ICPC-Asia-Jiaozuo-Regional-Contest-B(Ultraman-vs-Aodzilla-and-Bodzilla)%2F</url>
    <content type="text"><![CDATA[链接：https://codeforces.com/gym/102028/problem/B思路：神仙贪心题，细节很多也很容易写错。首先肯定要先杀其中的一种怪物并且越早杀越好，那么就分为先杀A和先杀B。如果先杀A，假设杀完A后溢出x点伤害，杀B的最后一刀需要y点伤害，如果x大于等于y，那么只用在x天改为杀B即可（满足字典序最小），否则就多加一天杀掉，前面保持不动。如果先杀B，假设杀完B后溢出x点伤害，杀A的最后一刀需要y点伤害，如果x大于等于y，则要在尽量靠前的位置选择杀A，并且保证用掉的大于y并且小于x。否则的话补一天，并且选择从1开始的连续尽量多的z天，使前面总和刚好小于x，改为杀A即可。代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int T;ll h1,h2,a1,a2;char res1[1000010],res2[1000010];int main()&#123; scanf("%d",&amp;T); while(T--)&#123; scanf("%lld%lld%lld%lld",&amp;h1,&amp;h2,&amp;a1,&amp;a2); ll ans1,ans2; ll len1 = sqrt(2*h1+0.5); while((len1)*(len1+1)&gt;=2*h1)len1--; while((len1)*(len1+1)&lt;2*h1)len1++; ll l1 = len1*(len1+1)/2-h1; ll ub = 1e9; ll lb = 0; //二分找到杀B的最后一天的位置 while(ub&gt;lb)&#123; ll mid = ub+lb&gt;&gt;1; if((2*len1+mid+1)*mid&lt;2*h2)lb = mid+1; else ub = mid; &#125; while((2*len1+lb+1)*lb&gt;=2*h2)lb--; ll len2 = lb; ll r1 = h2-(2*len1+len2+1)*len2/2; if(l1&gt;=r1)&#123; ans1 = (a1+a2)*len1+a2*len2; for(int i=0;i&lt;len1;i++)res1[i] = 'A'; res1[l1-1] = 'B'; for(int i=len1;i&lt;len1+len2;i++)res1[i] = 'B'; res1[len1+len2] = '\0'; &#125; else&#123; len2++; ans1 = (a1+a2)*len1+a2*len2; for(int i=0;i&lt;len1;i++)res1[i] = 'A'; for(int i=len1;i&lt;len1+len2;i++)res1[i] = 'B'; res1[len1+len2] = '\0'; &#125; ll len3 = sqrt(2*h2+0.5); while(len3*(len3+1)&gt;=2*h2)len3--; while(len3*(len3+1)&lt;2*h2)len3++; ll l2 = len3*(len3+1)/2-h2; ub = 1e9; lb = 0; //二分找到杀A的最后一天的位置 while(ub&gt;lb)&#123; ll mid = ub+lb&gt;&gt;1; if((2*len3+1+mid)*mid&lt;2*h1)lb = mid+1; else ub = mid; &#125; while((2*len3+1+lb)*lb&gt;=2*h1)lb--; ll len4 = lb; ll r2 = h1-(2*len3+1+len4)*len4/2; if(l2&lt;r2)&#123; len4++; ans2 = (a1+a2)*len3+a1*len4; ll s = 1; for(int i=0;i&lt;len3;i++)res2[i] = 'B'; for(int i=len3;i&lt;len3+len4;i++)res2[i] = 'A'; res2[len3+len4] = '\0'; //贪心尽量选前面的保证字典序最小 while(l2-s&gt;=0)&#123; res2[s-1] = 'A'; l2-=s; s++; &#125; &#125; else&#123; ans2 = (a1+a2)*len3+a1*len4; for(int i=0;i&lt;len3;i++)&#123; //这句话是灵魂，贪心的原则是如果（溢出的大于等于后两天的总和）或者（剩下需要的小于等于当天的并且溢出的大于等于当天的）时候可选 if(l2-i-i-3&gt;=0||(r2-i-1&lt;=0&amp;&amp;l2-i-1&gt;=0))&#123; res2[i] = 'A'; l2-=i+1; r2-=i+1; &#125; else res2[i] = 'B'; &#125; for(int i=len3;i&lt;len3+len4;i++)res2[i] = 'A'; res2[len3+len4] = '\0'; &#125; //选最优解 if(ans1&lt;ans2||(ans1==ans2&amp;&amp;strcmp(res1,res2)&lt;0))&#123; printf("%lld %s\n",ans1,res1); &#125; else printf("%lld %s\n",ans2,res2); &#125; return 0;&#125;]]></content>
      <categories>
        <category>贪心</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2018-2019 ACM-ICPC Asia Xuzhou Regional Contest Rikka with A Long Colour Palette]]></title>
    <url>%2F2018%2F12%2F08%2F2018-2019-ACM-ICPC-Asia-Xuzhou-Regional-Contest-Rikka-with-A-Long-Colour-Palette%2F</url>
    <content type="text"><![CDATA[链接：https://codeforces.com/gym/102012/problem/H思路：贪心题，从左往右扫，如果是左端点且此时num小于k，则选择一种没有用过的颜色染色，如果等于则将其入队。如果是右端点则看当前是否染过色，如果染过则从队首（左端点最靠前，这样保证所有区间都会被染色）拿一个区间出来跟它染上相同颜色，否则随便染一个用过的颜色（他一定被某个区间完全包含对答案无影响）。最后一定要注意特判一下，他只保证了sum（n）的范围，所以可能存在数据k&gt;n，那么只要输出0并且随便染色就好了。补充：用差分统计是不对的，因为有可能比如n = 4, k = 2情况，两个1 2和两个3 4区间，差分统计出来1 2 3 4都满足，答案为3，但实际上2 3之间断开了，差分是维护不了这种情况的，切记！123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123#include&lt;bits/stdc++.h&gt;using namespace std;int T;int n,k;const int maxn = 2e5+100;struct Seg&#123; int p,f,id; bool operator&lt;(const Seg &amp;a)const&#123; return p&lt;a.p||(p==a.p&amp;&amp;f&gt;a.f); &#125;&#125;ss[maxn];int color[maxn];bool vis[2*maxn];queue&lt;int&gt; u,un,q;int sum[maxn];int main()&#123; ios::sync_with_stdio(false); cin&gt;&gt;T; while(T--)&#123; cin&gt;&gt;n&gt;&gt;k; for(int i=0;i&lt;=n;i++)sum[i] = 0; while(!u.empty())u.pop(); while(!un.empty())un.pop(); while(!q.empty())q.pop(); int len = 0; for(int i=1;i&lt;=n;i++)&#123; int l,r; cin&gt;&gt;l&gt;&gt;r; ss[len].p = l; ss[len].f = -1; ss[len++].id = i; ss[len].p = r; ss[len].f = 1; ss[len++].id = i; &#125; for(int i=0;i&lt;=len;i++)vis[i] = 0; //不要忘了特判 if(k&gt;n)&#123; for(int i=1;i&lt;=n;i++)color[i] = i; cout&lt;&lt;0&lt;&lt;endl; for(int i=1;i&lt;=n;i++)&#123; cout&lt;&lt;color[i]&lt;&lt;(i==n?'\n':' '); &#125; continue; &#125; sort(ss,ss+len); for(int i=1;i&lt;=k;i++)un.push(i); int num = 0; for(int i=0;i&lt;len;i++)&#123; Seg now = ss[i]; //左区间 if(now.f==-1)&#123; if(num==k)&#123; q.push(i);//已经满了就放入队列中 &#125; else&#123; //没满就分配一种新颜色 color[now.id] = un.front(); un.pop(); u.push(color[now.id]); vis[now.id] = 1; num++; &#125; &#125; else&#123; if(!vis[now.id])&#123; //没染过色一定被包含，随便用一个当前有的颜色 color[now.id] = u.front(); vis[now.id] = 1; continue; &#125; else&#123; //从队列中取一个区间，染成当前区间的颜色 int uu = -1; while(!q.empty())&#123; int nn = q.front(); q.pop(); if(!vis[ss[nn].id])&#123; uu = nn; break; &#125; &#125; if(uu==-1)&#123; //如果不存在没染色的区间，则此时无法保持，总数-1 un.push(color[now.id]); num--; continue; &#125; vis[ss[uu].id] = 1; color[ss[uu].id] = color[now.id]; &#125; &#125; &#125; num = 0; int res = 0; int s = 0; //统计一下最长总和 for(int i=0;i&lt;len;i++)&#123; Seg now = ss[i]; if(now.f==-1)&#123; int f = num; if(sum[color[now.id]]++==0)num++; if(f==k-1&amp;&amp;num==k) s = ss[i].p; &#125; else&#123; int f = num; if(!(--sum[color[now.id]]))num--; if(f==k&amp;&amp;num==k-1)&#123; res+=now.p-s; &#125; &#125; &#125; cout&lt;&lt;res&lt;&lt;endl; for(int i=1;i&lt;=n;i++)&#123; cout&lt;&lt;color[i]&lt;&lt;(i==n?'\n':' '); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>贪心</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[HihoCoder 1879 Rikka with Triangles]]></title>
    <url>%2F2018%2F12%2F07%2FHihoCoder-1879-Rikka-with-Triangles%2F</url>
    <content type="text"><![CDATA[链接：https://vjudge.net/problem/HihoCoder-1879思路：求所有锐角三角形的面积和的二倍，我们可以对所有三角形，每个含一个锐角就算一次面积，这样锐角三角形会被算三次，直角和钝角只会被算两次。接下来我们可以选择对所有三角形都算面积，或者对钝角三角形算面积，实践证明出来对钝角要好算得多，因为对所有计数会有边界上的问题（比如所有点位于一条直线上，容易出现死循环），钝角计数我们先要把一条直线上的点处理点，然后以次为边界线，后面的叉积判断就不加=0了，防止出现转一圈回来又=0出现死循环的情况，最后减一下就是答案，细节特别多我wa了不知道多少发了，确实很难这个题，不太好写。代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef __int128 LL;const ll mod = 998244353;struct Point&#123; ll x,y; Point(ll xx = 0,ll yy = 0)&#123; x = xx; y = yy; &#125;&#125;;typedef Point Vector; Vector operator + (Vector A, Vector B) &#123; return Vector(A.x + B.x, A.y + B.y); &#125;Vector operator - (Vector A, Vector B) &#123; return Vector(A.x - B.x, A.y - B.y); &#125;Vector operator * (Vector A, ll p) &#123; return Vector(A.x*p, A.y*p); &#125;Vector operator / (Vector A, ll p) &#123; return Vector(A.x/p, A.y/p); &#125;bool operator == (const Point&amp; a, const Point&amp; b) &#123; return a.x==b.x &amp;&amp; a.y==b.y;&#125;LL Cross(Vector A, Vector B) &#123; return (LL)A.x*B.y - (LL)A.y*B.x; &#125;LL Dot(Vector A, Vector B) &#123; return (LL)A.x*B.x + (LL)A.y*B.y; &#125;int t;int n;Point a[10020],r[10020];ll sum1[10200],sum2[10020];bool cmp(Point a,Point b)&#123; if(a.y&lt;0&amp;&amp;b.y&gt;0)return true; if(a.y&gt;0&amp;&amp;b.y&lt;0)return false; if(a.y==0&amp;&amp;b.y==0)&#123; if(a.x&lt;0&amp;&amp;b.x&gt;0)return true; else return false; &#125; return Cross(a,b)&gt;0;&#125;ll pow_mod(ll q,ll w)&#123; ll ret = 1; while(w)&#123; if(w&amp;1)ret = ret*q%mod; q = q*q%mod; w&gt;&gt;=1; &#125; return ret;&#125;int main()&#123; ios::sync_with_stdio(false); cin&gt;&gt;t; while(t--)&#123; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++)&#123; cin&gt;&gt;a[i].x&gt;&gt;a[i].y; &#125; ll sum = 0; ll all = 0; for(int i=1;i&lt;=n;i++)&#123; int len = 0; for(int j=1;j&lt;=n;j++)&#123; if(i!=j) r[++len] = a[j]-a[i]; &#125; sort(r+1,r+len+1,cmp); for(int j=1;j&lt;n;j++)r[j+n-1] = r[j]; sum1[0] = sum2[0] = 0; //拆环为2倍链，维护一个前缀和 for(int j=1;j&lt;=2*n-2;j++)&#123; sum1[j] = (sum1[j-1]+r[j].x)%mod; sum2[j] = (sum2[j-1]+r[j].y)%mod; &#125; int q = 1; int e = 1; int tt = 1; for(int j=1;j&lt;n;j++)&#123; tt = max(tt,j); Point e0 = Point(-r[j].y,r[j].x); Point e1 = Point(-r[j].x,-r[j].y); //tt作为一个重合的分界线，小于他的时候更新或者大于他的时候满足条件更新 while(tt&lt;2*n-2&amp;&amp;Cross(r[tt+1],r[j])==0)tt++; //q小于tt或者大于且角度在0-90度时更新 while(q&lt;2*n-2&amp;&amp;(q&lt;tt||(Cross(r[q+1],e0)&gt;0&amp;&amp;Cross(r[q+1],r[j])&lt;=0)))q++; //tt小于q或者大于且角度在90-180度时更新 while(e&lt;2*n-2&amp;&amp;(e&lt;q||(Cross(r[e+1],e1)&gt;0&amp;&amp;Cross(r[e+1],e0)&lt;=0)))e++; //注意模运算很容易溢出 sum = (sum+(sum2[q]-sum2[tt]+mod)%mod*(r[j].x%mod)%mod-(sum1[q]-sum1[tt]+mod)%mod*(r[j].y%mod)%mod+mod)%mod; all = (all+(sum2[e]-sum2[q]+mod)%mod*(r[j].x%mod)%mod-(sum1[e]-sum1[q]+mod)%mod*(r[j].y%mod)%mod+mod)%mod; &#125; &#125; cout&lt;&lt;(sum-all+mod-all+mod)%mod*pow_mod(3LL,mod-2)%mod&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>计算几何</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2018-2019 ACM-ICPC Asia Xuzhou Regional Contest Rikka with Consistency]]></title>
    <url>%2F2018%2F12%2F06%2F2018-2019-ACM-ICPC-Asia-Xuzhou-Regional-Contest-Rikka-with-Consistency%2F</url>
    <content type="text"><![CDATA[链接：https://codeforces.com/gym/102012/problem/C思路：因为要保证时时刻刻在一条水平线上，我们不用考虑每条折线中间的路程，只用考虑端点，那么每次走到端点时二者要在一条水平线上，那么我们考虑把所有端点做水平线和折线相交，求出这些点和端点一起排序，然后进行bfs，每次向相邻结点拓展并且满足二者的高度相等，最后得到最短路径即可，要理解这个思考过程想通了题目其实就很简单了。代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128#include&lt;bits/stdc++.h&gt;using namespace std;struct Point &#123; double x, y; Point(double x = 0, double y = 0) : x(x), y(y) &#123;&#125;&#125;; typedef Point Vector; Vector operator + (Vector A, Vector B) &#123; return Vector(A.x + B.x, A.y + B.y); &#125;Vector operator - (Vector A, Vector B) &#123; return Vector(A.x - B.x, A.y - B.y); &#125;Vector operator * (Vector A, double p) &#123; return Vector(A.x*p, A.y*p); &#125;Vector operator / (Vector A, double p) &#123; return Vector(A.x/p, A.y/p); &#125; bool operator &lt; (const Point&amp; a, const Point b) &#123; return a.x &lt; b.x || (a.x == b.x &amp;&amp; a.y &lt; b.y);&#125; const double EPS = 1e-10;const double pi = acos(-1); int dcmp(double x) &#123; if(fabs(x) &lt; EPS) return 0; else return x &lt; 0 ? -1 : 1;&#125; bool operator == (const Point&amp; a, const Point&amp; b) &#123; return dcmp(a.x-b.x) == 0 &amp;&amp; dcmp(a.y-b.y) == 0;&#125;Point a[2010],r[2010];int t;int n;int len;map&lt;Point,bool&gt; check;struct node&#123; double d; int u,v; bool operator&lt;(const node &amp;r)const&#123; return d&gt;r.d; &#125;&#125;;bool vis[2000][2000];//注意别开小了容易出问题double dis(Point &amp;a,Point &amp;b)&#123; return sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));&#125;double bfs()&#123; for(int i=0;i&lt;=len;i++)&#123;//手动清空别memset否则超时 for(int j=0;j&lt;=len;j++)&#123; vis[i][j] = 0; &#125; &#125; priority_queue&lt;node&gt; q; q.push(node&#123;0,0,len-1&#125;); while(!q.empty())&#123; node now = q.top(); q.pop(); int u = now.u; int v = now.v; if(u==len-1&amp;&amp;v==0)&#123; return now.d; &#125; if(vis[u][v])continue; vis[u][v] = 1; for(int i=-1;i&lt;=1;i++)&#123; for(int j=-1;j&lt;=1;j++)&#123; int nu = u+i; int nv = v+j; // printf("%d %d\n",nu,nv); if(nu&lt;0||nu&gt;len-1||nv&lt;0||nv&gt;len-1||vis[nu][nv]||dcmp(r[nu].y-r[nv].y)!=0)continue; node p; p.u = nu; p.v = nv; p.d = now.d + dis(r[nu],r[u]) + dis(r[nv],r[v]); q.push(p); &#125; &#125; &#125; return 0;&#125;int main()&#123; scanf("%d",&amp;t); while(t--)&#123; check.clear(); scanf("%d",&amp;n); for(int i=0;i&lt;=n;i++)&#123; scanf("%lf",&amp;a[i].y); a[i].x = i; &#125; len = 0; for(int i=0;i&lt;=n;i++)&#123; for(int j=1;j&lt;=n;j++)&#123; if(i==j)continue; double k = (a[j].y-a[j-1].y)/(a[j].x-a[j-1].x); if(dcmp(k)==0)&#123; if(dcmp(a[i].y-a[j].y)==0)&#123; if(!check[a[j-1]])&#123; r[len++] = a[j-1]; check[a[j-1]] = 1; &#125; if(!check[a[j]])&#123; r[len++] = a[j]; check[a[j]] = 1; &#125; &#125; continue; &#125; //用斜率求解即可，方便快捷！ double b = a[j].y-k*a[j].x; double xx = (a[i].y-b)/k; if(!check[Point&#123;xx,a[i].y&#125;]&amp;&amp;dcmp(a[j-1].x-xx)*dcmp(a[j].x-xx)&lt;=0)&#123; r[len++] = Point&#123;xx,a[i].y&#125;; check[Point&#123;xx,a[i].y&#125;] = 1; &#125; &#125; &#125; sort(r,r+len); printf("%.15f\n",bfs()); &#125; return 0;&#125;]]></content>
      <categories>
        <category>计算几何</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2018-2019 ACM-ICPC Asia Xuzhou Regional Contest Rikka with Sorting Networks]]></title>
    <url>%2F2018%2F12%2F06%2F2018-2019-ACM-ICPC-Asia-Xuzhou-Regional-Contest-Rikka-with-Sorting-Networks%2F</url>
    <content type="text"><![CDATA[链接：https://codeforces.com/gym/102012/problem/I思路：第一反应是跟沈阳的题好像啊，推公式吧，后来发现好像不太可行（没敢继续试下去），事实上因为k有10的限制，所以我们考虑应该会有指数的存在，应该就是要枚举是否用交换器，那么在什么上枚举呢？肯定是所有n-1的排列上面，根据沈阳题的经验，这个排列数是在n^2级别的，所以整个算法的复杂度应该在n^2*2^n级别，有很多不必要的运算省去之后大概就能过了。代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;bits/stdc++.h&gt;using namespace std;int n,k,mod;int t;set&lt;vector&lt;int&gt; &gt; jj;int u[100],v[100];long long dfs(vector&lt;int&gt; &amp;a,int now)&#123; if(!now)return 1LL; int l = u[now],r = v[now]; long long ans = 0; if(a[l]&lt;a[r])&#123;//只有小于的时候才能作为用过交换器后的状态，大于的话只能作为未用过交换器的状态。 ans+=dfs(a,now-1); swap(a[u[now]],a[v[now]]); ans+=dfs(a,now-1); swap(a[u[now]],a[v[now]]); &#125; return ans;&#125;int main()&#123; ios::sync_with_stdio(false); cin&gt;&gt;t; while(t--)&#123; jj.clear(); long long res = 0; cin&gt;&gt;n&gt;&gt;k&gt;&gt;mod; for(int i=1;i&lt;=k;i++)&#123; cin&gt;&gt;u[i]&gt;&gt;v[i]; u[i]--; v[i]--; &#125; for(int i=1;i&lt;=n;i++)&#123;//枚举哪个数改变了位置 vector&lt;int&gt; s; for(int j=1;j&lt;i;j++)&#123; s.push_back(j); &#125; for(int j=i+1;j&lt;=n;j++)s.push_back(j); for(int j=0;j&lt;n;j++)&#123;//枚举改变到了那个位置 vector&lt;int&gt; ss; for(int k=0;k&lt;j;k++)&#123; ss.push_back(s[k]); &#125; ss.push_back(i); for(int k=j;k&lt;s.size();k++)ss.push_back(s[k]); if(!jj.count(ss))res+=dfs(ss,k); jj.insert(ss); &#125; &#125; cout&lt;&lt;res%mod&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>dfs</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2018-2019 ACM-ICPC Asia Xuzhou Regional Contest Rikka with Illuminations]]></title>
    <url>%2F2018%2F12%2F06%2F2018-2019-ACM-ICPC-Asia-Xuzhou-Regional-Contest-Rikka-with-Illuminations%2F</url>
    <content type="text"><![CDATA[链接：https://codeforces.com/gym/102012/problem/M思路：首先我们要处理出所有灯能覆盖到哪些区间，因为一定是一段连续的区间，所以我们记录最左和最右即可。能否照到直接用叉积判断即可，因为要求最少，我们首先考虑一维坐标下的最小区间覆盖，贪心即可。本题是环我们可以把环拆成2倍的链，对于每一个灯能照到的起始和最终点，如果前者编号小于后者（不跨越最大值），则维持不动，反之则将后者+n，保证在2倍链上前者小于后者，最后我们枚举一个灯，并将他的左端点作为起点，贪心求出最小值，更新答案即可得到最后的结果（细节非常多一定要慢慢写）代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161#include&lt;bits/stdc++.h&gt;using namespace std;struct Point&#123; double x,y; Point(double x=0,double y=0):x(x),y(y)&#123;&#125;&#125;;typedef Point Vector;Vector operator+(Vector A,Vector B)&#123; return Vector(A.x+B.x,A.y+B.y);&#125;Vector operator-(Vector A,Vector B)&#123; return Vector(A.x-B.x,A.y-B.y);&#125;Vector operator*(Vector A,double p)&#123; return Vector(A.x*p,A.y*p);&#125;Vector operator/(Vector A,double p)&#123; return Vector(A.x/p,A.y/p);&#125;const double eps = 1e-10;int dcmp(double x)&#123; if(fabs(x)&lt;eps)return 0; return x&lt;0?-1:1;&#125;double Cross(Vector A,Vector B)&#123; return A.x*B.y-A.y*B.x;&#125;int t;int n,m;Point rn[1010];Point rm[1010];bool g[2010][2010];pair&lt;int,int&gt; q[2010];Vector E[1010];struct event&#123; int l,r,id; bool operator&lt;(const event &amp;rr)&#123; return l&lt;rr.l||(l==rr.l&amp;&amp;r&gt;rr.r); &#125;&#125;ss[2010];int main()&#123; scanf("%d",&amp;t); while(t--)&#123; memset(g,0,sizeof(g)); scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++)&#123; scanf("%lf%lf",&amp;rn[i].x,&amp;rn[i].y); &#125; for(int i=1;i&lt;n;i++)&#123; E[i] = rn[i+1]-rn[i]; &#125; E[n] = rn[1]-rn[n]; for(int i=1;i&lt;=m;i++)&#123; scanf("%lf%lf",&amp;rm[i].x,&amp;rm[i].y); &#125; for(int i=1;i&lt;=m;i++)&#123; for(int j=1;j&lt;=n;j++)&#123; Vector r1 = E[j]; Vector r2 = rm[i]-rn[j]; if(dcmp(Cross(r2,r1))&gt;0)g[i][j] = g[i][j+n] = 1; &#125; &#125; //处理出环上的左右端点 for(int i=1;i&lt;=m;i++)&#123; int maxv = 0; int minv = n+1; int now; for(int j=1;j&lt;=n;j++)&#123; if(g[i][j])&#123; now = j; break; &#125; &#125; maxv = minv = now; while(g[i][(minv-1+n-1)%n+1])&#123; minv = (minv-1+n-1)%n+1; &#125; while(g[i][(maxv+n)%n+1])&#123; maxv = (maxv+n)%n+1; &#125; q[i] = make_pair(minv,maxv); &#125; //转换为链上的端点，如果满足前者小于后者则在后边区间复制一份即可 int len = 0; for(int i=1;i&lt;=m;i++)&#123; if(q[i].first&lt;=q[i].second)&#123; ss[len].id = i; ss[len].l = q[i].first; ss[len++].r = q[i].second; ss[len].id = i; ss[len].l = q[i].first+n; ss[len++].r = q[i].second+n; &#125; else&#123; ss[len].id = i; ss[len].l = q[i].first; ss[len++].r = q[i].second+n; &#125; &#125; sort(ss,ss+len); vector&lt;int&gt; an; int rr = 1e9; //枚举灯的起点，开始贪心 for(int k=0;k&lt;len;k++)&#123; int flag = 0; int s = ss[k].l; int now = s; int i = k; int res = 0; vector&lt;int&gt; ans; while(now&lt;s+n)&#123; int up = 0; int nowi = -1; for(;i&lt;len;i++)&#123; if(ss[i].l&gt;now)break; if(up&lt;ss[i].r+1)&#123; up = ss[i].r+1; nowi = ss[i].id; &#125; &#125; if(nowi!=-1)&#123; ans.push_back(nowi); now = up; res++; &#125; else&#123; flag = 1; break; &#125; &#125; if(flag)continue; if(rr&gt;res)&#123; rr = res; an = ans; &#125; &#125; if(rr==1e9)puts("-1"); else&#123; printf("%d\n",an.size()); for(int i=0;i&lt;an.size();i++) &#123; printf("%d%c",an[i],i==an.size()-1?'\n':' '); &#125; &#125; &#125; return 0;&#125; 真的佩服一一和谈学姐配合一发过这个题啊！]]></content>
      <categories>
        <category>计算几何</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Round 525 (Div. 2) Ehab-and-a-component-choosing-problem]]></title>
    <url>%2F2018%2F12%2F05%2FCodeforces%20Round%20525%20(Div.%202)%20Ehab-and-a-component-choosing-problem%2F</url>
    <content type="text"><![CDATA[链接：https://codeforces.com/contest/1088/problem/E思路：题目求点权和与连通块比值的最大值，首先我们需要想到最大的平均值一定等于一个连通块的最大值，如果不等于，我们可以只选这一个连通块，从而达到那个值。想到这里题目就变简单了，我们只需要第一次dfs找出所有连通块的最大值即可，第二次dfs查看每个点及其子树组成的连通块的大小，如果等于那个最大值k++，并将该点dp值变为0，否则就舍弃掉不取这一个，最后输出答案即可。代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 3e5+100;ll dp[maxn],ans = -1e18;vector&lt;int&gt; G[maxn];ll v[maxn];int n;ll k;ll dfs(int u,int f,int p)&#123; dp[u] = v[u]; for(int i=0;i&lt;G[u].size();i++)&#123; int vv = G[u][i]; if(vv==f)continue; dp[u]+=max(dfs(vv,u,p),0LL); &#125; if(p)ans = max(ans,dp[u]); else if(dp[u]==ans)&#123; k++; dp[u] = 0; &#125; return dp[u];&#125;int main()&#123; ios::sync_with_stdio(false); cin&gt;&gt;n; for(int i=1;i&lt;=n;i++)cin&gt;&gt;v[i]; for(int i=0;i&lt;n-1;i++)&#123; int a,b; cin&gt;&gt;a&gt;&gt;b; G[a].push_back(b); G[b].push_back(a); &#125; dfs(1,0,1); dfs(1,0,0); cout&lt;&lt;ans*k&lt;&lt;" "&lt;&lt;k&lt;&lt;endl; return 0;&#125;]]></content>
      <categories>
        <category>贪心</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Round 525(Div.2) Ehab and another another xor problem]]></title>
    <url>%2F2018%2F12%2F05%2FCodeforces%20Round%20525(Div.2)%20Ehab%20and%20another%20another%20xor%20problem%2F</url>
    <content type="text"><![CDATA[链接：https://codeforces.com/contest/1088/problem/D思路：一开始没转过弯来，虽然每一位需要三次询问才能确定，但是三次询问后后面的大小我们可以推出，所以除了第一位和最后一位，其他的位置我们相当于只需要两次询问即可算出，先询问00，再01，再11，把等于的情况单独拿出来判断即可，还是很简单的，记住交互题要刷新输出，并且输出要带上换行符啊不然就会出错！感觉代码可以精简一下，懒得改了，以后要注意这个问题！代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#include&lt;bits/stdc++.h&gt;using namespace std;int d;int main()&#123; int resa = 0; int resb = 0; int next = -2; for(int i=29;i&gt;=0;i--)&#123; int f = next; next = -2; if(f==-2)&#123; printf("? %d %d\n",resa,resb); fflush(stdout); scanf("%d",&amp;d); &#125; else&#123; d = f; &#125; if(d==1)&#123; printf("? %d %d\n",resa+(1&lt;&lt;i),resb);//一定要输出换行符 fflush(stdout);//一定要刷新 scanf("%d",&amp;d); if(d==1)&#123; printf("? %d %d\n",resa,resb+(1&lt;&lt;i)); fflush(stdout); scanf("%d",&amp;d); if(d==1)&#123; resa+=(1&lt;&lt;i); next = 1; &#125; else&#123; next = 1; &#125; &#125; else if(d==-1)&#123; printf("? %d %d\n",resa,resb+(1&lt;&lt;i)); fflush(stdout); scanf("%d",&amp;d); if(d==1)&#123; resa+=(1&lt;&lt;i); resb+=(1&lt;&lt;i); next = 1; &#125; else &#123; resa+=(1&lt;&lt;i); next = -1; &#125; &#125; else&#123; resa+=(1&lt;&lt;i); next = 0; &#125; &#125; else if(d==-1)&#123; printf("? %d %d\n",resa+(1&lt;&lt;i),resb); fflush(stdout); scanf("%d",&amp;d); if(d==1)&#123; printf("? %d %d\n",resa,resb+(1&lt;&lt;i)); fflush(stdout); scanf("%d",&amp;d); if(d==1)&#123; resb+=(1&lt;&lt;i); next = 1; &#125; else&#123; next = -1; &#125; &#125; else if(d==-1)&#123; printf("? %d %d\n",resa,resb+(1&lt;&lt;i)); fflush(stdout); scanf("%d",&amp;d); if(d==1)&#123; resa+=(1&lt;&lt;i); resb+=(1&lt;&lt;i); next = -1; &#125; else&#123; resb+=(1&lt;&lt;i); next = -1; &#125; &#125; else&#123; resb+=(1&lt;&lt;i); next = 0; &#125; &#125; else&#123; printf("? %d %d\n",resa,resb+(1&lt;&lt;i)); fflush(stdout); scanf("%d",&amp;d); if(d==1)&#123; resa+=(1&lt;&lt;i); resb+=(1&lt;&lt;i); &#125; next = 0; &#125; &#125; printf("! %d %d\n",resa,resb); return 0;&#125;]]></content>
      <categories>
        <category>交互题</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[UVA11186(Circum Triangle)]]></title>
    <url>%2F2018%2F12%2F03%2FUVA11186-Circum-Triangle%2F</url>
    <content type="text"><![CDATA[链接：https://vjudge.net/problem/UVA-11186思路：提供两种做法，首先说自己的（参考cqh北京计算几何题的思路），首先对所有点按照极角进行排序，每次按顺序枚举一个点，然后求出所有点的x坐标和y坐标和，然后枚举第二个点，按照叉积展开后的方法求出面积和，并把当前点的x,y和扣除，加入到另一个初始化为0的和中（因为枚举后一个点时前面的叉积就为负了，需要分开计算），最后每个三角形被算了6次，去重即可,注意要开long long。第二种做法是容斥原理，做法参考这里，也是很妙的做法：https://blog.csdn.net/accelerator_/article/details/44698869代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include&lt;bits/stdc++.h&gt;using namespace std;struct Point &#123; double x, y; Point(double x = 0, double y = 0) : x(x), y(y) &#123;&#125;&#125;; typedef Point Vector; Vector operator + (Vector A, Vector B) &#123; return Vector(A.x + B.x, A.y + B.y); &#125;Vector operator - (Vector A, Vector B) &#123; return Vector(A.x - B.x, A.y - B.y); &#125;Vector operator * (Vector A, double p) &#123; return Vector(A.x*p, A.y*p); &#125;Vector operator / (Vector A, double p) &#123; return Vector(A.x/p, A.y/p); &#125; bool operator &lt; (const Point&amp; a, const Point b) &#123; return a.x &lt; b.x || (a.x == b.x &amp;&amp; a.y &lt; b.y);&#125; const double EPS = 1e-10;const double pi = acos(-1); int dcmp(double x) &#123; if(fabs(x) &lt; EPS) return 0; else return x &lt; 0 ? -1 : 1;&#125; bool operator == (const Point&amp; a, const Point&amp; b) &#123; return dcmp(a.x-b.x) == 0 &amp;&amp; dcmp(a.y-b.y) == 0;&#125;//向量叉积double Cross(Vector A, Vector B) &#123; return A.x*B.y - A.y*B.x; &#125; int n;double R;Point r[1000];bool cmp(Point &amp;a,Point &amp;b)&#123; return dcmp(Cross(a,b))&gt;0;&#125;int main()&#123; ios::sync_with_stdio(false); while(cin&gt;&gt;n&gt;&gt;R&amp;&amp;n)&#123; for(int i=0;i&lt;n;i++)&#123; double rat; cin&gt;&gt;rat; r[i].x = R*cos(rat*pi/180); r[i].y = R*sin(rat*pi/180); &#125; sort(r,r+n,cmp); double ans = 0; for(int i=0;i&lt;n;i++)&#123; double sumx = 0,sumy = 0; for(int j=0;j&lt;n;j++)&#123; if(i==j)continue; double x = r[j].x-r[i].x; double y = r[j].y-r[i].y; sumx+=x; sumy+=y; &#125; double ssumx = 0,ssumy = 0; for(int j=(i+1)%n;j!=i;j=(j+1)%n)&#123; ans+=(r[j].x-r[i].x)*sumy-(r[j].y-r[i].y)*sumx; ans-=(r[j].x-r[i].x)*ssumy-(r[j].y-r[i].y)*ssumx; sumx-=r[j].x-r[i].x; sumy-=r[j].y-r[i].y; ssumx+=r[j].x-r[i].x; ssumy+=r[j].y-r[i].y; &#125; &#125; cout&lt;&lt;(long long)(ans/12+0.5)&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>计算几何</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Educational Codeforces Round 55(Rated for Div.2) Petya and Graph]]></title>
    <url>%2F2018%2F12%2F01%2FEducational-Codeforces-Round-55-Rated-for-Div-2-Petya-and-Graph%2F</url>
    <content type="text"><![CDATA[链接：https://codeforces.com/contest/1082/problem/G思路：最大权闭合子图的变形，关于最大权闭合子图的证明请移步https://www.cnblogs.com/wuyiqi/archive/2012/03/12/2391960.html 本题中只用把边作为上述中的正权顶点，其余顶点作为负权顶点，剩下的就完全变味了最大权闭合子图，证明过程要好好理解这里不多赘述了，建图跟其完全一致。代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int n,m;const int maxn = 3000;const ll INF = 1e18;struct edge&#123; int from,to; ll cap,flow;&#125;;struct Dinic&#123; int n,m,s,t; vector&lt;edge&gt; edges; vector&lt;int&gt; G[maxn]; bool vis[maxn]; ll d[maxn]; int cur[maxn]; void init(int n)&#123; this-&gt;n = n; edges.clear(); for(int i=0;i&lt;=n;i++)G[i].clear(); &#125; void addedge(int from,int to,ll cap)&#123; edges.push_back(edge&#123;from,to,cap,0&#125;); edges.push_back(edge&#123;to,from,0,0&#125;); m = edges.size(); G[from].push_back(m-2); G[to].push_back(m-1); &#125; bool bfs()&#123; memset(vis,0,sizeof(vis)); queue&lt;int&gt; q; q.push(s); d[s] = 0; vis[s] = 1; while(!q.empty())&#123; int x = q.front(); q.pop(); for(int i=0;i&lt;G[x].size();i++)&#123; edge &amp;e = edges[G[x][i]]; if(!vis[e.to]&amp;&amp;e.cap&gt;e.flow)&#123; vis[e.to] = 1; d[e.to] = d[x] + 1; q.push(e.to); &#125; &#125; &#125; return vis[t]; &#125; ll dfs(int x,ll a)&#123; if(x==t||a==0)return a; ll flow = 0,f; for(int &amp;i = cur[x];i&lt;G[x].size();i++)&#123; edge &amp;e = edges[G[x][i]]; if(d[x] + 1 == d[e.to]&amp;&amp;(f=dfs(e.to,min(a,e.cap-e.flow)))&gt;0)&#123; e.flow+=f; edges[G[x][i]^1].flow -=f; flow+=f; a-=f; if(a==0)break; &#125; &#125; return flow; &#125; ll maxflow(int s,int t)&#123; this-&gt;s = s; this-&gt;t = t; ll flow = 0; while(bfs())&#123; memset(cur,0,sizeof(cur)); flow+=dfs(s,INF); &#125; return flow; &#125;&#125;solver;int main()&#123; ios::sync_with_stdio(false); cin&gt;&gt;n&gt;&gt;m; solver.init(n+m+2); int s = 0,t = n+m+1; ll sum = 0; for(int i=1;i&lt;=n;i++)&#123; ll a; cin&gt;&gt;a; solver.addedge(m+i,t,a); &#125; for(int i=1;i&lt;=m;i++)&#123; int a,b; ll c; cin&gt;&gt;a&gt;&gt;b&gt;&gt;c; sum+=c; solver.addedge(s,i,c); solver.addedge(i,m+a,INF); solver.addedge(i,m+b,INF); &#125; ll res = solver.maxflow(s,t); cout&lt;&lt;sum-res&lt;&lt;endl; return 0;&#125;]]></content>
      <categories>
        <category>网络流</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Round #524 (Div. 2)Katya and Segments Sets]]></title>
    <url>%2F2018%2F11%2F29%2FCodeforces-Round-524-Div-2-Katya-and-Segments-Sets%2F</url>
    <content type="text"><![CDATA[链接：https://codeforces.com/contest/1080/problem/F思路：初学主席树，这个题稍微显得有点难不过还是看题解能想懂，主席树其实是一种值域线段树，这个性质注定了这个题我们必须要用集合的编号来当作下标，那么对于一个区间内的询问我们应该怎么转换呢，如果我们固定了左端点，其实只需要a-b编号内找到所有区间左端点在范围内并且存在一个右区间的端点小于y就行了，也就是这一点让我们考虑在线段树上维护集合所含区间右端点的最大值，如果有一个集合有多个区间那么我们只用更新右端点最左边那个即可。我们先对区间进行按左端点进行排序，然后我们考虑倒着更新线段树，如果当前集合更新过的区间右端点比现在的大我们就不用再更新，否则更新主席树，对于所有的询问，我们先找左边满足条件的第一个区间，然后在那个版本的线段树上求a-b编号右端点的最大值，如果最大值大于y则无解，小于y则有解。（不得不佩服这些人的思路牛逼啊，确实不太好想）。代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 3e5+100;const int inf = 0x3f3f3f3f;int n,m,k;int idx,sum[maxn&lt;&lt;5],lson[maxn&lt;&lt;5],rson[maxn&lt;&lt;5],root[maxn&lt;&lt;5],maxv[maxn&lt;&lt;5];int a[maxn],b[maxn];int mi[maxn],ss[maxn];struct Seg&#123; int l,r,id; bool operator&lt;(const Seg &amp;r)const&#123; return l&lt;r.l; &#125;&#125;seg[maxn];void build(int &amp;o,int l,int r)&#123; o = ++idx; if(l==r) return; int mid = l+r&gt;&gt;1; build(lson[o],l,mid); build(rson[o],mid+1,r);&#125;void update(int pre,int &amp;o,int l,int r,int p,int v)&#123; o = ++idx; lson[o] = lson[pre],rson[o] = rson[pre]; if(l==r)&#123; maxv[o] = v; return; &#125; int mid = l+r&gt;&gt;1; if(p&lt;=mid) update(lson[o],lson[o],l,mid,p,v); else update(rson[o],rson[o],mid+1,r,p,v); maxv[o] = max(maxv[lson[o]],maxv[rson[o]]);&#125;int query(int o,int l,int r,int tl,int tr)&#123; if(!o)return inf; if(tl&lt;=l&amp;&amp;tr&gt;=r)return maxv[o]; int mid = l+r&gt;&gt;1; if(mid&gt;=tr)return query(lson[o],l,mid,tl,tr); if(tl&gt;mid)return query(rson[o],mid+1,r,tl,tr); return max(query(lson[o],l,mid,tl,tr),query(rson[o],mid+1,r,tl,tr));&#125;int main()&#123; scanf("%d%d%d",&amp;n,&amp;m,&amp;k); maxv[0] = inf; memset(mi,0x3f,sizeof(mi)); for(int i=1;i&lt;=k;i++)&#123; scanf("%d%d%d",&amp;seg[i].l,&amp;seg[i].r,&amp;seg[i].id); &#125; sort(seg+1,seg+k+1); for(int i=1;i&lt;=k;i++)ss[i] = seg[i].l; for(int i=k;i&gt;=1;i--)&#123; root[i] = root[i+1]; if(seg[i].r&lt;mi[seg[i].id])&#123; update(root[i+1],root[i],1,n,seg[i].id,seg[i].r); mi[seg[i].id] = seg[i].r; &#125; &#125;ss[k+1] = inf; while(m--)&#123; int a,b,x,y; scanf("%d%d%d%d",&amp;a,&amp;b,&amp;x,&amp;y); int res = lower_bound(ss+1,ss+k+2,x)-ss; if(res==k+1)res = inf; else res = query(root[res],1,n,a,b); if(res&lt;=y)puts("yes"); else puts("no"); fflush(stdout); &#125; return 0;&#125;]]></content>
      <categories>
        <category>可持久化线段树</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[HDU(6249)Alice’s Stamps]]></title>
    <url>%2F2018%2F11%2F29%2FHDU-6249-Alice%E2%80%99s-Stamps%2F</url>
    <content type="text"><![CDATA[链接：https://vjudge.net/problem/HDU-6249思路：第一遍做的时候看掉了n有范围的条件，想了另外一个比较麻烦的办法，对于这个题，因为有n的限制所以我们可以利用它，对于任何一个位置我们预处理他能到达的最远的右端点，然后在区间上进行dp即可，dp时既要更新当前状态的最大值，又要更新它能到的最后端点的状态的最大值，这是简单的版本，复杂度O（mn）。 然后我们思考一下如果没有区间长度限制该如何做？cqh给我一个思路是区间进行离散化后再按照上面的步骤做，想了一下感觉可行，我想说一下我的另外一个思路。首先我们对所有区间按照左端点进行排序，然后排序后的右端点从左往右扫一遍，如果存在不单增的情况我们把它右端点变为当前位置之前已经达到的最远的点（不会影响结果，自行证明），这样保证了右端点也是单调的，我们dp[i][j]表示最后一个选第i个集合，已经选了j个集合，更新时我们先二分出最后一个与当前所在区间不重叠的区间，对于它及之前的我们可以用一个数组维护最大值，它及其之后的我们用单调队列维护最大值，这样转移就可以在O（1）完成，同时维护前面的最大值和单调队列即可，最后更新答案。复杂度是O（mk），与上面同阶但是常数偏大，所以提交的时候T掉了，不知道能不能优化过也懒得优化了毕竟不是最优的办法只是一个升级版的解答，答案应该是对的自己打了随机数据也检查了一下。代码： 简单版12345678910111213141516171819202122232425262728293031#include&lt;bits/stdc++.h&gt;using namespace std;int t,n,m,k;const int maxn = 2010;int dp[maxn][maxn];int up[maxn];int main()&#123; scanf("%d",&amp;t); int kase = 0; while(t--)&#123; memset(dp,0,sizeof(dp)); memset(up,0,sizeof(up)); scanf("%d%d%d",&amp;n,&amp;m,&amp;k); for(int i=1;i&lt;=n;i++)up[i] = i+1; for(int i=0;i&lt;m;i++)&#123; int l,r; scanf("%d%d",&amp;l,&amp;r); for(int j=l;j&lt;=r;j++)up[j] = min(up[j],l); &#125; for(int i=1;i&lt;=n;i++)&#123; for(int j=1;j&lt;=k;j++)&#123; dp[i][j] = dp[i-1][j]; dp[i][j] = max(dp[i][j],dp[up[i]-1][j-1]+i-up[i]+1); &#125; &#125; printf("Case #%d: %d\n",++kase,dp[n][k]); &#125; return 0;&#125; 升级版单调队列做法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include&lt;bits/stdc++.h&gt;using namespace std;int t,n,m,k;const int maxn = 2010;int dp[maxn][maxn]; //最后一个选到第i个集合，已经选了j个int l[maxn],r[maxn];struct Seg&#123; int l,r,id; bool operator&lt;(const Seg &amp;rr)const&#123; return l&lt;rr.l||(l==rr.l&amp;&amp;r&lt;rr.r); &#125;&#125;ss[maxn];int Q[maxn][maxn],I[maxn][maxn],head[maxn],tail[maxn];int maxv[maxn][maxn];bool vis[maxn];int main()&#123; int kase = 0; scanf("%d",&amp;t); while(t--)&#123; memset(dp,0,sizeof(dp)); memset(maxv,0,sizeof(maxv)); memset(Q,0,sizeof(Q)); memset(I,0,sizeof(I)); memset(vis,0,sizeof(vis)); memset(tail,0,sizeof(tail)); scanf("%d%d%d",&amp;n,&amp;m,&amp;k); for(int i=1;i&lt;=m;i++)&#123; scanf("%d%d",&amp;ss[i].l,&amp;ss[i].r); l[i] = ss[i].l; r[i] = ss[i].r; ss[i].id = i; &#125; sort(ss+1,ss+m+1); int mm = 0; for(int i=1;i&lt;=m;i++)&#123; if(ss[i].r&lt;mm)&#123; r[ss[i].id] = mm; ss[i].r = mm; &#125; else mm = ss[i].r; &#125; sort(r+1,r+m+1); int ans = 0; for(int i=0;i&lt;=m;i++)head[i] = 1; for(int i=1;i&lt;=m;i++)&#123; int b = lower_bound(r+1,r+m+1,ss[i].l)-r; for(int j=1;j&lt;=i&amp;&amp;j&lt;=k;j++)&#123; while(tail[j]&gt;=head[j]&amp;&amp;I[j][head[j]]&lt;b)head[j]++; //dp[i][j] = max(dp[i][j],dp[i-1][j]); //printf("%d %d\n",dp[i][j],i); dp[i][j] = max(dp[i][j],maxv[j-1][b-1]+ss[i].r-ss[i].l+1); // printf("%d %d %d ",head[j-1],tail[j-1],dp[i][j]); if(head[j-1]&lt;=tail[j-1]) dp[i][j] = max(dp[i][j],Q[j-1][head[j-1]]+ss[i].r); // printf("%d\n",dp[i][j]); maxv[j][i] = max(maxv[j][i],dp[i][j]); while(head[j]&lt;=tail[j]&amp;&amp;Q[j][head[j]]&lt;=dp[i][j]-ss[i].r)tail[j]--; tail[j]++; Q[j][tail[j]] = dp[i][j]-ss[i].r; I[j][tail[j]] = i; while(tail[j]&gt;=head[j]&amp;&amp;I[j][head[j]]&lt;b)head[j]++; //printf("%d %d %d %d 111\n",j,tail[j],Q[j][head[j]],I[j][head[j]]); // printf("%d %d %d %d\n",b,i,j,dp[i][j]); ans = max(ans,dp[i][j]); &#125; &#125; printf("Case #%d: %d\n",++kase,ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>基础dp</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[HDU(6252)Subway-Chasing]]></title>
    <url>%2F2018%2F11%2F29%2FHDU(6252)Subway-Chasing%2F</url>
    <content type="text"><![CDATA[链接：https://vjudge.net/problem/HDU-6252思路：之前还是没有学透啊，一做题就发现不对了，题目要求一组解，有多解时要求相邻距离差总和小于2e9，那我们就考虑让他尽量小，求一个和，最后发现就是Xn-X1的值，也就是求Xn-X1的最小值，根据差分约束系统我们知道，求最小值是跑最长路，求最大值跑最短路，最大值时所有不等式写为u+w&gt;=v，然后从u到v连一条距离为w的边，最后跑最短路。求最小值把所有不等式写为u+w&lt;=v，然后从u到v连一条w的边，最后求最长路即可。本题中，如果a和b或者c和d重叠，那么中间就至少相隔x+1分钟，否则满足a+x&lt;=d,b+x&gt;=c，同时相邻点满足Xi+1&gt;=Xi + 1，按照需要建图跑最长路即可求解。代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 2010;int n,m,t;struct edge&#123; int from,to,dist; edge()&#123;&#125; edge(int f,int t,int c)&#123; from = f; to = t; dist = c; &#125;&#125;;struct BellmanFord&#123; int n,m; vector&lt;edge&gt; edges; vector&lt;int&gt; G[maxn]; bool inq[maxn]; int d[maxn]; int p[maxn]; int cnt[maxn]; void init(int n)&#123; this-&gt;n = n; for(int i=0;i&lt;=n;i++)G[i].clear(); edges.clear(); &#125; void addedge(int from,int to,int dist)&#123; edges.push_back(edge&#123;from,to,dist&#125;); m = edges.size(); G[from].push_back(m-1); &#125; bool spfa(int s)&#123; queue&lt;int&gt; Q; memset(inq,0,sizeof(inq)); memset(cnt,0,sizeof(cnt)); for(int i=0;i&lt;=n;i++)&#123;//一定要注意最长路初始化要为负无穷啊！！！！ d[i] = -2e9; &#125; d[s] = 0; Q.push(s); while(!Q.empty())&#123; int u = Q.front(); Q.pop(); inq[u] = false; for(int i=0;i&lt;G[u].size();i++)&#123; edge&amp; e = edges[G[u][i]]; if(d[e.to]&lt;d[u]+e.dist)&#123; d[e.to] = d[u] + e.dist; p[e.to] = u; if(!inq[e.to])&#123; Q.push(e.to); inq[e.to] = true; if(++cnt[e.to]&gt;n)&#123; return true; &#125; &#125; &#125; &#125; &#125; return false; &#125;&#125;solver;int x;int main()&#123; scanf("%d",&amp;t); int kase = 0; while(t--)&#123; printf("Case #%d:",++kase); scanf("%d%d%d",&amp;n,&amp;m,&amp;x); solver.init(n); for(int i=0;i&lt;m;i++)&#123; int a,b,c,d; scanf("%d%d%d%d",&amp;a,&amp;b,&amp;c,&amp;d); int pf=0; if(a!=b||c!=d) pf=1; solver.addedge(c,b,-x+pf); solver.addedge(a,d,x+pf); &#125; for(int i=1;i&lt;n;i++)solver.addedge(i,i+1,1); bool res = solver.spfa(1); if(res)printf(" IMPOSSIBLE\n"); else&#123; for(int i=2;i&lt;=n;i++)&#123; printf(" %d",solver.d[i]-solver.d[i-1]); &#125; puts(""); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>差分约束系统</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[The Kouga Ninja Scrolls]]></title>
    <url>%2F2018%2F11%2F28%2FThe-Kouga-Ninja-Scrolls%2F</url>
    <content type="text"><![CDATA[链接：https://codeforces.com/gym/101955/problem/E思路：求曼哈顿距离的最大值，我们首先要转换为切比雪夫距离，因为切比雪夫距离可以直接取最大值，由此我们考虑在线段树上维护切比雪夫距离x与y的最大值和最小值，因为同时要考虑有门派的问题在里面，所以我们得再维护一个次大值和次小值，保证次大值的门派和最大值门派不同，次小值的门派和最小值的门派不同，这样的话我们就可以维护所有操作的信息了。我们已最大值为例，最大值取左右子树中最大值的较大值，次大值在左右子树的最大值，次大值中选一个与最大值不同门派的值更新即可。思路很简单但不太好写，最好是写成一个函数来操作不要像我一直复制8遍相同的操作从而显得及其弱智，最后450行debug半天才过。。。。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e5+10;typedef long long ll;typedef pair&lt;ll,int&gt; P;P maxv[maxn&lt;&lt;2][2],minv[maxn&lt;&lt;2][2],nmaxv[maxn&lt;&lt;2][2],nminv[maxn&lt;&lt;2][2];int n,q;ll x[maxn],y[maxn];int id[maxn];struct ans&#123; P mxv[2],mnv[2],nmxv[2],nmnv[2]; ans()&#123;&#125; ans(P *a,P *b,P *c,P *d)&#123; mxv[0] = a[0]; mxv[1] = a[1]; mnv[0] = b[0]; mnv[1] = b[1]; nmxv[0] = c[0]; nmxv[1] = c[1]; nmnv[0] = d[0]; nmnv[1] = d[1]; &#125;&#125;;void pushup(int o)&#123; if(maxv[o&lt;&lt;1][0].first&lt;maxv[o&lt;&lt;1|1][0].first)&#123; maxv[o][0] = maxv[o&lt;&lt;1|1][0]; if(maxv[o&lt;&lt;1][0].first&lt;nmaxv[o&lt;&lt;1|1][0].first)&#123; nmaxv[o][0] = nmaxv[o&lt;&lt;1|1][0]; &#125; else&#123; if(maxv[o&lt;&lt;1][0].second!=maxv[o&lt;&lt;1|1][0].second)&#123; nmaxv[o][0] = maxv[o&lt;&lt;1][0]; &#125; else&#123; if(nmaxv[o&lt;&lt;1][0].first&lt;nmaxv[o&lt;&lt;1|1][0].first)&#123; nmaxv[o][0] = nmaxv[o&lt;&lt;1|1][0]; &#125; else&#123; nmaxv[o][0] = nmaxv[o&lt;&lt;1][0]; &#125; &#125; &#125; &#125; else&#123; maxv[o][0] = maxv[o&lt;&lt;1][0]; if(maxv[o&lt;&lt;1|1][0].first&lt;nmaxv[o&lt;&lt;1][0].first)&#123; nmaxv[o][0] = nmaxv[o&lt;&lt;1][0]; &#125; else&#123; if(maxv[o&lt;&lt;1][0].second!=maxv[o&lt;&lt;1|1][0].second)&#123; nmaxv[o][0] = maxv[o&lt;&lt;1|1][0]; &#125; else&#123; if(nmaxv[o&lt;&lt;1][0].first&lt;nmaxv[o&lt;&lt;1|1][0].first)&#123; nmaxv[o][0] = nmaxv[o&lt;&lt;1|1][0]; &#125; else&#123; nmaxv[o][0] = nmaxv[o&lt;&lt;1][0]; &#125; &#125; &#125; &#125; if(maxv[o&lt;&lt;1][1].first&lt;maxv[o&lt;&lt;1|1][1].first)&#123; maxv[o][1] = maxv[o&lt;&lt;1|1][1]; if(maxv[o&lt;&lt;1][1].first&lt;nmaxv[o&lt;&lt;1|1][1].first)&#123; nmaxv[o][1] = nmaxv[o&lt;&lt;1|1][1]; &#125; else&#123; if(maxv[o&lt;&lt;1][1].second!=maxv[o&lt;&lt;1|1][1].second)&#123; nmaxv[o][1] = maxv[o&lt;&lt;1][1]; &#125; else&#123; if(nmaxv[o&lt;&lt;1][1].first&lt;nmaxv[o&lt;&lt;1|1][1].first)&#123; nmaxv[o][1] = nmaxv[o&lt;&lt;1|1][1]; &#125; else&#123; nmaxv[o][1] = nmaxv[o&lt;&lt;1][1]; &#125; &#125; &#125; &#125; else&#123; maxv[o][1] = maxv[o&lt;&lt;1][1]; if(maxv[o&lt;&lt;1|1][1].first&lt;nmaxv[o&lt;&lt;1][1].first)&#123; nmaxv[o][1] = nmaxv[o&lt;&lt;1][1]; &#125; else&#123; if(maxv[o&lt;&lt;1][1].second!=maxv[o&lt;&lt;1|1][1].second)&#123; nmaxv[o][1] = maxv[o&lt;&lt;1|1][1]; &#125; else&#123; if(nmaxv[o&lt;&lt;1][1].first&lt;nmaxv[o&lt;&lt;1|1][1].first)&#123; nmaxv[o][1] = nmaxv[o&lt;&lt;1|1][1]; &#125; else&#123; nmaxv[o][1] = nmaxv[o&lt;&lt;1][1]; &#125; &#125; &#125; &#125; if(minv[o&lt;&lt;1][0].first&lt;minv[o&lt;&lt;1|1][0].first)&#123; minv[o][0] = minv[o&lt;&lt;1][0]; if(minv[o&lt;&lt;1|1][0].first&gt;nminv[o&lt;&lt;1][0].first)&#123; nminv[o][0] = nminv[o&lt;&lt;1][0]; &#125; else&#123; if(minv[o&lt;&lt;1|1][0].second!=minv[o&lt;&lt;1][0].second)&#123; nminv[o][0] = minv[o&lt;&lt;1|1][0]; &#125; else&#123; if(nminv[o&lt;&lt;1][0].first&lt;nminv[o&lt;&lt;1|1][0].first)&#123; nminv[o][0] = nminv[o&lt;&lt;1][0]; &#125; else&#123; nminv[o][0] = nminv[o&lt;&lt;1|1][0]; &#125; &#125; &#125; &#125; else&#123; minv[o][0] = minv[o&lt;&lt;1|1][0]; if(minv[o&lt;&lt;1][0].first&gt;nminv[o&lt;&lt;1|1][0].first)&#123; nminv[o][0] = nminv[o&lt;&lt;1|1][0]; &#125; else&#123; if(minv[o&lt;&lt;1][0].second!=minv[o&lt;&lt;1|1][0].second)&#123; nminv[o][0] = minv[o&lt;&lt;1][0]; &#125; else&#123; if(nminv[o&lt;&lt;1|1][0].first&lt;nminv[o&lt;&lt;1][0].first)&#123; nminv[o][0] = nminv[o&lt;&lt;1|1][0]; &#125; else&#123; nminv[o][0] = nminv[o&lt;&lt;1][0]; &#125; &#125; &#125; &#125; if(minv[o&lt;&lt;1][1].first&lt;minv[o&lt;&lt;1|1][1].first)&#123; minv[o][1] = minv[o&lt;&lt;1][1]; if(minv[o&lt;&lt;1|1][1].first&gt;nminv[o&lt;&lt;1][1].first)&#123; nminv[o][1] = nminv[o&lt;&lt;1][1]; &#125; else&#123; if(minv[o&lt;&lt;1|1][1].second!=minv[o&lt;&lt;1][1].second)&#123; nminv[o][1] = minv[o&lt;&lt;1|1][1]; &#125; else&#123; if(nminv[o&lt;&lt;1][1].first&lt;nminv[o&lt;&lt;1|1][1].first)&#123; nminv[o][1] = nminv[o&lt;&lt;1][1]; &#125; else&#123; nminv[o][1] = nminv[o&lt;&lt;1|1][1]; &#125; &#125; &#125; &#125; else&#123; minv[o][1] = minv[o&lt;&lt;1|1][1]; if(minv[o&lt;&lt;1][1].first&gt;nminv[o&lt;&lt;1|1][1].first)&#123; nminv[o][1] = nminv[o&lt;&lt;1|1][1]; &#125; else&#123; if(minv[o&lt;&lt;1][1].second!=minv[o&lt;&lt;1|1][1].second)&#123; nminv[o][1] = minv[o&lt;&lt;1][1]; &#125; else&#123; if(nminv[o&lt;&lt;1|1][1].first&lt;nminv[o&lt;&lt;1][1].first)&#123; nminv[o][1] = nminv[o&lt;&lt;1|1][1]; &#125; else&#123; nminv[o][1] = nminv[o&lt;&lt;1][1]; &#125; &#125; &#125; &#125;&#125;void build(int o,int l,int r)&#123; nmaxv[o][0] = P&#123;-1e17,id[l]&#125;; nmaxv[o][1] = P&#123;-1e17,id[l]&#125;; nminv[o][0] = P&#123;1e17,id[l]&#125;; nminv[o][1] = P&#123;1e17,id[l]&#125;; if(l&lt;r)&#123; int mid = l+r&gt;&gt;1; build(o&lt;&lt;1,l,mid); build(o&lt;&lt;1|1,mid+1,r); pushup(o); &#125; else&#123; maxv[o][0] = P&#123;x[l],id[l]&#125;; maxv[o][1] = P&#123;y[l],id[l]&#125;; nmaxv[o][0] = P&#123;-1e17,id[l]&#125;; nmaxv[o][1] = P&#123;-1e17,id[l]&#125;; minv[o][0] = P&#123;x[l],id[l]&#125;; minv[o][1] = P&#123;y[l],id[l]&#125;; nminv[o][0] = P&#123;1e17,id[l]&#125;; nminv[o][1] = P&#123;1e17,id[l]&#125;; &#125;&#125;void update(int o,int tl,int tr,int l,int r,int v,ll dx,ll dy)&#123; if(tr&lt;l||r&lt;tl)return; if(l&lt;=tl&amp;&amp;tr&lt;=r)&#123; maxv[o][0].first+=dx+dy; maxv[o][1].first+=dx-dy; minv[o][0].first+=dx+dy; minv[o][1].first+=dx-dy; if(v!=-1)&#123; maxv[o][0].second = v; maxv[o][1].second = v; minv[o][0].second = v; minv[o][1].second = v; nmaxv[o][0].second = v; nmaxv[o][1].second = v; nminv[o][0].second = v; nminv[o][1].second = v; &#125; return; &#125; int mid = (tl+tr)&gt;&gt;1; update(o&lt;&lt;1,tl,mid,l,r,v,dx,dy); update(o&lt;&lt;1|1,mid+1,tr,l,r,v,dx,dy); pushup(o);&#125; ans query(int o,int tl,int tr,int l,int r)&#123; int mid = (tl+tr)&gt;&gt;1; if(l&lt;=tl&amp;&amp;tr&lt;=r)&#123; return ans&#123;maxv[o],minv[o],nmaxv[o],nminv[o]&#125;; &#125; if(r&lt;=mid)return query(o&lt;&lt;1,tl,mid,l,r); if(l&gt;mid) return query(o&lt;&lt;1|1,mid+1,tr,l,r); ans q1 = query(o&lt;&lt;1,tl,mid,l,r); ans q2 = query(o&lt;&lt;1|1,mid+1,tr,l,r); P mxv[2],mnv[2],nmxv[2],nmnv[2]; if(q1.mxv[0].first&lt;q2.mxv[0].first)&#123; mxv[0] = q2.mxv[0]; if(q1.mxv[0].first&lt;q2.nmxv[0].first)&#123; nmxv[0] = q2.nmxv[0]; &#125; else&#123; if(q1.mxv[0].second!=q2.mxv[0].second)&#123; nmxv[0] = q1.mxv[0]; &#125; else&#123; if(q1.nmxv[0].first&lt;q2.nmxv[0].first)&#123; nmxv[0] = q2.nmxv[0]; &#125; else&#123; nmxv[0] = q1.nmxv[0]; &#125; &#125; &#125; &#125; else&#123; mxv[0] = q1.mxv[0]; if(q2.mxv[0].first&lt;q1.nmxv[0].first)&#123; nmxv[0] = q1.nmxv[0]; &#125; else&#123; if(q2.mxv[0].second!=q1.mxv[0].second)&#123; nmxv[0] = q2.mxv[0]; &#125; else&#123; if(q2.nmxv[0].first&lt;q1.nmxv[0].first)&#123; nmxv[0] = q1.nmxv[0]; &#125; else&#123; nmxv[0] = q2.nmxv[0]; &#125; &#125; &#125; &#125; if(q1.mxv[1].first&lt;q2.mxv[1].first)&#123; mxv[1] = q2.mxv[1]; if(q1.mxv[1].first&lt;q2.nmxv[1].first)&#123; nmxv[1] = q2.nmxv[1]; &#125; else&#123; if(q1.mxv[1].second!=q2.mxv[1].second)&#123; nmxv[1] = q1.mxv[1]; &#125; else&#123; if(q1.nmxv[1].first&lt;q2.nmxv[1].first)&#123; nmxv[1] = q2.nmxv[1]; &#125; else&#123; nmxv[1] = q1.nmxv[1]; &#125; &#125; &#125; &#125; else&#123; mxv[1] = q1.mxv[1]; if(q2.mxv[1].first&lt;q1.nmxv[1].first)&#123; nmxv[1] = q1.nmxv[1]; &#125; else&#123; if(q2.mxv[1].second!=q1.mxv[1].second)&#123; nmxv[1] = q2.mxv[1]; &#125; else&#123; if(q2.nmxv[1].first&lt;q1.nmxv[1].first)&#123; nmxv[1] = q1.nmxv[1]; &#125; else&#123; nmxv[1] = q2.nmxv[1]; &#125; &#125; &#125; &#125; if(q1.mnv[0].first&gt;q2.mnv[0].first)&#123; mnv[0] = q2.mnv[0]; if(q1.mnv[0].first&gt;q2.nmnv[0].first)&#123; nmnv[0] = q2.nmnv[0]; &#125; else&#123; if(q1.mnv[0].second!=q2.mnv[0].second)&#123; nmnv[0] = q1.mnv[0]; &#125; else&#123; if(q1.nmnv[0].first&gt;q2.nmnv[0].first)&#123; nmnv[0] = q2.nmnv[0]; &#125; else&#123; nmnv[0] = q1.nmnv[0]; &#125; &#125; &#125; &#125; else&#123; mnv[0] = q1.mnv[0]; if(q2.mnv[0].first&gt;q1.nmnv[0].first)&#123; nmnv[0] = q1.nmnv[0]; &#125; else&#123; if(q2.mnv[0].second!=q1.mnv[0].second)&#123; nmnv[0] = q2.mnv[0]; &#125; else&#123; if(q2.nmnv[0].first&gt;q1.nmnv[0].first)&#123; nmnv[0] = q1.nmnv[0]; &#125; else&#123; nmnv[0] = q2.nmnv[0]; &#125; &#125; &#125; &#125; if(q1.mnv[1].first&gt;q2.mnv[1].first)&#123; mnv[1] = q2.mnv[1]; if(q1.mnv[1].first&gt;q2.nmnv[1].first)&#123; nmnv[1] = q2.nmnv[1]; &#125; else&#123; if(q1.mnv[1].second!=q2.mnv[1].second)&#123; nmnv[1] = q1.mnv[1]; &#125; else&#123; if(q1.nmnv[1].first&gt;q2.nmnv[1].first)&#123; nmnv[1] = q2.nmnv[1]; &#125; else&#123; nmnv[1] = q1.nmnv[1]; &#125; &#125; &#125; &#125; else&#123; mnv[1] = q1.mnv[1]; if(q2.mnv[1].first&gt;q1.nmnv[1].first)&#123; nmnv[1] = q1.nmnv[1]; &#125; else&#123; if(q2.mnv[1].second!=q1.mnv[1].second)&#123; nmnv[1] = q2.mnv[1]; &#125; else&#123; if(q2.nmnv[1].first&gt;q1.nmnv[1].first)&#123; nmnv[1] = q1.nmnv[1]; &#125; else&#123; nmnv[1] = q2.nmnv[1]; &#125; &#125; &#125; &#125; return ans(mxv,mnv,nmxv,nmnv);&#125;int T;int main()&#123; int kase = 0; scanf("%d",&amp;T); while(T--)&#123; scanf("%d%d",&amp;n,&amp;q); for(int i=1;i&lt;=n;i++)&#123; scanf("%lld %lld %d",&amp;x[i],&amp;y[i],&amp;id[i]); ll tmp = x[i]; x[i] = x[i]+y[i]; y[i] = tmp - y[i]; &#125; build(1,1,n); printf("Case #%d:\n",++kase); for(int i=1;i&lt;=q;i++)&#123; ll o,a,b,c; scanf("%lld%lld%lld",&amp;o,&amp;a,&amp;b); if(o==1)&#123; scanf("%lld",&amp;c); update(1,1,n,a,a,-1,b,c); &#125; if(o==2)&#123; update(1,1,n,a,a,b,0LL,0LL); &#125; if(o==3)&#123; ans res = query(1,1,n,a,b); // printf("%d %d %d %d\n",res.mxv[0].second,res.mnv[0].second,res.nmxv[0].second,res.nmnv[0].second); // printf("%d %d %d %d\n",res.mxv[1].second,res.mnv[1].second,res.nmxv[1].second,res.nmnv[1].second); // printf("%lld %lld %lld %lld\n",res.mxv[0].first,res.mnv[0].first,res.nmxv[0].first,res.nmnv[0].first); // printf("%lld %lld %lld %lld\n",res.mxv[1].first,res.mnv[1].first,res.nmxv[1].first,res.nmnv[1].first); ll r1,r2; if(res.mxv[0].second!=res.mnv[0].second)&#123; r1 = res.mxv[0].first - res.mnv[0].first; &#125; else&#123; r1 = max(res.nmxv[0].first-res.mnv[0].first,res.mxv[0].first-res.nmnv[0].first); &#125; if(res.mxv[1].second!=res.mnv[1].second)&#123; r2 = res.mxv[1].first - res.mnv[1].first; &#125; else&#123; r2 = max(res.nmxv[1].first-res.mnv[1].first,res.mxv[1].first-res.nmnv[1].first); &#125; ll rr = max(r1,r2); if(rr&lt;=-1e16||rr&gt;=1e16)rr = 0; printf("%lld\n",rr); &#125; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>线段树</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Let the Flames Begin]]></title>
    <url>%2F2018%2F11%2F26%2FLet-the-Flames-Begin%2F</url>
    <content type="text"><![CDATA[链接：https://codeforces.com/gym/101955/problem/K思路：题目保证m,k中有一个小于2e6，当m小于2e6时就是一个简单的递推，当k小于2e6时，代表每次走的步数k相比于m来说很少，那么中间很多取模的操作都是不必要的可以直接用乘法加速过去，一直到刚好取模的前一个再单独更新即可，递推式自行推一下，注意由于推出来要除以k-1，所以k=1的时候需要特判，并且因为m&lt;=n，所以k=1时答案直接就是m即可。代码：1234567891011121314151617181920212223242526272829303132333435363738#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int t;ll n,m,k;int main()&#123; scanf("%d",&amp;t); int kase = 0; while(t--)&#123; scanf("%lld%lld%lld",&amp;n,&amp;m,&amp;k); ll ans = 0; if(k&gt;=m)&#123; for(int i=1;i&lt;=m;i++)&#123; ans = (ans+k-1)%(i+n-m)+1; &#125; &#125; else&#123; if(k==1)&#123;//k=1的时候需要特判 ans = m; printf("Case #%d: %lld\n",++kase,ans); continue; &#125; ll tt = 1; ll r = 0; ans = (ans+k-1)%(1+n-m)+1; while(tt&lt;m)&#123; r = (tt+n-m-ans+k-2)/(k-1);//向上取整即可 if(m-tt&lt;r)r = m-tt;//如果溢出取最后一个 if(r==0)r++;//注意如果为0要++，否则会进入死循环 tt+=r;//更新最新的人数 ans = (ans+k*r-1)%(tt+n-m)+1; &#125; &#125; printf("Case #%d: %lld\n",++kase,ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>约瑟夫环</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Homework]]></title>
    <url>%2F2018%2F11%2F22%2FHomework%2F</url>
    <content type="text"><![CDATA[链接：http://codeforces.com/gym/101986/attachments题面：有两门课程，一共n个作业。每个作业有一个布置时间li、结束时间ri以及属于的课程。每一天都要选一门课程，然后在该课程已经布置的作业中，选择还未过期的、过期时间最近的作业来做，如果没有这样的，那就摸了。问最少做多少作业，最多做多少作业。思路：因为范围只有400，对于最大的我们考虑贪心，每次选择最近的ddl的作业做，这样一定保证是最优，暴力n^2 对于最小的，我们转换一下思维，即选择最少一些作业和一些天数完成后，剩下的天数都存在有课程无作业做，这想到了什么？是不是最小割，只是怎么表示A或者B无作业做确实需要很高的技巧，我们如果将AB放在一条路径上，那么如果A或者B无作业做，整个路径都会断开，即从源点向第一门课程每个作业拉一条容量为1的边，将天数建为两列，第一门课程向第一列l-r天的点连一条容量为1的边，第一列天数向对应的第二列天数连一条容量为1的边，然后第二门课程的作业向第二列对应的l-r连一条容量为1的边，然后第二门课程的每个作业向汇点连一条容量为1的边。等效于在网络流上切去一些源点到第一门作业的边或者第二门作业到汇点的边，表示需要做的作业，使得整个图的最大流为0，此时就可以不用再做作业了，那不是就等效于最小割了吗？跑一边最大流即可得到答案！（好好领悟建图的高妙）。代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124#include&lt;bits/stdc++.h&gt;using namespace std;int n,m;const int maxn = 3000;const int INF = 1e9;typedef pair&lt;int,int&gt; P;struct edge&#123; int from,to,cap,flow;&#125;;struct Dinic&#123; int n,m,s,t; vector&lt;edge&gt; edges; vector&lt;int&gt; G[maxn]; bool vis[maxn]; int d[maxn]; int cur[maxn]; void init(int n)&#123; this-&gt;n = n; edges.clear(); for(int i=0;i&lt;=n;i++)G[i].clear(); &#125; void addedge(int from,int to,int cap)&#123; edges.push_back(edge&#123;from,to,cap,0&#125;); edges.push_back(edge&#123;to,from,0,0&#125;); m = edges.size(); G[from].push_back(m-2); G[to].push_back(m-1); &#125; bool bfs()&#123; memset(vis,0,sizeof(vis)); queue&lt;int&gt; q; q.push(s); d[s] = 0; vis[s] = 1; while(!q.empty())&#123; int x = q.front(); q.pop(); for(int i=0;i&lt;G[x].size();i++)&#123; edge &amp;e = edges[G[x][i]]; if(!vis[e.to]&amp;&amp;e.cap&gt;e.flow)&#123; vis[e.to] = 1; d[e.to] = d[x] + 1; q.push(e.to); &#125; &#125; &#125; return vis[t]; &#125; int dfs(int x,int a)&#123; if(x==t||a==0)return a; int flow = 0,f; for(int &amp;i = cur[x];i&lt;G[x].size();i++)&#123; edge &amp;e = edges[G[x][i]]; if(d[x] + 1 == d[e.to]&amp;&amp;(f=dfs(e.to,min(a,e.cap-e.flow)))&gt;0)&#123; e.flow+=f; edges[G[x][i]^1].flow -=f; flow+=f; a-=f; if(a==0)break; &#125; &#125; return flow; &#125; int maxflow(int s,int t)&#123; this-&gt;s = s; this-&gt;t = t; int flow = 0; while(bfs())&#123; memset(cur,0,sizeof(cur)); flow+=dfs(s,INF); &#125; return flow; &#125;&#125;solver;P seg[500];bool vis[500];int main()&#123; scanf("%d%d",&amp;n,&amp;m); n-=m; int d = 0; for(int i=1;i&lt;=n+m;i++)&#123; scanf("%d%d",&amp;seg[i].first,&amp;seg[i].second); d = max(d,seg[i].second); &#125; int ans = 0; for(int i=1;i&lt;=d;i++)&#123; int minv = d+100; int mini = -1; for(int j=1;j&lt;=n+m;j++)&#123; if(vis[j]||seg[j].first&gt;i||seg[j].second&lt;i)continue; if(seg[j].second-i&lt;minv)&#123; minv = seg[j].second-i; mini = j; &#125; &#125; if(mini==-1)continue; vis[mini] = 1; ans++; &#125; int s = 0; int t = n+m+2*d+1; solver.init(t); for(int i=1;i&lt;=m;i++)&#123; solver.addedge(s,i,1); for(int j=seg[i].first;j&lt;=seg[i].second;j++)solver.addedge(i,j+m,1); &#125; for(int i=m+1;i&lt;=n+m;i++)&#123; solver.addedge(i+2*d,t,1); for(int j=seg[i].first;j&lt;=seg[i].second;j++)solver.addedge(j+m+d,i+2*d,1); &#125; for(int i=1;i&lt;=d;i++)solver.addedge(i+m,i+m+d,1); int res = solver.maxflow(s,t); printf("%d\n%d\n",ans,res); return 0;&#125;]]></content>
      <categories>
        <category>网络流</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Pizza Delivery]]></title>
    <url>%2F2018%2F11%2F22%2F%C2%96Pizza-Delivery%2F</url>
    <content type="text"><![CDATA[链接：http://codeforces.com/gym/101986题面：给定一个有重边的边带正权有向图，保证一开始有从1到2的路径。对于每条边，询问把它反向之后，从1到2的最短路如何变化。思路：首先跑一遍最短路，把所有能作为最短路的边拿出来放入一张新图中，对于新图跑一边tarjan（注意新图要把有向图变为无向图！！这是本题的核心，因为有向图中已经不存在环而我们要判断哪些边是桥，所有需要转为无向图，这里多想想容易想不清楚），然后对于每一条边，我们先看他变为反向边后最短路是否减少，如果不，我们看他是否为桥，如果为桥最最短路一定变差，否则不变。代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 2e5+100;typedef pair&lt;long long,int&gt; PA;int n,m;vector&lt;int&gt; GG[maxn];int dfn[maxn];int low[maxn];int sccno[maxn];int scount[maxn];int ntime;int bcc_cnt;deque&lt;int&gt; P;struct edge&#123; int from,to; long long dist;&#125;ss[maxn];struct Dij&#123; int n,m; vector&lt;int&gt; G[maxn]; vector&lt;edge&gt; edges; int id[maxn]; long long d[maxn]; void init(int n)&#123; this-&gt;n = n; for(int i=0;i&lt;=n;i++)G[i].clear(); edges.clear(); &#125; void addedge(int from,int to,long long dist)&#123; edges.push_back(edge&#123;from,to,dist&#125;); m = edges.size(); G[from].push_back(m-1); &#125; void addedge(int from,int to,long long dist,int _id)&#123; edges.push_back(edge&#123;from,to,dist&#125;); m = edges.size(); G[from].push_back(m-1); id[m-1] = _id; &#125; void dij(int s)&#123; for(int i=0;i&lt;=n;i++)d[i] = 1e18; d[s] = 0; priority_queue&lt;PA,vector&lt;PA&gt;,greater&lt;PA&gt; &gt; q; q.push(PA&#123;0LL,s&#125;); while(!q.empty())&#123; PA p = q.top(); q.pop(); int u = p.second; if(d[u]&lt;p.first)continue; for(int i=0;i&lt;G[u].size();i++)&#123; edge e = edges[G[u][i]]; if(d[e.to]&gt;d[u]+e.dist)&#123; d[e.to] = d[u]+e.dist; q.push(PA&#123;d[e.to],e.to&#125;); &#125; &#125; &#125; &#125;&#125;s1,s2,s3;int bridge[maxn];void tarjan(int u,int f)&#123; dfn[u] = low[u] = ++ntime; for(int i=0;i&lt;s3.G[u].size();i++)&#123; edge e = s3.edges[s3.G[u][i]]; int v = e.to; if(!dfn[v])&#123; tarjan(v,u); low[u] = min(low[u],low[v]); if(low[v]&gt;dfn[u])&#123;//如果为桥则满足此条件！ bridge[s3.id[s3.G[u][i]]] = 1; &#125; &#125; else if(f!=v)&#123; low[u] = min(low[u],dfn[v]); &#125; &#125;&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;m); s1.init(n); s2.init(n); for(int i=0;i&lt;m;i++)&#123; scanf("%d%d%lld",&amp;ss[i].from,&amp;ss[i].to,&amp;ss[i].dist); s1.addedge(ss[i].from,ss[i].to,ss[i].dist); s2.addedge(ss[i].to,ss[i].from,ss[i].dist); &#125; s1.dij(1); long long len = s1.d[2]; s2.dij(2); s3.init(n); for(int i=0;i&lt;s1.edges.size();i++)&#123; edge e = s1.edges[i]; if(s2.d[e.to]+s1.d[e.from]+e.dist==len)&#123;//注意有向图中枚举可能是最短路边的方法 //建新图，并转为无向图 s3.addedge(e.from,e.to,e.dist,i); s3.addedge(e.to,e.from,e.dist,i); &#125; &#125; tarjan(1,0); for(int i=0;i&lt;m;i++)&#123; int u = ss[i].from; int v = ss[i].to; if(s1.d[v]+s2.d[u]+ss[i].dist&lt;len)printf("HAPPY\n"); else if(bridge[i])printf("SAD\n"); else printf("SOSO\n"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>最短路</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Black or White]]></title>
    <url>%2F2018%2F11%2F22%2FBlack-or-White%2F</url>
    <content type="text"><![CDATA[链接：http://codeforces.com/gym/101986/attachments题面：给定两个长度相同的 0/1的初始串s和目标串t。你每次可以把长度不超过k的一段变成相同数字，问最少操作次数。思路：比赛时以为是一个贪心，觉得只要能尽量覆盖就一定可以是最优解，其实不是贪心，分析可得当前最优解一定是前一个状态+中间若干步操作得来，我们定义f[i]为t串中的段数，可以经过推导得出公式：dp[i] = dp[i-1] s[i]==t[i]dp[i] = min(dp[j]-(f[i]-f[j+1])/2+1) (i-k=]]></content>
      <categories>
        <category>单调队列dp</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[LightOJ1341(Aladdin and the Flying Carpet)]]></title>
    <url>%2F2018%2F11%2F19%2FLightOJ1341-Aladdin-and-the-Flying-Carpet%2F</url>
    <content type="text"><![CDATA[链接：https://vjudge.net/problem/LightOJ-1341思路：找个题如果直接枚举a的因子会超时，但正解其实最坏复杂度和这个是同阶的，估摸着是数据的问题吧。首先我们用算术基本定理：a的所有正约数的个数为num = (1 + a1) (1 + a2) …(1 + ai)，用质因数未接求出总的因子数目，因为不存在相等的因子所以除以2就为方案数，最后枚举下1-b-1中是因子的扣除即可，这样可以避免超时。代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e6+100;bool isprime[maxn];bool vis[maxn];int prime[maxn];int t,cnt;typedef long long ll;ll a,b;int main()&#123; int kase = 0; scanf(&quot;%d&quot;,&amp;t); isprime[0] = isprime[1] = 0; for(int i=2;i&lt;=maxn-100;i++)&#123; if(!vis[i])&#123; vis[i] = 1; isprime[i] = 1; prime[cnt++] = i; for(int j=2*i;j&lt;=maxn-100;j+=i)&#123; vis[j] = 1; &#125; &#125; &#125; while(t--)&#123; scanf(&quot;%lld %lld&quot;,&amp;a,&amp;b); printf(&quot;Case %d: &quot;,++kase); if(a&lt;b*b)&#123; printf(&quot;0\n&quot;); continue; &#125; ll res = 1; ll now = a; for(int i=0;i&lt;cnt&amp;&amp;prime[i]&lt;=sqrt(now+0.5);i++)&#123; if(now&lt;=maxn-100&amp;&amp;isprime[now])break; int len = 0; while(now%prime[i]==0)&#123; len++; now/=prime[i]; &#125; res*=(1+len); &#125; if(now!=1)res*=2; res/=2; for(int i=1;i&lt;b;i++)&#123; if(a%i==0)res--; &#125; printf(&quot;%lld\n&quot;,res); &#125; return 0;&#125;]]></content>
      <categories>
        <category>数论</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[UVALive7364(Robots)]]></title>
    <url>%2F2018%2F11%2F19%2FUVALive7364-Robots%2F</url>
    <content type="text"><![CDATA[链接：https://vjudge.net/problem/UVALive-7364思路：首先我们想清楚一个问题，就是如果二者走到一起后就不会再分开了，如果两个机器人能走到一个格子，那么他们就变为了一个，所以对于原问题其实就是求解任何两个机器人能否走到一个格子，如果能的话就肯定存在解，因为不管怎么走都还在n个格子上，并且有解，我们只要依次合并即可，如果不行的话就一定无解，总会存在两个格子的机器人最终永远无法走到一起，所以我们只需要从终点开始逆向bfs，得到所有可能到达的状态，最后判断一下是否两两可达即可。代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1010;vector&lt;int&gt; R[maxn],G[maxn];int t,n,k;int vis[maxn][maxn];void bfs()&#123; queue&lt;pair&lt;int,int&gt; &gt; q; for(int i=0;i&lt;n;i++)q.push(make_pair(i,i)); while(!q.empty())&#123; pair&lt;int,int&gt; p = q.front(); q.pop(); int a = p.first; int b = p.second; if(vis[a][b])continue; vis[a][b] = 1; for(int i=0;i&lt;R[a].size();i++)&#123; for(int j=0;j&lt;R[b].size();j++)&#123; if(!vis[R[a][i]][R[b][j]])q.push(make_pair(R[a][i],R[b][j])); &#125; &#125; for(int i=0;i&lt;G[a].size();i++)&#123; for(int j=0;j&lt;G[b].size();j++)&#123; if(!vis[G[a][i]][G[b][j]])q.push(make_pair(G[a][i],G[b][j])); &#125; &#125; &#125;&#125;int main()&#123; scanf(&quot;%d&quot;,&amp;t); while(t--)&#123; scanf(&quot;%d%d&quot;,&amp;k,&amp;n); for(int i=0;i&lt;=n;i++)G[i].clear(),R[i].clear(); memset(vis,0,sizeof(vis)); for(int i=0;i&lt;n;i++)&#123; int a; scanf(&quot;%d&quot;,&amp;a); G[a].push_back(i);//保存逆向操作 &#125; for(int i=0;i&lt;n;i++)&#123; int a; scanf(&quot;%d&quot;,&amp;a); R[a].push_back(i);//保存逆向操作 &#125; bfs(); int flag = 1; for(int i=0;i&lt;n;i++)&#123; for(int j=0;j&lt;n;j++)&#123; if(!vis[i][j])&#123;//存在不能两两可达，无解 flag = 0; break; &#125; &#125; if(!flag)break; &#125; if(flag)printf(&quot;%d YES\n&quot;,k); else printf(&quot;%d NO\n&quot;,k); &#125; return 0;&#125;]]></content>
      <categories>
        <category>bfs</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[UVALive7366(Brocard)]]></title>
    <url>%2F2018%2F11%2F19%2FUVALive7366-Brocard%2F</url>
    <content type="text"><![CDATA[链接：https://vjudge.net/problem/UVALive-7366思路：本题有数学定理可以直接得到答案，但是为了练习计算几何我决定不用定理，二分三分均可以得到答案，二分的话就枚举旋转的角度，看两个向量旋转第三个向量与原边夹角的大小，然后调整左右边界的值，三分的话就是看三个点围成三角形面积的大小，只有当三点合一面积才为0，此时为峰值，因为精度要求eps必须要到1e-10才行。二分三分我都写一次。代码： 三分123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#include&lt;bits/stdc++.h&gt;using namespace std;struct Point &#123; double x, y; Point(double x = 0, double y = 0) : x(x), y(y) &#123;&#125;&#125;; typedef Point Vector; Vector operator + (Vector A, Vector B) &#123; return Vector(A.x + B.x, A.y + B.y); &#125;Vector operator - (Vector A, Vector B) &#123; return Vector(A.x - B.x, A.y - B.y); &#125;Vector operator * (Vector A, double p) &#123; return Vector(A.x*p, A.y*p); &#125;Vector operator / (Vector A, double p) &#123; return Vector(A.x/p, A.y/p); &#125; bool operator &lt; (const Point&amp; a, const Point b) &#123; return a.x &lt; b.x || (a.x == b.x &amp;&amp; a.y &lt; b.y);&#125; const double eps = 1e-10; int dcmp(double x) &#123; if(fabs(x) &lt; eps) return 0; else return x &lt; 0 ? -1 : 1;&#125; bool operator == (const Point&amp; a, const Point&amp; b) &#123; return dcmp(a.x-b.x) == 0 &amp;&amp; dcmp(a.y-b.y) == 0;&#125; //向量a的极角double Angle(const Vector&amp; v) &#123; return atan2(v.y, v.x);&#125; //向量点积double Dot(Vector A, Vector B) &#123; return A.x*B.x + A.y*B.y; &#125; //向量长度\share\CodeBlocks\templates\wizard\console\cppdouble Length(Vector A) &#123; return sqrt(Dot(A, A)); &#125; //向量夹角double Angle(Vector A, Vector B) &#123; return acos(Dot(A, B) / Length(A) / Length(B)); &#125; //向量叉积double Cross(Vector A, Vector B) &#123; return A.x*B.y - A.y*B.x; &#125; //三角形有向面积的二倍double Area2(Point A, Point B, Point C) &#123; return Cross(B-A, C-A); &#125; //向量逆时针旋转rad度(弧度)Vector Rotate(Vector A, double rad) &#123; return Vector(A.x*cos(rad)-A.y*sin(rad), A.x*sin(rad)+A.y*cos(rad));&#125;Point GetLineIntersection(Point P, Vector v, Point Q, Vector w) &#123; Vector u = P - Q; double t = Cross(w, u)/Cross(v, w); return P+v*t;&#125;Point a1,a2,a3;Vector a,b,c;int t,k;double cal(double r)&#123; Vector na = Rotate(a,r); Vector nb = Rotate(b,r); Vector nc = Rotate(c,r); Point p1 = GetLineIntersection(a1,na,a2,nb); Point p2 = GetLineIntersection(a1,na,a3,nc); Point p3 = GetLineIntersection(a2,nb,a3,nc); return fabs(Area2(p1,p2,p3));&#125;int main()&#123; scanf(&quot;%d&quot;,&amp;t); while(t--)&#123; scanf(&quot;%d&quot;,&amp;k); scanf(&quot;%lf%lf%lf%lf%lf%lf&quot;,&amp;a1.x,&amp;a1.y,&amp;a2.x,&amp;a2.y,&amp;a3.x,&amp;a3.y); Vector r1 = a2-a1; Vector r2 = a3-a1; double rat = Angle(r1,r2); if(dcmp(rat)&lt;0)&#123; a = a3-a1; b = a1-a2; c = a2-a3; &#125; else&#123; a = a2-a1; b = a3-a2; c = a1-a3; &#125; double ub = rat; double lb = 0; while(ub-lb&gt;eps)&#123; double r1 = lb + (ub-lb)/3; double r2 = ub - (ub-lb)/3; if(cal(r1)&lt;=cal(r2))ub = r2; else lb = r1; &#125; Vector re1 = Rotate(a,ub); Vector re2 = Rotate(b,ub); Point res = GetLineIntersection(a1,re1,a2,re2); printf(&quot;%d %.5f %.5f\n&quot;,k,res.x,res.y); &#125; return 0;&#125; 二分1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include&lt;bits/stdc++.h&gt;using namespace std;struct Point &#123; double x, y; Point(double x = 0, double y = 0) : x(x), y(y) &#123;&#125;&#125;; typedef Point Vector; Vector operator + (Vector A, Vector B) &#123; return Vector(A.x + B.x, A.y + B.y); &#125;Vector operator - (Vector A, Vector B) &#123; return Vector(A.x - B.x, A.y - B.y); &#125;Vector operator * (Vector A, double p) &#123; return Vector(A.x*p, A.y*p); &#125;Vector operator / (Vector A, double p) &#123; return Vector(A.x/p, A.y/p); &#125; bool operator &lt; (const Point&amp; a, const Point b) &#123; return a.x &lt; b.x || (a.x == b.x &amp;&amp; a.y &lt; b.y);&#125; const double eps = 1e-10; int dcmp(double x) &#123; if(fabs(x) &lt; eps) return 0; else return x &lt; 0 ? -1 : 1;&#125; bool operator == (const Point&amp; a, const Point&amp; b) &#123; return dcmp(a.x-b.x) == 0 &amp;&amp; dcmp(a.y-b.y) == 0;&#125; //向量a的极角double Angle(const Vector&amp; v) &#123; return atan2(v.y, v.x);&#125; //向量点积double Dot(Vector A, Vector B) &#123; return A.x*B.x + A.y*B.y; &#125; //向量长度\share\CodeBlocks\templates\wizard\console\cppdouble Length(Vector A) &#123; return sqrt(Dot(A, A)); &#125; //向量夹角double Angle(Vector A, Vector B) &#123; return acos(Dot(A, B) / Length(A) / Length(B)); &#125; //向量叉积double Cross(Vector A, Vector B) &#123; return A.x*B.y - A.y*B.x; &#125; //三角形有向面积的二倍double Area2(Point A, Point B, Point C) &#123; return Cross(B-A, C-A); &#125; //向量逆时针旋转rad度(弧度)Vector Rotate(Vector A, double rad) &#123; return Vector(A.x*cos(rad)-A.y*sin(rad), A.x*sin(rad)+A.y*cos(rad));&#125;Point GetLineIntersection(Point P, Vector v, Point Q, Vector w) &#123; Vector u = P - Q; double t = Cross(w, u)/Cross(v, w); return P+v*t;&#125;Point a1,a2,a3,p;Vector a,b,c;int t,k;double cal(double r)&#123; Vector na = Rotate(a3-a2,r); Vector nb = Rotate(a2-a1,r); p = GetLineIntersection(a1,nb,a2,na); return Angle(p-a3,a1-a3);&#125;int main()&#123; scanf(&quot;%d&quot;,&amp;t); while(t--)&#123; scanf(&quot;%d&quot;,&amp;k); scanf(&quot;%lf%lf%lf%lf%lf%lf&quot;,&amp;a1.x,&amp;a1.y,&amp;a2.x,&amp;a2.y,&amp;a3.x,&amp;a3.y); double rat = Angle(a2-a1,a3-a1); rat = min(rat,Angle(a1-a2,a3-a2)); rat = min(rat,Angle(a1-a3,a2-a3)); double ub = rat; double lb = 0; while(ub-lb&gt;eps)&#123; double mid = (lb+ub)/2; if(cal(mid)&gt;mid)lb = mid; else ub = mid; &#125; printf(&quot;%d %.5f %.5f\n&quot;,k,p.x,p.y); &#125; return 0;&#125;]]></content>
      <categories>
        <category>计算几何</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[牛客练习赛30E(国政议事)]]></title>
    <url>%2F2018%2F11%2F17%2F%E7%89%9B%E5%AE%A2%E7%BB%83%E4%B9%A0%E8%B5%9B30E(%E5%9B%BD%E6%94%BF%E8%AE%AE%E4%BA%8B)%2F</url>
    <content type="text"><![CDATA[链接：https://ac.nowcoder.com/acm/contest/216/E思路：关于二分图必须匹配问题，看这里，引用一下：https://blog.csdn.net/element_hero/article/details/82845931事实上对于匈牙利算法中不完备匹配我们可能需要额外建图（还没怎么想懂后面我用匈牙利算法再写一遍），事实上用网络流的话不需要重新建图，只需要在残留网络上跑一边tarjan边双即可，但注意要思考清楚跑tarjan的时候哪些边可以走，我一开始就是随便抄了一下一直不对，网上也没人用我这种图的表示方法，后面我认真思考了一下，对于u，v有流量，那么反向边可以跑而正向边不能跑，如果u，v没流量那么正向边可以跑而反向边不能跑，其实根本不用重新建图，概括起来也就一句话e.cap-e.flow&gt;0时可以跑，否则不行。最后对于所有已经匹配的边检查一下是否属于一个强连通分量，如果属于则是可行边，否则是必须边。代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;using namespace std;const int maxn = 1001;const int INF = 1e9;struct edge&#123; int from,to,cap,flow;&#125;; int n,m,s,t,q; vector&lt;edge&gt; edges; vector&lt;int&gt; G[maxn],RG[maxn]; bool vis[maxn]; int d[maxn]; int cur[maxn]; vector&lt;int&gt; bcc[maxn];//强连通分量 int dfn[maxn]; int low[maxn]; int scount[maxn];//是否为割点 int sccno[maxn];//属于哪一个强连通分量 int ntime; int bcc_cnt; deque&lt;int&gt; P; void init()&#123; edges.clear(); for(int i=0;i&lt;=n;i++)G[i].clear(); &#125; void addedge(int from,int to,int cap)&#123; edges.push_back(edge&#123;from,to,cap,0&#125;); edges.push_back(edge&#123;to,from,0,0&#125;); m = edges.size(); G[from].push_back(m-2); G[to].push_back(m-1); &#125; bool bfs()&#123; memset(vis,0,sizeof(vis)); queue&lt;int&gt; q; q.push(s); d[s] = 0; vis[s] = 1; while(!q.empty())&#123; int x = q.front(); q.pop(); for(int i=0;i&lt;G[x].size();i++)&#123; edge &amp;e = edges[G[x][i]]; if(!vis[e.to]&amp;&amp;e.cap&gt;e.flow)&#123; vis[e.to] = 1; d[e.to] = d[x] + 1; q.push(e.to); &#125; &#125; &#125; return vis[t]; &#125; int dfs(int x,int a)&#123; if(x==t||a==0)return a; int flow = 0,f; for(int &amp;i = cur[x];i&lt;G[x].size();i++)&#123; edge &amp;e = edges[G[x][i]]; if(d[x] + 1 == d[e.to]&amp;&amp;(f=dfs(e.to,min(a,e.cap-e.flow)))&gt;0)&#123; e.flow+=f; edges[G[x][i]^1].flow -=f; flow+=f; a-=f; if(a==0)break; &#125; &#125; return flow; &#125; int maxflow()&#123; int flow = 0; while(bfs())&#123; memset(cur,0,sizeof(cur)); flow+=dfs(s,INF); &#125; return flow; &#125; void tarjan(int u)&#123; dfn[u] = low[u] = ++ntime; P.push_back(u); for(int i=0;i&lt;G[u].size();i++)&#123; edge &amp;e = edges[G[u][i]]; if(e.cap-e.flow==0)continue;//一定要注意这里的判断！！！！因为写法不同所以这里判断的写法也不同！！！ int v = e.to; if(!dfn[v])&#123; tarjan(v); low[u] = min(low[u],low[v]); &#125; else if(!sccno[v])&#123; low[u] = min(low[u],dfn[v]); &#125; &#125; if(low[u]==dfn[u])&#123; bcc_cnt++; int tmp; do&#123; tmp = P.back(); P.pop_back(); sccno[tmp] = bcc_cnt; scount[bcc_cnt]++;//计算连通块所含的点数 &#125;while(tmp!=u); &#125;&#125;void find_bcc()&#123; memset(sccno,0,sizeof(sccno)); memset(dfn,0,sizeof(dfn)); memset(scount,0,sizeof(scount)); ntime = bcc_cnt = 0; for(int i=0;i&lt;=2*n+1;++i)if(!dfn[i])tarjan(i);&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;q); s = 0; t = 2*n+1; init(); for(int i=0;i&lt;q;i++)&#123; int a,b; scanf("%d%d",&amp;a,&amp;b); addedge(a,b+n,1); &#125; for(int i=1;i&lt;=n;i++)addedge(s,i,1),addedge(i+n,t,1); int res = maxflow(); printf("%d ",res); find_bcc(); vector&lt;int&gt; ans; for(int i=0;i&lt;q*2;i+=2)&#123; edge e = edges[i]; if(e.flow&amp;&amp;sccno[e.from]!=sccno[e.to])ans.push_back(i/2+1); &#125; sort(ans.begin(),ans.end()); printf("%d\n",ans.size()); for(int i=0;i&lt;ans.size();i++)&#123; printf("%d\n",ans[i]); &#125; return 0;&#125; 补充一下删边的做法，对于匹配边我们删除之后再跑匈牙利算法，如果答案不变就不是必须边，否则就是必须边。代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 2000;//注意编号从1开始vector&lt;int&gt; G[maxn],RG[maxn];bool vis[maxn];int link[maxn];int relink[maxn];int m,s,t,q;int nx,ny;int dfn[maxn];int low[maxn];int sccno[maxn];int scount[maxn];int ntime;int bcc_cnt;//连通块数量int nowi = -1;deque&lt;int&gt; P; struct edge&#123; int from,to; &#125;; vector&lt;edge&gt; edges; void init(int nx,int ny)&#123; for(int i=0;i&lt;=nx+ny+2;i++)G[i].clear(); &#125; inline void addedge(int from,int to)&#123; edges.push_back(edge&#123;from,to&#125;); q = edges.size(); G[from].push_back(q-1); &#125; bool dfs(int u)&#123; vis[u] = 1; for(int i=0;i&lt;G[u].size();i++)&#123; if(G[u][i]==nowi)continue; edge e = edges[G[u][i]]; int v = e.to; if(!vis[v])&#123; vis[v] = 1; if(link[v]==-1||dfs(link[v]))&#123; link[v] = u; return true; &#125; &#125; &#125; return false; &#125; int hungrey()&#123; int res = 0; memset(link,-1,sizeof(link)); for(int i=1;i&lt;=nx;i++)&#123; memset(vis,0,sizeof(vis)); if(dfs(i))res++; &#125; return res; &#125;int main()&#123; scanf("%d%d",&amp;nx,&amp;m); ny = nx; init(nx,ny); for(int i=1;i&lt;=m;i++)&#123; int u,v; scanf("%d%d",&amp;u,&amp;v); v+=nx; addedge(u,v); &#125; int res = hungrey(); for(int i=nx+1;i&lt;=nx+ny;i++)&#123; relink[i] = link[i]; &#125; printf("%d ",res); vector&lt;int&gt; ans; for(int i=0;i&lt;m;i++)&#123; nowi = i; int u = edges[i].from; int v = edges[i].to; if(relink[v]!=u)continue; int now = hungrey(); if(now!=res)ans.push_back(i+1); &#125; printf("%d\n",ans.size()); for(int i=0;i&lt;ans.size();i++)&#123; printf("%d\n",ans[i]); &#125; return 0;&#125;]]></content>
      <categories>
        <category>二分图</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[牛客练习赛30D(消消乐)]]></title>
    <url>%2F2018%2F11%2F17%2F%E7%89%9B%E5%AE%A2%E7%BB%83%E4%B9%A0%E8%B5%9B30D(%E6%B6%88%E6%B6%88%E4%B9%90)%2F</url>
    <content type="text"><![CDATA[链接：https://ac.nowcoder.com/acm/contest/216/D思路：一道比较经典的网络流题目，按行和列建图，对于每一个a[i][j]=’*’的点，我们从i向j拉一条边，那么原问题可以转换为，在行和列对应的二分图中，每一条边至少要有一个端点被选中，求最小点覆盖。由定理可知，最小点覆盖的值定于最大匹配数，如果用网络流的话也就是最大流。这个题难点在于方案输出，我们对于两种算法的方案输出解释一下： 网络流代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127#include&lt;bits/stdc++.h&gt;using namespace std;int n,m;const int maxn = 6000;const int INF = 1e9;struct edge&#123; int from,to,cap,flow;&#125;;struct Dinic&#123; int n,m,s,t; vector&lt;edge&gt; edges; vector&lt;int&gt; G[maxn]; bool vis[maxn]; int d[maxn]; int cur[maxn]; void init(int n)&#123; this-&gt;n = n; edges.clear(); for(int i=0;i&lt;=n;i++)G[i].clear(); &#125; void addedge(int from,int to,int cap)&#123; edges.push_back(edge&#123;from,to,cap,0&#125;); edges.push_back(edge&#123;to,from,0,0&#125;); m = edges.size(); G[from].push_back(m-2); G[to].push_back(m-1); &#125; bool bfs()&#123; memset(vis,0,sizeof(vis)); queue&lt;int&gt; q; q.push(s); d[s] = 0; vis[s] = 1; while(!q.empty())&#123; int x = q.front(); q.pop(); for(int i=0;i&lt;G[x].size();i++)&#123; edge &amp;e = edges[G[x][i]]; if(!vis[e.to]&amp;&amp;e.cap&gt;e.flow)&#123; vis[e.to] = 1; d[e.to] = d[x] + 1; q.push(e.to); &#125; &#125; &#125; return vis[t]; &#125; int dfs(int x,int a)&#123; if(x==t||a==0)return a; int flow = 0,f; for(int &amp;i = cur[x];i&lt;G[x].size();i++)&#123; edge &amp;e = edges[G[x][i]]; if(d[x] + 1 == d[e.to]&amp;&amp;(f=dfs(e.to,min(a,e.cap-e.flow)))&gt;0)&#123; e.flow+=f; edges[G[x][i]^1].flow -=f; flow+=f; a-=f; if(a==0)&#123; break; &#125; &#125; &#125; return flow; &#125; int maxflow(int s,int t)&#123; this-&gt;s = s; this-&gt;t = t; int flow = 0; while(bfs())&#123; memset(cur,0,sizeof(cur)); flow+=dfs(s,INF); &#125; return flow; &#125;&#125;solver;int iscut[maxn];void dfs(int u)&#123; iscut[u] = 1; for(int i=0;i&lt;solver.G[u].size();i++)&#123; edge e = solver.edges[solver.G[u][i]]; if(!iscut[e.to]&amp;&amp;e.cap&gt;e.flow)dfs(e.to);//注意网络流中的写法 &#125;&#125;char ch[2010];int main()&#123; scanf("%d%d",&amp;n,&amp;m); solver.init(n+m+2); for(int i=1;i&lt;=n;i++)&#123; solver.addedge(0,i,1); scanf("%s",ch); for(int j=0;j&lt;m;j++)&#123; if(ch[j]=='*')solver.addedge(i,j+1+n,1e9); &#125; &#125; for(int i=1;i&lt;=m;i++)solver.addedge(n+i,n+m+1,1); int res = solver.maxflow(0,n+m+1); dfs(0); printf("%d\n",res); int l = 0,r = 0; for(int i=1;i&lt;=n;i++)&#123; if(!iscut[i])l++; &#125; for(int i=n+1;i&lt;=n+m;i++)&#123; if(iscut[i])r++; &#125; printf("%d ",l); for(int i=1;i&lt;=n;i++)&#123; if(!iscut[i])printf("%d ",i); &#125; printf("\n%d ",r); for(int i=n+1;i&lt;=n+m;i++)&#123; if(iscut[i])printf("%d ",i-n); &#125; printf("\n"); return 0;&#125; 匈牙利算法：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 4010;//注意编号从1开始vector&lt;int&gt; G[maxn];bool vis[maxn];int link[maxn];int m;int nx,ny; void init(int nx,int ny)&#123; for(int i=0;i&lt;=nx+ny;i++)G[i].clear(); &#125; inline void addedge(int from,int to)&#123; G[from].push_back(to); &#125; bool dfs(int u)&#123; vis[u] = 1; for(int i=0;i&lt;G[u].size();i++)&#123; int v = G[u][i]; if(!vis[v])&#123; vis[v] = 1; if(link[v]==-1||dfs(link[v]))&#123; link[v] = u; link[u] = v; return true; &#125; &#125; &#125; return false; &#125; int hungrey()&#123; int res = 0; memset(link,-1,sizeof(link)); for(int i=1;i&lt;=nx;i++)&#123; memset(vis,0,sizeof(vis)); if(dfs(i))res++; &#125; return res; &#125;char a[maxn][maxn];int main()&#123; scanf("%d%d",&amp;nx,&amp;ny); init(nx,ny); for(int i=1;i&lt;=nx;i++)&#123; scanf("%s",a[i]+1); for(int j=1;j&lt;=ny;j++)&#123; if(a[i][j]=='*')addedge(i,j+nx); &#125; &#125; int res = hungrey(); printf("%d\n",res); memset(vis,0,sizeof(vis));//记得先清空已经用过的标记 for(int i=1;i&lt;=nx;i++)&#123; if(link[i]==-1)dfs(i); &#125; int ans = 0; for(int i=1;i&lt;=nx;i++)&#123; if(!vis[i])ans++; &#125; printf("%d ",ans); for(int i=1;i&lt;=nx;i++)&#123; if(!vis[i])printf("%d ",i); &#125; ans = 0; for(int i=nx+1;i&lt;=nx+ny;i++)&#123; if(vis[i])ans++; &#125; printf("\n%d ",ans); for(int i=nx+1;i&lt;=nx+ny;i++)&#123; if(vis[i])printf("%d ",i-nx); &#125; printf("\n"); return 0;&#125; 关于求解最小点覆盖集，可以参考如下：https://blog.csdn.net/niushuai666/article/details/7036897思路是从一个未匹配的点开始，沿着未匹配的边走，沿途标记所有的点，对于左侧的未标记的点、右侧标记的点就是选中的最小点覆盖集。]]></content>
      <categories>
        <category>网络流</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[牛客练习赛28(数据结构)]]></title>
    <url>%2F2018%2F11%2F17%2F%E7%89%9B%E5%AE%A2%E7%BB%83%E4%B9%A0%E8%B5%9B28(%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84)%2F</url>
    <content type="text"><![CDATA[https://www.nowcoder.com/acm/contest/200/B思路：比较经典的线段树模板题，事后学习了一下并且调了很久，主要是加法和乘法标记下传的问题，我们考虑同时如果同时存在两种标记，前一种标记必定是下传的最后一个区间（否则可以继续下传标记清空），但标记已经被写入，所以先乘后加是正确的选择，这种情况下不论先进行加法操作后进行乘法操作，或者先进行乘法操作后进行加法操作都可以得到正确的结果，最后注意整个维护的细节即可（初始化，标记下传等）。代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e5+10;long long a[maxn&lt;&lt;2],sum[maxn&lt;&lt;2],dousum[maxn&lt;&lt;2],maxv[maxn&lt;&lt;2],minv[maxn&lt;&lt;2];long long mulzy[maxn&lt;&lt;2],addzy[maxn&lt;&lt;2];int n,q;inline void pushup(int o)&#123; sum[o] = sum[o&lt;&lt;1] + sum[o&lt;&lt;1|1]; minv[o] = min(minv[o&lt;&lt;1],minv[o&lt;&lt;1|1]); maxv[o] = max(maxv[o&lt;&lt;1],maxv[o&lt;&lt;1|1]); dousum[o] = dousum[o&lt;&lt;1] + dousum[o&lt;&lt;1|1];&#125;void pushdown(int o,int m)&#123;//先乘后加 if(mulzy[o]!=1)&#123; dousum[o&lt;&lt;1]*=mulzy[o]*mulzy[o];;//因为要用的是原来的sum所以先计算平方和 dousum[o&lt;&lt;1|1]*=mulzy[o]*mulzy[o]; sum[o&lt;&lt;1] = mulzy[o]*sum[o&lt;&lt;1]; sum[o&lt;&lt;1|1] = mulzy[o]*sum[o&lt;&lt;1|1] ; addzy[o&lt;&lt;1] = addzy[o&lt;&lt;1]*mulzy[o]; addzy[o&lt;&lt;1|1] = addzy[o&lt;&lt;1|1]*mulzy[o]; mulzy[o&lt;&lt;1] *=mulzy[o]; mulzy[o&lt;&lt;1|1] *= mulzy[o]; mulzy[o] = 1; &#125; if(addzy[o])&#123; dousum[o&lt;&lt;1]=dousum[o&lt;&lt;1]+2*addzy[o]*sum[o&lt;&lt;1]+addzy[o]*addzy[o]*(m-(m&gt;&gt;1)); dousum[o&lt;&lt;1|1]=dousum[o&lt;&lt;1|1]+2*addzy[o]*sum[o&lt;&lt;1|1]+addzy[o]*addzy[o]*((m&gt;&gt;1)); sum[o&lt;&lt;1] = sum[o&lt;&lt;1] + addzy[o]*(m-(m&gt;&gt;1)); sum[o&lt;&lt;1|1] = sum[o&lt;&lt;1|1] + addzy[o]*(m&gt;&gt;1); addzy[o&lt;&lt;1] +=addzy[o]; addzy[o&lt;&lt;1|1] += addzy[o]; addzy[o] = 0; &#125;&#125;void build(int o,int l,int r)&#123; if(l&lt;r)&#123; int mid = l+r&gt;&gt;1; build(o&lt;&lt;1,l,mid); build(o&lt;&lt;1|1,mid+1,r); mulzy[o] = 1;//注意全部区间初始化为1 pushup(o); &#125; else&#123; sum[o] = a[l]; minv[o] = a[l]; maxv[o] = a[l]; dousum[o] = a[l]*a[l]; mulzy[o] = 1;//注意全部区间初始化为1 addzy[o] = 0; &#125;&#125;void add(int o,int tl,int tr,int l,int r,long long v)&#123; if(tr&lt;l||r&lt;tl)return; if(l&lt;=tl&amp;&amp;tr&lt;=r)&#123; dousum[o] = dousum[o] + 2*sum[o]*v + v*v*(tr-tl+1); addzy[o]+=v; sum[o]+=(tr-tl+1)*v; return; &#125; pushdown(o,tr-tl+1); int mid = (tl+tr)&gt;&gt;1; add(o&lt;&lt;1,tl,mid,l,r,v); add(o&lt;&lt;1|1,mid+1,tr,l,r,v); pushup(o);&#125; void mul(int o,int tl,int tr,int l,int r,long long v)&#123; if(tr&lt;l||r&lt;tl)return; if(l&lt;=tl&amp;&amp;tr&lt;=r)&#123; mulzy[o]*=v; addzy[o]*=v; sum[o]*=v; dousum[o]*=v*v; return; &#125; pushdown(o,tr-tl+1); int mid = (tl+tr)&gt;&gt;1; mul(o&lt;&lt;1,tl,mid,l,r,v); mul(o&lt;&lt;1|1,mid+1,tr,l,r,v); pushup(o);&#125; long long querysum(int o,int tl,int tr,int l,int r)&#123; if(tr&lt;l||r&lt;tl)return 0; if(l&lt;=tl&amp;&amp;tr&lt;=r)return sum[o]; pushdown(o,tr-tl+1); int mid = (tl+tr)&gt;&gt;1; long long ret = querysum(o&lt;&lt;1,tl,mid,l,r); ret+=querysum(o&lt;&lt;1|1,mid+1,tr,l,r); return ret;&#125;long long querydousum(int o,int tl,int tr,int l,int r)&#123; if(tr&lt;l||r&lt;tl)return 0; if(l&lt;=tl&amp;&amp;tr&lt;=r)return dousum[o]; pushdown(o,tr-tl+1); int mid = (tl+tr)&gt;&gt;1; long long ret = querydousum(o&lt;&lt;1,tl,mid,l,r); ret+=querydousum(o&lt;&lt;1|1,mid+1,tr,l,r); return ret;&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;q); for(int i=1;i&lt;=n;i++)&#123; scanf("%lld",&amp;a[i]); &#125; build(1,1,n); int num; int p,o; for(int i=1;i&lt;=q;i++)&#123; scanf("%d%d%d",&amp;num,&amp;p,&amp;o); if(num==1)printf("%lld\n",querysum(1,1,n,p,o)); if(num==2)printf("%lld\n",querydousum(1,1,n,p,o)); if(num==3)&#123; long long v; scanf("%lld",&amp;v); mul(1,1,n,p,o,v); &#125; if(num==4)&#123; long long v; scanf("%lld",&amp;v); add(1,1,n,p,o,v); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>线段树</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[牛客国庆集训派对Day6(kingdom)]]></title>
    <url>%2F2018%2F11%2F17%2F%E7%89%9B%E5%AE%A2%E5%9B%BD%E5%BA%86%E9%9B%86%E8%AE%AD%E6%B4%BE%E5%AF%B9Day6(kingdom)%2F</url>
    <content type="text"><![CDATA[链接：https://www.nowcoder.com/acm/contest/206/F思路：我们考虑对于一个n，因为国王是最高上司，所以国王就是树的根，那么整个的和的最大值就等于各个子树的和的最大值+总结点数-结点树最多的子树的结点个数-1，因为各个子树可以重复出现，让我们想起了多重背包，我们考虑用f[i]表示当前i个结点总和的最大值，用g[i][j]表示总和为j，其最大子树的总结点数不超过i时的最大值，那么我们就很容易得到状态转移方程：f[i] = max(f[i],f[j] + g[j][i-j-1]+i-j-1); 1&lt;=j]]></content>
      <categories>
        <category>树形dp</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[牛客国庆集训派对Day1(Princess-Principal)]]></title>
    <url>%2F2018%2F11%2F17%2F%E7%89%9B%E5%AE%A2%E5%9B%BD%E5%BA%86%E9%9B%86%E8%AE%AD%E6%B4%BE%E5%AF%B9Day1(Princess-Principal)%2F</url>
    <content type="text"><![CDATA[链接：https://www.nowcoder.com/acm/contest/201/J思路：好像又学到了一些新姿势，首先匹配括号的时候可以从左向右扫一遍把右括号先全部匹配掉，再从右往左扫一遍把左括号匹配掉（可以证明如果能匹配左右括号是对应匹配的，如果不能都为-1），然后建立RMQ（好久没有用过都快忘了这是个什么东西了），求区间的最大最小值，如果最小值为-1或者小于l或者最大值大于r，则这个区间无解。代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e6+100;int s[maxn];int head = 0;int a[maxn];int b[maxn];int dmin[maxn][100];int dmax[maxn][100];int n,m,q;void RMQ_init()&#123; for(int i=0;i&lt;n;i++)&#123; dmin[i][0] = b[i]; dmax[i][0] = b[i]; &#125; for(int j=1;(1&lt;&lt;j)&lt;=n;j++) for(int i=0;i+(1&lt;&lt;j)-1&lt;n;i++)&#123; dmax[i][j] = max(dmax[i][j-1],dmax[i+(1&lt;&lt;(j-1))][j-1]); dmin[i][j] = min(dmin[i][j-1],dmin[i+(1&lt;&lt;(j-1))][j-1]); &#125;&#125;int RMQ_MAX(int L,int R)&#123; int k = 0; while(1&lt;&lt;(k+1)&lt;=R-L+1)k++; return max(dmax[L][k],dmax[R-(1&lt;&lt;k)+1][k]);&#125;int RMQ_MIN(int L,int R)&#123; int k = 0; while(1&lt;&lt;(k+1)&lt;=R-L+1)k++; return min(dmin[L][k],dmin[R-(1&lt;&lt;k)+1][k]);&#125;int main()&#123; scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;q); for(int i=0;i&lt;n;i++)scanf(&quot;%d&quot;,&amp;a[i]); for(int i=0;i&lt;n;i++)&#123; if(a[i]%2==0)&#123; s[head++] = i; &#125; else&#123; int now = -1; if(head)now = s[--head]; if(now==-1)b[i] = -1; else&#123; if(a[now]/2==a[i]/2)b[i] = now; else b[i] = -1; &#125; &#125; &#125; head = 0; for(int i=n-1;i&gt;=0;i--)&#123; if(a[i]&amp;1)&#123; s[head++] = i; &#125; else&#123; int now = -1; if(head)now = s[--head]; if(now==-1)b[i] = -1; else&#123; if(a[now]/2==a[i]/2)b[i] = now; else b[i] = -1; &#125; &#125; &#125; RMQ_init(); for(int i=0;i&lt;q;i++)&#123; int l,r; scanf(&quot;%d%d&quot;,&amp;l,&amp;r); l--; r--; int minv = RMQ_MIN(l,r); int maxv = RMQ_MAX(l,r); if(minv==-1||minv&lt;l||maxv&gt;r)printf(&quot;No\n&quot;); else printf(&quot;Yes\n&quot;); &#125; return 0;&#125;]]></content>
      <categories>
        <category>RMQ</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[洛谷P1880-[NOI1995]石子合并]]></title>
    <url>%2F2018%2F11%2F17%2F%E6%B4%9B%E8%B0%B7P1880-%5BNOI1995%5D%E7%9F%B3%E5%AD%90%E5%90%88%E5%B9%B6%2F</url>
    <content type="text"><![CDATA[链接：https://www.luogu.org/problemnew/show/P1880思路：再次接触区间dp，这次感觉比第一次理解更深入了一些，一般的线性dp是从前往后递推，但有些情形是需要从左右两个小区间合并为一个大区间，这时候就是区间合并问题了，石子合并是最经典的区间合并问题，区间dp首先枚举区间长度，从2开始（1没有意义且会影响最终结果），然后枚举左端点，然后得出右端点，最后枚举中间断层的地方（k表示在第k个数后断开）。对于环形，我们可以把环拆成长度2倍的链，只需要枚举一下链的起点就可以得到换上所有答案的最值。代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;bits/stdc++.h&gt;using namespace std;int n;typedef long long ll;const int maxn = 210;int a[maxn];ll maxv[maxn][maxn];ll minv[maxn][maxn];ll sum[maxn];int main()&#123; scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;i++)&#123; scanf(&quot;%d&quot;,&amp;a[i]); a[n+i] = a[i];//拆环为链 &#125; for(int i=1;i&lt;=2*n;i++)&#123; sum[i] = sum[i-1]+a[i]; &#125; for(int i=1;i&lt;=2*n;i++)&#123; for(int j=1;j&lt;=2*n;j++)&#123; minv[i][j] = 1e18; &#125; &#125; for(int i=1;i&lt;=2*n;i++)maxv[i][i] = minv[i][i] = 0; for(int len=2;len&lt;=2*n;len++)&#123;//从2开始枚举长度（包含左端点本身） for(int l=1;l+len-1&lt;=2*n;l++)&#123;//枚举左端点 int r = len+l-1;//得出右端点 for(int k=l;k&lt;r;k++)&#123;//枚举断点（在k的右边断开） maxv[l][r] = max(maxv[l][r],maxv[l][k]+maxv[k+1][r]); minv[l][r] = min(minv[l][r],minv[l][k]+minv[k+1][r]); &#125; //补上合并代价 maxv[l][r]+=sum[r]-sum[l-1]; minv[l][r]+=sum[r]-sum[l-1]; &#125; &#125; ll res1 = 0,res2 = 1e18; for(int i=1;i&lt;=n+1;i++)&#123;//找到环上所有方案的最值 res1 = max(res1,maxv[i][i+n-1]); res2 = min(res2,minv[i][i+n-1]); &#125; printf(&quot;%lld\n%lld\n&quot;,res2,res1); return 0;&#125;]]></content>
      <categories>
        <category>区间dp</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[洛谷(魔术球问题)]]></title>
    <url>%2F2018%2F11%2F17%2F%E6%B4%9B%E8%B0%B7(%E9%AD%94%E6%9C%AF%E7%90%83%E9%97%AE%E9%A2%98)%2F</url>
    <content type="text"><![CDATA[链接：https://www.luogu.org/problemnew/show/P2765思路：利用网络流可以在残留网络上跑的性质，我们考虑边跑网络流边加点，当当前点数-二分图的最大匹配数（将一个点拆为两个分别放在x和y上进行二分匹配，详见最小路径覆盖问题）&gt;n时表示最小路径覆盖的数目超过了n，这时候停止达到球的最大值，最后出来查看一下所有的正向边flow不为0的，将每个点的下一个点记录出来，最后输出路径即可。代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124#include&lt;bits/stdc++.h&gt;using namespace std;int n,m;const int maxn = 5010;const int INF = 1e9;int vis[maxn];int nexto[maxn];struct edge&#123; int from,to,cap,flow;&#125;;struct Dinic&#123; int n,m,s,t; vector&lt;edge&gt; edges; vector&lt;int&gt; G[maxn]; bool vis[maxn]; int d[maxn]; int cur[maxn]; void init(int n)&#123; this-&gt;n = n; edges.clear(); for(int i=0;i&lt;=n;i++)G[i].clear(); &#125; void addedge(int from,int to,int cap)&#123; edges.push_back(edge&#123;from,to,cap,0&#125;); edges.push_back(edge&#123;to,from,0,0&#125;); m = edges.size(); G[from].push_back(m-2); G[to].push_back(m-1); &#125; bool bfs()&#123; memset(vis,0,sizeof(vis)); queue&lt;int&gt; q; q.push(s); d[s] = 0; vis[s] = 1; while(!q.empty())&#123; int x = q.front(); q.pop(); for(int i=0;i&lt;G[x].size();i++)&#123; edge &amp;e = edges[G[x][i]]; if(!vis[e.to]&amp;&amp;e.cap&gt;e.flow)&#123; vis[e.to] = 1; d[e.to] = d[x] + 1; q.push(e.to); &#125; &#125; &#125; return vis[t]; &#125; int dfs(int x,int a)&#123; if(x==t||a==0)return a; int flow = 0,f; for(int &amp;i = cur[x];i&lt;G[x].size();i++)&#123; edge &amp;e = edges[G[x][i]]; if(d[x] + 1 == d[e.to]&amp;&amp;(f=dfs(e.to,min(a,e.cap-e.flow)))&gt;0)&#123; e.flow+=f; edges[G[x][i]^1].flow -=f; flow+=f; a-=f; if(a==0)break; &#125; &#125; return flow; &#125; int maxflow(int s,int t)&#123; this-&gt;s = s; this-&gt;t = t; int flow = 0; while(bfs())&#123; memset(cur,0,sizeof(cur)); flow+=dfs(s,INF); &#125; return flow; &#125;&#125;solver;set&lt;int&gt; all;int main()&#123; scanf(&quot;%d&quot;,&amp;n); for(int i=0;i&lt;=100;i++)all.insert(i*i); solver.init(5000); int now = 0; int res = 0; while(++now)&#123; solver.addedge(0,now,1); solver.addedge(now+2000,5000,1);//2000作为x和y的分界线 for(int i=1;i&lt;now;i++)&#123; if(all.count(i+now)) solver.addedge(i,now+2000,1); &#125; res+=solver.maxflow(0,5000); //printf(&quot;%d\n&quot;,res); if(now-res&gt;n)break; &#125; printf(&quot;%d\n&quot;,now-1); for(int i=0;i&lt;solver.edges.size();i+=2)&#123; edge e = solver.edges[i]; if(e.flow)nexto[e.from] = e.to&gt;2000?e.to-2000:e.to; &#125; for(int i=1;i&lt;=now-1;i++)&#123; int u = i; if(!vis[u])&#123; printf(&quot;%d&quot;,u); vis[u] = 1; u = nexto[u]; while(u)&#123; vis[u] = 1; printf(&quot; %d&quot;,u); u = nexto[u]; &#125; printf(&quot;\n&quot;); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>网络流</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[洛谷(餐巾计划问题)]]></title>
    <url>%2F2018%2F11%2F17%2F%E6%B4%9B%E8%B0%B7(%E9%A4%90%E5%B7%BE%E8%AE%A1%E5%88%92%E9%97%AE%E9%A2%98)%2F</url>
    <content type="text"><![CDATA[链接：https://www.luogu.org/problemnew/show/P1251思路：费用流题目，建图还是关键，首先很显然想到了拆点，因为有用掉和送出去两个状态，所以把每天拆为两个点，一个表示使用量，一个表示送出去的量，分别放在二分图的x和y上，建立源点汇点，对于每个点i，从源点到x上的i建立一条容量c[i]，费用为0的边，表示当天使用c[i]个餐巾;从y轴上的i到汇点建立一条容量为c[i]，费用为p的边，用来限制最大流。然后对于每个x上的点，向x+1建立一条容量为INF，费用为0的边，向y+m上建立一条容量为INF，费用为f的边，向y+n上建立一条容量为INF，费用为s的边，最后跑一遍费用流即可。代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 5050;const int INF = 1e9;int t;int c[2010];int p,m,f,n,s;struct edge&#123; int from,to,cap,flow,cost;&#125;;struct MCMF&#123; int n,m,s,t; vector&lt;edge&gt; edges; vector&lt;int&gt; G[maxn]; int d[maxn]; int inq[maxn]; int p[maxn]; int a[maxn]; void init(int n)&#123; this-&gt;n = n; for(int i=0;i&lt;=n;i++)G[i].clear(); edges.clear(); &#125; void addedge(int from,int to,int cap,int cost)&#123; edges.push_back(edge&#123;from,to,cap,0,cost&#125;); edges.push_back(edge&#123;to,from,0,0,-cost&#125;); m = edges.size(); G[from].push_back(m-2); G[to].push_back(m-1); &#125; bool spfa(int s,int t,int &amp;flow,long long &amp;cost)&#123; for(int i=0;i&lt;=n;i++)d[i] = INF; memset(inq,0,sizeof(inq)); d[s] = 0; inq[s] = 1; p[s] = 0; a[s] = INF; queue&lt;int&gt; q; q.push(s); while(!q.empty())&#123; int u = q.front(); q.pop(); inq[u] = 0; for(int i=0;i&lt;G[u].size();i++)&#123; edge &amp;e = edges[G[u][i]]; if(e.cap&gt;e.flow&amp;&amp;d[e.to]&gt;d[u]+e.cost)&#123; d[e.to] = d[u] + e.cost; p[e.to] = G[u][i]; a[e.to] = min(a[u],e.cap-e.flow); if(!inq[e.to])&#123; q.push(e.to); inq[e.to] = 1; &#125; &#125; &#125; &#125; if(d[t]==INF)return false; flow+=a[t]; cost+=1LL*d[t]*a[t]; int u = t; while(u!=s)&#123; edges[p[u]].flow+=a[t]; edges[p[u]^1].flow-=a[t]; u = edges[p[u]].from; &#125; return true; &#125; long long mincost(int s,int t)&#123; int flow = 0; long long cost = 0; while(spfa(s,t,flow,cost)); return cost; &#125;&#125;solver;int main()&#123; scanf(&quot;%d&quot;,&amp;t); for(int i=1;i&lt;=t;i++)scanf(&quot;%d&quot;,&amp;c[i]); scanf(&quot;%d%d%d%d%d&quot;,&amp;p,&amp;m,&amp;f,&amp;n,&amp;s); solver.init(2*t+1); for(int i=1;i&lt;=t;i++)&#123; solver.addedge(0,i,c[i],0); solver.addedge(i+t,2*t+1,c[i],0); solver.addedge(0,i+t,INF,p); if(i!=t)solver.addedge(i,i+1,INF,0); if(i+m&lt;=t)solver.addedge(i,i+t+m,INF,f); if(i+n&lt;=t)solver.addedge(i,i+t+n,INF,s); &#125; long long res = solver.mincost(0,2*t+1); printf(&quot;%lld\n&quot;,res); return 0; &#125;]]></content>
      <categories>
        <category>网络流</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[洛谷(软件补丁问题)]]></title>
    <url>%2F2018%2F11%2F17%2F%E6%B4%9B%E8%B0%B7(%E8%BD%AF%E4%BB%B6%E8%A1%A5%E4%B8%81%E9%97%AE%E9%A2%98)%2F</url>
    <content type="text"><![CDATA[链接：https://www.luogu.org/problemnew/show/P2761思路：状压最短路，首先将b1,b2,f1,f2压入一个数组中，用来表示转移条件，然后初始状态是(1&lt;]]></content>
      <categories>
        <category>网络流</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[洛谷(航空路线问题)]]></title>
    <url>%2F2018%2F11%2F17%2F%E6%B4%9B%E8%B0%B7(%E8%88%AA%E7%A9%BA%E8%B7%AF%E7%BA%BF%E9%97%AE%E9%A2%98)%2F</url>
    <content type="text"><![CDATA[链接：https://www.luogu.org/problemnew/show/P2770思路：跟题解做的有点不一样，因为是要求经过城市的数量最大，所以跑最大费用最大流，拆点，然后点之间的边流量为1表示只能经过一次，cost为-1统计费用用来表示经过的点的数量，然后建立一个源点连向1，容量为2，费用为0，表示两条路，建立一个汇点连接n，容量为2，费用为0，当最大流为2的时候有解输出费用即为经过的城市，注意有以下需要注意的地方。1、如果最大流为1（无解）但起点和终点有一条连边，则可以直接到达，需要特判。2、两个城市建边的时候要从序号小的指向大的（即从西到东）（发现之前有些网络流的题都没在意过这个问题），这样才能保证能流到汇点里面去。代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1010;const int INF = 1e9;int n,m;map&lt;string,int&gt; mat;string name[maxn];vector&lt;int&gt; path;int vis[maxn];struct edge&#123; int from,to,cap,flow,cost;&#125;;struct MCMF&#123; int n,m,s,t; vector&lt;edge&gt; edges; vector&lt;int&gt; G[maxn]; int inq[maxn]; int d[maxn]; int p[maxn]; int a[maxn]; int flow; void init(int n)&#123; this-&gt;n = n; for(int i=0;i&lt;=n;i++)G[i].clear(); edges.clear(); &#125; void addedge(int from,int to,int cap,int cost)&#123; edges.push_back(edge&#123;from,to,cap,0,cost&#125;); edges.push_back(edge&#123;to,from,0,0,-cost&#125;); m = edges.size(); G[from].push_back(m-2); G[to].push_back(m-1); &#125; bool spfa(int s,int t,int &amp;flow,int &amp;cost)&#123; for(int i=0;i&lt;=n;i++)d[i] = INF; memset(inq,0,sizeof(inq)); d[s] = 0; inq[s] = 1; p[s] = 0; a[s] = INF; queue&lt;int&gt; q; q.push(s); while(!q.empty())&#123; int u = q.front(); q.pop(); inq[u] = 0; for(int i = 0;i&lt;G[u].size();i++)&#123; edge &amp;e = edges[G[u][i]]; // printf(&quot;%d %d %d&quot;,d[e.from],e.cost,d[e.to]); if(e.cap&gt;e.flow&amp;&amp;d[e.to]&gt;d[u] + e.cost)&#123; d[e.to] = d[u] + e.cost; p[e.to] = G[u][i]; a[e.to] = min(a[u],e.cap-e.flow); if(!inq[e.to])&#123; q.push(e.to); inq[e.to] = 1; &#125; &#125; &#125; &#125; if(d[t]==INF)return false; flow+=a[t]; cost+=d[t]*a[t]; int u = t; while(u!=s)&#123; edges[p[u]].flow+=a[t]; edges[p[u]^1].flow-=a[t]; u = edges[p[u]].from; &#125; return true; &#125; int mincost(int s,int t)&#123; int flow = 0,cost = 0; while(spfa(s,t,flow,cost)); this-&gt;flow = flow; return cost; &#125; void print(int x)&#123; int now = x; if(x&gt;n/2)now-=n/2; path.push_back(now); vis[now] = 1; for(int i=0;i&lt;G[now].size();i++)&#123; edge e = edges[G[now][i]]; if(e.to==n||e.to==0)continue; if(e.to&gt;n/2)e.to-=n/2; if(e.flow&amp;&amp;!vis[e.to])print(e.to); &#125; &#125;&#125;solver;int main()&#123; cin&gt;&gt;n&gt;&gt;m; solver.init(2*n+1); int check = 0; for(int i=1;i&lt;=n;i++)&#123; string a; cin&gt;&gt;a; mat[a] = i; name[i] = a; if(i!=1&amp;&amp;i!=n) solver.addedge(i+n,i,1,-1); else if(i==n)solver.addedge(2*n,n,2,-1); else if(i==1)solver.addedge(n+1,1,2,-1); &#125; for(int i=0;i&lt;m;i++)&#123; string a,b; cin&gt;&gt;a&gt;&gt;b; if((mat[a]==1&amp;&amp;mat[b]==n)||(mat[a]==n&amp;&amp;mat[b]==1))check = 1; if(mat[a]&gt;mat[b])solver.addedge(mat[b],mat[a]+n,1,0); else solver.addedge(mat[a],mat[b]+n,1,0); &#125; solver.addedge(0,1,2,0); solver.addedge(n,2*n+1,2,0); int res = solver.mincost(0,2*n+1); if(!solver.flow||(solver.flow==1&amp;&amp;!check))cout&lt;&lt;&quot;No Solution!&quot;&lt;&lt;endl; else if(solver.flow==1&amp;&amp;check==1)cout&lt;&lt;&quot;2\n&quot;&lt;&lt;name[1]&lt;&lt;endl&lt;&lt;name[n]&lt;&lt;endl&lt;&lt;name[1]&lt;&lt;endl; else&#123; cout&lt;&lt;-res&lt;&lt;endl; solver.print(1); int len = 0; for(int i=0;i&lt;path.size();i++)&#123; if(path[i]!=2*n+1&amp;&amp;path[i]!=0&amp;&amp;path[i]!=n)cout&lt;&lt;name[path[i]]&lt;&lt;endl; else if(path[i]==n)&#123; cout&lt;&lt;name[n]&lt;&lt;endl; len = i; break; &#125; &#125; for(int i=path.size()-1;i&gt;len;i--)&#123; cout&lt;&lt;name[path[i]]&lt;&lt;endl; &#125; cout&lt;&lt;name[1]&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>网络流</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[洛谷(最长不下降子序列问题)]]></title>
    <url>%2F2018%2F11%2F17%2F%E6%B4%9B%E8%B0%B7(%E6%9C%80%E9%95%BF%E4%B8%8D%E4%B8%8B%E9%99%8D%E5%AD%90%E5%BA%8F%E5%88%97%E9%97%AE%E9%A2%98)%2F</url>
    <content type="text"><![CDATA[链接：https://www.luogu.org/problemnew/show/P2766思路：首先第一问用n^2的dp求出，第二问用网络流做，因为每个点只能用一次相当于结点上有限制，所以需要拆点，左边的点负责接输入，右边的点负责输出，中间拉一条容量为1的边，然后源点到每个dp[i] = 1的点都拉一条边，表示开始，所有dp[i] = res(一问答案)的点到汇点拉一条边，表示结束，跑一遍网络流即可。第三问不能重新建图会超时，直接把源点到1的边变为无穷，1拆的两个点之间的边变为无穷，n如果跟汇点有边就把边变为无穷，n拆的两个点间变为无穷，跑的最大流加上第二问的答案就是第三问的答案。代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1010;const int INF = 1e9;int n;int a[maxn];struct edge&#123; int from,to,cap,flow;&#125;;struct Dinic&#123; int n,m,s,t; vector&lt;int&gt; G[maxn]; vector&lt;edge&gt; edges; int d[maxn]; int cur[maxn]; bool vis[maxn]; void init(int n)&#123; this-&gt;n = n; for(int i=0;i&lt;=n;i++)G[i].clear(); edges.clear(); &#125; void addedge(int from,int to,int cap)&#123; edges.push_back(edge&#123;from,to,cap,0&#125;); edges.push_back(edge&#123;to,from,0,0&#125;); m = edges.size(); G[from].push_back(m-2); G[to].push_back(m-1); &#125; bool bfs()&#123; memset(vis,0,sizeof(vis)); d[s] = 0; vis[s] = 1; queue&lt;int&gt; q; q.push(s); while(!q.empty())&#123; int x = q.front(); q.pop(); for(int i=0;i&lt;G[x].size();i++)&#123; edge &amp;e = edges[G[x][i]]; if(!vis[e.to]&amp;&amp;e.cap&gt;e.flow)&#123; vis[e.to] = 1; d[e.to] = d[x] + 1; q.push(e.to); &#125; &#125; &#125; return vis[t]; &#125; int dfs(int x,int a)&#123; if(x==t||a==0)return a; int flow = 0,f; for(int &amp;i = cur[x];i&lt;G[x].size();i++)&#123; edge &amp;e = edges[G[x][i]]; if(d[x] + 1==d[e.to]&amp;&amp;(f=dfs(e.to,min(a,e.cap-e.flow)))&gt;0)&#123; e.flow+=f; edges[G[x][i]^1].flow-=f; flow+=f; a-=f; if(!a)break; &#125; &#125; return flow; &#125; int maxflow(int s,int t)&#123; this-&gt;s = s; this-&gt;t = t; int flow = 0; while(bfs())&#123; memset(cur,0,sizeof(cur)); flow+=dfs(s,INF); &#125; return flow; &#125;&#125;solver;int dp[maxn];int main()&#123; scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;i++)&#123; scanf(&quot;%d&quot;,&amp;a[i]); &#125; for(int i=1;i&lt;=n;i++)dp[i] = 1; for(int i=1;i&lt;=n;i++)&#123; for(int j=1;j&lt;i;j++)&#123; if(a[j]&lt;=a[i])dp[i] = max(dp[i],dp[j] + 1); &#125; &#125; int res = 0; for(int i=1;i&lt;=n;i++)&#123; res = max(res,dp[i]); &#125; solver.init(2*n+1); for(int i=1;i&lt;=n;i++)&#123; for(int j=1;j&lt;i;j++)&#123; if(a[j]&lt;=a[i]&amp;&amp;dp[j]+1==dp[i])//一定要两个条件都确保才能建边solver.addedge(j+n,i,1); &#125; &#125; for(int i=1;i&lt;=n;i++)&#123; solver.addedge(i,i+n,1); if(dp[i]==res)&#123; solver.addedge(i+n,2*n+1,1); &#125; if(dp[i]==1)solver.addedge(0,i,1); &#125; int res1 = solver.maxflow(0,2*n+1); solver.addedge(0,1,INF); solver.addedge(1,1+n,INF); if(dp[n]==res)&#123;//如果有边则加一条容量为无穷的边 solver.addedge(n,2*n,INF); solver.addedge(2*n,2*n+1,INF); &#125; int res2 = res1 + solver.maxflow(0,2*n+1); printf(&quot;%d\n%d\n%d\n&quot;,res,res1,res2); return 0;&#125;]]></content>
      <categories>
        <category>网络流</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[洛谷(最小路径覆盖问题)]]></title>
    <url>%2F2018%2F11%2F17%2F%E6%B4%9B%E8%B0%B7(%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E8%A6%86%E7%9B%96%E9%97%AE%E9%A2%98)%2F</url>
    <content type="text"><![CDATA[链接：https://www.luogu.org/problemnew/show/P2764思路：最小路径覆盖问题分为最小不相交路径覆盖（每个顶点只能经过一次）和最小相交路径覆盖（定点可以经过多次）。后者做一次floyd传递闭包就变成了前者。而前者需要拆点，将每个点x拆为两个点x1，x2，x1作为二分图的左边点，x2作为二分图的右边点，然后建立一个超级源点和超级汇点，跑一遍最大流，最后用顶点数目（最初的）n-最大流就是最小路径的数目。（证明：一开始每个点都是独立的为一条路径，总共有n条不相交路径。我们每次在二分图里找一条匹配边就相当于把两条路径合成了一条路径，也就相当于路径数减少了1。所以找到了几条匹配边，路径数就减少了多少。所以有最小路径覆盖=原图的结点数-新图的最大匹配数。）代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114#include&lt;bits/stdc++.h&gt;using namespace std;int n,m;const int maxn = 300;const int INF = 1e9;int vis[maxn];int nexto[maxn];struct edge&#123; int from,to,cap,flow;&#125;;struct Dinic&#123; int n,m,s,t; vector&lt;edge&gt; edges; vector&lt;int&gt; G[maxn]; bool vis[maxn]; int d[maxn]; int cur[maxn]; void init(int n)&#123; this-&gt;n = n; edges.clear(); for(int i=0;i&lt;=n;i++)G[i].clear(); &#125; void addedge(int from,int to,int cap)&#123; edges.push_back(edge&#123;from,to,cap,0&#125;); edges.push_back(edge&#123;to,from,0,0&#125;); m = edges.size(); G[from].push_back(m-2); G[to].push_back(m-1); &#125; bool bfs()&#123; memset(vis,0,sizeof(vis)); queue&lt;int&gt; q; q.push(s); d[s] = 0; vis[s] = 1; while(!q.empty())&#123; int x = q.front(); q.pop(); for(int i=0;i&lt;G[x].size();i++)&#123; edge &amp;e = edges[G[x][i]]; if(!vis[e.to]&amp;&amp;e.cap&gt;e.flow)&#123; vis[e.to] = 1; d[e.to] = d[x] + 1; q.push(e.to); &#125; &#125; &#125; return vis[t]; &#125; int dfs(int x,int a)&#123; if(x==t||a==0)return a; int flow = 0,f; for(int &amp;i = cur[x];i&lt;G[x].size();i++)&#123; edge &amp;e = edges[G[x][i]]; if(d[x] + 1 == d[e.to]&amp;&amp;(f=dfs(e.to,min(a,e.cap-e.flow)))&gt;0)&#123; e.flow+=f; edges[G[x][i]^1].flow -=f; flow+=f; a-=f; if(a==0)break; &#125; &#125; return flow; &#125; int maxflow(int s,int t)&#123; this-&gt;s = s; this-&gt;t = t; int flow = 0; while(bfs())&#123; memset(cur,0,sizeof(cur)); flow+=dfs(s,INF); &#125; return flow; &#125;&#125;solver;int main()&#123; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); solver.init(2*n+1); for(int i=1;i&lt;=m;i++)&#123; int a,b; scanf(&quot;%d%d&quot;,&amp;a,&amp;b); solver.addedge(a,b+n,1); &#125; for(int i=1;i&lt;=n;i++)&#123; solver.addedge(0,i,1); solver.addedge(i+n,2*n+1,1); &#125; int res = n - solver.maxflow(0,2*n+1); for(int i=0;i&lt;solver.edges.size();i+=2)&#123;//这样遍历的都是反向边 edge e = solver.edges[i]; if(e.flow)nexto[e.from] = e.to&gt;n?e.to-n:e.to; &#125; for(int i=1;i&lt;=n;i++)&#123; int u = i; if(!vis[u])&#123; while(u)&#123; vis[u] = 1; printf(&quot;%d &quot;,u); u = nexto[u]; &#125; printf(&quot;\n&quot;); &#125; &#125; printf(&quot;%d\n&quot;,res); return 0;&#125;]]></content>
      <categories>
        <category>网络流</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[洛谷(方格取数问题)]]></title>
    <url>%2F2018%2F11%2F17%2F%E6%B4%9B%E8%B0%B7(%E6%96%B9%E6%A0%BC%E5%8F%96%E6%95%B0%E9%97%AE%E9%A2%98)%2F</url>
    <content type="text"><![CDATA[链接：https://www.luogu.org/problemnew/show/P2774思路：题目要求在n*m的棋盘中取一些数字，使得任意两数字没有临边并且要求总和最大。这是个经典的最大独立集覆盖，首先如果要满足上述条件，我们可以理解为任意两点间互相独立，也就是在原图上切去一些边使得图独立，又要求剩下的点权最大（在加边时边权等于点权），也就是切去的要最小，那就是最小割了，而又已知最小割等于最大流，所以建图跑一遍最大流，再用总和减去最大流就是答案。建图的话先将图染色成二分图，相邻点之间拉一条容量为INF的边（都从染色的0到1），然后从源点到所有染色为0点拉一条容量为该点权值的边（这样最后跑出来的最大流就是数字的总和），染色为1的点到汇点拉一条容量为该点权值的边，跑最大流即可。代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113#include&lt;bits/stdc++.h&gt;using namespace std;int n,m;const int maxn = 110*110;const int INF = 1e9;int a[110][110];int color[110][110];struct edge&#123; int from,to,cap,flow;&#125;;struct Dinic&#123; int n,m,s,t; vector&lt;edge&gt; edges; vector&lt;int&gt; G[maxn]; bool vis[maxn]; int d[maxn]; int cur[maxn]; void init(int n)&#123; this-&gt;n = n; edges.clear(); for(int i=0;i&lt;=n;i++)G[i].clear(); &#125; void addedge(int from,int to,int cap)&#123; edges.push_back(edge&#123;from,to,cap,0&#125;); edges.push_back(edge&#123;to,from,0,0&#125;); m = edges.size(); G[from].push_back(m-2); G[to].push_back(m-1); &#125; bool bfs()&#123; memset(vis,0,sizeof(vis)); queue&lt;int&gt; q; q.push(s); d[s] = 0; vis[s] = 1; while(!q.empty())&#123; int x = q.front(); q.pop(); for(int i=0;i&lt;G[x].size();i++)&#123; edge &amp;e = edges[G[x][i]]; if(!vis[e.to]&amp;&amp;e.cap&gt;e.flow)&#123; vis[e.to] = 1; d[e.to] = d[x] + 1; q.push(e.to); &#125; &#125; &#125; return vis[t]; &#125; int dfs(int x,int a)&#123; if(x==t||a==0)return a; int flow = 0,f; for(int &amp;i = cur[x];i&lt;G[x].size();i++)&#123; edge &amp;e = edges[G[x][i]]; if(d[x] + 1 == d[e.to]&amp;&amp;(f=dfs(e.to,min(a,e.cap-e.flow)))&gt;0)&#123; e.flow+=f; edges[G[x][i]^1].flow -=f; flow+=f; a-=f; if(a==0)break; &#125; &#125; return flow; &#125; int maxflow(int s,int t)&#123; this-&gt;s = s; this-&gt;t = t; int flow = 0; while(bfs())&#123; memset(cur,0,sizeof(cur)); flow+=dfs(s,INF); &#125; return flow; &#125;&#125;solver;int main()&#123; int sum = 0; scanf(&quot;%d%d&quot;,&amp;m,&amp;n); solver.init(n*m+1); for(int i=0;i&lt;m;i++)&#123; color[i][0] = i%2; for(int j=0;j&lt;n;j++)&#123; if(j)color[i][j] = !color[i][j-1]; scanf(&quot;%d&quot;,&amp;a[i][j]); sum+=a[i][j]; &#125; &#125; for(int i=0;i&lt;m;i++)&#123; for(int j=0;j&lt;n;j++)&#123; if(color[i][j]==1)&#123; solver.addedge(i*n+j,n*m+1,a[i][j]); continue; &#125; solver.addedge(n*m,i*n+j,a[i][j]); if(i-1&gt;=0)solver.addedge(i*n+j,(i-1)*n+j,INF); if(i+1&lt;m)solver.addedge(i*n+j,(i+1)*n+j,INF); if(j-1&gt;=0)solver.addedge(i*n+j,i*n+j-1,INF); if(j+1&lt;n)solver.addedge(i*n+j,i*n+j+1,INF); &#125; &#125; int res = solver.maxflow(n*m,n*m+1); printf(&quot;%d\n&quot;,sum-res); return 0;&#125;]]></content>
      <categories>
        <category>网络流</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[回文自动机]]></title>
    <url>%2F2018%2F11%2F17%2F%E5%9B%9E%E6%96%87%E8%87%AA%E5%8A%A8%E6%9C%BA%2F</url>
    <content type="text"><![CDATA[写一篇文章来详解一下回文自动机吧，之前没弄懂吃了大亏。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 5e5;const int sigma_size = 26;struct Palindromic_Tree&#123; int ch[maxn][sigma_size];//next数组 int f[maxn];//表示失配指针，具体来说就是与当前点有相同后缀（最长）最近的位置 int cnt[maxn];//表示当前节点前的那一个回文串在整个数组中总共出现了几次（调用count后） int num[maxn];//以当前节点结尾的回文串的种类数 int len[maxn];//以当前节点为结尾的回文串的最长长度 int s[maxn];//储存字符 int last; int n; int p; int newnode(int w)&#123; for(int i=0;i&lt;sigma_size;i++)ch[p][i] = 0; cnt[p] = 0; num[p] = 0; len[p] = w; return p++; &#125; void init()&#123; p = 0; newnode(0); newnode(-1); last = 0; n = 0; s[n] = -1; f[0] = 1; &#125; int getfail(int x)&#123; while(s[n-len[x]-1]!=s[n])x = f[x];//向前找相同后缀的并比较后一位是否相等，相等则返回（因为寻找的默认是最长优先，所以保证找到的回文串一定是最长的） return x; &#125; void add(int c)&#123; c-=&apos;a&apos;; s[++n] = c; int cur = getfail(last); if(!ch[cur][c])&#123; int now = newnode(len[cur]+2); f[now] = ch[getfail(f[cur])][c]; ch[cur][c] = now; num[now] = num[f[now]] + 1; &#125; last = ch[cur][c]; cnt[last]++; &#125; void count()&#123; for(int i=p-1;i&gt;=0;i--)&#123; cnt[f[i]]+=cnt[i];//统计每个节点对应的某种回文串出现的次数 &#125; &#125;&#125;solver;char str[maxn];int main()&#123; solver.init(); scanf(&quot;%s&quot;,str); int len = strlen(str); long long ans = 0; for(int i=0;i&lt;len;i++)solver.add(str[i]); solver.count(); for(int i=2;i&lt;solver.p;i++)&#123;//0表示偶数树上的节点，1表示奇数树上的节点，所以要从2开始遍历 ans = max(ans,1LL*solver.len[i]*solver.cnt[i]); &#125; printf(&quot;%lld\n&quot;,ans); return 0;&#125;]]></content>
      <categories>
        <category>回文自动机</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[ZOJ3261(Connections-in-Galaxy-War)]]></title>
    <url>%2F2018%2F11%2F17%2FZOJ3261(Connections-in-Galaxy-War)%2F</url>
    <content type="text"><![CDATA[链接：https://vjudge.net/problem/ZOJ-3261思路：有几天没做并查集了，这个题我们先按权值合并，小的向大的合并，如果权值相等我们考虑编号，我们将所有命令先读入，然后在从末态开始输出询问，destroy就变成了建边，每次合并时同上合并方式，询问时检查一下当前点的权值和父节点权值是否相等，如果相等则无解，否则记录答案（一定要先getroot一下啊不然上次更新的并没有传递上去，这个地方已经错了很多次了长点记性啊拜托！！！！）代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#pragma GCC diagnostic error &quot;-std=c++11&quot; #include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 60010;int n,m,q;set&lt;pair&lt;int,int&gt; &gt; edge;struct order&#123; int o,u,v;&#125;ss[maxn];int maxv[maxn];int par[maxn];int ans[maxn];char ch[100];int getroot(int a)&#123; if(par[a]==a)return a; return par[a] = getroot(par[a]);&#125;void merge(int u,int v)&#123;//先按权值合并，权值相同按编号合并 int p1 = getroot(u); int p2 = getroot(v); if(p1==p2)return ; if(maxv[p1]&gt;maxv[p2])&#123; par[p2] = p1; &#125; else if(maxv[p1]&lt;maxv[p2])&#123; par[p1] = p2; &#125; else&#123; if(p1&lt;p2)&#123; par[p2] = p1; &#125; else if(p1&gt;p2)&#123; par[p1] = p2; &#125;&#125;&#125;int main()&#123; int kase = 0; while(~scanf(&quot;%d&quot;,&amp;n))&#123; if(kase++)printf(&quot;\n&quot;); edge.clear(); for(int i=0;i&lt;=n;i++)par[i] = i; for(int i=0;i&lt;n;i++)scanf(&quot;%d&quot;,&amp;maxv[i]); scanf(&quot;%d&quot;,&amp;m); for(int i=0;i&lt;m;i++)&#123; int u,v; scanf(&quot;%d%d&quot;,&amp;u,&amp;v); if(u&gt;v)swap(u,v); edge.insert(make_pair(u,v)); &#125; scanf(&quot;%d&quot;,&amp;q); for(int i=0;i&lt;q;i++)&#123; int a,b; scanf(&quot;%s%d&quot;,ch,&amp;a); if(ch[0]==&apos;q&apos;)&#123; ss[i].o = 0; ss[i].u = a; &#125; else if(ch[0]==&apos;d&apos;)&#123; scanf(&quot;%d&quot;,&amp;b); if(a&gt;b)swap(a,b); ss[i].o = 1; ss[i].u = a; ss[i].v = b; edge.erase(make_pair(a,b)); &#125; &#125; for(auto &amp;it:edge)&#123;//将现村的边进行更新 int u = it.first; int v = it.second; merge(u,v); &#125; for(int i=q-1;i&gt;=0;i--)&#123; if(!ss[i].o)&#123; getroot(ss[i].u);//！！！！！一定要记得先路径压缩一下更新最新的父节点！！！！！ if(maxv[ss[i].u]!=maxv[par[ss[i].u]]) ans[i] = par[ss[i].u]; else ans[i] = -1; &#125; else&#123; ans[i] = -2; int u = ss[i].u; int v = ss[i].v; merge(u,v); &#125; &#125; for(int i=0;i&lt;q;i++)&#123; if(ans[i]!=-2) printf(&quot;%d\n&quot;,ans[i]); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>并查集</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[ZOJ1610(Count-the-Colors)]]></title>
    <url>%2F2018%2F11%2F17%2FZOJ1610(Count-the-Colors)%2F</url>
    <content type="text"><![CDATA[链接：https://vjudge.net/contest/260644#problem/F思路：题目求的是每种颜色覆盖的段数，因为区间段数只有8000，所以我们可以考虑暴力，对于每个区间我们用tag表示当前区间覆盖的颜色，-1表示已经传递完了不需要再向下传递，最后找到所有的叶结点统计颜色即可。（注意我们要用左区间端点l来表示l,l+1是某种颜色，所以右区间r是开区间）代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e6+10;int tag[maxn&lt;&lt;2],color[maxn&lt;&lt;2];int n,q;int head;void pushdown(int o,int m)&#123; if(tag[o]!=-1)&#123; tag[o&lt;&lt;1] = tag[o]; tag[o&lt;&lt;1|1] = tag[o]; tag[o] = -1; &#125;&#125;void build(int o,int l,int r)&#123; tag[o] = -1; if(l&lt;r)&#123; int mid = l+r&gt;&gt;1; build(o&lt;&lt;1,l,mid); build(o&lt;&lt;1|1,mid+1,r); &#125;&#125;void update(int o,int tl,int tr,int l,int r,int v)&#123; if(tr&lt;l||r&lt;tl)return; if(l&lt;=tl&amp;&amp;tr&lt;=r)&#123; tag[o] = v; return; &#125; pushdown(o,tr-tl+1); int mid = (tl+tr)&gt;&gt;1; update(o&lt;&lt;1,tl,mid,l,r,v); update(o&lt;&lt;1|1,mid+1,tr,l,r,v);&#125; void query(int o,int tl,int tr)&#123; if(tl==tr)&#123; color[head++] = tag[o]; return; &#125; pushdown(o,tr-tl+1); int mid = (tl+tr)&gt;&gt;1; query(o&lt;&lt;1,tl,mid); query(o&lt;&lt;1|1,mid+1,tr);&#125;int sum[maxn];int main()&#123; while(~scanf(&quot;%d&quot;,&amp;n))&#123; memset(color,-1,sizeof(color)); memset(sum,0,sizeof(sum)); head = 0; build(1,1,8000); for(int i=0;i&lt;n;i++)&#123; int a,b,c; scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c); update(1,1,8000,a+1,b,c); &#125; query(1,1,8000); int j; for(int i=0;i&lt;head;)&#123; if(color[i]==-1)&#123; i++; continue; &#125; sum[color[i]]++; for(j = i + 1; j &lt; head; j++) &#123; if(color[j] != color[i] || color[j] == -1) break; &#125; i = j; &#125; for(int i=0;i&lt;=8000;i++)&#123; if(sum[i]) printf(&quot;%d %d\n&quot;,i,sum[i]); &#125; printf(&quot;\n&quot;); &#125; return 0;&#125;]]></content>
      <categories>
        <category>线段树</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[UVA-1025（A-Spy-in-the-Metro）（动态规划dp）]]></title>
    <url>%2F2018%2F11%2F17%2FUVA-1025%EF%BC%88A-Spy-in-the-Metro%EF%BC%89%EF%BC%88%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92dp%EF%BC%89%2F</url>
    <content type="text"><![CDATA[链接：https://vjudge.net/problem/UVA-1025思考：纯暴力搜索复杂度太大，考虑使用动态规划，首先考虑用一个三维数组记录火车信息int train[i][j][k];i表示时刻t，j表示某个车站，k表示向左或者向右。 int dp[i][j]i表示时刻t，j表示车站，用于记录各个状态最短停留时间 然后考虑从终点开始回推，每个时刻有三种状态：1、停留1个单位时间2、坐开向左的车3、坐开向右的车 dp[i][j] = dp[i+1][j]+1;if(j]]></content>
      <categories>
        <category>基础dp</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Uva(12235)(helpbubu)]]></title>
    <url>%2F2018%2F11%2F17%2FUva(12235)(helpbubu)%2F</url>
    <content type="text"><![CDATA[链接：https://vjudge.net/problem/UVA-12235思路：状态表示dp[i][j][k][m],前i本中拿j本且拿出的集合为k最后一本为m的状态，转移就很简单了见代码，注意有两个点，需要一个特殊的值表示最后没放的情况，其次最后需要比较一下最后的集合和原集合元素差，差几答案就需要加几（无论放哪里混乱度都会+1）代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 105;int dp[maxn][maxn][1&lt;&lt;8][9];int a[maxn];int one[1&lt;&lt;8];int n,m;int main()&#123; int kase = 0; for(int i=0;i&lt;(1&lt;&lt;8);i++)&#123; for(int j=0;j&lt;8;j++)&#123; if(i&amp;(1&lt;&lt;j))one[i]++; &#125; &#125; while(scanf(&quot;%d%d&quot;,&amp;n,&amp;m)&amp;&amp;(n||m))&#123; int all = 0; int maxv = 0; memset(dp,0x3f3f3f3f,sizeof(dp)); for(int i=1;i&lt;=n;i++)&#123; scanf(&quot;%d&quot;,&amp;a[i]); all|=(1&lt;&lt;(a[i]-25)); maxv = max(maxv,a[i]-25); &#125; maxv++; int tot = (1&lt;&lt;maxv); dp[1][0][1&lt;&lt;(a[1]-25)][a[1]-25] = 1; dp[1][1][0][maxv] = 0; for(int i=2;i&lt;=n;i++)&#123; for(int j=0;j&lt;i&amp;&amp;j&lt;=m;j++)&#123; for(int k=0;k&lt;tot;k++)&#123; for(int p=0;p&lt;=maxv;p++)&#123; if(a[i]-25==p)dp[i][j][k][p] = min(dp[i][j][k][p],dp[i-1][j][k][p]); else&#123; dp[i][j][k|(1&lt;&lt;(a[i]-25))][a[i]-25] = min(dp[i][j][k|(1&lt;&lt;(a[i]-25))][a[i]-25],dp[i-1][j][k][p]+1); dp[i][j+1][k][p] = min(dp[i][j+1][k][p],dp[i-1][j][k][p]); &#125; &#125; &#125; &#125; &#125; int ans = 1e9; for(int j=0;j&lt;=m;j++)&#123; for(int i = 0;i&lt;tot;i++)&#123; for(int p=0;p&lt;maxv;p++)&#123; int st = all^i; ans = min(ans,one[st]+dp[n][j][i][p]); &#125; &#125; &#125; printf(&quot;Case %d: %d\n\n&quot;,++kase,ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>基础dp</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Uva(12167)(Proving-Equivalences)]]></title>
    <url>%2F2018%2F11%2F17%2FUva(12167)(Proving-Equivalences)%2F</url>
    <content type="text"><![CDATA[链接：https://vjudge.net/problem/UVA-12167思路：强连通分量+缩点。最后统计出度和入度为0的点，取最大值即可代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include&lt;cstdio&gt;#include&lt;deque&gt;#include&lt;vector&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;struct edge&#123; int u,v; edge()&#123;&#125; edge(int uu,int vv):u(uu),v(vv)&#123;&#125;&#125;;const int maxn = 20001;int t,n,m;vector&lt;int&gt; G[maxn];int dfn[maxn],low[maxn],sccno[maxn],in[maxn],out[maxn];int ntime,bcc_cnt;deque&lt;int&gt; P;void tarjan(int u)&#123; dfn[u] = low[u] = ++ntime; P.push_back(u); for(int i=0;i&lt;G[u].size();i++)&#123; int v = G[u][i]; if(!dfn[v])&#123; tarjan(v); low[u] = min(low[u],low[v]); &#125; else if(!sccno[v])&#123; low[u] = min(low[u],dfn[v]); &#125; &#125; if(low[u]==dfn[u])&#123; bcc_cnt++; int tmp; do&#123; tmp = P.back(); P.pop_back(); sccno[tmp] = bcc_cnt;//一个强连通分量里面的点属于一个缩点的编号 &#125;while(tmp!=u); &#125;&#125;void find_bcc(int n)&#123; memset(sccno,0,sizeof(sccno)); memset(dfn,0,sizeof(dfn)); ntime = bcc_cnt = 0; for(int i=0;i&lt;n;++i)if(!dfn[i])tarjan(i);&#125;int main()&#123; scanf("%d",&amp;t); while(t--)&#123; for(int i=0;i&lt;n;++i)G[i].clear(); scanf("%d%d",&amp;n,&amp;m); for(int i=0;i&lt;m;i++)&#123; int a,b; scanf("%d%d",&amp;a,&amp;b); a--; b--; G[a].push_back(b); &#125; find_bcc(n); for(int i=1;i&lt;=bcc_cnt;i++)in[i] = out[i] = 1; for(int u=0;u&lt;n;u++) for(int i=0;i&lt;G[u].size();i++)&#123; int v = G[u][i]; if(sccno[u]!=sccno[v]) in[sccno[v]] = out[sccno[u]] = 0;//如果u，v不属于一个强连通分量，那么u的出度不为0，v的入度不为0！！ &#125; int a = 0,b=0; for(int i=1;i&lt;=bcc_cnt;i++)&#123; if(in[i])a++; if(out[i])b++; &#125; int ans = max(a,b); if(bcc_cnt==1)ans = 0; printf("%d\n",ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>tarjan强连通分量</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Uva(12124)(Assemble-)]]></title>
    <url>%2F2018%2F11%2F17%2FUva(12124)(Assemble-)%2F</url>
    <content type="text"><![CDATA[链接：https://vjudge.net/problem/UVA-12124思路：求最小值最大的题目，一般采取二分的方法，注意本题目输入配件的时候不一定是按照分类顺序输入的，所以需要一个map给每种配件分配一个编号，然后注意二分时新建一个map并赋值为原来map的值，不要直接用原map修改(又错在这种很细节的小地方了)代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;map&gt;using namespace std;struct pj&#123;char a[1000],b[1000];int cost,q;&#125;pp[1001];int t,n,times;//times记录配件的种类个数long long b;map&lt;string,int&gt; jj;map&lt;string,int&gt; kk;//为每个种类配件分配一个编号，因为输入不一定是按照种类分类输入的int aaa[1001];bool c(long long d)&#123; int qqq = times; long long sum = 0; map&lt;string,int&gt; jjj;//复制一个原来的map jjj = jj; for(int i=0;i&lt;times;i++)aaa[i] = 1e9;//全部设为无穷大for(int i=0;i&lt;n;i++)&#123;if(pp[i].q&gt;=d&amp;&amp;pp[i].cost&lt;aaa[kk[pp[i].a]])&#123; aaa[kk[pp[i].a]] = pp[i].cost;&#125;if(--jjj[pp[i].a]==0)qqq--;&#125;for(int i=0;i&lt;times;i++)sum+=aaa[i];return sum&lt;=b&amp;&amp;qqq==0;&#125;int main()&#123; scanf(&quot;%d&quot;,&amp;t); while(t--)&#123; jj.clear(); kk.clear(); times = 0; scanf(&quot;%d%d&quot;,&amp;n,&amp;b); for(int i=0;i&lt;n;++i)&#123; scanf(&quot;%s%s%d%d&quot;,pp[i].a,pp[i].b,&amp;pp[i].cost,&amp;pp[i].q); if(jj[pp[i].a]++==0)&#123; kk[pp[i].a] = times++; &#125; &#125; long long lb = 0; long long ub = 1e9;while(ub-lb&gt;1)&#123; long long mid = lb+(ub-lb)/2; if(c(mid))lb = mid; else ub = mid;&#125;printf(&quot;%lld\n&quot;,lb); &#125; return 0;&#125;]]></content>
      <categories>
        <category>二分</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Uva(11997)(K-Smallest-Sums)]]></title>
    <url>%2F2018%2F11%2F17%2FUva(11997)(K-Smallest-Sums)%2F</url>
    <content type="text"><![CDATA[链接：https://vjudge.net/problem/UVA-11997思路：这虽然是一个优先队列的题，但其中的思想却远超过优先队列，原来是二个数组的，现在拓展成了n个。方法基本完全一样，首先我们要解决n行的前k个最小值，我们如果知道前n-1行的前k个值再加上最后一行就可以了，这样原问题可以拆分为子问题，然后在考虑状态更新之前我们先考虑一个问题，就是一行中第k个值最早被选也只能总的第k个值（因为他前k-1个都比他小），所以我们考虑到给每组和一个下标，是他最后更新的那个值在数组中的下标，用于确定前k个值是否选完。说的不是很清楚，要靠自己领悟一下。。。。。代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 768;int A[maxn][maxn];struct Item&#123; int s,b; Item()&#123;&#125; Item(int ss,int bb):s(ss),b(bb)&#123;&#125; bool operator&lt;(const Item &amp; r)const&#123; return s&gt;r.s; &#125;&#125;;void merge(int* A,int *B,int* C,int n)&#123; priority_queue&lt;Item&gt; q; for(int i=0;i&lt;n;i++)q.push(Item(A[i]+B[0],0));//合并第一排和第二排第一个值 for(int i=0;i&lt;n;i++)&#123; Item item = q.top(); q.pop(); C[i] = item.s;//记录当前第i小的值 int b = item.b; if(b+1&lt;n)q.push(Item(item.s-B[b]+B[b+1],b+1));//更新，将第二排下标后移一个 &#125;&#125;int main()&#123; int n; while(scanf("%d",&amp;n)==1)&#123; for(int i=0;i&lt;n;i++)&#123; for(int j=0;j&lt;n;j++)scanf("%d",&amp;A[i][j]); sort(A[i],A[i]+n); &#125; for(int i=1;i&lt;n;i++) merge(A[0],A[i],A[0],n);//可以覆盖A[0]来记录结果，节约空间。 printf("%d",A[0][0]); for(int i=1;i&lt;n;i++) printf(" %d",A[0][i]); printf("\n"); &#125;return 0;&#125;]]></content>
      <categories>
        <category>贪心</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Uva(11825)(hackerscrackdown)]]></title>
    <url>%2F2018%2F11%2F17%2FUva(11825)(hackerscrackdown)%2F</url>
    <content type="text"><![CDATA[链接：https://vjudge.net/problem/UVA-11825思路：首先要把题意抽象出来，可以理解为题目给你n个集合，让你尽可能合并成多个集合，使得每个集合都是电脑的全集，最后集合数就是答案，那么我们可以考虑把题目给的每个集合都表示成一个二进制的数，然后求出这些集合的所有子集，f(s) = max(f(s0)+1(其中s0是s的子集且s和s0的差集是一个全集)，接下来就可以用动态规划解决问题附录：求所有i的子集：for(int j=i;j;j=(j-1)&amp;i)代码：123456789101112131415161718192021222324252627282930313233343536373839#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;int n,m,t;int a[20];int s[65660],f[65660],o=0;int main()&#123; while(cin&gt;&gt;n&amp;&amp;n)&#123; memset(a,0,sizeof(a)); memset(s,0,sizeof(s)); memset(f,0,sizeof(f)); for(int i=0;i&lt;n;i++)&#123; cin&gt;&gt;m; a[i]+=(1&lt;&lt;i); for(int j=0;j&lt;m;j++)&#123; cin&gt;&gt;t; a[i]|=(1&lt;&lt;t);//将相邻电脑表示为一个二进制数 &#125; &#125; for(int i=1;i&lt;(1&lt;&lt;n);i++)&#123; for(int j=0;j&lt;n;j++)&#123; if(i&amp;(1&lt;&lt;j)) s[i]|=a[j];//求出这些相邻电脑组成集合（将其看为一个大集合的元素）的子集 &#125; &#125; f[0] = 0; int all = (1&lt;&lt;n)-1;//全集 for(int i=1;i&lt;=(1&lt;&lt;n)-1;i++)&#123; for(int j=i;j;j=(j-1)&amp;i)&#123;//j=(j-1)&amp;i是一种遍历子集的写法，可以表示出所有子集，相当于每次去掉一个不同位置的1 if(s[j]==all) f[i] = max(f[i],f[i^j]+1);//因为j是i的子集，所以i^j就是去除i中且j中共同1的位置，求得的就是i和j的差集，实在是很妙，一定要多多理解一下 &#125; &#125; cout&lt;&lt;&quot;Case &quot;&lt;&lt;++o&lt;&lt;&quot;: &quot;&lt;&lt;f[all]&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>状压dp</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Uva(11820)(Flying-to-Fredericton)]]></title>
    <url>%2F2018%2F11%2F17%2FUva(11820)(Flying-to-Fredericton)%2F</url>
    <content type="text"><![CDATA[链接：https://vjudge.net/problem/UVA-11280思路：dijkstra和动态规划结合的题目，其中有个点被坑的不要不要的，如果给的次数大于城市的数目则要初始化为n-1，因为最多转机n-1次不这样处理的话就会一直WA，经验教训啊！！！！！代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113#include&lt;cstdio&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;map&gt;#include&lt;iostream&gt;using namespace std;const int INF = 0x3f3f3f3f;const int maxn = 105;int t,n,m;map&lt;string,int&gt; maple;struct edge&#123; int from,to,dist; edge()&#123;&#125; edge(int f,int t,int d):from(f),to(t),dist(d)&#123;&#125;&#125;;struct node&#123; int id;int s;int cost; node()&#123;&#125; node(int i,int ss,int c):id(i),s(ss),cost(c)&#123;&#125; bool operator&lt;(const node &amp; q)const&#123; return cost&gt;q.cost; &#125;&#125;;struct Dijskstra&#123; int n,m; vector&lt;edge&gt; edges; vector&lt;int&gt; G[maxn]; int d[maxn][maxn]; void init(int n)&#123; this-&gt;n = n; for(int i=0;i&lt;=n;++i)G[i].clear(); edges.clear();&#125;void addedge(int from,int to,int cost)&#123; edges.push_back(edge(from,to,cost)); m = edges.size(); G[from].push_back(m-1);&#125;int dijskstra(int s)&#123;for(int i=0;i&lt;=n;i++)&#123; for(int j=0;j&lt;=103;j++)&#123; d[i][j] = INF; &#125;&#125;d[0][s+1] = 0;priority_queue&lt;node&gt; qq;qq.push(node(0,s+1,0));while(!qq.empty())&#123; node p = qq.top(); qq.pop(); int u = p.id; int ss = p.s; if(d[u][ss]&lt;p.cost)continue; for(int i=0;i&lt;G[u].size();i++)&#123; edge &amp;e = edges[G[u][i]]; if(d[e.to][ss-1]&gt;d[u][ss]+e.dist&amp;&amp;ss&gt;0)&#123;//动态规划！ d[e.to][ss-1] = d[u][ss] + e.dist; qq.push(node(e.to,ss-1,d[e.to][ss-1])); &#125; &#125;&#125;int ans = INF;for(int i=0;i&lt;=min(n-1,s+1);i++)&#123; ans = min(ans,d[n-1][i]);&#125;return ans;&#125;&#125;solver;int main()&#123; freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin); freopen(&quot;out.txt&quot;,&quot;w&quot;,stdout); int kase = 0; scanf(&quot;%d&quot;,&amp;t); while(t--)&#123; if(kase)printf(&quot;\n&quot;); maple.clear(); scanf(&quot;%d&quot;,&amp;n); solver.init(n); string now,noww; for(int i=0;i&lt;n;i++)&#123; cin&gt;&gt;now; maple[now] = i; &#125; scanf(&quot;%d&quot;,&amp;m); int c; for(int i=0;i&lt;m;i++)&#123; cin&gt;&gt;now&gt;&gt;noww&gt;&gt;c; solver.addedge(maple[now],maple[noww],c); &#125; printf(&quot;Scenario #%d\n&quot;,++kase); int q; scanf(&quot;%d&quot;,&amp;q); while(q--)&#123; scanf(&quot;%d&quot;,&amp;c); if(c&gt;n-1)c = n-1;//鲁棒性！！！！！！！！！1 int res = solver.dijskstra(c); if(res==INF)printf(&quot;No satisfactory flights\n&quot;); else printf(&quot;Total cost of flight(s) is $%d\n&quot;,res); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>最短路</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Uva(11600)(Masud-Rana-)]]></title>
    <url>%2F2018%2F11%2F17%2FUva(11600)(Masud-Rana-)%2F</url>
    <content type="text"><![CDATA[链接：https://vjudge.net/problem/UVA-11600思路：主要是状态的考虑，因为每两个点都有路，所以只用区分有没有怪兽即可，我们可以算从一个点开始走到全部两两连通的时候的概率，这时候我们需要用一个数来表示当前已经两两连通的点的集合，状态转移就是枚举不在集合中的点，dp[u][s] += DP(i,(s|(1&lt;]]></content>
      <categories>
        <category>基础dp</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Uva(11552)(Fewest-Flops)]]></title>
    <url>%2F2018%2F11%2F17%2FUva(11552)(Fewest-Flops)%2F</url>
    <content type="text"><![CDATA[链接：https://vjudge.net/problem/UVA-11552思路：就动态规划加枚举就完事了，有以下贪心在里面：当上一个结尾为k时，则下一个的结尾肯定不为j，且一个大块中所有相同的要连在一起，注意动态规划时第一块要拿出来单独处理，因为他左边没有块所以跟其他的处理方式不太一样，复杂度的话O(n)，后面枚举的时候枚举前一块的结尾和后一块的结尾，如果二者相等则跳过，不等则查询一下后一块中是否有前一块结尾，有的话就可以把加的长度-1，否则不行，然后遍历最后一块的结尾即可得到最大值代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;using namespace std;int tt,n;string a;int dp[1001][26];int c[1001][26];//查询某一个大块中某个小连块有多少个int t[1001];//查询某一个大块中有多少种小连块int main()&#123; //freopen("in.txt","r",stdin); //freopen("out.txt","w",stdout); cin&gt;&gt;tt; while(tt--)&#123; memset(c,0,sizeof(c)); memset(t,0,sizeof(t)); cin&gt;&gt;n&gt;&gt;a; for(int i=1;i&lt;=a.size()/n;i++)&#123;//全部赋值为无穷大，代表该状态不存在 for(int j=0;j&lt;26;j++)&#123; dp[i][j] = 1e9; &#125; &#125;//读入每一大块的小块信息 for(int i=0;i&lt;a.size()/n;i++)&#123; for(int j=0;j&lt;n;j++)&#123; if(c[i][a[i*n+j]-'a']++==0)t[i]++; &#125; &#125;//第一块单独处理 for(int i=0;i&lt;26;i++)&#123; if(c[0][i])&#123; dp[0][i] = t[0]; &#125; else dp[0][i] = 1e9; &#125; for(int i=0;i&lt;a.size()/n-1;i++)&#123; for(int j=0;j&lt;26;j++)&#123; if(c[i+1][j]==0)continue; for(int k=0;k&lt;26;k++)&#123; if(j==k&amp;&amp;t[i+1]&gt;1)continue;//如果j=k且小连块种类大于1，则绝对不是最优解，等于1他既是头又是尾 else if(c[i][k]&amp;&amp;c[i+1][k])dp[i+1][j] = min(dp[i+1][j],dp[i][k] + t[i+1] - 1); else dp[i+1][j] = min(dp[i+1][j],dp[i][k]+t[i+1]); &#125; &#125; &#125; int ans = 1e9; for(int i=0;i&lt;26;i++)&#123; ans = min(ans,dp[a.size()/n-1][i]); &#125; cout&lt;&lt;ans&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>贪心</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Uva(11549)(Calculator-Conundrum)]]></title>
    <url>%2F2018%2F11%2F17%2FUva(11549)(Calculator-Conundrum)%2F</url>
    <content type="text"><![CDATA[链接：https://vjudge.net/problem/UVA-11549思路：首先很容易猜到这个平方最后一定会循环，不然的话最大值就根本没法确定了，具体证明暂时没想到但很容易猜到，既然循环，自然而然想到应该用一个set来判断是否重复，于是很容易写出如下的循环版本代码：123456789101112131415161718192021222324252627282930313233#include&lt;cstdio&gt;#include&lt;set&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;using namespace std;int t,n,k;set&lt;int&gt; j;long long cal(long long w)&#123; while(w&gt;=pow(10,n))w/=10; return w;&#125;int main()&#123; //freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin); //freopen(&quot;out.txt&quot;,&quot;w&quot;,stdout); scanf(&quot;%d&quot;,&amp;t); while(t--)&#123; j.clear(); scanf(&quot;%d%d&quot;,&amp;n,&amp;k); long long now = k; long long maxn = k; while(j.count(now)==0)&#123; j.insert(now); now*=now; if(now&gt;=pow(10,n))&#123; now = cal(now); &#125; maxn = max(maxn,now); &#125; printf(&quot;%lld\n&quot;,maxn); &#125; return 0;&#125; 虽然能过，但是set似乎还是很占空间。这时看了刘汝佳大大大大神的做法，了解了一下floyd判圈，大概就是两个小孩跑步(具体表现为下述代码中k1或者k2，)，第二个以两倍于第一个的速度前进，当他们俩碰面的时候，正好多走了一个圈。 代码：1234567891011121314151617181920212223242526272829#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;using namespace std;int t,n,k;long long calnext(long long w)&#123; w = w*w; while(w&gt;=pow(10,n))w/=10; return w;&#125;int main()&#123; //freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin); //freopen(&quot;out.txt&quot;,&quot;w&quot;,stdout); scanf(&quot;%d&quot;,&amp;t); while(t--)&#123; scanf(&quot;%d%d&quot;,&amp;n,&amp;k); long long now = k; long long maxn = k; long long k1 = k,k2=k; do&#123; k1 = calnext(k1);//小孩1 k2 = calnext(k2);if(k2&gt;maxn)maxn = k2;//小孩2 k2 = calnext(k2);if(k2&gt;maxn)maxn = k2; &#125;while(k1!=k2);//碰面，k2比k1刚好多走一圈 printf(&quot;%lld\n&quot;,maxn); &#125; return 0;&#125;]]></content>
      <categories>
        <category>数论</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Uva(11525)(Permutation)]]></title>
    <url>%2F2018%2F11%2F17%2FUva(11525)(Permutation)%2F</url>
    <content type="text"><![CDATA[链接：https://vjudge.net/problem/UVA-11525思路：一开始看到式子头皮发麻，后来查了一下是康拓展开的逆式，没学过正好学习了一下，Sk就表示当前位置排的是还剩下的数字中第k小的数，看到这里自然想到了树状数组求前缀和了，然后对于位置应该二分求解，二分注意一下跟普通的二分有些不同，还需记录当前位置的数字是否使用过。需要对二分相等的情况进行特殊处理一下代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include&lt;bits/stdc++.h&gt;using namespace std;int t,n;const int maxn = 5e4+100;int c[maxn&lt;&lt;1];int j[maxn];int lowbit(int x)&#123; return x&amp;(-x);&#125;void add(int x,int d)&#123; while(x&lt;=n)&#123; c[x]+=d; x+=lowbit(x); &#125;&#125;int sum(int x)&#123; int res = 0; while(x)&#123; res+=c[x]; x-=lowbit(x); &#125; return res;&#125;int cc(int d,int p)&#123; if (sum(d-1)&gt;p) return 1; if (sum(d-1)==p)return 0; if(sum(d-1)&lt;p)return -1;&#125;int main()&#123; scanf(&quot;%d&quot;,&amp;t); while(t--)&#123; memset(c,0,sizeof(c)); memset(j,0,sizeof(j)); scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;i++)&#123; add(i,1); &#125; int now; for(int i=0;i&lt;n;i++)&#123; scanf(&quot;%d&quot;,&amp;now); int ub = n; int lb = 0; while(ub&gt;lb)&#123; int mid = (ub+lb)/2; int res = cc(mid,now); if(res==1)ub = mid; else if(res==0&amp;&amp;j[mid])lb = mid+1;//等于且使用过该数字，则要的值一定在后面 else if(res==0&amp;&amp;!j[mid])&#123;//未使用则及时跳出 ub = mid; break; &#125; else lb = mid+1; if(ub==lb&amp;&amp;j[ub])&#123; while(j[ub])ub++; break; &#125; &#125; j[ub] = 1; add(ub,-1); printf(&quot;%d%c&quot;,ub,i==n-1?&apos;\n&apos;:&apos; &apos;); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>二分</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Uva(11427)(Expect-the-Expected)]]></title>
    <url>%2F2018%2F11%2F17%2FUva(11427)(Expect-the-Expected)%2F</url>
    <content type="text"><![CDATA[链接：https://vjudge.net/problem/UVA-11427思路：由于每天是独立的，所以期望就是一天概率的倒数（很好证明），关键是一天的概率不太好算，因为涉及到当前的状态的判断（即总比例是否超过p），所以我们考虑到了概率中的动态规划。用pp[i][j]表示一共玩了i天赢了j天的状态，i&gt;j是不存在的所以全部为0，然后概率大于p的也全都为0，如果当前i，j概率小于p，那么状态转移pp[i][j] = pp[i-1][j](1-p) + pp[i-1][j-1]p，注意j=0的时候要特殊处理一下即可，最后算0-n的总和，表示这n天总共失败的概率，即可算出成功概率，倒一下就是期望。代码：123456789101112131415161718192021222324252627282930313233#include&lt;bits/stdc++.h&gt;using namespace std;int t,n;double p;double pp[110][110];int main()&#123; //freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin); //freopen(&quot;out.txt&quot;,&quot;w&quot;,stdout); int kase = 0; scanf(&quot;%d&quot;,&amp;t); while(t--)&#123; memset(pp,0,sizeof(pp)); int now1,now2; scanf(&quot;%d/%d%d&quot;,&amp;now1,&amp;now2,&amp;n);//这种输入方法有点妙学习一下 pp[0][0] = 1; pp[0][1] = 0; p = 1.0*now1/now2; for(int i=1;i&lt;=n;i++)&#123; for(int j=0;j*now2&lt;=i*now1;j++)&#123; pp[i][j] = pp[i-1][j]*(1-p); if(j)pp[i][j]+=pp[i-1][j-1]*p; //j=0防止越界要特判 &#125;&#125;double res = 0;for(int i=0;now2*i&lt;=n*now1;i++)&#123; res+=pp[n][i];&#125;printf(&quot;Case #%d: %d\n&quot;,++kase,(int)(1/res));&#125; return 0;&#125;]]></content>
      <categories>
        <category>期望/概率</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Uva(11404)(Palindromic-Subsequence)]]></title>
    <url>%2F2018%2F11%2F17%2FUva(11404)(Palindromic-Subsequence)%2F</url>
    <content type="text"><![CDATA[链接：https://vjudge.net/problem/UVA-11404思路：因为最大回文串，也就是前后两端相等，那么很容易想到把原串倒过来然后求最长公共子序列，求出来的值就刚好是最大回文串的长度（因为是和倒置的串求最长公共子序列，所以求出来一定是回文串），关键是如何输出这个回文串。因为有字典序，所以为了方便起见我们用string(重载了min函数可求字段序，虽然比较慢一点)，然后动态规划中条件要改，详见代码代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;string a,b;int dp[1001][1001];string d[1001][1001];int main()&#123;//freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin);//freopen(&quot;out.txt&quot;,&quot;w&quot;,stdout); while(cin&gt;&gt;a)&#123; b = a; for(int i=0;i&lt;a.size();i++)b[i] = a[a.size()-1-i];//倒置原串 memset(dp,0,sizeof(dp)); d[0][0] = &quot;&quot;;//初始化为空 for(int i=0;i&lt;a.size();i++)&#123; for(int j=0;j&lt;b.size();j++)&#123; if(a[i]==b[j])&#123; dp[i+1][j+1] = dp[i][j] + 1; d[i+1][j+1] = d[i][j] + a[i]; &#125; else &#123;//如果不等就用长度大的那一个的长度和回文 if(dp[i][j+1]&gt;dp[i+1][j])&#123; dp[i+1][j+1] = dp[i][j+1]; d[i+1][j+1] = d[i][j+1]; &#125; else if(dp[i][j+1]&lt;dp[i+1][j])&#123; dp[i+1][j+1] = dp[i+1][j]; d[i+1][j+1] = d[i+1][j]; &#125;//如果相等的时候则要比较二者的字典序大小 else&#123; dp[i+1][j+1] = dp[i][j+1]; d[i+1][j+1] = min(d[i+1][j],d[i][j+1]); &#125; &#125; &#125; &#125; int res = dp[a.size()][a.size()];//要分长度为奇数和偶数进行输出最大回文串 if(res%2)&#123; for(int i=0;i&lt;res/2;i++)cout&lt;&lt;d[a.size()][a.size()][i]; for(int i=res/2;i&gt;=0;i--)cout&lt;&lt;d[a.size()][a.size()][i]; cout&lt;&lt;endl; &#125; else&#123; for(int i=0;i&lt;res/2;i++)cout&lt;&lt;d[a.size()][a.size()][i]; for(int i=res/2-1;i&gt;=0;i--)cout&lt;&lt;d[a.size()][a.size()][i]; cout&lt;&lt;endl; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>基础dp</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Uva(11396)(Claw-Decomposition)]]></title>
    <url>%2F2018%2F11%2F17%2FUva(11396)(Claw-Decomposition)%2F</url>
    <content type="text"><![CDATA[链接：https://vjudge.net/problem/UVA-11396思路：二分图匹配，哎看不出来啊，说一下思路吧，如果确定某个点为爪点，那么它身边的三个点一定是附点，附点之间又不可能相连，所以附点连接的又一定是爪点，这不就是二分图匹配吗………代码：1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;vector&gt;using namespace std;const int maxn = 301;vector&lt;int&gt; G[maxn];int n;int color[maxn];bool bipatirate(int u)&#123;for(int i=0;i&lt;G[u].size();i++)&#123; int v = G[u][i]; if(color[v]==color[u])return false; if(!color[v])&#123; color[v] = 3-color[u]; if(!bipatirate(v))return false; &#125; &#125; return true;&#125;int main()&#123; //freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin); //freopen(&quot;out.txt&quot;,&quot;w&quot;,stdout);while(scanf(&quot;%d&quot;,&amp;n)&amp;&amp;n)&#123; memset(color,0,sizeof(color)); for(int i=0;i&lt;n;i++)G[i].clear();int a,b;while(scanf(&quot;%d%d&quot;,&amp;a,&amp;b)&amp;&amp;(a||b))&#123; a--; b--; G[a].push_back(b); G[b].push_back(a);&#125;color[0] = 1;if(bipatirate(0))printf(&quot;YES\n&quot;);else printf(&quot;NO\n&quot;);&#125;return 0;&#125;]]></content>
      <categories>
        <category>二分图</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Uva(11367)(Full-Tank)]]></title>
    <url>%2F2018%2F11%2F17%2FUva(11367)(Full-Tank)%2F</url>
    <content type="text"><![CDATA[链接：https://vjudge.net/problem/UVA-11367思路：这是一个dijkstra+dp的问题，将dijkstra中的d改为二维，并以花费作为排序目标，然后进行dp，dp的时候可以回忆一下01背包滚动数组的dp方式，从右往左进行选择，即以单位油为状态进行选择。代码中我会详细解释代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;cstring&gt;using namespace std;typedef pair&lt;int,int&gt; P;int n,m;const int maxn = 1010;int cost[maxn];struct edge&#123; int from;int to;int dist; edge()&#123;&#125; edge(int f,int t,int d):from(f),to(t),dist(d)&#123;&#125;;&#125;;//表示状态，cost表示当前花费，f表示剩下的油量，id表示当前在哪个站struct node&#123; int cost,f,id; node()&#123;&#125; node(int c,int i,int ff)&#123; cost = c; id = i; f = ff; &#125; bool operator&lt;(const node &amp;r)const&#123; return cost&gt;r.cost; &#125;&#125;;struct Dijsktra&#123;vector&lt;int&gt; G[maxn];vector&lt;edge&gt; edges;int d[maxn][100];int p[maxn];int n,m;void init(int n)&#123; this-&gt;n = n; for(int i=0;i&lt;=n;i++)G[i].clear(); edges.clear();&#125;void addedge(int from,int to,int dist)&#123; edges.push_back(edge(from,to,dist)); m = edges.size(); G[from].push_back(m-1);&#125;int dijsktra(int c,int s,int e)&#123; priority_queue&lt;node&gt; qq; qq.push(node(0,s,0)); for(int i=0;i&lt;n;i++)for(int j=0;j&lt;=100;j++) d[i][j] = 1e9;d[s][0] = 0;while(!qq.empty())&#123; node p1 = qq.top(); qq.pop(); int u = p1.id; int f1 = p1.f; if(u==e)return p1.cost;//到达查询终点就可以跳出，不需要把每个点都算出来 if(d[u][f1]&lt;p1.cost)continue; for(int i=0;i&lt;G[u].size();i++)&#123; edge &amp;e = edges[G[u][i]];//01背包二维滚动数组的变形，从右往左进行状态更新，注意下届是当前油量和下一条边距离的较大值，自行理解一下，可以囊括所有状态 for(int j=c;j&gt;=max(f1,e.dist);j--)&#123; if(d[e.to][j-e.dist] &gt; d[u][f1]+(j-f1)*cost[u])&#123; d[e.to][j-e.dist] = d[u][f1]+(j-f1)*cost[u]; qq.push(node(d[e.to][j-e.dist],e.to,j-e.dist)); &#125; &#125; &#125;&#125;return -1;&#125;&#125;solver;int main()&#123; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); solver.init(n); for(int i=0;i&lt;n;i++)scanf(&quot;%d&quot;,&amp;cost[i]); for(int i=0;i&lt;m;i++)&#123; int a,b,c; scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c); solver.addedge(a,b,c); solver.addedge(b,a,c); &#125; int q; scanf(&quot;%d&quot;,&amp;q); while(q--)&#123; int c,s,e; scanf(&quot;%d%d%d&quot;,&amp;c,&amp;s,&amp;e); int res = solver.dijsktra(c,s,e); if(res==-1)printf(&quot;impossible\n&quot;);//无解 else&#123; printf(&quot;%d\n&quot;,res); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>最短路</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Uva(11324)(The-Largest-Clique)]]></title>
    <url>%2F2018%2F11%2F17%2FUva(11324)(The-Largest-Clique)%2F</url>
    <content type="text"><![CDATA[链接：https://vjudge.net/problem/UVA-11324思路：还是一道有向图的强连通分量+缩点+DAG动态规划问题，首先主要还是熟悉tarjan的强连通分量，双连通分量（点双，边双）的不同写法。这道题有所不同，缩点的时候还要统计每个强连通分量有多少个点，把点数作为权值在新图上进行DAG的动态规划，顺便补了一下DAG的动态规划的写法，如果不清楚tarjan写法的可以看我其他几篇tarjan的题的博客，有详解代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include&lt;cstdio&gt;#include&lt;deque&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;#include&lt;cstring&gt;using namespace std;int t,n,m;const int maxn = 1001;vector&lt;int&gt; G[maxn];int dfn[maxn],low[maxn],dp[maxn],sccno[maxn],scount[maxn];int ntime,scc_cnt;deque&lt;int&gt; qq;int NG[maxn][maxn];void tarjan(int u)&#123; dfn[u] = low[u] = ++ntime; qq.push_back(u); for(int i=0;i&lt;G[u].size();i++)&#123; int v =G[u][i]; if(!dfn[v])&#123; tarjan(v); low[u] = min(low[u],low[v]); &#125; else if(!sccno[v])&#123; low[u] = min(low[u],dfn[v]); &#125; &#125; if(low[u]==dfn[u])&#123; scc_cnt++; int tmp; do&#123; tmp = qq.back(); qq.pop_back(); sccno[tmp] = scc_cnt; scount[scc_cnt]++; //统计每个强连通分量点的个数 &#125;while(tmp!=u); &#125;&#125;void find_scc(int n)&#123; memset(sccno,0,sizeof(sccno)); memset(dfn,0,sizeof(dfn)); memset(scount,0,sizeof(scount)); ntime = scc_cnt = 0; for(int i=0;i&lt;n;++i)if(!dfn[i])tarjan(i);&#125;//DAG上的动态规划int dfs(int x)&#123; if(dp[x])return dp[x]; dp[x] = scount[x];//记得要在这里赋值，不然最后一个点的权值没法读入for(int v=1;v&lt;=scc_cnt;v++)&#123; if(NG[x][v]!=0)&#123; dp[x] = max(dp[x],scount[x]+dfs(v)); &#125;&#125;return dp[x];&#125;int main()&#123; //freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin); //freopen(&quot;out.txt&quot;,&quot;w&quot;,stdout); scanf(&quot;%d&quot;,&amp;t); while(t--)&#123; memset(dp,0,sizeof(dp)); memset(NG,0,sizeof(NG)); for(int i=0;i&lt;n;i++)G[i].clear(); scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=0;i&lt;m;i++)&#123; int a,b; scanf(&quot;%d%d&quot;,&amp;a,&amp;b); a--; b--; G[a].push_back(b); &#125; find_scc(n); for(int i=0;i&lt;n;i++)&#123; for(int j=0;j&lt;G[i].size();j++)&#123; int v = G[i][j]; if(sccno[i]!=sccno[v])&#123; NG[sccno[i]][sccno[v]] = 1;//构建新图 &#125; &#125; &#125; int res = 0; for(int i=1;i&lt;=scc_cnt;i++)&#123; res = max(res,dfs(i));//每个点作为起点进行dp，最后取最大值 &#125; printf(&quot;%d\n&quot;,res); &#125; return 0;&#125;]]></content>
      <categories>
        <category>tarjan强连通分量</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Uva(11300)(Spreading-the-Wealth)]]></title>
    <url>%2F2018%2F11%2F17%2FUva(11300)(Spreading-the-Wealth)%2F</url>
    <content type="text"><![CDATA[链接：https://vjudge.net/problem/UVA-11300思路：一道很巧妙的数学思路的贪心题，设xi为i到i-1的金币传递数量，可以推导出如下结论：代码：12345678910111213141516171819202122232425262728293031323334353637#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;int n;int a[1000001];int main()&#123; while(~scanf("%d",&amp;n))&#123; if(n==0)&#123; printf("0\n"); continue; &#125;long long sum = 0; for(int i=0;i&lt;n;++i)&#123; scanf("%d",&amp;a[i]);sum+=a[i];&#125;sum/=n;for(int i=0;i&lt;n;i++)&#123; a[i]=sum-a[i];&#125;long long s;for(int i=1;i&lt;n-1;i++)&#123; a[i]+=a[i-1]; // printf("%d\n",a[i]);&#125;a[n-1] = 0;sort(a,a+n);s=a[n/2];long long res = 0;for(int i=0;i&lt;n;++i)&#123; res+=labs(a[i]-s);&#125;printf("%lld\n",res); &#125; return 0;&#125;]]></content>
      <categories>
        <category>贪心</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Uva(11294)(Wedding)]]></title>
    <url>%2F2018%2F11%2F17%2FUva(11294)(Wedding)%2F</url>
    <content type="text"><![CDATA[链接：https://vjudge.net/problem/UVA-11294思路：再一次深刻领悟到了2-SAT的一些东西，这个题首先要合点，把夫妇（或者说新郎新娘）变为一个点的两个状态，即一个凳子上要吗只坐新郎要吗只坐新娘，就可以变为2-SAT的模型，然后按照序号依次查看其mark[2*i]的值判断坐的是新郎还是新娘，最后输出即可，特别坑的地方就是要注意起始状态是0号的新娘，而不是说0号新郎新娘都可以，有两种办法，要吗mark[0]标为1，要吗从i=2开始进行2-SAT算法运行。代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;deque&gt;using namespace std;const int maxn = 50003;int n,m;struct twosat&#123;vector&lt;int&gt; G[maxn];int n;bool mark[maxn*2];int S[maxn*2];int c;bool dfs(int x)&#123; if(mark[x^1])return false; if(mark[x])return true; mark[x] = true; S[c++] = x; for(int i=0;i&lt;G[x].size();i++) if(!dfs(G[x][i]))return false; return true;&#125; void init(int n)&#123; this-&gt;n = n; for(int i=0;i&lt;n*2;i++)G[i].clear(); memset(mark,0,sizeof(mark)); mark[0]= 1;&#125;void add_clause(int x,int xval,int y,int yval)&#123; x = x*2+xval; y = y*2+yval; G[x^1].push_back(y); G[y^1].push_back(x);&#125;bool solve()&#123; for(int i=0;i&lt;n*2;i+=2)&#123; if(!mark[i]&amp;&amp;!mark[i+1])&#123; c = 0; if(!dfs(i))&#123; while(c&gt;0)mark[S[--c]] = false; if(!dfs(i+1))return false; &#125; &#125; &#125; return true;&#125;&#125;;twosat solver;int main()&#123; freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin); freopen(&quot;out.txt&quot;,&quot;w&quot;,stdout); while(scanf(&quot;%d%d&quot;,&amp;n,&amp;m)!=EOF)&#123; solver.init(n); for(int i=0;i&lt;m;i++)&#123; int now1,now2; char str1,str2; scanf(&quot;%d%c %d%c&quot;,&amp;now1,&amp;str1,&amp;now2,&amp;str2); int sex1,sex2; if(str1==&apos;h&apos;)sex1 = 1; else sex1 = 0; if(str2==&apos;h&apos;)sex2 = 1; else sex2 = 0; solver.add_clause(now1,sex1,now2,sex2); &#125; if(!solver.solve())printf(&quot;bad luck\n&quot;); else&#123; for(int i=1;i&lt;n;i++)&#123; if(i!=1)printf(&quot; &quot;); printf(&quot;%d%c&quot;,i,solver.mark[2*i]?&apos;w&apos;:&apos;h&apos;); &#125; printf(&quot;\n&quot;); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>2-SAT</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Uva(11038)(How-Many-O's--)]]></title>
    <url>%2F2018%2F11%2F17%2FUva(11038)(How-Many-O's--)%2F</url>
    <content type="text"><![CDATA[链接：https://vjudge.net/problem/UVA-11038思路：虽然最后代码非常短，但是我觉得里面蕴含的巧妙的思想远远不止这些，首先算0个数肯定不能硬来，也不太好分区间算容易产生重叠，正解的方法是枚举原数的各个位置的数字，如果不为0，则该位前面的数字pow （10，后面数字个数）就是当前位为0的方案总数（例如12139，枚举第三位为0，方案书为12100），如果为0，则需要（前面-1）pow （10，后面数字个数）+后面+1（例如12039，当枚举第三位时，此时的个位为前面的11种后面的100种+39+1），这时最妙的来了，这样不会重叠或者说不是根本没有计算0有多少个吗，我们枚举的是当前为0的数的个数，试想一个数有很多个0，那么他的每个位置都会被枚举一次，从而这个数会被计算他0的个数那么多次，刚好就是我们要算的一共有多少0，这个实在是太妙了！！！！代码：123456789101112131415161718192021222324#include&lt;bits/stdc++.h&gt;using namespace std;long long n,m;long long num(long long x)&#123;long long res = 1,ans = 0,xx=1; if(x&lt;0)return 0; while(x&gt;=10)&#123; long long mid = x%10; x/=10; if(mid)res+=x*xx; else res+=(x-1)*xx+(ans+1); ans = ans+mid*xx; xx*=10; &#125; return res;&#125;int main()&#123; while(scanf(&quot;%lld%lld&quot;,&amp;n,&amp;m)&amp;&amp;n!=-1)&#123; printf(&quot;%lld\n&quot;,num(m)-num(n-1)); &#125; return 0;&#125;]]></content>
      <categories>
        <category>数论</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Uva(11019)(Matrix-Matcher)]]></title>
    <url>%2F2018%2F11%2F17%2FUva(11019)(Matrix-Matcher)%2F</url>
    <content type="text"><![CDATA[链接：https://vjudge.net/problem/UVA-11019思路：我们需要改造一下就可以变成一个自动机的题目，我们把需要查找的矩阵按行拆成母串，然后构成一个trie图，用val记录他在原矩阵中的行数，然后将大的那个矩阵拆分成行依次进行匹配，当匹配成功就将对应的矩阵左上角顶点的值++，当某一个点的值等于小矩阵的行数的时候，就说明找到了一个矩阵。注意事项：做自动机时一定要考虑到母串可能重叠覆盖的问题，对于本题可以将val改造成一个vector，记录每个的对应行数，还有一个就是注意内存问题，自动机的题很容易超内存！代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116#include&lt;bits/stdc++.h&gt;using namespace std;const int maxnode = 1e6+10;const int sigma_size = 26;int t,n,m,x,y;char str1[1010][1010];char str2[1010][1010];struct AC&#123; int ch[maxnode][sigma_size]; int num[1010][1010]; int sz; vector&lt;int&gt; val[maxnode]; int f[maxnode]; void init()&#123; sz = 1; memset(ch[0],0,sizeof(ch[0])); memset(num,0,sizeof(num)); val[0].clear(); &#125; inline int idx(char c)&#123; return c-'a'; &#125; void insert(char *s,int r)&#123; int u=0; int n = strlen(s); for(int i=0;i&lt;n;i++)&#123; int c = idx(s[i]); if(!ch[u][c])&#123; memset(ch[sz],0,sizeof(ch[sz])); val[sz].clear(); ch[u][c] = sz++; &#125; u = ch[u][c]; &#125; val[u].push_back(r); &#125; void getfail()&#123; queue&lt;int&gt; q; f[0] = 0; for(int c=0;c&lt;sigma_size;c++)&#123; int u = ch[0][c]; if(u)&#123; f[u] = 0; q.push(u); &#125; &#125; while(!q.empty())&#123; int r = q.front(); q.pop(); for(int c=0;c&lt;sigma_size;c++)&#123; int u = ch[r][c]; if(!u)&#123; ch[r][c] = ch[f[r]][c]; continue; &#125; q.push(u); int v = f[r]; while(v&amp;&amp;!ch[v][c])v = f[v]; f[u] = ch[v][c]; &#125; &#125; &#125; void print(int i,int j,int k)&#123; // printf("%d %d\n",i,j); if(i-k+1&gt;0&amp;&amp;j-y+1&gt;0) num[i-k+1][j-y+1]++;//对应的矩阵的左上角的顶点值++ &#125; void find(char *s,int r)&#123; int n = strlen(s); int j = 0; for(int i=0;i&lt;n;i++)&#123; int c = idx(s[i]); j = ch[j][c]; if(val[j].size())&#123; for(int p=0;p&lt;val[j].size();p++) print(r,i+1,val[j][p]); &#125; &#125; &#125;&#125;solver;int main()&#123; scanf("%d",&amp;t); while(t--)&#123; solver.init(); scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++)&#123; scanf("%s",str1[i]); &#125; scanf("%d%d",&amp;x,&amp;y); for(int i=1;i&lt;=x;i++)&#123; scanf("%s",str2[i]); solver.insert(str2[i],i); &#125; solver.getfail(); for(int i=1;i&lt;=n;i++)&#123; solver.find(str1[i],i); &#125; int ans = 0; for(int i=1;i&lt;=n;i++)&#123; for(int j=1;j&lt;=m;j++)&#123; if(solver.num[i][j]==x)ans++; &#125; &#125; printf("%d\n",ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>AC自动机</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Uva(10891)(Game-of-Sum)]]></title>
    <url>%2F2018%2F11%2F17%2FUva(10891)(Game-of-Sum)%2F</url>
    <content type="text"><![CDATA[链接：https://vjudge.net/problem/UVA-10891思路：其实我一开始没有看出来这是一个动态规划的题目，不过我们可以来思考一下，设d(i,j)为先手所能取得的最好的最大的分差，那么我们怎么表示这个d(i,j)呢，我们知道，总和是一定的，你取了多少分，马上可以算出对手取了多少分，那么d(i,j)就可以i表示为sum(i,j)-min(d(i+1,j),d(i+2,j)…….d(i,j-1),d(i,j-2)…..d(i,i+1),0)(注意0表示对手决策用完，即我一把把所有的都全部抓完，对手从而没有东西可以抓了，这种情况一定不要漏掉！！！)，然后用dd[][]保存已经计算出的值，记忆式搜索求出答案。代码：12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;int n,sum[101][101],a[101],dd[101][101];int d(int i,int j)&#123; if(dd[i][j]!=0)return dd[i][j];//保存已经搜索出的值 if(i==j)return a[i]; int minn = 0;//一把抓完所有的//取最小值 for(int k=i+1;k&lt;=j;k++)&#123; minn = min(minn,d(k,j)); &#125; for(int k=j-1;k&gt;=i;k--)&#123; minn = min(minn,d(i,k)); &#125; dd[i][j] = sum[i][j] - minn;//保存当前最优解 return dd[i][j];//返回最优解&#125;int main()&#123;// freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin);// freopen(&quot;out.txt&quot;,&quot;w&quot;,stdout); while(cin&gt;&gt;n&amp;&amp;n)&#123; memset(sum,0,sizeof(sum)); memset(dd,0,sizeof(dd)); for(int i=1;i&lt;=n;i++)cin&gt;&gt;a[i]; for(int i=1;i&lt;=n;i++)&#123; for(int j=i;j&lt;=n;j++)&#123; for(int k=i;k&lt;=j;k++)&#123; sum[i][j]+=a[k]; &#125; &#125; &#125; cout&lt;&lt;2*d(1,n)-sum[1][n]&lt;&lt;endl;//结果等于d(i,j)-(sum(i,j)-d(i,j))，即原式 &#125; return 0;&#125; 老刘的o（n^2）解法暂时没看懂,先放这里吧]]></content>
      <categories>
        <category>基础dp</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Uva(10881)(Piotr's-Ants)]]></title>
    <url>%2F2018%2F11%2F17%2FUva(10881)(Piotr's-Ants)%2F</url>
    <content type="text"><![CDATA[链接：https://vjudge.net/problem/UVA-10881思路：这个题之前做过类似，不过这个更复杂。首先，蚂蚁碰撞并掉头可以等效看为他们擦肩然后继续前进，但是这样会打乱顺序，因为题目要求按照输入顺序输出对应的蚂蚁，我们注意到，由于有掉头存在，所以所有蚂蚁从左到右的相对顺序是不会变的，由于初始输入不一定是按照从左到右输入的，我们需要给蚂蚁一个编号，然后从左到右排序，用一个数组记录j对应id的蚂蚁从左到右排在第几个，然后用等效擦肩进行计算，最后再排序，最后用j还原顺序，输出各个蚂蚁的情况。代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;map&gt;using namespace std;struct ants&#123;int ss;char turn; int id;bool operator&lt;(const ants&amp;a1)&#123; return ss&lt;a1.ss;&#125;&#125;a[10001];;int j[10001];int main()&#123; //freopen("in.txt","r",stdin); //freopen("out.txt","w",stdout); int tt,l,t,n; char s[20]; int o = 0; scanf("%d",&amp;tt); while(tt--)&#123; printf("Case #%d:\n",++o); scanf("%d%d%d",&amp;l,&amp;t,&amp;n); map&lt;int,int&gt; jj;//记录某个位置有多少个蚂蚁最后存在，从而判断是否在turning for(int i=0;i&lt;n;++i)&#123; scanf("%d%s",&amp;a[i].ss,s); a[i].id = i; if(s[0]=='L')a[i].turn = 'L'; else a[i].turn = 'R'; &#125; sort(a,a+n); for(int i=0;i&lt;n;i++)&#123; j[a[i].id] = i;//编号与位置的对应 &#125; for(int i=0;i&lt;n;++i)&#123; if(a[i].turn=='L')a[i].ss-=t; if(a[i].turn=='R') a[i].ss+=t; &#125; sort(a,a+n); for(int i=0;i&lt;n;i++)&#123; jj[a[i].ss]++; &#125; for(int i=0;i&lt;n;i++)&#123; if(a[j[i]].ss&lt;0)printf("Fell off\n"); else if(a[j[i]].ss&gt;l)printf("Fell off\n"); else&#123; printf("%d ",a[j[i]].ss); if(jj[a[j[i]].ss]&gt;1)printf("Turning\n"); else printf("%c\n",a[j[i]].turn); &#125; &#125; printf("\n"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>贪心</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Uva(10859)(Placing-Lampposts-)]]></title>
    <url>%2F2018%2F11%2F17%2FUva(10859)(Placing-Lampposts-)%2F</url>
    <content type="text"><![CDATA[链接：https://vjudge.net/problem/UVA-10859思路：还是一开始一点思路都没有啊，找不到状态转移，看了老刘的思路突然就感觉很清晰，这就是差距吧。到一个点有两种决策，放或者不放，如果不放必须是父节点有灯或者它本身为根节点（因为根节点不放的话他的子节点就一定会放，所以不存在照不到的情况），那么我们就用i表示当前节点，j表示父节点是否放灯，f表示他的父节点，那么先看能否不放，如果能遍历一遍他的子节点然后算出总和（这里注意可以让放一盏灯的权重高一点，按照老刘的书为2000，这样又可以记录下被两个灯都照到的路的数量，一举两得），然后再算放灯，遍历一遍然后算出总和，比较两个总和的大小取小的一个即可。注意要用一个vis数组记录当前状态是否已经查看过，用一个dp数组记录这个状态的值避免重复计算！代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;vector&gt;using namespace std;int t,n,m,a,b;vector&lt;int&gt; G[1010];int vis[1010][2],dp[1001][2];int dfs(int i,int j,int f)&#123; if(vis[i][j])return dp[i][j];//如果查看过，则返回值避免重复计算 vis[i][j] = 1; int&amp; ans = dp[i][j];//引用 ans = 2000;//一盏灯权重为2000for(int k=0;k&lt;G[i].size();k++) if(G[i][k]!=f)&#123; ans+=dfs(G[i][k],1,i); &#125; if(!j&amp;&amp;f&gt;=0) ans++;//如果父节点存在并且点灯，则有两灯照的道路+1 if(j||f&lt;0)&#123;//如果为根节点或者父节点已经点灯 int sum = 0; for(int k=0;k&lt;G[i].size();k++) if(G[i][k]!=f) sum+=dfs(G[i][k],0,i); if(f&gt;=0)sum++; ans = min(ans,sum);&#125;return ans;&#125;int main()&#123; scanf(&quot;%d&quot;,&amp;t); while(t--)&#123; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=0;i&lt;n;i++)G[i].clear(); for(int i=0;i&lt;m;i++)&#123; scanf(&quot;%d%d&quot;,&amp;a,&amp;b); G[a].push_back(b); G[b].push_back(a); &#125; memset(vis,0,sizeof(vis)); int ans = 0; for(int i=0;i&lt;n;i++)//因为图有可能不连通，所以必须全部遍历 if(!vis[i][0]) ans+=dfs(i,0,-1); printf(&quot;%d %d %d\n&quot;,ans/2000,m-ans%2000,ans%2000); &#125; return 0;&#125; 感叹一下差距真的大啊，再继续努力吧！！！]]></content>
      <categories>
        <category>树形dp</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Uva(10817)(Headmaster's-Headache)]]></title>
    <url>%2F2018%2F11%2F17%2FUva(10817)(Headmaster's-Headache)%2F</url>
    <content type="text"><![CDATA[链接：https://vjudge.net/problem/UVA-10817思路：有些日子没做dp了，上手做一个，一开始想的是用一个数来表示集合，后来发现拆为两个更方便一些，一个表示已经有一个老师的，一个表示有两个老师的，然后进行状态转移，对当前老师选或者不选，如果选的话更新集合状态，然后加上钱。本题坑点有点多，一个是输入，最好是用getline读入一行，然后用stringstream进行重定向。然后就是要注意位运算的优先级，以后所有位运算最好打上括号保证得到想要的顺序。代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;bits/stdc++.h&gt;using namespace std;int dp[1&lt;&lt;9][1&lt;&lt;9][130];vector&lt;int&gt; T[130];int money[130];int s,m,n; int dfs(int i,int j,int k)&#123; if(dp[i][j][k]&gt;=0)return dp[i][j][k]; if(i==((1&lt;&lt;s)-1)&amp;&amp;(j==(1&lt;&lt;s)-1))return 0; if(k==m+n)return 1e9; int &amp;res = dp[i][j][k]; int ii = i; int jj = j;//更新集合状态 for(int p=0;p&lt;T[k].size();p++)&#123; if((ii&amp;(1&lt;&lt;T[k][p]))&amp;&amp;((jj&amp;(1&lt;&lt;T[k][p]))==0))jj+=(1&lt;&lt;T[k][p]);//如果第一个已经有了老师，则更新第二个集合 else if((ii&amp;(1&lt;&lt;T[k][p]))==0)ii+=(1&lt;&lt;T[k][p]);//如果第一个没有则更新第一个 &#125; res=money[k] + dfs(ii,jj,k+1);//不选当前老师 int sum = dfs(i,j,k+1); res = min(res,sum); return res; &#125; string line;int main()&#123; while(getline(cin,line))&#123; stringstream ss(line); ss&gt;&gt;s&gt;&gt;m&gt;&gt;n; if(s==0)break; memset(dp,-1,sizeof(dp)); for(int i=0;i&lt;=m+n;i++)T[i].clear(); int now1 = 0; int now2 = 0; int res = 0; int num; for(int i=0;i&lt;m+n;i++)&#123; getline(cin,line); stringstream ss(line); ss&gt;&gt;money[i]; while(ss&gt;&gt;num)&#123; num--; T[i].push_back(num); if(i&lt;m)&#123; if(now1&amp;(1&lt;&lt;num)&amp;&amp;((now2&amp;(1&lt;&lt;num))==0)) now2+=(1&lt;&lt;(num)); else if((now1&amp;(1&lt;&lt;num))==0) now1+=(1&lt;&lt;(num)); &#125; &#125; if(i&lt;m)&#123; res+=money[i]; &#125;&#125; int ans = res + dfs(now1,now2,m); cout&lt;&lt;ans&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>状压dp</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Uva(10765)(Doves-and-bombs)]]></title>
    <url>%2F2018%2F11%2F17%2FUva(10765)(Doves-and-bombs)%2F</url>
    <content type="text"><![CDATA[链接：https://vjudge.net/problem/UVA-10765思路：本质上还是个求双连通分量的问题，因为是点双，所以每个割点所属的双连通分量是不确定的，如何判断缩点后一个点周围的双连通分量个数就成了一直卡住我的问题，后来发现其实特别简单，只需要在tarjan算法弹出双连通分量是用一个数组每次+1即可！！！！，因为每次求出新连通块是在割点的基础上做的tarjan算法。砍点后的连通块个数分情况讨论：若为割点则为他周围不同的双连通分量的个数，若不为割点则还是为一个连通块。代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106 #include&lt;cstdio&gt;#include&lt;deque&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;using namespace std;const int maxn = 10001;struct sta&#123; int id,num;&#125;res[maxn];vector&lt;int&gt; G[maxn],bcc[maxn];int iscut[maxn],io[maxn],dfn[maxn],low[maxn],bccno[maxn];int n,m,ntime,bcc_cnt;struct edge&#123; int u,v; edge()&#123;&#125; edge(int uu,int vv):u(uu),v(vv)&#123;&#125;&#125;;deque&lt;edge&gt; edges;void tarjan(int u,int f)&#123; dfn[u] = low[u] = ++ntime; int child = 0; for(int i=0;i&lt;G[u].size();i++)&#123; int v = G[u][i]; if(!dfn[v])&#123; child++; edges.push_back(edge(u,v)); tarjan(v,u); low[u] = min(low[u],low[v]); if(dfn[u]&lt;=low[v])&#123; io[u]++;//只需在此处多一步更新即可！！！ edge tmp; iscut[u] = 1; bcc_cnt++; bcc[bcc_cnt].clear(); do&#123; tmp = edges.back(); edges.pop_back(); if(bccno[tmp.u]!=bcc_cnt)&#123; bcc[bcc_cnt].push_back(tmp.u); bccno[tmp.u] = bcc_cnt; &#125; if(bccno[tmp.v]!=bcc_cnt)&#123; bcc[bcc_cnt].push_back(tmp.v); bccno[tmp.v] = bcc_cnt; &#125; &#125;while(!(tmp.u==u&amp;&amp;tmp.v==v)); &#125; &#125; else if(dfn[v]&lt;dfn[u]&amp;&amp;v!=f)&#123; edges.push_back(edge(u,v)); low[u] = min(low[u],dfn[v]); &#125; &#125; if(f&lt;0&amp;&amp;child==1)iscut[u] = 0;&#125;void find_bcc(int n)&#123; memset(dfn,0,sizeof(dfn)); memset(iscut,0,sizeof(iscut)); memset(bccno,0,sizeof(bccno)); ntime = bcc_cnt = 0; for(int i=0;i&lt;n;i++)if(!dfn[i])tarjan(i,-1);&#125;bool cmp(const sta &amp;q1,const sta &amp;q2)&#123; return q1.num&gt;q2.num||(q1.num==q2.num&amp;&amp;q1.id&lt;q2.id);&#125;int main()&#123; //freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin); //freopen(&quot;out.txt&quot;,&quot;w&quot;,stdout); while(scanf(&quot;%d%d&quot;,&amp;n,&amp;m)&amp;&amp;(n||m))&#123; for(int i=0;i&lt;n;i++)G[i].clear(); for(int i=0;i&lt;n;i++)io[i]= 1; while(1)&#123; int a,b; scanf(&quot;%d%d&quot;,&amp;a,&amp;b); if(a&lt;0||b&lt;0)break; G[a].push_back(b); G[b].push_back(a); &#125; find_bcc(n); for(int i=0;i&lt;n;i++)&#123; res[i].id = i; if(!iscut[i])res[i].num = 1; else&#123; res[i].num = io[i]; &#125; &#125; sort(res,res+n,cmp); for(int i=0;i&lt;m;i++)&#123; printf(&quot;%d %d\n&quot;,res[i].id,res[i].num); &#125; printf(&quot;\n&quot;); &#125; return 0;&#125;]]></content>
      <categories>
        <category>基础dp</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Uva(10635)(Prince-and-Princess)]]></title>
    <url>%2F2018%2F11%2F17%2FUva(10635)(Prince-and-Princess)%2F</url>
    <content type="text"><![CDATA[链接：https://vjudge.net/problem/UVA-10635#author=0思路：一开始用的是最普通的最长公共子序列去做，看错了范围（以为是p，q都小于250），结果是小于250*250，如果用二维数组明显会超内存。然后就不会做了，看了题解发现可以转换为最长上升子序列的问题（LIS），真的强啊这种转化，顺便学习了nlogn复杂度的上升子序列写法。复制一下：（感谢原博主 https://blog.csdn.net/u014800748/article/details/45749991）考虑这样一个事实，给定两个下标a,b(注意，这里a,b大小未知)，如果它们满足Aamax{a,b},a并不会比b差。另外，如果b满足Ab&lt;Ai，那么对于a也满足这个性质，且二者的d值相同。但是，如果Aa&lt;Ai，却不一定有Ab&lt;Ai。 通过以上的事实，我们发现，对于某一个d’值，只要保留最小的那个Aa，使得d(a)==d‘即可。我们用g(i)表示d值为i的最小状态的编号（即i对应的最小的那个Aa，如果不存在设置为INF）。根据以上的推理有如下不等式： g(1)≤g(2)≤g(3)≤…≤g(n) 注意，上述的g(i)是会动态改变的。对于一个给定的状态i，我们只考虑在i之前已经计算过的状态j(即j&lt;i)，上述的g值也是基于这些状态而改变的。随着i的增大，我们要考虑的状态也越来越多，g也随之发生改变。在给定状态i时，可以用二分查找得到满足g(k)≥Ai的第一个下标k（实际上是要找g(k’)&lt;Ai的最后一个下标k’,则d(i)=k’+1,令k=k’+1即可得到，这里用lower_bound省略了k’+1的操作）,则d(i)=k，此时Ai&lt;g(k).而d(i)=k，所以更新g(k)=Ai（此时正是利用了上述的事实！虽然这里的g(k)在变小，但仍然大于等于g(k-1)，满足上述的不等式）。 附录：ologn最长上升子序列写法int ans = 0; for(int i=1;i&lt;=x;i++) g[i] = INF; for(int i=0;i&lt;x;i++){ int k = lower_bound(g+1,g+x+1,s[i])-g;//查找第一个大于等于s[i]值的下标 d[i] = k; //更新前i个数最大上升子序列的值 g[k] = s[i]; //更新最后一位的值ans = max(ans,d[i]);// 更新一下之前有误，需要用一个ans记录最长的序列的长度 } 代码：12345678910111213141516171819202122232425262728293031323334353637#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;int t,k1,k2,n,p,o=0;int num[63000],s[63000],d[63000],g[63000];int main()&#123; //freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin); //freopen(&quot;out.txt&quot;,&quot;w&quot;,stdout); scanf(&quot;%d&quot;,&amp;t); while(t--)&#123; memset(num,0,sizeof(num)); scanf(&quot;%d%d%d&quot;,&amp;n,&amp;k1,&amp;k2); k1++; k2++; for(int i=1;i&lt;=k1;i++)&#123; scanf(&quot;%d&quot;,&amp;p); num[p] = i; //给原序列编号 &#125; int x= 0; for(int i=0;i&lt;k2;i++)&#123; scanf(&quot;%d&quot;,&amp;p); if(num[p])s[x++] = num[p];//将数字转化为第一个序列里的编号，即可转化为最长上升子序列问题 &#125;int ans = 0; for(int i=1;i&lt;=x;i++)g[i] = 1e9;//g[i]代表长度为i的子序列最后一位的值 for(int i=0;i&lt;x;i++)&#123; int k = lower_bound(g+1,g+x+1,s[i])-g;//查找第一个大于等于s[i]值的下标 d[i] = k; //更新前i个数最大上升子序列的值 g[k] = s[i]; //更新最后一位的值ans = max(ans,d[i]); &#125; printf(&quot;Case %d: %d\n&quot;,++o,ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>基础dp</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Uva(10564)(Paths-through-the-Hourglass)]]></title>
    <url>%2F2018%2F11%2F17%2FUva(10564)(Paths-through-the-Hourglass)%2F</url>
    <content type="text"><![CDATA[链接：https://vjudge.net/problem/UVA-10564思路：dp题，有点像数字三角形，但是因为要涉及路径输出我们不能把它拆为两个来做，还是直接记忆式搜索吧，以n为边界，上下采取不同的状态转移方程。。记住记忆式搜索不要用dp数组的值是否为0来判断是否查询过，因为本题很多点都为0（表示无解），养成好习惯用vis来判重，我就是这种不好习惯导致这道题一开始tl了。然后枚举第一排所有起点，第一个找到的解一定是题目要求最优的！代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;string&gt;using namespace std;int a[51][51];long long dp[51][51][501];int vis[51][51][501];int n,s,cnt,id;string ress;long long dfs(int i,int j,int k,string path)&#123;if(dp[i][j][k]||vis[i][j][k])return dp[i][j][k];vis[i][j][k] = 1;if(k&lt;0||i&gt;2*n)return 0;if(i==2*n&amp;&amp;k==0)&#123; if(id==-1)id=cnt,ress = path; return 1;&#125;long long &amp;sum = dp[i][j][k];//上半区的状态转移if(i&lt;n)&#123; if(a[i+1][j-1]!=-1)sum+=dfs(i+1,j-1,k-a[i][j],path+&apos;L&apos;); if(a[i+1][j]!=-1)sum+=dfs(i+1,j,k-a[i][j],path+&apos;R&apos;);&#125;//下半区的状态转移else &#123; if(i+1==2*n)sum+=dfs(i+1,j,k-a[i][j],path);//需要单独判断 else if(a[i+1][j]!=-1)sum+=dfs(i+1,j,k-a[i][j],path+&apos;L&apos;); if(a[i+1][j+1]!=-1)sum+=dfs(i+1,j+1,k-a[i][j],path+&apos;R&apos;);&#125;return sum;&#125;int main()&#123; while(~scanf(&quot;%d%d&quot;,&amp;n,&amp;s)&amp;&amp;(n||s))&#123; memset(dp,0,sizeof(dp)); memset(vis,0,sizeof(vis)); memset(a,-1,sizeof(a)); ress = &quot;&quot;;//一定要注意输入的数据在数组中的位置！！！ for(int i=1;i&lt;=n;i++)&#123; for(int j=1;j&lt;=n-i+1;j++)&#123; scanf(&quot;%d&quot;,&amp;a[i][j]); &#125; &#125; for(int i=n+1;i&lt;2*n;i++)&#123; for(int j=1;j&lt;=i-n+1;j++)&#123; scanf(&quot;%d&quot;,&amp;a[i][j]); &#125; &#125; long long res = 0; cnt = 0; id = -1; for(int j=1;j&lt;=n;j++,cnt++)&#123; res+=dfs(1,j,s,&quot;&quot;); &#125; if(res)printf(&quot;%lld\n%d %s\n&quot;,res,id,ress.c_str()); else printf(&quot;0\n\n&quot;);&#125; return 0;&#125;]]></content>
      <categories>
        <category>基础dp</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Uva(10534)(waviosequence)]]></title>
    <url>%2F2018%2F11%2F17%2FUva(10534)(waviosequence)%2F</url>
    <content type="text"><![CDATA[链接：https://vjudge.net/problem/UVA-10534思路：这可以转换为一个最长上升子序列的问题，一开始我先枚举的终点再算，复杂度是o(n^2logn)，后来发现子序列的值算一遍就可以了，可以先算然后再枚举，复杂度就是o(nlogn)了，注意这个题因为上升子序列终点和下降子序列的起点必须是相同的，所以不用记录用一个ans去记录最长子序列的最大值，直接枚举终点（起点）即可，也不用判断子序列长度是否相等，直接取最小的那一个拿去更新最大值即可，因为大的那一个可以扔掉一些元素标为小的那个的长度。代码：12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;int n;int a[10001],b[10001];int f1[10001],f2[10001],g1[10001],g2[10001];int main()&#123; //freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin); //freopen(&quot;out.txt&quot;,&quot;w&quot;,stdout); while(~scanf(&quot;%d&quot;,&amp;n))&#123; for(int i=0;i&lt;n;++i)&#123; scanf(&quot;%d&quot;,&amp;a[i]); b[n-i-1] = a[i];//反向就变成最长上升子序列了 &#125; int res = 0; memset(f1,0,sizeof(f1)); memset(f2,0,sizeof(f2)); for(int m=1;m&lt;=n;m++)&#123; g1[m] = 1e9; g2[m] = 1e9; &#125;//算出正反的最长上升子序列for(int j=0;j&lt;n;j++)&#123; int k1 = lower_bound(g1+1,g1+1+n,a[j])-g1; f1[j] = k1; g1[k1] = a[j];&#125;for(int k=0;k&lt;n;k++)&#123; int k2 = lower_bound(g2+1,g2+1+n,b[k])-g2; f2[k] = k2; g2[k2] = b[k];&#125;//枚举终点(起点)并更新最大值for(int i=0;i&lt;n;i++)&#123; res = max(res,min(f1[i],f2[n-i-1]));&#125; printf(&quot;%d\n&quot;,2*res-1); &#125; return 0;&#125;]]></content>
      <categories>
        <category>基础dp</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Uva(10269)(Adventure-of-Super-Mario-)]]></title>
    <url>%2F2018%2F11%2F17%2FUva(10269)(Adventure-of-Super-Mario-)%2F</url>
    <content type="text"><![CDATA[链接：https://vjudge.net/problem/UVA-10269思路：不得不说自己真的菜，不等号打反了看了大半个小时，这个题首先要用flyod预处理，中间有城堡的就不进行处理，保证处理后的最短路上都可以用魔法鞋，然后用dijstkra进行最短路，将d变二维进行dp即可，floyd预处理要学会！！！代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;cstring&gt;using namespace std;const int INF = 1&lt;&lt;30;int dp[101][11];int t,a,b,l,m,k;int G[105][105];struct P&#123;int second, used; P()&#123;&#125; P(int s,int u):second(s),used(u)&#123;&#125;&#125;;void dijstkra()&#123; for(int i=0;i&lt;a+b;i++)&#123; for(int j=0;j&lt;=k;j++)&#123; dp[i][j] = INF; &#125; &#125; queue&lt;P&gt; qq; qq.push(P(a+b-1,k)); dp[a+b-1][k] = 0; while(!qq.empty())&#123; P p = qq.front(); qq.pop(); int u = p.second; int k1 = p.used; for(int v=0;v&lt;a+b;v++)&#123; if(G[u][v]==INF||u==v)continue; //不用魔法鞋 if(dp[v][k1]&gt;dp[u][k1]+G[u][v])&#123; dp[v][k1] = dp[u][k1] + G[u][v]; qq.push(P(v,k1)); &#125; //满足条件用魔法鞋 if(G[u][v]&lt;=m&amp;&amp;k1&gt;0&amp;&amp;dp[v][k1-1]&gt;dp[u][k1])&#123; dp[v][k1-1] = dp[u][k1]; qq.push(P(v,k1-1)); &#125; &#125; &#125; &#125;int main()&#123; scanf(&quot;%d&quot;,&amp;t); while(t--)&#123; scanf(&quot;%d%d%d%d%d&quot;,&amp;a,&amp;b,&amp;l,&amp;m,&amp;k); for(int i=0;i&lt;a+b;i++) for(int j=0;j&lt;a+b;j++)G[i][j] = INF; for(int i=0;i&lt;l;i++)&#123; int e,f,g; scanf(&quot;%d%d%d&quot;,&amp;e,&amp;f,&amp;g); e--; f--; G[e][f] = G[f][e] = min(G[e][f],g); &#125; for(int k=0;k&lt;a;k++)&#123; for(int i=0;i&lt;a+b;i++)&#123; for(int j=0;j&lt;a+b;j++)&#123; if(G[i][k]==INF||G[k][j]==INF)continue; G[i][j] = min(G[i][k]+G[k][j],G[i][j]); &#125; &#125; &#125; dijstraka(); int ans = INF; for(int i=0;i&lt;=k;i++)&#123; ans = min(ans,dp[0][i]); &#125; printf(&quot;%d\n&quot;,ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>最短路</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Uva(1513)(Movie-collection)]]></title>
    <url>%2F2018%2F11%2F17%2FUva(1513)(Movie-collection)%2F</url>
    <content type="text"><![CDATA[链接：https://vjudge.net/problem/UVA-1513思路：有几天没写了，今天来一个树状数组的。求一个盘子上面的盘子数目。首先我们要明白树状数组求的东西都要跟前缀有关，而盘子上面的数目正好就是前缀，恰好满足我们的条件，但是我们随即发现，抽出来之后还要将盘子放上面，我们是无法在树状数组的前端插入一个新值的，也不可能让整个数组移动，怎么办呢？我们想到只能在后端插值，那么此时前缀和的意义就变为了他下面盘子的数目，其实只需要用n减一下就可以转化为上面盘子的个数，将拿出位置的值设为0即可。需要把数组开大一点。代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e6;int c[maxn];int arr[maxn];int n,t,m;int lowbit(int x)&#123; return x&amp;(-x);&#125;void add(int x,int d)&#123; while(x&lt;m+n+1)&#123; c[x]+=d; x+=lowbit(x); &#125;&#125;int sum(int x)&#123; int res = 0; while(x)&#123; res+=c[x]; x-=lowbit(x); &#125; return res;&#125;int main()&#123; scanf(&quot;%d&quot;,&amp;t); while(t--)&#123; memset(c,0,sizeof(c)); scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1;i&lt;=n;i++)&#123; arr[i] = n-i+1; add(i,1); &#125; for(int j=1;j&lt;=m;j++)&#123; int now; scanf(&quot;%d&quot;,&amp;now); printf(&quot;%d%c&quot;,n-sum(arr[now]),j==m?&apos;\n&apos;:&apos; &apos;); add(arr[now],-1); arr[now] = j+n; add(j+n,1); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>树状数组</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Uva(1452)(Jump)]]></title>
    <url>%2F2018%2F11%2F17%2FUva(1452)(Jump)%2F</url>
    <content type="text"><![CDATA[链接：https://vjudge.net/problem/UVA-1452思路：约瑟夫环问题的变形，之前一直对约瑟夫环的递推没搞太懂，现在大概看懂了。约瑟夫环是可以分解成子问题，即如果现在有n人，出列一人后就变成n-1人的子问题，同时建立一个映射关系，而求最后一人的则是从1个人推回n人的情况。求最后三人的可以看作先求最后一人，然后把最后一人除去，变成n-1个人求最后一人，然后再除去，变成n-2个人求最后一人。附上约瑟夫环问题的递推公式：f（n） =（ f（n-1）+k）% n代码：12345678910111213141516171819202122232425#include&lt;iostream&gt;using namespace std;int t,n,k,ans1,ans2,ans3;int main()&#123; cin&gt;&gt;t; while(t--)&#123; cin&gt;&gt;n&gt;&gt;k; ans1 = 0; ans2 = (k-1)%2; ans3 = (k-1)%3; for(int i=2;i&lt;=n;i++)&#123; ans1 = (ans1+k)%i; &#125; for(int i=3;i&lt;=n;i++)&#123; ans2 = (ans2+k)%i; &#125; for(int i=4;i&lt;=n;i++)&#123; ans3 = (ans3+k)%i; &#125; cout&lt;&lt;ans3+1&lt;&lt;&quot; &quot;&lt;&lt;ans2+1&lt;&lt;&quot; &quot;&lt;&lt;ans1+1&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>约瑟夫环</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Uva(1437)(String-painter)]]></title>
    <url>%2F2018%2F11%2F17%2FUva(1437)(String-painter)%2F</url>
    <content type="text"><![CDATA[链接：https://vjudge.net/problem/UVA-1437思路：想了半天也没啥思路，总感觉贪心能错其实不太行，后来知道这是个区间dp的题，虽然对区间dp没太多了解，但是先把本题记录在这里回去慢慢理解吧。首先是对b串进行遍历，先假设总共刷b的长度那么多次，如果中间有两块相等（不管有没有间隔），总的刷次数就可以-1，这样先对b进行预处理，然后我们比对a和b，如果对应位置不等，那么就像等于从空的开始刷成b，就跟预处理所得到的需要的次数一样，如果相等，该位置就可以忽略，那么只用看前后两个子串需要的次数即可，这就是所谓的区间dp（做法是理解了，但是区间dp还是不太理解，慢慢领悟吧）代码：123456789101112131415161718192021222324252627282930313233#include&lt;bits/stdc++.h&gt;using namespace std;string a,b;const int maxn = 110;int dp[maxn][maxn];int ans[maxn];int main()&#123; while(cin&gt;&gt;a&gt;&gt;b)&#123; memset(dp,0,sizeof(dp)); memset(ans,0,sizeof(ans));//预处理b串 for(int j=0;j&lt;a.size();j++)&#123; for(int i=j;i&gt;=0;i--)&#123; dp[i][j] = dp[i+1][j]+1; for(int k=i+1;k&lt;=j;k++)&#123; if(b[i]==b[k]) dp[i][j] = min(dp[i][j],dp[i+1][k]+dp[k+1][j]); &#125; &#125; &#125; for(int i=0;i&lt;a.size();i++) ans[i] = dp[0][i]; for(int i=0;i&lt;a.size();i++)&#123; if(a[i]!=b[i])//不等则为预处理的结果 for(int j=0;j&lt;i;j++) ans[i] = min(ans[i],ans[j] + dp[j+1][i]); else ans[i] = ans[i-1];//相等则等于前一个子问题 &#125; cout&lt;&lt;ans[a.size()-1]&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>区间dp</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Uva(1428)(Ping-pong)]]></title>
    <url>%2F2018%2F11%2F17%2FUva(1428)(Ping-pong)%2F</url>
    <content type="text"><![CDATA[链接：https://vjudge.net/problem/UVA-1428思路：刚学树状数组，完全没有看出来这是一个树状数组的题，关键是要统计左边比他大和小的人数，这时候不应该用人来建立区间，而是应该用能力值去建立区间，然后每加入一个能力值就统计1-当前能力值-1的所有的和（即为比他小的人数和）。必须每加一个就统计算出当前的（不然后面加入后人数就发生了改变，就不是他左边的比他小的人数了），然后再从右往左算一次，最后用乘法原理求和即可，很妙但是感觉自己还没能完全理解这种转化思想，先写在这里慢慢领悟把。代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;bits/stdc++.h&gt;using namespace std;int t,n;const int maxn = 1e5+10;int c[maxn],l[maxn],r[maxn],a[maxn];int lowbit(int x)&#123; return x&amp;(-x);&#125;void add(int x,int d)&#123; while(x&lt;maxn)&#123; c[x]+=d;//c[x]表示当前x能力值的人数有多少。 x+=lowbit(x); &#125;&#125;int sum(int x)&#123; int res = 0; while(x&gt;0)&#123; res+=c[x]; x-=lowbit(x); &#125; return res;&#125;int main()&#123; //freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin); //freopen(&quot;out.txt&quot;,&quot;w&quot;,stdout); scanf(&quot;%d&quot;,&amp;t); while(t--)&#123; memset(c,0,sizeof(c)); scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;i++)&#123; scanf(&quot;%d&quot;,&amp;a[i]); add(a[i],1); l[i] = sum(a[i]-1);//统计当前左边的比他能力值小的人的总和 &#125; memset(c,0,sizeof(c)); for(int i=n;i&gt;=1;i--)&#123; add(a[i],1); r[i] = sum(a[i]-1);//统计当前右边的比他能力值笑的人的总和 &#125; long long ans = 0; for(int i=2;i&lt;=n;i++)&#123; ans+=l[i]*(n-i-r[i])+(i-l[i]-1)*r[i]; &#125; printf(&quot;%lld\n&quot;,ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>树状数组</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Uva(1427)(Parade)]]></title>
    <url>%2F2018%2F11%2F17%2FUva(1427)(Parade)%2F</url>
    <content type="text"><![CDATA[链接：https://vjudge.net/problem/UVA-1427思路：状态不难想，每上一层的一个点的最大值就等于下一层左右时间范围内各点过来的最大值，但是这样的话最坏情况有nm^2个状态需要枚举，肯定超时，肯定需要优化，而且优化的地方肯定是在枚举各点过来的地方，我们希望这个时间能在常数时间内完成，不妨设从左边过来，那么 dp[i-1][j] = dp[i][k]+sum[k][j]，继续变形一下就等于dp[i-1][j] = dp[i][k]+sum[j]-sum[k]，我们发现只跟最大值dp[i][k]-sum[k]有关，那么我们就可以把这一段用一个单调队列来维护，每次取队首元素就是最大值，当位置往右遍历时单调队列跟着变化，即可将复杂度降为O(nm)，这只是左边，右边类似，倒过来遍历一遍即可，只是要维护的变成了dp[i][k]+sum[k]，然后比较两种取最大值即可。注意学习单调队列的写法，这里单调队列最好是维护数组的下标，这样方便移动，不用再另外记录。代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;bits/stdc++.h&gt;using namespace std;int n,m,k;const int maxn = 110;const int maxm = 10010;int t[maxn][maxm];int dp[maxm];int sum[maxn][maxm];int q[maxm],d[maxm];int main()&#123; while(scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;k)&amp;&amp;n||m||k)&#123; memset(sum,0,sizeof(sum)); memset(t,0,sizeof(t)); for(int i=0;i&lt;=m;i++)dp[i] = 0; int tt; for(int i=1;i&lt;=n+1;i++)&#123; for(int j=1;j&lt;=m;j++)&#123; scanf(&quot;%d&quot;,&amp;tt); sum[i][j] = sum[i][j-1] + tt; &#125; &#125; for(int i=1;i&lt;=n+1;i++)&#123; for(int j=1;j&lt;=m;j++)&#123; scanf(&quot;%d&quot;,&amp;tt); t[i][j] = t[i][j-1] + tt; &#125; &#125; for(int i=n+1;i&gt;=1;i--)&#123; for(int j=0;j&lt;=m;j++)&#123; d[j] = dp[j]; &#125; int front = 0,rear = -1; for(int j=0;j&lt;=m;j++)&#123; tt = d[j] - sum[i][j]; while(front&lt;=rear&amp;&amp;tt&gt;=d[q[rear]]-sum[i][q[rear]])rear--; q[++rear] = j; while(front&lt;=rear&amp;&amp;t[i][j]-t[i][q[front]]&gt;k)front++; tt = d[q[front]] - sum[i][q[front]] + sum[i][j]; dp[j] = max(dp[j],tt); &#125; front = 0; rear = -1; for(int j=m;j&gt;=0;j--)&#123; tt = d[j] + sum[i][j]; while(front&lt;=rear&amp;&amp;tt&gt;=d[q[rear]]+sum[i][q[rear]])rear--; q[++rear] = j; while(front&lt;=rear&amp;&amp;t[i][q[front]]-t[i][j]&gt;k)front++; tt = d[q[front]] + sum[i][q[front]] - sum[i][j]; dp[j] = max(dp[j],tt); &#125; &#125; int ans = -1e9; for(int i=0;i&lt;=m;i++) ans = max(ans,dp[i]); printf(&quot;%d\n&quot;,ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>基础dp</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Uva(1422)(Processor)]]></title>
    <url>%2F2018%2F11%2F17%2FUva(1422)(Processor)%2F</url>
    <content type="text"><![CDATA[链接：https://vjudge.net/problem/UVA-1422思路：一开始以为是一道很普通的二分，后面发现没那么简单，因为区间可以重叠，所以要决策每个区间到底要完成哪个任务，然后开始枚举任务，结果反而不能得出正确的结论（如果每两个任务都要比较的话复杂度也会很高），最后看了题解，发现可以枚举时间，一共最多20000分钟，枚举时间即可，将任务按照起始时间进行排序，然后当时间大于等于任务的起始时间时就可以放入完成队列中，然后这一分钟完成的任务应该选择结束时间最早的来完成，如果还有剩余时间则继续完成下一个，否则就减去该分钟的完成量再入队即可，注意如果队首任务的完成时间大于当前枚举时间则返回false，因为这样贪心下来就确定不可能以速度d完成，二分枚举速度d即可（要学会二分+优先队列这种操作啊！！！！！！）代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;int t,n;struct work&#123; int s,e,w; bool operator&lt;(const work &amp;p)const&#123; return e&gt;p.e; &#125;&#125;a[10001];bool cmp(const work &amp;a1,const work &amp;a2)&#123; return a1.s&lt;a2.s||(a1.s==a2.s&amp;&amp;a1.e&lt;a2.e);&#125;bool c(int d)&#123; priority_queue&lt;work&gt; qq; work now; int i=0;for(int j=1;j&lt;=20000;j++)&#123;if(!qq.empty())&#123; now = qq.top(); if(now.e&lt;j)return false;//如果队首完成时间小于当前枚举时间，返回false&#125;while(i&lt;n&amp;&amp;a[i].s+1&lt;=j)&#123;//如果下一个任务开始时间小于当前枚举时间，则入队 qq.push(a[i++]);&#125;int sum = d;while(sum&amp;&amp;!qq.empty())&#123; now = qq.top(); qq.pop();//选择任务并在这一分钟完成 if(sum&lt;now.w)&#123; now.w-=sum; sum = 0; qq.push(now);//若还有剩余则再入队即可 &#125; else sum-=now.w; if(i==n&amp;&amp;qq.empty())return true;&#125;&#125;return false;&#125;int main()&#123; //freopen("in.txt","r",stdin); //freopen("out.txt","w",stdout); scanf("%d",&amp;t); while(t--)&#123; scanf("%d",&amp;n); for(int i=0;i&lt;n;++i)&#123; scanf("%d%d%d",&amp;a[i].s,&amp;a[i].e,&amp;a[i].w); &#125; sort(a,a+n,cmp);int lb = 1;int ub = 1e7;//二分枚举即可while(ub&gt;lb)&#123; int mid = (ub+lb)/2; if(c(mid))ub = mid; else lb = mid+1;&#125;printf("%d\n",ub); &#125; return 0;&#125;]]></content>
      <categories>
        <category>贪心</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Uva(1407)(Caves)]]></title>
    <url>%2F2018%2F11%2F17%2FUva(1407)(Caves)%2F</url>
    <content type="text"><![CDATA[链接：https://vjudge.net/problem/UVA-1407思路：树形dp，以前做过子节点与父节点有联系那种，而这种求最多多少个点的根本不会设计状态，看了题解，用dp[u][j][0/1]表示从u开始走j个节点需要走的最短距离，0/1表示最后在u点或者不在u点。首先为什么dp数组不保存点的个数呢，这样的话避免不了要判重，即哪些点走过，哪些没有。但这个图是无向图，且可以走回父节点，所以很难去设计判重的方法，而只好转换为距离最小值，然后比较与询问的q，找到比q的距离小中最大的那个对应的j就是答案，状态转移的话，如果最后在u的话，则沿途所有的边都要走两次，只有一种状态转移，如果不在的话则要考虑两种情况，一种是走其他子树回了u点，这一个子树可以不用回，另一种是这个子树要回，其他子树可以不用回= =代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 510;int dp[maxn][maxn][2],d[maxn],tot[maxn],n;vector&lt;int&gt; G[maxn];void dfs(int u)&#123; tot[u] = 1; for(int i=0;i&lt;G[u].size();i++)&#123; int v = G[u][i]; dfs(v); tot[u]+=tot[v]; &#125; dp[u][1][0] = dp[u][1][1] = 0; for(int i=2;i&lt;=tot[u];i++)&#123; dp[u][i][0] = dp[u][i][1] = 1e9; &#125; for(int i=0;i&lt;G[u].size();i++)&#123; int v = G[u][i]; for(int j=tot[u];j&gt;=2;j--)&#123;//枚举下u下一共多少个节点，2是因为包括u，v在内 for(int k=1;k&lt;=tot[v];k++)&#123;//枚举走v一下走了多少个节点，从1开始是因为v已经在内 dp[u][j][0] = min(dp[u][j][0],dp[u][j-k][0]+dp[v][k][0]+2*d[v]); dp[u][j][1] = min(dp[u][j][1],dp[u][j-k][0]+dp[v][k][1]+d[v]); dp[u][j][1] = min(dp[u][j][1],dp[u][j-k][1]+dp[v][k][0]+2*d[v]); &#125; &#125; &#125;&#125;int main()&#123; int kase = 0; while(scanf(&quot;%d&quot;,&amp;n)&amp;&amp;n)&#123; for(int i=0;i&lt;=n;i++)G[i].clear(); memset(tot,0,sizeof(tot)); memset(dp,0,sizeof(dp)); memset(d,0,sizeof(d)); for(int i=1;i&lt;=n-1;i++)&#123; int u,v,w; scanf(&quot;%d%d%d&quot;,&amp;v,&amp;u,&amp;w); G[u].push_back(v);//做成有向图是为了方便防止父子节点来回走 d[v] = w; &#125; dfs(0); int q; scanf(&quot;%d&quot;,&amp;q); printf(&quot;Case %d:\n&quot;,++kase); while(q--)&#123; int k; scanf(&quot;%d&quot;,&amp;k); int ans = 0; for(int i=n;i&gt;=1;i--)&#123; if(k&gt;=dp[0][i][1]) &#123; ans = i; break; &#125; &#125; printf(&quot;%d\n&quot;,ans); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>树形dp</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Uva(1398)(Meteor)]]></title>
    <url>%2F2018%2F11%2F17%2FUva(1398)(Meteor)%2F</url>
    <content type="text"><![CDATA[链接：https://vjudge.net/problem/UVA-1398思路： 一开始拿到题目就想到用数学公式强行算出进入左端点的时间，出去的时间，然后还要和零比较，后面看了刘汝佳的写法才发现还可以写的这么简单。原来我是建的一个区间结构，将开始和结尾时间都放进去，然后用一个优先级队列去维护右端点结构，每次到左端点记录时就将队列中在这个时间之前的右端点（包括闭区间）全部pop出去，记录这个左端点并更新最大值后再将他的右端点放入队列中。今天学到了一种新的写法，就是把左右端点拆开，遇到左端点就将当前数目+1并更新最大值，遇到最右端点就将当前数目减1，这样避免了左右端点在一起时只能拿一边排序从而需要用队列维护另一边的尴尬局面。妙不可言！！！代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;struct Event&#123; double t; int type; Event()&#123;&#125; Event(double tt,int typee)&#123; t = tt; type = typee; &#125; bool operator&lt;(const Event &amp;a1)const&#123; return t&lt;a1.t||(t==a1.t&amp;&amp;type&gt;a1.type); &#125;&#125;ess[200001];int t,n,w,h,x,y,a,b;void update(int x,int w,int a,double &amp;l,double &amp;r)&#123; if(a==0)&#123; if(x&gt;=w||x&lt;=0)r = l-1;//无解 &#125; else if(a&gt;0)&#123; l = max(l,-(double)x/a); r = min(r,(double)(w-x)/a); &#125; else&#123; l = max(l,(double)(w-x)/a); r = min(r,-(double)x/a); &#125;&#125;int main()&#123; scanf("%d",&amp;t); while(t--)&#123; int e = 0; scanf("%d%d%d",&amp;w,&amp;h,&amp;n); for(int i=0;i&lt;n;++i)&#123; double l = 0,r = 1e9; scanf("%d%d%d%d",&amp;x,&amp;y,&amp;a,&amp;b); update(x,w,a,l,r);//更新左端点的边 update(y,h,b,l,r);//更新右端点的边 if(l&lt;r)&#123; ess[e++] = Event(l,0); ess[e++] = Event(r,1); &#125; &#125; sort(ess,ess+e); int res = 0; int ans = 0; for(int i=0;i&lt;e;i++)&#123; if(ess[i].type==0)&#123; ans++; res = max(res,ans); &#125; else ans--; &#125; printf("%d\n",res); &#125; return 0;&#125;]]></content>
      <categories>
        <category>贪心</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Uva(1395)(Slim-Span)]]></title>
    <url>%2F2018%2F11%2F17%2FUva(1395)(Slim-Span)%2F</url>
    <content type="text"><![CDATA[链接：https://vjudge.net/problem/UVA-1395思路：表面看起来跟最小生成树没什么关系，其实不然，由于点比较少，可以用kruskal之前枚举边的起点，然后贪心取就可以得到当前枚举的最大边和最小边差值的最小，然后更新值即可，一开始我既枚举了起点又枚举了终点，完全没必要，浪费了一个n的复杂度被T了，后来发现完全是浪费改掉之后就A了代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 110;int n,m;struct edge&#123; int from,to,dist; edge()&#123;&#125; edge(int f,int t,int d):from(f),to(t),dist(d)&#123;&#125; bool operator&lt;(const edge &amp;r)const&#123; return dist&lt;r.dist; &#125;&#125;;struct Kruskal&#123; vector&lt;int&gt; G[maxn]; int m,n; int par[maxn]; vector&lt;edge&gt; edges; int done; void init(int n)&#123; this-&gt;n = n; for(int i=0;i&lt;=n;i++)G[i].clear(); edges.clear(); for(int i=0;i&lt;n;i++)par[i] = i; &#125; void addedge(int from,int to,int dist)&#123; edges.push_back(edge(from,to,dist)); m = edges.size(); G[from].push_back(m-1); done = 0; &#125; int getroot(int a)&#123; if(par[a]==a)return a; par[a] = getroot(par[a]); return par[a]; &#125; void merge(int a,int b)&#123; int p1 = getroot(a); int p2 = getroot(b); if(p1==p2)return; par[p2] = p1; &#125; int kruskal()&#123; int res = 1e9; sort(edges.begin(),edges.end()); for(int k=0;k&lt;edges.size();k++)&#123;//枚举起点 done = 0; for(int p=0;p&lt;n;p++)par[p] = p; int i; for(i=k;i&lt;edges.size();i++)&#123; if(getroot(edges[i].from)!=getroot(edges[i].to))&#123; merge(edges[i].from,edges[i].to); ++done; &#125; if(done==n-1)break; &#125;if(done==n-1)res = min(res,edges[i].dist-edges[k].dist);//更新&#125;return res;&#125;&#125;solver;int main()&#123; //freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin); //freopen(&quot;out.txt&quot;,&quot;w&quot;,stdout); while(scanf(&quot;%d%d&quot;,&amp;n,&amp;m)&amp;&amp;(n+m))&#123; solver.init(n); for(int i=0;i&lt;m;i++)&#123; int a,b,c; scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c); a--; b--; solver.addedge(a,b,c); solver.addedge(b,a,c); &#125; int res = solver.kruskal(); printf(&quot;%d\n&quot;,res==1e9?-1:res); &#125; return 0;&#125;]]></content>
      <categories>
        <category>最小生成树</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Uva(1393)(Highways)]]></title>
    <url>%2F2018%2F11%2F17%2FUva(1393)(Highways)%2F</url>
    <content type="text"><![CDATA[链接：https://vjudge.net/problem/UVA-1393思路：代码很短，但是却不好想，首先我们要考虑如果确定两点怎么判断他们能否形成一条之前没有重复过的直线，方法就是看他的向量的gcd是否为1，不为1则前面肯定计算过，所以我们考虑预处理的时候用dp[i][j]表示向量(x,y)(x]]></content>
      <categories>
        <category>数论</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Uva(1391)(Astronauts-)]]></title>
    <url>%2F2018%2F11%2F17%2FUva(1391)(Astronauts-)%2F</url>
    <content type="text"><![CDATA[链接：https://vjudge.net/problem/UVA-1391思路：刚学了2-SAT算法做的一个题，比较明显的一个模板题。我们容易观察到每个宇航员最多都有两种选择，只是因为年龄不同导致选择可能也不同，不妨令false为选择公共任务C，true为对应的另一个任务，建图时则要分情况讨论，若属于同一个类型，则他们不能同时为真和同时为假，若为不同类型，则不能同时为假，建图即可。注意判断平均年龄时不要算出平均年龄再比较，这样会涉及double可能有麻烦，最好的是算出总年龄total，用一个人的年龄*n与total比较即可判断在平均年龄之上还是之下。下面我会顺便详细解释一下2-SAT模板代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;using namespace std;const int maxn = 100001;int n,m;int total;int age[maxn];struct twosat&#123; int n; vector&lt;int&gt; G[maxn*2];//存边 bool mark[maxn*2]; int S[maxn*2];//用来反悔标记的栈 int c;bool dfs(int x)&#123; if(mark[x^1])return false;//如果另一个已经标记，说明矛盾，无解 if(mark[x])return true;//如果该点已经标记，返回有解 mark[x] = true; S[c++] = x;//栈中记录一路过来的点，方便无解的时候“回溯” for(int i=0;i&lt;G[x].size();i++) if(!dfs(G[x][i]))return false; return true;&#125;void init(int n)&#123; this-&gt;n = n; for(int i=0;i&lt;n*2;i++)G[i].clear(); memset(mark,0,sizeof(mark));&#125;//xval，yval表示该点选择为0（假）还是1（真），该函数表示x的xval选择或者y的yval选择，若x和y相同，1表示x，0表示！xvoid add_clause(int x,int xval,int y,int yval)&#123; x = x*2+xval; y = y*2+yval; G[x^1].push_back(y); //因为外部中1代表真，0代表假，而mark中时2i代表假，2i+1代表真 G[y^1].push_back(x);&#125;bool solve()&#123; for(int i=0;i&lt;n*2;i+=2)&#123; if(!mark[i]&amp;&amp;!mark[i+1])&#123;//如果两个都没有标记，则搜索 c = 0; if(!dfs(i))&#123; while(c&gt;0)mark[S[--c]] = false;//反悔之前标记的结点，然后搜索另一种情况 if(!dfs(i+1))return false; &#125; &#125; &#125; return true;&#125;&#125;;twosat solver;bool isyoung(int aa)&#123; return aa*n&lt;total;&#125;int main()&#123; while(scanf(&quot;%d%d&quot;,&amp;n,&amp;m)==2&amp;&amp;(n||m))&#123;total = 0; solver.init(n); for(int i=0;i&lt;n;i++)&#123; scanf(&quot;%d&quot;,&amp;age[i]); total+=age[i]; &#125; for(int i=0;i&lt;m;i++)&#123; int a,b; scanf(&quot;%d%d&quot;,&amp;a,&amp;b); a--; b--; //if(a==b)continue; if(isyoung(age[a])==isyoung(age[b]))&#123; solver.add_clause(a,0,b,0);//两个都为false solver.add_clause(a,1,b,1);//两个都为true &#125; else solver.add_clause(a,0,b,0);//l两个都为false &#125; if(solver.solve())&#123; for(int i=0;i&lt;n;i++)&#123; if(!isyoung(age[i]))&#123; if(solver.mark[2*i])printf(&quot;A\n&quot;); else printf(&quot;C\n&quot;); &#125; else&#123; if(solver.mark[2*i])printf(&quot;B\n&quot;); else printf(&quot;C\n&quot;); &#125; &#125; &#125; else printf(&quot;No solution.\n&quot;); &#125; return 0;&#125;]]></content>
      <categories>
        <category>2-SAT</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Uva(1357)(Cells)]]></title>
    <url>%2F2018%2F11%2F17%2FUva(1357)(Cells)%2F</url>
    <content type="text"><![CDATA[链接：https://vjudge.net/problem/UVA-1357思路：太妙了太妙了，再次感叹自己智商不够了。。利用dfs的特性，在dfs的时候给每个点标上开始查找时间和结束查找时间，则如果满足祖先和子孙关系的话两个的时间应该是包含关系，其他的都是不相交关系。由于数量级较大不能直接dfs，用栈模拟即可！！！代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;vector&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;algorithm&gt; using namespace std;const int maxn = 3 * 1e5 + 5;const int maxm = 2 * 1e7 + 5; int N, M, S[maxn], C[maxn], pre[maxm], post[maxm]; void dfs(int root) &#123; stack&lt;int&gt; sta; sta.push(root); int dfslock = pre[root] = 0; while (!sta.empty()) &#123; int x = sta.top(); if (pre[x]) &#123; post[x] = ++dfslock; sta.pop(); continue; &#125; pre[x] = ++dfslock; for (int i = S[x]; i &lt; S[x] + C[x]; i++) &#123; if (i &lt; N) &#123; pre[i] = 0; sta.push(i); &#125; else &#123; pre[i] = ++dfslock; post[i] = ++ dfslock; &#125; &#125; &#125;&#125; int main () &#123; int cas, u, v; scanf(&quot;%d&quot;, &amp;cas); for (int kcas = 1; kcas &lt;= cas; kcas++) &#123; scanf(&quot;%d&quot;, &amp;N); S[0] = 1; for (int i = 0; i &lt; N; i++) &#123; scanf(&quot;%d&quot;, &amp;C[i]); if (i) S[i] = S[i-1] + C[i-1]; &#125; dfs(0); scanf(&quot;%d&quot;, &amp;M); printf(&quot;Case %d:\n&quot;, kcas); for (int i = 0; i &lt; M; i++) &#123; scanf(&quot;%d%d&quot;, &amp;u, &amp;v); printf(&quot;%s\n&quot;, pre[u] &lt; pre[v] &amp;&amp; post[u] &gt; post[v] ? &quot;Yes&quot; : &quot;No&quot;); &#125; if (kcas &lt; cas) printf(&quot;\n&quot;); &#125; return 0;&#125;]]></content>
      <categories>
        <category>dfs</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Uva(1328)(Period)]]></title>
    <url>%2F2018%2F11%2F17%2FUva(1328)(Period)%2F</url>
    <content type="text"><![CDATA[链接：https://vjudge.net/problem/UVA-1328思路：原来感觉都是暴力做的，但因为数据水所以能过，现在刚学了kmp发现可以用kmp做这种查找循环节的问题，具体就是求出f数组（next数组），然后当i%(i-f[i])==0(表示从开头到当前位置)的长度是这个相同最长前缀的长度的整数倍的话，则错位部分的第一段等于原来的第二段，第二段等于第三段———-，一直可以推出等分的每一段都相等，这样就可以推出是一个循环节，如果不能整除肯定不为循环节- -，证明完毕~~代码：123456789101112131415161718192021222324252627#include&lt;bits/stdc++.h&gt;using namespace std;int n;const int maxn = 1e6+10;char a[maxn];int f[maxn];int main()&#123; int kase = 0; while(~scanf(&quot;%d&quot;,&amp;n)&amp;&amp;n)&#123; scanf(&quot;%s&quot;,a); f[0] = f[1] = 0; for(int i=1;i&lt;n;i++)&#123; int j = f[i]; while(j&amp;&amp;a[i]!=a[j])j = f[j]; f[i+1] = (a[i]==a[j]?j+1:0); &#125; printf(&quot;Test case #%d\n&quot;,++kase); for(int i=2;i&lt;=n;i++)printf(&quot;%d\n&quot;,f[i]); for(int i=2;i&lt;=n;i++)&#123; if(f[i]&gt;0&amp;&amp;i%(i-f[i])==0) printf(&quot;%d %d\n&quot;,i,i/(i-f[i])); &#125; printf(&quot;\n&quot;); &#125; return 0;&#125;]]></content>
      <categories>
        <category>kmp</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Uva(1267)(Network)]]></title>
    <url>%2F2018%2F11%2F17%2FUva(1267)(Network)%2F</url>
    <content type="text"><![CDATA[链接:https://vjudge.net/problem/UVA-1267思路:由于各个客户端都可以看做树的根节点，我们考虑从根节点开始向前搜索，当距离大于k且没遇到原来VOD的时候即要安装一个服务器。那遇到有多条路时怎么决定往哪边走呢(即决定服务器位置放哪里，从而保证是最优解)，不难想到，如果我们从深度最深的根节点开始一直向上走，然后当刚好大于k距离时安装一台服务器，这样的解一定是最优的，为了区分服务器和VOD，我们可以在安装服务器后马上进行一次dfs，对能达到的根节点进行标记。那么如何进行根节点深度的排序呢，我们可以进行一次bfs，然后遇到根节点就把它放入vector中，这样再倒着遍历一遍vector就是按照根节点深度从大到小的顺序进行遍历，从而确保了最优解，然后如果需要按照服务器就进行一次遍历，将能达到的其他根节点进行标记为已经覆盖。代码:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;cstring&gt;#include&lt;queue&gt;using namespace std;int t,n,p,k,a,b,res = 0;;int visss[1001];//dfs中判重int viss[1001];//bfs中判重int pre[1001];int cover[1001];vector&lt;int&gt; G[1001],nodes; //G记录边信息，nodes记录根节点信息//bfs确定深度，从而按深度放入nodes中void bfs(int w)&#123; queue&lt;int&gt; qq; qq.push(w); viss[w] = 1; pre[w] = -1;while(!qq.empty())&#123; int e = qq.front(); qq.pop(); for(int i=0;i&lt;G[e].size();i++)&#123; int v = G[e][i]; if(viss[v])continue; pre[v] = e; viss[v] = 1; if(G[v].size()==1)nodes.push_back(v); else&#123; qq.push(v); &#125; &#125;&#125;&#125;//安装新服务器后对其他能覆盖的根节点的扫描void dfs(int w,int dd)&#123; if(dd&gt;k)return; if(G[w].size()==1)cover[w] = 1;for(int i=0;i&lt;G[w].size();i++)&#123; if(!visss[G[w][i]])&#123; visss[G[w][i]] = 1; // printf("%d\n",G[w][i]); dfs(G[w][i],dd+1); &#125; else continue;&#125;&#125;void solve()&#123; for(int i=nodes.size()-1;i&gt;=0;--i)&#123;//按根节点深度从大到小进行排序遍历 if(cover[nodes[i]]==1)continue; int v = nodes[i]; for(int l=0;l&lt;k;++l)&#123; v = pre[v]; if(v==p)&#123; cover[nodes[i]] = 1; break; &#125; &#125; if(cover[nodes[i]]==0)&#123; memset(visss,0,sizeof(visss)); visss[v] = 1; res++; // printf("%d %d\n",v,nodes[i]); dfs(v,0); &#125; &#125;&#125;int main()&#123;// freopen("in.txt","r",stdin);// freopen("out.txt","w",stdout); scanf("%d",&amp;t); while(t--)&#123; for(int i=0;i&lt;n;i++)G[i].clear(); nodes.clear(); int times = 0; res = 0; memset(viss,0,sizeof(viss)); memset(pre,0,sizeof(pre)); memset(cover,0,sizeof(cover)); scanf("%d%d%d",&amp;n,&amp;p,&amp;k); for(int i=0;i&lt;n-1;i++)&#123; scanf("%d%d",&amp;a,&amp;b); G[a].push_back(b); G[b].push_back(a); &#125; bfs(p); solve(); printf("%d\n",res); &#125; return 0;&#125;]]></content>
      <categories>
        <category>贪心</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Uva(1265)(Tour-Belt)]]></title>
    <url>%2F2018%2F11%2F17%2FUva(1265)(Tour-Belt)%2F</url>
    <content type="text"><![CDATA[链接：https://vjudge.net/problem/UVA-1265思路：感觉最近做题都好没感觉啊，调试半天= =，这个题竟然直接n方暴力枚举边确实没想到，说一下思路，从大到小依次枚举两条边，若两边的都属于一个连通分量的内部，则更新这个内部的最小值，如果第二条边的某一个点与另一个点以及第一条边的祖先相等，说明第二条边之前已经枚举过，但与第一条边不属于一个连通分量，则此时更新一下最大值，然后比较一下最大值和最小值，若最小值保证大于最大值，则此时连通分量满足子图。代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102#include&lt;bits/stdc++.h&gt;using namespace std;int n,m,t;const int maxn = 5010;struct edge&#123; int from,to,dist; edge()&#123;&#125; edge(int f,int t,int d)&#123; from = f; to = t; dist = d; &#125; bool operator&lt;(const edge &amp;r)&#123; return dist&gt;r.dist; &#125;&#125;;struct Kruskal&#123; vector&lt;edge&gt; edges; int n,m; int par[maxn]; int ans; int done; int d[maxn]; vector&lt;int&gt; G[maxn]; int num[maxn]; void init(int n)&#123; this-&gt;n = n; for(int i=0;i&lt;n;i++)G[i].clear(); edges.clear(); &#125; void addedge(int from,int to,int dist)&#123; edges.push_back(edge(from,to,dist)); m = edges.size(); G[from].push_back(m-1); &#125; int getroot(int a)&#123; if(a==par[a])return a; par[a] = getroot(par[a]); return par[a]; &#125; void merge(int a,int b)&#123; int p1 = getroot(a); int p2 = getroot(b); if(p1==p2)return; par[p2] = p1; num[p1]+=num[p2]; num[p2] = 0; &#125; void kruskal()&#123; for(int i=0;i&lt;=n;i++)&#123; par[i] = i; num[i] = 1; &#125; sort(edges.begin(),edges.end()); ans = 0; for(int i=0;i&lt;edges.size();i++)&#123; int xx = getroot(edges[i].from); int yy = getroot(edges[i].to); if(xx!=yy)&#123; int minv = 1e9; int maxv = -1e9; merge(edges[i].from,edges[i].to); for(int j=0;j&lt;edges.size();j++)&#123; int px = getroot(edges[j].from); int py = getroot(edges[j].to); if(px==py&amp;&amp;px==xx)minv = min(minv,edges[j].dist); else if(px==xx||py==xx)maxv = max(maxv,edges[j].dist); &#125; if(minv&gt;maxv)ans+=num[xx]; &#125; &#125; &#125;&#125;solver;int main()&#123; // freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin); //freopen(&quot;out.txt&quot;,&quot;w&quot;,stdout); scanf(&quot;%d&quot;,&amp;t); while(t--)&#123; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); solver.init(n); for(int i=0;i&lt;m;i++)&#123; int a,b,c; a--; b--; scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c); solver.addedge(a,b,c); solver.addedge(b,a,c); &#125; solver.kruskal(); printf(&quot;%d\n&quot;,solver.ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>最小生成树</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Uva(1169)(Robotruck)]]></title>
    <url>%2F2018%2F11%2F17%2FUva(1169)(Robotruck)%2F</url>
    <content type="text"><![CDATA[链接：https://vjudge.net/problem/UVA-1169思路：啊啊啊啊啊啊太开心了，刚刚上一道题觉得很难，这道题我用刘汝佳上道题的思路写感觉比他的解还要简单一点，很开心。首先找出状态，我们定义dp[i][j]为当前机器人站在第i个垃圾上且已经捡起了第i个垃圾后手上的重量为j，那么我们要考虑下一步操作，回去把垃圾倒掉或者继续捡垃圾，继续捡垃圾的条件是必须捡起下一个垃圾后手上重量小于等于最大可承受重量，那么就可以分为两步进行递归，最后取最小值（用记忆式搜索会比递推好写且更好理解）代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;using namespace std;struct point&#123; int x,y,w;&#125;pp[100001];int dp[100001][101];int t,c,n;int dfs(int i,int j)&#123; if(dp[i][j]!=0)return dp[i][j];//如果有值的话则代表已经计算过 int&amp; ans = dp[i][j];//引用的技巧，一定要学会，非常好用 if(i==n)&#123;//到最后一个垃圾且已经捡起来了，则可以返回了 ans+=pp[i].x+pp[i].y; return ans; &#125; if(j+pp[i+1].w&lt;=c)&#123;//决策一，捡下一个垃圾 ans+=(fabs(pp[i].x-pp[i+1].x)+fabs(pp[i+1].y-pp[i].y)); ans+=dfs(i+1,j+pp[i+1].w); &#125; else ans = 1e9;//一定不能少这一步，不然如果不满足决策1条件此时ans为0，下一步则会被最后min给覆盖掉！！！！//决策2，先回去再回来捡垃圾 int sum = pp[i].x+pp[i].y+pp[i+1].x+pp[i+1].y; sum+=dfs(i+1,pp[i+1].w); ans = min(ans,sum);//取所需步数较小的一个即可 return ans;&#125;int main()&#123; scanf(&quot;%d&quot;,&amp;t); while(t--)&#123; memset(dp,0,sizeof(dp)); scanf(&quot;%d%d&quot;,&amp;c,&amp;n); pp[0].x = pp[0].y = pp[0].w = 0; for(int i=1;i&lt;=n;++i)&#123; scanf(&quot;%d%d%d&quot;,&amp;pp[i].x,&amp;pp[i].y,&amp;pp[i].w); &#125; printf(&quot;%d\n&quot;,dfs(0,0)); if(t)printf(&quot;\n&quot;);//注意输出格式，uva上格式是真的蛋疼！ &#125; return 0;&#125; 好吧，原来是老刘觉得我的方法要超时所以用了优化，暂时看不懂写贴上来吧]]></content>
      <categories>
        <category>基础dp</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Uva(1108)(Mining-Your-Own-Business-)]]></title>
    <url>%2F2018%2F11%2F17%2FUva(1108)(Mining-Your-Own-Business-)%2F</url>
    <content type="text"><![CDATA[链接：https://vjudge.net/problem/UVA-1108思路：还是熟悉模板的练习题，但是要先建模，首先不可能在割顶放，因为这样割顶没了剩下的连通块都没了，所以肯定不是最优，其次如果有两个割顶，那么此时一定连着两边，所以这里可以不用放，所以只有一个割顶的连通块才需要放。且可以放在任意非割顶的位置，所以方案数就是每个要放的连通块的非割顶点数相乘即可，注意如果整个图只有一个割顶，那么需要放两个，这种情况需要特判！！！！补充：这是求的点双连通分量，如果只有两个点一条边其实也是算点双连通分量的。。。。且两个点都算作割顶代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#include&lt;cstdio&gt;#include&lt;deque&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;using namespace std;const int maxn = 5*1e4+10;vector&lt;int&gt; G[maxn],bbc[maxn];int bbcno[maxn];int dfn[maxn],low[maxn];int iscut[maxn];int ntime,bbc_cnt;int m;struct edge&#123; int u,v; edge()&#123;&#125; edge(int uu,int vv):u(uu),v(vv)&#123;&#125;;&#125;;deque&lt;edge&gt; edges;void tarjan(int u,int f)&#123; dfn[u] = low[u] = ++ntime; int child = 0; for(int i=0;i&lt;G[u].size();i++)&#123; int v = G[u][i]; if(!dfn[v])&#123; edges.push_back(edge(u,v)); child++; tarjan(v,u); low[u] = min(low[u],low[v]); edge tmp; if(dfn[u]&lt;=low[v])&#123; iscut[u] = 1; bbc_cnt++; bbc[bbc_cnt].clear(); do&#123; tmp = edges.back(); edges.pop_back(); if(bbcno[tmp.u]!=bbc_cnt)&#123; bbc[bbc_cnt].push_back(tmp.u); bbcno[tmp.u] = bbc_cnt; &#125; if(bbcno[tmp.v]!=bbc_cnt)&#123; bbc[bbc_cnt].push_back(tmp.v); bbcno[tmp.v] = bbc_cnt; &#125; &#125;while(!(tmp.u==u&amp;&amp;tmp.v==v)); &#125; &#125; else if(dfn[v]&lt;dfn[u]&amp;&amp;v!=f)&#123; edges.push_back(edge(u,v)); low[u] = min(low[u],dfn[v]); &#125; &#125; if(f&lt;0&amp;&amp;child==1)iscut[u] = 0;&#125;void find_bbc(int n)&#123;memset(dfn,0,sizeof(dfn));memset(low,0,sizeof(low));memset(bbcno,0,sizeof(bbcno));memset(iscut,0,sizeof(iscut));ntime = bbc_cnt = 0;for(int i=0;i&lt;n;i++)&#123; if(!dfn[i])tarjan(i,-1);&#125;&#125;int main()&#123; int kase = 0; while(scanf(&quot;%d&quot;,&amp;m)&amp;&amp;m)&#123; int maxnn = 0; for(int i=0;i&lt;maxn;i++)G[i].clear(); for(int i=0;i&lt;m;i++)&#123; int a,b; scanf(&quot;%d%d&quot;,&amp;a,&amp;b); maxnn = max(maxnn,a); maxnn = max(maxnn,b); a--; b--; G[a].push_back(b); G[b].push_back(a); &#125; find_bbc(maxnn); long long ans1 = 0,ans2 = 1; for(int i=1;i&lt;=bbc_cnt;i++)&#123; int cut_bbc = 0; for(int j=0;j&lt;bbc[i].size();j++)&#123; if(iscut[bbc[i][j]])&#123; printf(&quot;%d\n&quot;,bbc[i][j]); cut_bbc++; &#125; &#125; if(cut_bbc==1)&#123; ans1++; ans2*=(long long)(bbc[i].size()-cut_bbc); &#125; &#125; if(bbc_cnt==1)&#123; ans1 = 2; ans2 = bbc[1].size()*(bbc[1].size()-1)/2; &#125; printf(&quot;Case %d: %lld %lld\n&quot;,++kase,ans1,ans2); &#125; return 0;&#125;]]></content>
      <categories>
        <category>tarjan强连通分量</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Uva(1099)(sharingchocolatlie)]]></title>
    <url>%2F2018%2F11%2F17%2FUva(1099)(sharingchocolatlie)%2F</url>
    <content type="text"><![CDATA[链接：https://vjudge.net/problem/UVA-1099思路：10年wf的题，还是首先来建立状态。遍历当前集合，如果里面有一个面积的蛋糕是当前长或者宽的因子，那么就可以切，然后把该元素从集合中剔除，进入到下一个状态。我们考虑到最多分15个蛋糕，那么子集有2的15次方-1个，32767个，然后长和宽各为100，一共327670000个状态，很明显要超时超内存。考虑一下，当i确定的时候，就已经明确了集合中还有哪几个元素，此时总面积也是确定的，所以我们可以预处理算出集合中有某些元素时的面积，此时为了压缩状态，我们取长和宽中小的那一个标记状态，另一个可以由面积/该边得出。这样以来复杂度降低了很多，就可以通过了（这种方法确实牛逼啊，膜拜老刘）代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;int n,x,y,o=0;int a[16];int dp[66000][101],nsum[66000];int vis[66000][101];int bitcount(int x)&#123;//计算是否只剩一个元素 return x==0?0:bitcount(x/2)+(x&amp;1);&#125;int dfs(int i,int j)&#123; if(vis[i][j])return dp[i][j]; vis[i][j] = 1; int&amp; ans = dp[i][j]; if(bitcount(i)==1)//如果只剩一个元素，则返回真return ans = 1; int y = nsum[i]/j;//算出另一边 for(int s=(i-1)&amp;i;s;s=(s-1)&amp;i)&#123;//枚举所有子集的方法 int s1 = i-s;//子集与全集对应的差集 if(nsum[s]%j==0&amp;&amp;dfs(s,min(j,nsum[s]/j))&amp;&amp;dfs(s1,min(j,nsum[s1]/j)))//为长的因子且切开的两部分都有解，则当前状态有解 return ans = 1; if(nsum[s]%y==0&amp;&amp;dfs(s,min(y,nsum[s]/y))&amp;&amp;dfs(s1,min(y,nsum[s1]/y)))//为宽的因子且切开的两部分都有解，则当前状态有解 return ans = 1; &#125; return ans = 0;&#125;int main()&#123; //freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin); //freopen(&quot;out.txt&quot;,&quot;w&quot;,stdout); while(scanf(&quot;%d&quot;,&amp;n)&amp;&amp;n)&#123; scanf(&quot;%d%d&quot;,&amp;x,&amp;y); for(int i=0;i&lt;n;i++)&#123; scanf(&quot;%d&quot;,&amp;a[i]); &#125; for(int i=0;i&lt;(1&lt;&lt;n);i++)&#123; nsum[i] = 0; for(int j=0;j&lt;n;j++)&#123; if(i&amp;(1&lt;&lt;j))nsum[i]+=a[j]; &#125; &#125; memset(vis,0,sizeof(vis)); int all = (1&lt;&lt;n)-1; int ans; if(nsum[all]!=x*y||nsum[all]%x!=0)ans = 0; else ans = dfs(all,min(x,y)); printf(&quot;Case %d: %s\n&quot;,++o,ans?&quot;Yes&quot;:&quot;No&quot;); &#125; return 0;&#125;]]></content>
      <categories>
        <category>基础dp</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Uva(1086)(The-Ministers'-Major-Mess)]]></title>
    <url>%2F2018%2F11%2F17%2FUva(1086)(The-Ministers'-Major-Mess)%2F</url>
    <content type="text"><![CDATA[链接：https://vjudge.net/problem/UVA-1086思路：2-SAT的问题，让我对2-SAT的认识更深了一步，首先一个议案只能是通过或者否决，所以就是一个2-SAT的问题，然后一个人的k如果小于等于2，那么他的所有提议都应该是正确的，那么怎么表示这两个议案恒为真呢，即自己向自己添加一条边，所以对于addedge(x,xval,y,yval)的正确理解应该是x的xval情况和y的yval情况其中之一必有一个为真，也可能两个同时为真，但不可能同时为假，如果x，xval与y，yval完全对应相同则说明恒为真。如果k大于3，那么就最多有一个提议没通过，每两条边之间都连一下即可，即若有一个确定不符合，其他的必定全部为真。最后如何判断是否为确定的呢，我们可以遍历n，每个议案都添加一条反向边，按理说添加反向边会产生矛盾，只要经过这拆出来的两个点必定会返回false，所以如果无法确定，就一定不会经过这个议案对应的点，加了反向边依然会有解。如果无解就一定确定，值为当前mark种储存的值。代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include&lt;bits/stdc++.h&gt;using namespace std;int n,m;const int maxn = 101;int save[maxn];struct twosat&#123; int n; bool mark[maxn*2]; vector&lt;int&gt; G[maxn]; int S[maxn*2]; int c; bool dfs(int x)&#123; if(mark[x^1])return false; if(mark[x])return true; mark[x] = true; S[c++] = x; for(int i = 0;i&lt;G[x].size();i++)&#123; if(!dfs(G[x][i]))return false; &#125; return true; &#125; void init(int n)&#123; this-&gt;n = n; for(int i=0;i&lt;n*2;i++)G[i].clear(); memset(mark,0,sizeof(mark)); &#125; void add_clause(int x,int xval,int y,int yval)&#123; x = x*2+xval; y = y*2+yval; G[x^1].push_back(y); G[y^1].push_back(x); &#125; void delete_clause(int x,int xval,int y,int yval)&#123; x = x*2+xval; y = y*2+yval; G[x^1].pop_back(); G[y^1].pop_back(); &#125; bool solve()&#123; for(int i=0;i&lt;n*2;i+=2)&#123; if(!mark[i]&amp;&amp;!mark[i+1])&#123; c = 0; if(!dfs(i))&#123; while(c&gt;0)mark[S[--c]] = false; if(!dfs(i+1))return false; &#125; &#125; &#125; return true; &#125;&#125;solver;int main()&#123; while(scanf(&quot;%d%d&quot;,&amp;n,&amp;m)&amp;&amp;(n+m))&#123; memset(save,0,sizeof(save)); solver.init(n); int k,t[4],w[4]; char ch; for(int i=0;i&lt;m;i++)&#123; scanf(&quot;%d&quot;,&amp;k); for(int j=0;j&lt;k;j++)&#123; scanf(&quot;%d %c&quot;,&amp;t[j],&amp;ch); if(ch==&apos;y&apos;)w[j] = 1; else w[j] = 0; &#125; if(k==1||k==2)&#123; for(int j=0;j&lt;k;i++)&#123; solver.add_clause(t[j]-1,w[j],t[j]-1,w[j]); &#125; &#125; else&#123; for(int j=0;j&lt;k;j++)&#123; for(int jj=j+1;jj&lt;k;jj++)&#123; solver.add_clause(t[j]-1,w[j],t[jj]-1,w[jj]); &#125; &#125; &#125; &#125; bool res = solver.solve(); if(!res)printf(&quot;impossible\n&quot;); else&#123; for(int i=0;i&lt;n;i++)save[i] = solver.mark[2*i+1]; for(int i=0;i&lt;n;i++)&#123; memset(solver.mark,0,sizeof(solver.mark)); solver.add_clause(i,!save[i],i,!save[i]);//添加反向边 if(solver.solve())printf(&quot;?&quot;);//查看当前是否有解 else printf(&quot;%c&quot;,save[i]?&apos;y&apos;:&apos;n&apos;); solver.delete_clause(i,!save[i],i,!save[i]);//恢复原图 &#125; printf(&quot;\n&quot;); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>2-SAT</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Topological-Sort(拓扑排序)]]></title>
    <url>%2F2018%2F11%2F17%2FTopological-Sort(%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F)%2F</url>
    <content type="text"><![CDATA[链接:https://vjudge.net/problem/Aizu-GRL_4_B下面基于bfs和dfs分别进行实现 bfs:思路:通过寻找入度为0的点作为拓扑排序的起点,对其相邻点进行搜索并减少对应入度,搜索完成后将该点加入排序队列,并在图中删除该点,对后面的点进行继续搜索.代码:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;queue&gt;#include&lt;cstring&gt;using namespace std;const int MAX = 1000000;const int INF = (1&lt;&lt;29);int n;vector&lt;int&gt; G[MAX];vector&lt;int&gt; result;queue&lt;int&gt; line;int indeg[MAX];bool V[MAX];void bfs(int s)&#123;line.push(s);V[s] = true;while(!line.empty())&#123;int u = line.front();line.pop();result.push_back(u);for(int i=0;i&lt;G[u].size();i++)&#123;int v = G[u][i];indeg[v]--;if(indeg[v]==0&amp;&amp;V[v]==false)&#123;V[v] = true;line.push(v);&#125;&#125;&#125;&#125;void tsort()&#123;for(int i=0;i&lt;n;i++)&#123;for(int u=0;u&lt;G[i].size();u++)&#123;int v = G[i][u];indeg[v]++;&#125;&#125;for(int i=0;i&lt;n;i++)&#123;if(indeg[i]==0&amp;&amp;V[i]==false) bfs(i);&#125;for(int u = 0;u&lt;result.size();u++)cout&lt;&lt;result[u]&lt;&lt;endl;&#125;int main()&#123;memset(indeg,0,sizeof(indeg));memset(V,0,sizeof(V));int num,a,b;cin&gt;&gt;n&gt;&gt;num;while(num--)&#123;cin&gt;&gt;a&gt;&gt;b;G[a].push_back(b);&#125;tsort();return 0;&#125; dfs:思路:若图中u,v间存在路径,则v在排序中一定在u之后,dfs搜索只需保证每一条路径的v都在u之后即可得出最后的排序结果，此时并不需要回溯。代码：123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;list&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int MAX = 1000000;int n;vector&lt;int&gt; G[MAX];list&lt;int&gt; result;bool V[MAX];void dfs(int s)&#123;V[s] = true;for(int i=0;i&lt;G[s].size();i++)&#123;int v = G[s][i];if(V[v]==false)dfs(v);&#125;result.push_front(s);&#125;int main()&#123;memset(V,0,sizeof(V));int num,a,b;cin&gt;&gt;n&gt;&gt;num;while(num--)&#123;cin&gt;&gt;a&gt;&gt;b;G[a].push_back(b);&#125;for(int i=0;i&lt;n;i++)&#123;if(V[i]==false) dfs(i);&#125;for(list&lt;int&gt;::iterator it = result.begin();it!=result.end();it++)cout&lt;&lt;*it&lt;&lt;endl;return 0;&#125; 注意：因为一张图可能存在多个排序结果，所以同一图用bfs和dfs可能得出不同的结果。]]></content>
      <categories>
        <category>dfs</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Range-Search-(kD-Tree)-范围搜索]]></title>
    <url>%2F2018%2F11%2F17%2FRange-Search-(kD-Tree)-%E8%8C%83%E5%9B%B4%E6%90%9C%E7%B4%A2%2F</url>
    <content type="text"><![CDATA[链接：https://vjudge.net/problem/Aizu-DSL_2_C思想：通过构造二叉树，将x与y在树上了交替进行排序（如第一层对x排序，第二层对y进行排序，第三层再对x，以此类推），可以将原本为o（n方）的复杂度降低为o（n（logn方））,注意数据量大用scanf和printf替代cin和cout!代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;class Node&#123;//树结点的构造public:int location,l,r,p;//左右父节点Node()&#123;&#125;&#125;;class Point&#123;//记录原来的点的序列public:int id,x,y;Point()&#123;&#125;Point(int id,int x,int y):id(id),x(x),y(y)&#123;&#125;bool operator &lt; (const Point &amp;p)const&#123;return id&lt;p.id;&#125;void print()&#123;printf(&quot;%d\n&quot;, id);&#125;&#125;;static const int NIL = -1;static const int MAX =1000010;int N;Point P[MAX];Node T[MAX];int np;bool lessX(const Point &amp;p1,const Point &amp;p2)&#123;return p1.x&lt;p2.x;&#125;//结点按照x排序bool lessY(const Point &amp;p1,const Point &amp;p2)&#123;return p1.y&lt;p2.y;&#125;//结点按照y排序int maketree(int l,int r,int depth)&#123;//递归构造二叉树if(l&gt;=r)return NIL;int mid = (l+r)/2;int t = np++;if(depth%2==0)//按层给x和y交替排序构成二叉树sort(P+l,P+r,lessX);//按照x排序else sort(P+l,P+r,lessY);//按照y排序T[t].location = mid;T[t].l = maketree(l,mid,depth+1);T[t].r = maketree(mid+1,r,depth+1);return t;&#125;void find(int v,int sx,int tx,int sy,int ty,int depth,vector&lt;Point&gt; &amp;ans)&#123;//寻找范围内的点int x = P[T[v].location].x;int y = P[T[v].location].y;if(sx&lt;=x&amp;&amp;x&lt;=tx&amp;&amp;sy&lt;=y&amp;&amp;y&lt;=ty)ans.push_back(P[T[v].location]);if(depth%2==0)&#123;//按x和y分层的构造方式,采取对应的分层查找方法if(T[v].l!=NIL&amp;&amp;x&gt;=sx)find(T[v].l,sx,tx,sy,ty,depth+1,ans);if(T[v].r!=NIL&amp;&amp;x&lt;=tx)find(T[v].r,sx,tx,sy,ty,depth+1,ans);&#125;else&#123;if(T[v].l!=NIL&amp;&amp;y&gt;=sy)find(T[v].l,sx,tx,sy,ty,depth+1,ans);if(T[v].r!=NIL&amp;&amp;y&lt;=ty)find(T[v].r,sx,tx,sy,ty,depth+1,ans);&#125;&#125;int main()&#123;int x,y;scanf(&quot;%d&quot;, &amp;N);for(int i=0;i&lt;N;i++)&#123;scanf(&quot;%d %d&quot;, &amp;x, &amp;y);P[i] = Point(i,x,y);T[i].l = T[i].r = T[i].p = NIL;&#125;np = 0;int root = maketree(0,N,0);//printf(&quot;%d%d\n&quot;,root,P[T[root].location]);int n;scanf(&quot;%d&quot;, &amp;n);int sx,tx,sy,ty;vector&lt;Point&gt; result;for(int j=0;j&lt;n;j++)&#123;scanf(&quot;%d %d %d %d&quot;,&amp;sx,&amp;tx,&amp;sy,&amp;ty);result.clear();find(root,sx,tx,sy,ty,0,result);sort(result.begin(),result.end());for(int i=0;i&lt;result.size();i++)result[i].print();printf(&quot;\n&quot;);&#125;return 0;&#125;]]></content>
      <categories>
        <category>二叉树</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[POJ3666(Making-the-Grade)]]></title>
    <url>%2F2018%2F11%2F17%2FPOJ3666(Making-the-Grade)%2F</url>
    <content type="text"><![CDATA[链接：https://vjudge.net/problem/POJ-3666思路：（本题其实可以只用求递增，数据出的有失误）一直在思考怎么表示状态，猜到了最后结果肯定都是原来的几个数，所以我们可以考虑离散化，考虑到后一位是否要变取决于前一位的最大值，那么我们用dp[i][j]表示枚举到第i个数，且最后一位为第j大的数，转移的话dp[i][j] = min(dp[i-1][1,2,3,….j-1]) +abs(a[i]-c[j])，其实不需要枚举k，用一个变量在递推的时候维护最小值就可以了，好好思考一下离散化+dp的操作。代码：1234567891011121314151617181920212223242526272829303132#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;typedef long long ll;const int maxn = 2010;ll a[maxn];ll c[maxn];int n;ll dp[maxn][maxn];int main()&#123; while(~scanf(&quot;%d&quot;,&amp;n))&#123; memset(c,0,sizeof(c)); for(int i=1;i&lt;=n;i++)scanf(&quot;%lld&quot;,&amp;a[i]),c[i] = a[i]; memset(dp,0,sizeof(dp)); sort(c+1,c+n+1); int len = unique(c+1,c+n+1)-c-1; for(int i=1;i&lt;=n;i++)&#123; //递推时维护最小值 long long minv = dp[i-1][1]; for(int j=1;j&lt;=len;j++)&#123; minv = min(minv,dp[i-1][j]); dp[i][j] = minv+abs(a[i]-c[j]); &#125; &#125; ll res = 1e18; for(int i=1;i&lt;=len;i++)res = min(res,dp[n][i]); printf(&quot;%lld\n&quot;,res); &#125; return 0;&#125;]]></content>
      <categories>
        <category>基础dp</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[POJ-3616(Milking-Time)]]></title>
    <url>%2F2018%2F11%2F17%2FPOJ-3616(Milking-Time)%2F</url>
    <content type="text"><![CDATA[链接：https://vjudge.net/problem/POJ-3616#author=0 思路：dp题，首先构造一个结构保存三个时间点，然后排序。接着用状态转移，当前最大值等于之前某个休息时间外的最大值加上当前的value，所以可以构造出状态转移方程代码：12345678910111213141516171819202122232425262728293031323334353637#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;struct cow&#123; int start,end,value;&#125;;bool cmp(const cow &amp;a1,const cow &amp;a2)&#123; return a1.start&lt;a2.start;&#125;cow a[1001];int dp[1001];int main()&#123; int n,m,r; cin&gt;&gt;n&gt;&gt;m&gt;&gt;r; for(int i=1;i&lt;=m;i++)&#123; cin&gt;&gt;a[i].start&gt;&gt;a[i].end&gt;&gt;a[i].value; &#125; sort(a+1,a+m+1,cmp); for(int i=1;i&lt;=m;i++)&#123; dp[i] = a[i].value; for(int j=1;j&lt;i;j++)&#123; if(a[j].end+r&lt;=a[i].start) dp[i] = max(dp[i],dp[j]+a[i].value); &#125; &#125; int ans = dp[1]; for(int i=2;i&lt;=m;i++)&#123; ans = max(ans,dp[i]); &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;]]></content>
      <categories>
        <category>基础dp</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[POJ-3259(Wormholes)]]></title>
    <url>%2F2018%2F11%2F17%2FPOJ-3259(Wormholes)%2F</url>
    <content type="text"><![CDATA[链接：https://vjudge.net/problem/POJ-3259 思路：一个裸着的判断是否存在负环即可，可用Bellman-Ford算法判断负环的形式，但是一定要注意，秘密通道和走廊是可以同时存在，也就是既要花费时间也要回溯时间。代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;struct edge&#123; int from,to,cost;&#125;;edge es[5500];int d[5500];const int INF = 1e9;int n,m,w,t=0;//Bellman-Ford算法判断负环的形式bool findf()&#123;memset(d,0,sizeof(d)); for(int i=0;i&lt;n;i++)&#123; for(int j=0;j&lt;t;j++)&#123; edge e = es[j]; if(d[e.to]&gt;d[e.from]+e.cost)&#123; d[e.to] = d[e.from] + e.cost; if(i==n-1)return true; &#125; &#125; &#125; return false; &#125;int main()&#123; int q; cin&gt;&gt;q; while(q--)&#123; cin&gt;&gt;n&gt;&gt;m&gt;&gt;w; t = 0; for(int i=0;i&lt;m;i++)&#123; int from,to,cost; cin&gt;&gt;from&gt;&gt;to&gt;&gt;cost; from--; to--; es[t].from = from; es[t].to = to; es[t].cost = cost; t++;//注意这是一个无向图 es[t].from = to; es[t].to = from; es[t].cost = cost; t++; &#125; for(int i=0;i&lt;w;i++)&#123; int from,to,cost; cin&gt;&gt;from&gt;&gt;to&gt;&gt;cost; --from; --to; es[t].from = from; es[t].to = to; es[t].cost = -cost; t++; &#125; if(findf())cout&lt;&lt;&quot;YES\n&quot;; else cout&lt;&lt;&quot;NO\n&quot;; &#125; return 0;&#125;]]></content>
      <categories>
        <category>最短路</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[POJ-3253（Fence-Repair）]]></title>
    <url>%2F2018%2F11%2F17%2FPOJ-3253%EF%BC%88Fence-Repair%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题目链接：https://vjudge.net/problem/POJ-3253意思：一道贪心的题目，要求将木块切成指定的长度，每切一次的开销是切之前的总长度，问最小开销。思考：很自然的想到反向还原，从最终结果还原为完整的一根木块，每次还原的代价就是拼接后的总长度。也就是说每次拼接后，后面再拼接都需要计算当前木块的长度。举个例子，原始有长度为1 3的木块，那么如果第一次拼接他们，后面每次拼接都需要加一次1和3,。而拼接的总次数是一定的，那么很自然的想到从最小的两个开始拼接，接好后算作新的一根，再取最小的两个拼接，一直直到最后拼成完整的一根，这种贪心的正确性是显而易见的。需要注意的是，如果结果本身就是一整根，需要的代价就是这根的长度而不是0，需要特别拿出来。由于最大的木块数目是50000，o（n2）的算法大概率会TL，如果采取优先级队列，每次取出来两根，再拼接放进去，复杂度是o（nlogn），可以满足要求。代码：123456789101112131415161718192021222324252627282930313233343536373839#include&lt;iostream&gt;#include&lt;queue&gt;#include&lt;vector&gt;using namespace std;struct cmp&#123; //重新定义排序方法 bool operator()(int x,int y)&#123; return x&gt;y; &#125;&#125;;priority_queue &lt;int,vector&lt;int&gt; ,cmp&gt; a; //队列储存木块长度int main()&#123; int n; cin&gt;&gt;n; int now; while(n--)&#123; cin&gt;&gt;now; a.push(now); &#125;long long int result = 0; if(a.size()==1)&#123; //等于1的情况需要单独讨论 result+=a.top(); &#125; else&#123; while(a.size()&gt;1)&#123; int now1 = a.top(); a.pop(); int now2 = a.top(); a.pop(); a.push(now1+now2); result+=(now1+now2); &#125; &#125; cout&lt;&lt;result&lt;&lt;endl;return 0;&#125;]]></content>
      <categories>
        <category>贪心</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[POJ-3009（冰壶问题）]]></title>
    <url>%2F2018%2F11%2F17%2FPOJ-3009%EF%BC%88%E5%86%B0%E5%A3%B6%E9%97%AE%E9%A2%98%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题目链接：https://vjudge.net/problem/POJ-3009冰壶问题，又是一道经典dfs问题。思路也比较明确，一开始采取全局变量控制x，y，，代码如下代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;int a[25][25];int q,w,startq,startw,times = 0;int nowx ,nowy;int mins = 11;int gox[4] = &#123;-1,1,0,0&#125;;int goy[4] = &#123;0,0,-1,1&#125;;int go(int i)&#123; if(nowx+gox[i]&gt;=0&amp;&amp;nowx+gox[i]&lt;q&amp;&amp;nowy+goy[i]&gt;=0&amp;&amp;nowy+goy[i]&lt;w)&#123; nowx = nowx + gox[i];nowy = nowy + goy[i];times++; return 1; &#125; else return 0;&#125;void dfs()&#123;for(int i = 0;i&lt;4;i++)&#123; if(times&gt;10)return ; if (go(i))&#123; cout&lt;&lt;times&lt;&lt;&quot; &quot;&lt;&lt; i&lt;&lt;&quot; &quot;&lt;&lt;nowx&lt;&lt;&quot; &quot;&lt;&lt;nowy&lt;&lt;endl; if(a[nowx][nowy]==1)&#123; a[nowx][nowy]=0; nowx = nowx-gox[i]; nowy = nowy-goy[i]; if(a[nowx][nowy]==3)&#123;mins = min(mins,times);a[nowx+gox[i]][nowy+goy[i]] = 1;return ;&#125; else if(a[nowx][nowy]==0)&#123; dfs(); a[nowx+gox[i]][nowy+goy[i]] = 1; return ; &#125; &#125; if(a[nowx][nowy]==0)&#123; i--; dfs(); nowx = nowx-gox[i];nowy = nowy-goy[i];times--; &#125; &#125; else&#123; if(a[nowx][nowy]==3)&#123;mins = min(mins,times);return ;&#125; if(a[nowx][nowy]==0)&#123;dfs();&#125; &#125;&#125;&#125;int main()&#123; while(cin&gt;&gt;w&gt;&gt;q&amp;&amp;q&amp;&amp;w)&#123; mins = 11; times = 0; memset(a,0,sizeof(a)); for(int k=0;k&lt;q;k++)&#123; for(int l=0;l&lt;w;l++)&#123; cin&gt;&gt;a[k][l]; if(a[k][l]==2)&#123;startq = k;startw = l;nowx = k;nowy = l;&#125; &#125; &#125; cout&lt;&lt;startq&lt;&lt;&quot; &quot;&lt;&lt;startw&lt;&lt;endl; dfs(); cout&lt;&lt;mins&lt;&lt;endl; &#125;return 0;&#125; 很快发现了很致命的问题，，一个是关于墙壁边界的判断，因为越界很不好写，还有如果有连续两次移动一步就停止，就会没有办法回溯。。。。 于是在思考怎么控制边界，，突然想到若是把数组开大一点，然后前后都留空，留空的位置值设为-1，这样访问时不会越界，而且可以很方便判断边界，，于是变为：memset(a,-1,sizeof(a));然后再思索：前进的路程上由于连续两次走一步就停会让回溯很麻烦，，干脆将x，y设为局部变量然后先进行移动判断是否下一步走后符合要求再进行移动，若不符合也可以很方便的就变为原来的位置。而且注意求的不是移动步数，而是投掷次数（停止次数）。还有一个点要注意，就是只有在移动过程中碰到1才可以把他变为0，若是静止状态下不能向1的方向走，那同样是1，怎么去判断到底是不是移动状态呢，有一个很巧妙的办法：1234567891011121314151617181920212223void dfs(int x,int y)&#123; times++; if(times&gt;10)return;for(int i = 0;i&lt;4;i++)&#123;int nx = x+gox[i];int ny = y+goy[i];if(a[nx][ny]==1)continue;while(a[nx][ny]==2||a[nx][ny]==0)&#123; nx+=gox[i];ny+=goy[i];&#125;if(a[nx][ny]&lt;0)continue;if(a[nx][ny]==1)&#123; a[nx][ny] = 0; dfs(nx-gox[i],ny-goy[i]); times--; a[nx][ny] = 1;&#125;if(a[nx][ny]==3)&#123; mins = min(times,mins); continue;&#125;&#125;&#125; 如果是移动状态则在其遇到1前必会遇到其他数字的地板，这时就将对移动状态的1判断放在整个判断的最后。而静止放在最前，如果遇到静止直接continue出去。完美解决。 总结一下：本题难点在墙壁的边界判断，以及两个地板1的不同处理上。注意数组录入数据下标不要从0开始，保证第一个数据前有空间可以设置边界从而不会访问越界！！！代码如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;int a[25][25];int q,w,startq,startw,times = 0;int mins = 11; //最大值不会超过10int gox[4] = &#123;-1,1,0,0&#125;;//x方向移动int goy[4] = &#123;0,0,-1,1&#125;;//y方向移动void dfs(int x,int y)&#123; times++; if(times&gt;10)return;for(int i = 0;i&lt;4;i++)&#123;int nx = x+gox[i];int ny = y+goy[i];if(a[nx][ny]==1)continue;//静止状态1的判断while(a[nx][ny]==2||a[nx][ny]==0)&#123;//0和2地板等效，都继续向前走 nx+=gox[i];ny+=goy[i];&#125;if(a[nx][ny]&lt;0)continue;//到了边界就放弃这种移动，并不改变x，y的值if(a[nx][ny]==1)&#123;//移动状态1的判断，同时进行回溯法。 a[nx][ny] = 0; dfs(nx-gox[i],ny-goy[i]); times--; a[nx][ny] = 1;&#125;if(a[nx][ny]==3)&#123; mins = min(times,mins); continue;&#125;&#125;&#125;int main()&#123; while(cin&gt;&gt;w&gt;&gt;q&amp;&amp;q&amp;&amp;w)&#123; mins = 11; times = 0; memset(a,-1,sizeof(a)); for(int k=1;k&lt;=q;k++)&#123; for(int l=1;l&lt;=w;l++)&#123; cin&gt;&gt;a[k][l]; if(a[k][l]==2)&#123;startq = k;startw = l;&#125;//确定起始位置 &#125; &#125; dfs(startq,startw); if(mins==11)cout&lt;&lt;&quot;-1&quot;&lt;&lt;endl; else cout&lt;&lt;mins&lt;&lt;endl; &#125;return 0;&#125;157ms]]></content>
      <categories>
        <category>dfs</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[POJ2912(Rochambeau)]]></title>
    <url>%2F2018%2F11%2F17%2FPOJ2912(Rochambeau)%2F</url>
    <content type="text"><![CDATA[链接：https://vjudge.net/problem/POJ-2912思路：这个题有点意思，如果不是放在并查集专题真不一定会往这个方向去想，首先如果一个人是裁判当且仅当除了他以外的所有人没矛盾以及包括他在内的所有人存在矛盾。所以当除开裁判外所有人的关系是满足模3加法的传递性的，所以我们考虑枚举所有可能为裁判的人，除开他之外所有人维护一个并查集并寻找是否有错误，如果没有的话更新答案，如果存在两个这样的人就不能判断出谁是裁判，如果不存在就无解，否则的话在最后一个矛盾出现的地方就是能判断出裁判的地方（这个地方有些争议，不过因为这个是题意问题就这样吧）代码：~~~ includeincludeincludeusing namespace std; const int maxn = 5000;int par[maxn];int rel[maxn];int n,m; int getroot(int a){ if(par[a]==a)return a; int px = par[a]; par[a] = getroot(par[a]); rel[a] = (rel[a]+rel[px]+3)%3; return par[a];} struct con{ int u,v,w;}ss[maxn]; char ch[1000]; int main(){ while(~scanf(“%d%d”,&amp;n,&amp;m)){ for(int i=0;i&lt;m;i++){ int a,b; char c; scanf(“%d%c%d”,&amp;a,&amp;c,&amp;b); int r; if(c==’&gt;’) r = 1; else if(c==’&lt;’)r = 2; else r = 0; ss[i].u = a; ss[i].v = b; ss[i].w = r; } int nowi = -1; int resj = -1; int tmp = -1; int j; int flag = 1; for(int i=0;i&lt;n;i++){ for(int jj=0;jj&lt;=n;jj++){ par[jj] = jj; rel[jj] = 0; } tmp = -1; for(j=0;j&lt;m;j++){ if(ss[j].u==i||ss[j].v==i)continue; int u = ss[j].u; int v = ss[j].v; int p1 = getroot(u); int p2 = getroot(v); if(p1==p2&amp;&amp;((rel[u]-rel[v]+3)%3)!=ss[j].w){ tmp = j; break; } else if(p1!=p2){ par[p2] = p1; rel[p2] = (-rel[v]-ss[j].w+rel[u]+6)%3; } } if(j==m){//发现一个新成立的答案 if(nowi!=-1){//如果已经有答案存在 printf(“Can not determine\n”); flag = 0; break; } else nowi = i;//没有的话更新答案 } else resj = max(resj,tmp);//更新最后一个矛盾出现的地方 } if(!flag)continue; if(nowi!=-1){ printf(“Player %d can be determined to be the judge after %d lines\n”,nowi,resj+1); } else printf(“Impossible\n”); } return 0;}~]]></content>
      <categories>
        <category>并查集</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[POJ-2442（Sequence）]]></title>
    <url>%2F2018%2F11%2F17%2FPOJ-2442%EF%BC%88Sequence%EF%BC%89%2F</url>
    <content type="text"><![CDATA[链接：https://vjudge.net/problem/POJ-2442一个最大堆的问题，比较简单，按照如下思路：1、将前两组数组降序排序2、将a[0]和 b[0]-b[n] 这n个和入队（优先队列）3、将a[1]-a[n]分别和b[0]-b[n]求和，与队列中最大元素比较，若小于最大元素，最大元素出队，然后入队。4、将队列中的n个最终元素赋给数组a5、输入第3-n组数据，每输入一组完成1-4步骤一次。6、最后倒序输出数组a总结：本题要求6000ms，所以此方法不会TL，虽然容易想但是效率比较低。AC代码：12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;cstring&gt;using namespace std;int a[2100],b[2100];priority_queue&lt;int&gt; all;int main()&#123; int t; int m,n; cin&gt;&gt;t; while(t--)&#123; memset(a,0,sizeof(a)); cin&gt;&gt;m&gt;&gt;n; for(int j=0;j&lt;n;j++)cin&gt;&gt;a[j]; while(--m)&#123; for(int j=0;j&lt;n;j++)cin&gt;&gt;b[j]; sort(a,a+n,greater&lt;int&gt;()); sort(b,b+n,greater&lt;int&gt;()); /*for(int i=0;i&lt;n;i++)&#123; cout&lt;&lt;a[i]; &#125; cout&lt;&lt;endl; for(int i=0;i&lt;n;i++)&#123; cout&lt;&lt;b[i]; &#125; cout&lt;&lt;endl;*/ for(int i=0;i&lt;n;i++)all.push(a[0]+b[i]); for(int i=1;i&lt;n;i++)&#123; for(int j=0;j&lt;n;j++)&#123; if(a[i]+b[j]&lt;all.top())&#123;all.pop();all.push(a[i]+b[j]);&#125; &#125; &#125; for(int i=0;i&lt;n;i++)&#123;a[i] = all.top();all.pop();&#125; &#125; for(int i=n-1;i&gt;0;i--)cout&lt;&lt;a[i]&lt;&lt;" "; cout&lt;&lt;a[0]&lt;&lt;endl; &#125;return 0;&#125;3797ms]]></content>
      <categories>
        <category>贪心</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[POJ-2385(Apple-Catching)]]></title>
    <url>%2F2018%2F11%2F17%2FPOJ-2385(Apple-Catching)%2F</url>
    <content type="text"><![CDATA[链接：https://vjudge.net/problem/POJ-2385#author=SCU2018 思路：dp题，首先找到状态转移关系，有dp[i][j] = max(dp[i-1][j],dp[i-1][j-1])，如果此时所在位置还有苹果，那么dp[i][j]还需+1，注意最后输出的不一定是dp[t][m]，因为可能最大移动步数不需要用完，所以还需要dp[t][k]中寻找最大值。代码：123456789101112131415161718192021222324252627282930#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;using namespace std;int a[1001];int dp[1001][31];int main()&#123; memset(dp,0,sizeof(dp)); int t,m; cin&gt;&gt;t&gt;&gt;m; for(int i=1;i&lt;=t;i++)&#123; cin&gt;&gt;a[i]; &#125; for(int i=1;i&lt;=t;i++)&#123; for(int j=0;j&lt;=m;j++)&#123; if(j==0)dp[i][j] = dp[i-1][j]; else dp[i][j] = max(dp[i-1][j],dp[i-1][j-1]); if(j%2+1==a[i])dp[i][j]++; &#125; &#125; int ans = dp[t][0]; for(int j=1;j&lt;=m;j++)&#123; ans = max(ans,dp[t][j]); &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;]]></content>
      <categories>
        <category>基础dp</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[POJ-2376（Cleaning-Shifts）]]></title>
    <url>%2F2018%2F11%2F17%2FPOJ-2376%EF%BC%88Cleaning-Shifts%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题目链接：https://vjudge.net/problem/POJ-2376意思：贪心题，给定牛的数量和工作时长以及每头牛的工作时间段，要求用最少的牛，覆盖所有的工作时间。思路：先将牛开始的工作时间排序，然后比较他们的结束时间，选择结束的最晚的，一定是最有解，然后从结束的最晚的时间往前找，再在范围内继续寻找结束的最晚的，一直到工作结束。提醒：如1-2，3-4时刻是可以算覆盖整个1-4的工作时间的，结束时间是指把这一个时间干完后再结束，所以应该从最晚时间+1再向前寻找。代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;struct cow&#123; int start,end; &#125;;bool cmp(const cow &amp; a,const cow &amp; b)&#123;//自定义排序 return a.start&lt;b.start;&#125;int main()&#123; int n,t; while(scanf("%d%d",&amp;n,&amp;t)==2)&#123; cow now; std::vector&lt;cow&gt; all; int p = n; while(n--)&#123; scanf("%d%d",&amp;now.start,&amp;now.end); all.push_back(now); &#125; sort(all.begin(),all.end(),cmp); int times = 0; //当前时间 int result = -1; //记录结果 int max = 0; // 当前可以跳至的最大end值 int nexti = 0; //当前的vector数组位置 while(times&lt;t)&#123; while(all[nexti].start&lt;=times+1&amp;&amp;nexti&lt;p)&#123;//一定要记住判断越界啊之前就是没判断不会报错但是就是WA max = max&gt;all[nexti].end?max:all[nexti].end; nexti++; &#125; if(times==max)&#123;result=-1;break;&#125;//如果max的值没有更改说明在原地一直循环，说明没有办法覆盖整个工作时间段，则选择跳出。 times = max; result++; &#125; if(result!=-1)result++; printf("%d\n",result);&#125; return 0;&#125;]]></content>
      <categories>
        <category>贪心</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[POJ1984(Navigation-Nightmare)]]></title>
    <url>%2F2018%2F11%2F17%2FPOJ1984(Navigation-Nightmare)%2F</url>
    <content type="text"><![CDATA[链接：https://vjudge.net/problem/POJ-1984思路：感觉kuangbin系列的并查集都是一个套路啊，维护与根节点的关系，不管是可传递的模加法还是距离实质都是一样的，本题我的做法是先把所有道路全部读入保存，然后再把所有查询读入保存，按照时间先后排序，然后遍历所有查询，每次查询前先把该时间点之前的所有道路都用并查集关系建立起来(在x，y上分别维护关系)，然后查询，如果二者的根节点相同说明之间有路，返回二者x，y距离差的绝对值的和即可，否则一定没有道路，返回-1，最后再按照之前的输入顺序输出答案即可。代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;const int maxn = 400000;int par[maxn];int relx[maxn];int rely[maxn];int n,m,q;int getroot(int a)&#123; if(par[a]==a)return a; int px = par[a]; par[a] = getroot(par[a]); relx[a] = relx[a] + relx[px]; rely[a] = rely[a] + rely[px]; return par[a]; &#125;struct query&#123; int a,b,t,id,res; bool operator&lt;(const query&amp; r)const&#123; return t&lt;r.t; &#125;&#125;ask[maxn];bool cmp(const query &amp;r1,const query &amp;r2)&#123; return r1.id&lt;r2.id;&#125;struct change&#123; int a,b,dx,dy;&#125;cc[maxn];int main()&#123; while(~scanf(&quot;%d%d&quot;,&amp;n,&amp;m))&#123; for(int i=0;i&lt;=n;i++)&#123; par[i] = i; relx[i] = rely[i] = 0; &#125; for(int i=0;i&lt;m;i++)&#123; char ch[10]; int d = 0; scanf(&quot;%d%d%d%s&quot;,&amp;cc[i].a,&amp;cc[i].b,&amp;d,ch); if(ch[0]==&apos;E&apos;)cc[i].dy = d,cc[i].dx = 0; else if(ch[0]==&apos;W&apos;)cc[i].dy = -d,cc[i].dx = 0; else if(ch[0]==&apos;N&apos;)cc[i].dx = -d,cc[i].dy = 0; else if(ch[0]==&apos;S&apos;)cc[i].dx = d,cc[i].dy = 0; &#125; scanf(&quot;%d&quot;,&amp;q); for(int i=0;i&lt;q;i++)&#123; scanf(&quot;%d%d%d&quot;,&amp;ask[i].a,&amp;ask[i].b,&amp;ask[i].t); ask[i].id = i; &#125; sort(ask,ask+q);//按照时间先后顺序排序 int nowi = 0; for(int i=0;i&lt;q;i++)&#123; while(nowi+1&lt;=ask[i].t)&#123;//将该时间点前的所有道路建立处理 int a = cc[nowi].a; int b = cc[nowi].b; int p1 = getroot(a); int p2 = getroot(b); if(p1==p2)continue; par[p2] = p1; //x和y上分别维护关系 relx[p2] = -relx[b]-cc[nowi].dx+relx[a]; rely[p2] = -rely[b]-cc[nowi].dy+rely[a]; nowi++; &#125; int a = ask[i].a; int b = ask[i].b; int p1 = getroot(a); int p2 = getroot(b); if(p1==p2)&#123; ask[i].res = abs(relx[a]-relx[b])+abs(rely[a]-rely[b]); &#125; else ask[i].res = -1; &#125; sort(ask,ask+q,cmp);//还原原来的输入顺序 for(int i=0;i&lt;q;i++)&#123; printf(&quot;%d\n&quot;,ask[i].res); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>并查集</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[POJ1417(True-Liars)]]></title>
    <url>%2F2018%2F11%2F17%2FPOJ1417(True-Liars)%2F</url>
    <content type="text"><![CDATA[链接：https://vjudge.net/problem/POJ-1417思路：首先我们先明白，当a指认b时，ab就已经有关系并且不可分离了，所以自然而然就是并查集，并且为种类并查集，同时满足模2加法运算，即a说b坏人，b说c坏人，那么a和c一定是同类人，我们就这样维护一个种类并查集，完成之后可能有多个块，每个块都可以有两种取值方式，这时候就变成一个01背包问题的变形了，做一次背包然后逆推找到路径即可。(注意并查集完成时并没有全部进行路径压缩，所以要手动压缩一遍！！！切记切记就是在这里错了一天！！！)代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;#include&lt;set&gt;using namespace std;int n,p,q,nn;const int maxn = 1010;int par[maxn];int rel[maxn];int num[maxn];int w[maxn][2];int dp[maxn][maxn];int cho[maxn];int bcc[maxn];int getroot(int a)&#123; if(a==par[a])return a; int px = par[a]; par[a] = getroot(par[a]); rel[a] = (rel[a]+rel[px]+2)%2; return par[a];&#125;void merge(int a,int b,int r)&#123; int p1 = getroot(a); int p2 = getroot(b); if(p1==p2)return; par[p2] = p1; num[p1]+=num[p2]; num[p2] = 0; rel[p2] = (rel[a]+r-rel[b]+2)%2;//根据矢量图得到的转移式子&#125;int main()&#123; while(~scanf(&quot;%d%d%d&quot;,&amp;nn,&amp;p,&amp;q)&amp;&amp;(nn||p||q))&#123; memset(w,0,sizeof(w)); memset(dp,0,sizeof(dp)); memset(bcc,0,sizeof(bcc)); memset(cho,0,sizeof(cho)); n = p+q; for(int i=1;i&lt;=n;i++)&#123; par[i] = i; num[i] = 1; rel[i] = 0; &#125; for(int i=0;i&lt;nn;i++)&#123; int a,b; char ch[10]; scanf(&quot;%d%d%s&quot;,&amp;a,&amp;b,ch); int r; if(ch[0]==&apos;y&apos;)r = 0; else r = 1; merge(a,b,r); &#125; int cnt = 0; for(int i=1;i&lt;=n;i++)&#123; if(num[i])&#123; bcc[i] = ++cnt;//扫描集合的个数 &#125; &#125; for(int i=1;i&lt;=n;i++)&#123; getroot(i);//切记切记一定要手动把所有路径都压缩这样才能完成后面的记数 w[bcc[par[i]]][rel[i]]++; &#125; dp[0][0] = 1; for(int i=1;i&lt;=cnt;i++)&#123; for(int j=0;j&lt;=p;j++)&#123; if(j&gt;=w[i][0])dp[i][j] = dp[i-1][j-w[i][0]]; if(j&gt;=w[i][1])dp[i][j] += dp[i-1][j-w[i][1]]; &#125; &#125; if(dp[cnt][p]==1)&#123;//学习别人简单的寻找路径方法，自己不知道写了些什么乱七八糟的东西 int j = p; for(int i=cnt; i&gt;=1; i--)&#123; if(dp[i][j]==dp[i-1][j-w[i][0]])&#123; cho[i] = 0; j-=w[i][0]; &#125; else if(dp[i][j]==dp[i-1][j-w[i][1]])&#123; cho[i] = 1; j-=w[i][1]; &#125; &#125; for(int i=1;i&lt;=n;i++)&#123; int ff = bcc[par[i]]; if(cho[ff]==rel[i]) printf(&quot;%d\n&quot;,i); &#125; printf(&quot;end\n&quot;); &#125; else printf(&quot;no\n&quot;); &#125; return 0;&#125;]]></content>
      <categories>
        <category>并查集</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[POJ1308(Is-It-A-Tree-)]]></title>
    <url>%2F2018%2F11%2F17%2FPOJ1308(Is-It-A-Tree-)%2F</url>
    <content type="text"><![CDATA[链接：https://vjudge.net/problem/POJ-1308思路：放在并查集专题的，思路是每次合并两个点，如果之前已经合并过了那么一定不能构成一棵树，完成之后检查集合的个数是否为1(即图是否连通)。我这题就想换一个写法，没想到关于树的东西还是一直写不好，到处wa，细节抠不好，所以写篇文章总结下坑点：1、一定要注意空树、单个点、一条链等特殊情况2、一定要注意是否需要判断图是否连通！（各大赛区已经有很多人栽在这同一个坑点上了）3、注意是有向边还是无向边，有向边的树上dfs不需要加父节点判断，而无向边一般是需要的（对比这个专题的最后两个题）。代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;using namespace std;const int maxn = 1e5+100;int vis[maxn],mark[maxn];vector&lt;int&gt; G[maxn];int in[maxn];int a,b;int flag;void dfs(int u)&#123; vis[u] = 1; for(int i=0;i&lt;G[u].size();i++)&#123; int v = G[u][i]; if(vis[v])&#123; flag = 0; return; &#125; dfs(v); &#125;&#125;int main()&#123; int kase = 0; flag = 1; int maxv = 0; int times = 0; while(scanf(&quot;%d%d&quot;,&amp;a,&amp;b))&#123; if((a==0&amp;&amp;b==0)||(a==-1&amp;&amp;b==-1))&#123; if(a==-1)break; printf(&quot;Case %d &quot;,++kase); if(times==0)&#123;//判断空树的情况（又被坑了！！！） printf(&quot;is a tree.\n&quot;); continue; &#125; int num = 0; for(int i=1;i&lt;=maxv;i++)&#123;//找入度为0的点的个数（根节点），不等于1则无解 if(mark[i]&amp;&amp;!in[i])num++; &#125; if(num!=1)flag = 0; else&#123; for(int i=1;i&lt;=maxv;i++)&#123; if(mark[i]&amp;&amp;in[i]==0)&#123;//找根节点做一次dfs，如果是树连通则一定可以遍历所有节点 dfs(i); break; &#125; &#125; for(int i=1;i&lt;=maxv;i++)&#123; if(mark[i]&amp;&amp;!vis[i])flag = 0;//如果有节点没有被遍历到（不连通），则无法构成树 &#125; &#125; if(flag)printf(&quot;is a tree.\n&quot;); else printf(&quot;is not a tree.\n&quot;); for(int i=1;i&lt;=maxv;i++)&#123; G[i].clear(); &#125; memset(vis,0,sizeof(vis)); memset(mark,0,sizeof(mark)); memset(in,0,sizeof(in)); maxv = 0; flag = 1; times = 0; continue; &#125; G[a].push_back(b); in[b]++; maxv = max(maxv,max(a,b)); mark[a] = 1; mark[b] = 1; times++; &#125; return 0;&#125;]]></content>
      <categories>
        <category>并查集</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[POJ1182(食物链)]]></title>
    <url>%2F2018%2F11%2F17%2FPOJ1182(%E9%A3%9F%E7%89%A9%E9%93%BE)%2F</url>
    <content type="text"><![CDATA[链接：https://vjudge.net/problem/POJ-1182思路：由于已经确定了只有三种关系并且为一个圈，我们如果x-&gt;y为0表示同类，x-&gt;y为1表示x吃y，x-&gt;y为2表示y吃x，那么整个关系可以用模3的加法来传递下去，也就是说我们记录某个点到根节点的关系，合并的时候沿途记录到根节点距离模3的值，即可维护与根节点的关系。如果二者根节点不同，那么他们之前一定没有进行过任何相关的操作，此时正常维护二者的关系。否则判断二者关系是否有误即可。（关系并查集和带权并查集合并时关键需要画出矢量图，总是跟矢量密切相关，矢量图画对了关系就有了）代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;cstdio&gt;using namespace std;int n,k;const int maxn = 50010;int par[maxn];int rel[maxn];int getroot(int a)&#123; if(par[a]==a)return a; int px = par[a]; par[a] = getroot(par[a]); rel[a] = (rel[a]+rel[px]+3)%3; return par[a];&#125;int main()&#123; scanf(&quot;%d%d&quot;,&amp;n,&amp;k); for(int i=0;i&lt;=n;i++)&#123; par[i] = i; rel[i] = 0; &#125; int res = 0; for(int i=0;i&lt;k;i++)&#123; int a,b,c; scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c); int p1 = getroot(b); int p2 = getroot(c); if(b&gt;n||c&gt;n)&#123; res++; continue; &#125; if(a==2&amp;&amp;b==c)&#123; res++; continue; &#125; if(p1!=p2)&#123; par[p2] = p1; rel[p2] = (3+a-1+rel[b]-rel[c])%3; &#125; else&#123; if(a==1&amp;&amp;rel[b]!=rel[c])&#123; res++; continue; &#125; if(a==2&amp;&amp;((3-rel[b]+rel[c])%3)!=a-1)&#123; res++; continue; &#125; &#125; &#125; printf(&quot;%d\n&quot;,res); return 0;&#125;]]></content>
      <categories>
        <category>并查集</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[POJ-1077（八数码问题）-双向广搜]]></title>
    <url>%2F2018%2F11%2F17%2FPOJ-1077%EF%BC%88%E5%85%AB%E6%95%B0%E7%A0%81%E9%97%AE%E9%A2%98%EF%BC%89-%E5%8F%8C%E5%90%91%E5%B9%BF%E6%90%9C%2F</url>
    <content type="text"><![CDATA[文章：https://www.jianshu.com/p/a7fbbaddd2b6题目：https://vjudge.net/problem/POJ-1077 双向搜索明显快于单向的bfs，具体bfs细节与单向的类似，参考上一篇文章。双向实现如下代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#include&lt;iostream&gt;#include&lt;map&gt;#include&lt;queue&gt;using namespace std;queue&lt;int&gt; all1,all2;map&lt;int,int&gt; line;int a[9],b[9];map&lt;int,int&gt; distance1,distance2;int flag = 0;int gox[4] = &#123;-1,1,0,0&#125;;int goy[4] = &#123;0,0,-1,1&#125;;void bfs(int *c,queue&lt;int&gt; &amp;all,bool jjj);void getxy(int &amp;x,int &amp;y,int *c)&#123; //0的x，y坐标改为动态获取for(int i=0;i&lt;9;i++)&#123;if(c[i]==0)&#123;x = i/3;y=i%3;return ;&#125;&#125;&#125;int judge(int *c)&#123;return c[8] * 100000000+c[7] * 10000000+c[6] * 1000000+c[5] * 100000+c[4] * 10000+c[3] * 1000+c[2] * 100+c[1] * 10+c[0];&#125;void trans(int n,int *c)&#123;//转化为数组for(int i=0;i&lt;9;i++)&#123;c[i] = n%10;n/=10;&#125;&#125;void dbfs()&#123;//双向广搜if(judge(a)==judge(b))&#123;//单独判断初始状态相等的情况flag = 1;return ;&#125;line[judge(a)] = 1;line[judge(b)] = 2;all1.push(judge(a));all2.push(judge(b));while(!all1.empty()||!all2.empty())&#123;if(flag)return;if(!all1.empty())bfs(a,all1,true);if(flag)return;if(!all2.empty())bfs(b,all2,false);if(flag)return;&#125;&#125;void bfs(int *c,queue&lt;int&gt; &amp;all,bool jjj)&#123;//单向广搜int now = all.front();//取出这一个系列操作的初始状态all.pop();for(int i=0;i&lt;4;i++)&#123;trans(now,c);int x,y;getxy(x,y,c);int tx = x + gox[i];int ty = y + goy[i];if(tx&gt;=0&amp;&amp;tx&lt;3&amp;&amp;ty&gt;=0&amp;&amp;ty&lt;3)&#123;if(jjj)&#123;int temp = c[tx*3+ty];c[tx*3+ty] = c[x*3+y];c[x*3+y] = temp;if(line[judge(c)]==2)&#123;flag = 1;distance1[judge(c)] = distance1[now] + 1;return;&#125;else&#123;if(line[judge(c)]==1)continue;else&#123;//cout&lt;&lt;judge(a)&lt;&lt;&quot; &quot;&lt;&lt;judge(b)&lt;&lt;endl;distance1[judge(c)] = distance1[now] + 1;line[judge(c)] = 1;all.push(judge(c));&#125;&#125;&#125;else&#123;int temp = c[tx*3+ty];c[tx*3+ty] = c[x*3+y];c[x*3+y] = temp;if(line[judge(c)]==1)&#123;flag = 1;distance2[judge(c)] = distance2[now] + 1;return;&#125;else&#123;if(line[judge(c)]==2)continue;else&#123;distance2[judge(c)] = distance2[now] + 1;line[judge(c)] = 2;all.push(judge(c));//cout&lt;&lt;judge(a)&lt;&lt;&quot; &quot;&lt;&lt;judge(b)&lt;&lt;endl;&#125;&#125;&#125;&#125;&#125;&#125;int main()&#123;for(int i=0;i&lt;9;i++)&#123;cin&gt;&gt;a[i];&#125;for(int i=0;i&lt;9;i++)&#123;cin&gt;&gt;b[i];&#125;distance1[judge(a)] = 0;distance2[judge(b)] = 0;//cout&lt;&lt;judge(a)&lt;&lt;&quot; &quot;&lt;&lt;judge(b)&lt;&lt;endl;dbfs();cout&lt;&lt;distance1[judge(a)]+distance2[judge(b)]&lt;&lt;endl;return 0;&#125;]]></content>
      <categories>
        <category>bfs</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[POJ-1077（八数码问题）bfs]]></title>
    <url>%2F2018%2F11%2F17%2FPOJ-1077%EF%BC%88%E5%85%AB%E6%95%B0%E7%A0%81%E9%97%AE%E9%A2%98%EF%BC%89bfs%2F</url>
    <content type="text"><![CDATA[链接：https://vjudge.net/problem/POJ-1077申明：本题没有AC，因为存在多解情况下没有明确说选择哪条路径，所以不同bfs方法出来的最优路径可能有所不同。 第一个练习的bfs问题，采取了比较简化的做法，没有优化纯粹暴力，先说下关键思路。1、用一个九位数来表示当前33棋盘的状态2、用一个map映射line来判重，如果没重复则将值赋为13、用一个map映射distance1来记录距离，每次都在上一个状态上加一的距离4、用一个map映射gogo来记录移动的方法，用string类字符相加即可完成5、正常bfs中queue来作为队列6、用一个trans函数来把9位数还原为33的棋盘 没有什么太大的难点，就是优化以后厉害了再进行吧，现在水平只能写出这个样子了。。。代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include&lt;iostream&gt;#include&lt;queue&gt;#include&lt;cmath&gt;#include&lt;map&gt;#include&lt;string&gt;using namespace std;map&lt;int,int&gt; line; //记录是否出现过当前状态queue&lt;int&gt; all;//bfs队列map&lt;int,int&gt; distance1;//记录距离map&lt;int,string&gt; gogo; //记录移动方式int x,y;//记录当前0所在位置的坐标int a[9];//九宫格数组int gox[4]=&#123;0,0,1,-1&#125;;//x移动方式int goy[4] = &#123;1,-1,0,0&#125;;//y移动方式char go[5] = &quot;udrl&quot;;//移动命令int flag = 0;//判断是否已经求出解int judge()&#123;//转换为9位数return a[8] * 100000000+a[7] * 10000000+a[6] * 1000000+a[5] * 100000+a[4] * 10000+a[3] * 1000+a[2] * 100+a[1] * 10+a[0];&#125;void trans(int re)&#123;//9位数翻译回3*3棋盘if(re==0)return ;for(int i = 0;i&lt;=8;i++)&#123;a[i] = re%10;if(a[i]==0)&#123;x = i/3;y=i%3;&#125;re/=10;&#125;&#125;void bfs()&#123;//广搜int n;//判断并记录队首元素if(!all.empty())&#123;n = all.front();all.pop();&#125;else n = 0;for(int i=0;i&lt;4;i++)&#123;trans(n);int tx = x+gox[i];//移动xint ty = y+goy[i];//移动yif(tx&gt;=0&amp;&amp;tx&lt;3&amp;&amp;ty&gt;=0&amp;&amp;ty&lt;3)&#123;//cout&lt;&lt;judge()&lt;&lt;endl;int temp1 = judge();//储存变化前状态的9位数int temp = a[tx*3+ty];a[tx*3+ty] = 0;a[x*3+y] = temp;x = tx;y = ty;if(line[judge()]==1)continue;else&#123;line[judge()] = 1;all.push(judge());//入队distance1[judge()] = distance1[temp1] + 1;//距离增加gogo[judge()] = gogo[temp1] + go[i];//移动方式更新if(judge()==result)&#123;cout&lt;&lt;gogo[judge()]&lt;&lt;endl;cout&lt;&lt;distance1[judge()]&lt;&lt;endl;flag = 1;return;&#125;&#125;&#125;&#125;bfs();if(flag==1)return;&#125;int main()&#123;int now;for(int i=0;i&lt;9;i++)&#123;cin&gt;&gt;a[i];if(a[i]==0)&#123;x=i/3;y=i%3;&#125;&#125;for(int i=0;i&lt;9;i++)&#123;cin&gt;&gt;now;result+=now*pow(10,i);&#125;distance1[judge()] = 0;//初始化距离gogo[judge()] = &quot;&quot;;//初始化移动方式位空cout&lt;&lt;judge()&lt;&lt;endl;cout&lt;&lt;result&lt;&lt;endl;bfs();return 0;&#125; 好吧上述版本有点问题，例如测试数据：2 6 4 1 3 7 0 5 88 1 5 7 3 6 4 0 2这个要移动31次，原程序递归好像栈溢出了。。。。。。。解决方法：把bfs中的递归改成while循环判断即可。。 代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include&lt;iostream&gt;#include&lt;queue&gt;#include&lt;cmath&gt;#include&lt;map&gt;#include&lt;string&gt;using namespace std;map&lt;int,int&gt; line; //记录是否出现过当前状态queue&lt;int&gt; all;//bfs队列map&lt;int,int&gt; distance1;//记录距离map&lt;int,string&gt; gogo; //记录移动方式int x,y;//记录当前0所在位置的坐标int a[9];//九宫格数组int gox[4]=&#123;0,0,1,-1&#125;;//x移动方式int goy[4] = &#123;1,-1,0,0&#125;;//y移动方式char go[5] = &quot;udrl&quot;;//移动命令int flag = 0;//判断是否已经求出解int judge()&#123;//转换为9位数return a[8]*100000000+a[7]*10000000+a[6]*1000000+a[5]*100000+a[4]*10000+a[3]*1000+a[2]*100+a[1]*10+a[0];&#125;void trans(int re)&#123;//9位数翻译回3*3棋盘if(re==0)return ;for(int i = 0;i&lt;=8;i++)&#123;a[i] = re%10;if(a[i]==0)&#123;x = i/3;y=i%3;&#125;re/=10;&#125;&#125;void bfs()&#123;//广搜int n;//判断并记录队首元素while(flag==0)&#123;n = all.front();all.pop();&#125;else n = 0;for(int i=0;i&lt;4;i++)&#123;trans(n);int tx = x+gox[i];//移动xint ty = y+goy[i];//移动yif(tx&gt;=0&amp;&amp;tx&lt;3&amp;&amp;ty&gt;=0&amp;&amp;ty&lt;3)&#123;//cout&lt;&lt;judge()&lt;&lt;endl;int temp1 = judge();//储存变化前状态的9位数int temp = a[tx*3+ty];a[tx*3+ty] = 0;a[x*3+y] = temp;x = tx;y = ty;if(line[judge()]==1)continue;else&#123;line[judge()] = 1;all.push(judge());//入队distance1[judge()] = distance1[temp1] + 1;//距离增加gogo[judge()] = gogo[temp1] + go[i];//移动方式更新if(judge()==result)&#123;cout&lt;&lt;gogo[judge()]&lt;&lt;endl;cout&lt;&lt;distance1[judge()]&lt;&lt;endl;flag = 1;return;&#125;&#125;&#125;&#125;&#125;&#125;int main()&#123;int now;for(int i=0;i&lt;9;i++)&#123;cin&gt;&gt;a[i];if(a[i]==0)&#123;x=i/3;y=i%3;&#125;&#125;for(int i=0;i&lt;9;i++)&#123;cin&gt;&gt;now;result+=now*pow(10,i);&#125;distance1[judge()] = 0;//初始化距离gogo[judge()] = &quot;&quot;;//初始化移动方式位空cout&lt;&lt;judge()&lt;&lt;endl;cout&lt;&lt;result&lt;&lt;endl;bfs();return 0;&#125;]]></content>
      <categories>
        <category>bfs</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[POJ(3963)(Evacuation-Plan)]]></title>
    <url>%2F2018%2F11%2F17%2FPOJ(3963)(Evacuation-Plan)%2F</url>
    <content type="text"><![CDATA[链接：https://vjudge.net/problem/POJ-3963思路：感觉状态还是很好分析出来，但是有很多细节自己根本没有考虑到导致WA声一片，第一就是输入的顺序不一定是排好序的，所以需要排序，第二是需要按照原来的输入顺序输出，所以需要开一个map记录一下，第三是因为要输出选择的避难所，不能直接更新值（最近做dp老是在犯这个错），所以需要记录一下当前状态的前一个状态是什么，然后一直dfs下去找到最初的状态然后输出。注意因为要保存前一个状态，所以最好的是由前两个状态的最优转移到当前状态而不是由前一个状态转移到两个不同的状态- -代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;map&gt;using namespace std;int n,m;const int maxn = 4010; long long dp[2][maxn];int a[maxn],b[maxn];map&lt;int,int&gt; num1,num2;bool path[maxn][maxn];int id[maxn];void dfs(int u,int v)&#123; if(u==0)return; id[num1[a[u]]] = num2[b[v]]; if(path[u][v]==0) dfs(u-1,v-1); else dfs(u-1,v);&#125;int main()&#123; while(scanf(&quot;%d&quot;,&amp;n)!=EOF)&#123; num1.clear(); num2.clear(); for(int i=1;i&lt;=n;i++)&#123; scanf(&quot;%d&quot;,&amp;a[i]); num1[a[i]] = i; &#125; scanf(&quot;%d&quot;,&amp;m); for(int i=1;i&lt;=m;i++)&#123; scanf(&quot;%d&quot;,&amp;b[i]); num2[b[i]] = i; &#125; memset(path,0,sizeof(path)); for(int i=0;i&lt;2;i++)&#123; for(int j=0;j&lt;=m;j++)&#123; dp[i][j] = 1e18; &#125; &#125; sort(a+1,a+n+1); sort(b+1,b+1+m); dp[0][0] = 0; for(int i=1;i&lt;=n;i++)&#123; int now = i&amp;1;//滚动数组防止mle dp[now][0] = 1e18; for(int j=1;j&lt;=m;j++)&#123; if(dp[now^1][j-1]&lt;=dp[now^1][j])&#123; dp[now][j] = dp[now^1][j-1]+abs(b[j]-a[i]); path[i][j] = 0; &#125; else&#123; dp[now][j] =dp[now^1][j]+abs(b[j]-a[i]); path[i][j] = 1; &#125; &#125; &#125; dfs(n,m); printf(&quot;%lld\n%d&quot;,dp[n&amp;1][m],id[1]); for(int i=2;i&lt;=n;i++)printf(&quot; %d&quot;,id[i]); printf(&quot;\n&quot;); &#125; return 0;&#125;]]></content>
      <categories>
        <category>基础dp</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[POJ(3660)(Cow-Contest-)]]></title>
    <url>%2F2018%2F11%2F17%2FPOJ(3660)(Cow-Contest-)%2F</url>
    <content type="text"><![CDATA[链接：https://vjudge.net/problem/POJ-3660思路：首先一个牛如果排名确定，那么打败它的牛+他打败的牛 = n-1，其次如果a打败b，b打败c，可以确定a打败c，综上我们需要求整个图传递闭包，然后统计每个点的度，度数 = n-1的点就是确定的点代码：123456789101112131415161718192021222324252627282930313233343536#include&lt;cstdio&gt;#include&lt;cstring&gt;int dp[110][110];int point[110];int n,m;int main()&#123; memset(dp,0,sizeof(dp)); scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=0;i&lt;m;i++)&#123; int a,b; scanf(&quot;%d%d&quot;,&amp;a,&amp;b); a--; b--; dp[a][b] = 1; &#125; for(int k=0;k&lt;n;k++)&#123; for(int i=0;i&lt;n;i++)&#123; for(int j=0;j&lt;n;j++)&#123; dp[i][j] = dp[i][j]||(dp[i][k]&amp;&amp;dp[k][j]);//传递闭包 &#125; &#125; &#125; for(int i=0;i&lt;n;i++)&#123; for(int j=0;j&lt;n;j++)&#123; if(dp[i][j]||dp[j][i])&#123; point[i]++; &#125; &#125; &#125; int res = 0; for(int i=0;i&lt;n;i++)if(point[i]==n-1)res++; printf(&quot;%d\n&quot;,res); return 0;&#125;]]></content>
      <categories>
        <category>基础dp</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[POJ（3190）（Stall-Reservations）]]></title>
    <url>%2F2018%2F11%2F17%2FPOJ%EF%BC%883190%EF%BC%89%EF%BC%88Stall-Reservations%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题目链接：https://vjudge.net/problem/POJ-3190意思：每个牛在某个区间工作，需要占用一个牛棚，问至少需要准备多少牛棚，并给出一个分配方案思路：贪心加上优先级队列的题，需要注意，下一头牛开始时间必须是上一头牛结束时间+1才能用同一个牛棚。我采用的是用一个优先级队列（结束时间优先），一个数组排序（开始时间优先），然后一个普通队列（记录哪些牛棚编号可以用）。扫描每一头牛，首先将优先级队列中所有结束时间比当前牛开始时间早的弹出，并将对应牛棚编号压入普通队列（就是更新一遍对于该牛当前哪些牛棚可以用），紧接着先判断队列是否为空，如果为空则需要一个新牛棚，否则可以用空闲的原来有的牛棚，最后把当前牛的信息压入优先级队列，循环扫描所有牛的数据即可得到。代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;struct cow&#123; int start;//开始时间 int end;//结束时间 int num;//给牛的编号 int qq;//牛所用牛棚的编号 bool operator &lt; (const cow &amp; a)const&#123;//优先级队列，结束时间小的优先 return end &gt; a.end; &#125;&#125;;bool cmp(const cow &amp;a1,const cow &amp; a2)&#123;//数组排序，开始时间小的优先 if(a1.start!=a2.start) return a1.start&lt;a2.start; return a2.end&lt;a2.end;&#125;bool cmp2(const cow &amp;a1,const cow &amp; a2)&#123;//数组排序，还原原来输入时的编号顺序 return a1.num&lt;a2.num;&#125;int n;int main()&#123; while(scanf("%d",&amp;n)==1)&#123; vector&lt;cow&gt; all; cow now; for(int i=0;i&lt;n;i++)&#123; scanf("%d%d",&amp;now.start,&amp;now.end); now.num = i+1; all.push_back(now); &#125; sort(all.begin(),all.end(),cmp);//按照开始时间大小排序 int result = 1; queue&lt;int&gt; nowr ;//记录空闲牛棚编号的队列 priority_queue&lt;cow&gt; judge;//以结束时间优先的优先级队列 all[0].qq = 1; judge.push(all[0]); for(int i=1;i&lt;n;i++)&#123; while(all[i].start&gt;judge.top().end)&#123;//更新一遍当前可用牛棚的状态 nowr.push(judge.top().qq); judge.pop(); &#125; if(nowr.size()==0)&#123;//先判断是否为空，为空则增加最小牛棚数量 result++; all[i].qq = result; &#125; if(nowr.size()!=0)&#123;//不为空则用已有的空闲牛棚 all[i].qq = nowr.front(); nowr.pop(); &#125; judge.push(all[i]);//将当前牛状态压入优先级队列并更新 &#125; printf("%d\n",result);sort(all.begin(),all.end(),cmp2); for(int i = 0;i&lt;n;i++)&#123; printf("%d\n",all[i].qq); &#125; &#125;return 0;&#125;]]></content>
      <categories>
        <category>贪心</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[POJ(3126)(Prime-Path)]]></title>
    <url>%2F2018%2F11%2F17%2FPOJ(3126)(Prime-Path)%2F</url>
    <content type="text"><![CDATA[链接：https://vjudge.net/problem/POJ-3126#author=0 思路：一道埃氏筛法 + bfs的题目，因为要测试多个数据所以可以先打印一张五位数内的质数表，然后bfs从起点开始搜索，每次变化一位，然后判断条件并确定是否放入队列，dp数组记录距离（即花费）。代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;queue&gt;using namespace std;const int maxn = 10000;bool isprime[maxn+1];int prime[maxn+1];int dp[maxn+1];int getnext(int num,int t,int change)&#123; if(t==0)return num/10*10+change; else if(t==1)return num/100*100+num%10+change*10; else if(t==2)return num/1000*1000+num%100+change*100; else return num%1000+change*1000;&#125;int main()&#123;//打表 int p = 0; for(int i=0;i&lt;=maxn;i++)isprime[i] = true; isprime[0] = isprime[1] = false; for(int i=2;i&lt;=maxn;i++)&#123; if(isprime[i])&#123; prime[p++] = i; for(int j=2*i;j&lt;=maxn;j+=i)&#123; isprime[j] = false; &#125; &#125; &#125; int n; cin&gt;&gt;n; while(n--)&#123; int a,b; cin&gt;&gt;a&gt;&gt;b; memset(dp,0x3f,sizeof(dp)); dp[a] = 0;//bfs queue&lt;int&gt; q; q.push(a); while(!q.empty())&#123; int cur = q.front(); q.pop(); for(int i=0;i&lt;4;i++)&#123; for(int j=0;j&lt;10;j++)&#123; if(i==3&amp;&amp;j==0)continue; int next = getnext(cur,i,j); if(isprime[next]==false||dp[next]&lt;=dp[cur])continue; dp[next] = dp[cur] + 1; q.push(next); &#125; &#125; &#125; cout&lt;&lt;dp[b]&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>数论</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[POJ(3104)(Drying)]]></title>
    <url>%2F2018%2F11%2F17%2FPOJ(3104)(Drying)%2F</url>
    <content type="text"><![CDATA[链接：https://vjudge.net/problem/POJ-3104#author=169074291 思路：二分法求解，注意有几个细节，最好是将烘干机人工看完每分钟掉水1和额外的每分钟掉水k-1，这样方便后面的计算，还有就是k=0的情况需要单独拿出来讨论，特别注意判断的时候返回true ub = mid，不要形成惯性思维。代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;const int maxn = 1e5+1;int n,k;int a[maxn];bool c(int d)&#123; unsigned long long int minute = 0; for(int i=0;i&lt;n;i++)&#123; int more = a[i] - d; if(more&gt;0)&#123; minute += (more+k-1)/k; //将可整除和不可整除两种情况合二为一 &#125; if(minute&gt;d)return false; &#125; return true;&#125;bool cmp(int &amp;a,int &amp;b)&#123; return a&gt;b;&#125;int main()&#123; while(scanf(&quot;%d&quot;,&amp;n)!=EOF)&#123; for(int i=0;i&lt;n;i++)scanf(&quot;%d&quot;,&amp;a[i]); scanf(&quot;%d&quot;,&amp;k); k--; //分为自然掉水和额外的k-1掉水 if(k==0)&#123;//k=0的情况需要单独讨论 printf(&quot;%d\n&quot;,*max_element(a,a+n)); &#125; else&#123; int lb = 0; int ub = *max_element(a,a+n); sort(a,a+n,cmp); while(ub-lb&gt;1)&#123; int mid = (ub+lb)/2; if(c(mid))ub = mid;//一定注意true的时候到底是往哪边走 else lb = mid; &#125; printf(&quot;%d\n&quot;,ub); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>二分</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[POJ(3034)(ACM-Computer-Factory)]]></title>
    <url>%2F2018%2F11%2F17%2FPOJ(3034)(ACM-Computer-Factory)%2F</url>
    <content type="text"><![CDATA[链接：https://vjudge.net/problem/POJ-3436思路：网络流题目，建图是一个难点，首先要用g[][]储存每个工厂的每种零件的情况，然后用G表示网络流里面的边，将一个工厂拆成两个点，分别对应生产厂和出产厂，两个点之间的流量为单位小时的生产值，建立一个源点和汇点，源点连向所需原料不含1的生产厂，流量为无穷，产品全为1的出产厂与汇点相连，流量为无穷，然后出产厂产品和生产厂的产品和原料对应相等且不为同一个点拆分出来的生产厂和出产厂之间连线，流量为无穷，即可建立好图。至于路径，备份原图，然后生产厂到汇点+出产厂进行搜索，和原图流量不一致的地方即为路径。代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182/************************************************************************* &gt; File Name: acmcomputerfactory.cpp &gt; Author: &gt; Mail: &gt; Created Time: Wed 01 Aug 2018 07:34:32 PM CST ************************************************************************/#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;#include&lt;queue&gt;#include&lt;cstring&gt;using namespace std;int n,m;int G[120][120],GC[120][120];const int INF = 0x3f3f3f3f;int vis[120];int Layer[120];int g[120][120];int q[120];struct factory&#123;int a1,a2,a3;&#125;;bool countlayer()&#123; memset(Layer,0xff,sizeof(Layer)); Layer[0] = 0; deque&lt;int&gt; q; q.push_back(0); while(!q.empty())&#123; int v = q.front(); q.pop_front(); for(int i=0;i&lt;=2*n+1;i++)&#123; if(G[v][i]&gt;0&amp;&amp;Layer[i]==-1)&#123; Layer[i] = Layer[v] + 1; if(i==2*n+1)return true; q.push_back(i); &#125; &#125; &#125; return false;&#125;int Dinic()&#123; int i; int s; deque&lt;int&gt; q; int MaxFlow = 0; while(countlayer())&#123; q.push_back(0); memset(vis,0,sizeof(vis)); vis[0] = 1; while(!q.empty())&#123; int nd = q.back(); if(nd==2*n+1)&#123; int nminc = INF; int nminc_vs = 0; for(i=1;i&lt;q.size();i++)&#123; int vs = q[i-1]; int ve = q[i]; if(G[vs][ve]&gt;0)&#123; if(nminc&gt;G[vs][ve])&#123; nminc = G[vs][ve]; nminc_vs = vs; &#125; &#125; &#125; MaxFlow+=nminc; for(i=1;i&lt;q.size();i++)&#123; int vs = q[i-1]; int ve = q[i]; G[vs][ve]-=nminc; G[ve][vs]+=nminc; &#125; while(!q.empty()&amp;&amp;q.back()!=nminc_vs)&#123; vis[q.back()] = 0; q.pop_back(); &#125; &#125; else&#123; for(i=1;i&lt;=2*n+1;i++)&#123; if(G[nd][i]&gt;0&amp;&amp;Layer[i]==Layer[nd]+1&amp;&amp;!vis[i])&#123; vis[i] = 1; q.push_back(i); break; &#125; &#125; if(i&gt;2*n+1) q.pop_back(); &#125; &#125; &#125; return MaxFlow;&#125;int main()&#123; while(cin&gt;&gt;m&gt;&gt;n)&#123; memset(G,0,sizeof(G)); memset(GC,0,sizeof(GC)); for(int j=1;j&lt;=n;j++)&#123; cin&gt;&gt;q[j]; for(int i=1;i&lt;=m;i++)&#123; cin&gt;&gt;g[j][i]; &#125; for(int i=1;i&lt;=m;i++)&#123; cin&gt;&gt;g[j+n][i]; &#125; &#125; //拆点 for(int i=1;i&lt;=n;i++)&#123; G[i][i+n] = q[i]; &#125;//源点到不需要原料的生产厂 for(int i=1;i&lt;=n;i++)&#123; bool flag = true; for(int j=1;j&lt;=m;j++)&#123; if(g[i][j]!=0&amp;&amp;g[i][j]!=2)&#123; flag = false; break; &#125; &#125; if(flag)G[0][i] = INF; &#125;//出产厂到匹配的生产厂 for(int i=1;i&lt;=n;i++)&#123; bool flag = true; for(int j=1;j&lt;=m;j++)&#123; if(g[i+n][j]!=1)&#123; flag = false; break; &#125; &#125; if(flag) G[i+n][2*n+1] = INF; &#125;//出产厂到汇点 for(int i=n+1;i&lt;=2*n+1;i++)&#123; for(int j=1;j&lt;=n;j++)&#123; bool flag = true; for(int k=1;k&lt;=m;k++)&#123; if(!(g[i][k]==g[j][k]||g[j][k]==2))&#123; flag = false; break; &#125; &#125; if(flag)&#123; G[i][j] = INF; &#125; &#125; &#125;//备份 for(int i=0;i&lt;=2*n+1;i++)&#123; for(int j=0;j&lt;=2*n+1;j++)&#123; GC[i][j] = G[i][j]; &#125; &#125; cout&lt;&lt;Dinic()&lt;&lt;&quot; &quot;; int cnt = 0;vector&lt;factory&gt; v;//寻找路径for(int i=n+1;i&lt;=2*n+1;i++)&#123; for(int j=1;j&lt;=n;j++)&#123; if(i-n!=j&amp;&amp;G[i][j]!=GC[i][j])&#123; cnt++; factory tmp; tmp.a1 = i-n; tmp.a2 = j; tmp.a3 = GC[i][j] - G[i][j]; v.push_back(tmp); &#125; &#125;&#125;cout&lt;&lt;cnt&lt;&lt;endl;for(int i=0;i&lt;v.size();i++)&#123; cout&lt;&lt;v[i].a1&lt;&lt;&quot; &quot;&lt;&lt;v[i].a2&lt;&lt;&quot; &quot;&lt;&lt;v[i].a3&lt;&lt;endl;&#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>网络流</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[POJ(2942)(Knights-of-the-Round-Table-)]]></title>
    <url>%2F2018%2F11%2F17%2FPOJ(2942)(Knights-of-the-Round-Table-)%2F</url>
    <content type="text"><![CDATA[链接：https://vjudge.net/problem/POJ-2942思路：本来算是一个多个算法的综合模板题，但是我不熟悉就拿来熟悉模板了，大概就是先用tarjan求出双连通分量，然后利用二分图对每个分量染色，并将能成功染色（必定为奇圈）的顶点标记，最后没标记的点就不能参加会议代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;using namespace std;const int maxn = 1001;vector&lt;int&gt; G[1001],bcc[1001];int odd[1001],color[1001];int dfn[1001];int low[1001];int iscut[1001];int bccno[1001];int ntime;int n,m,bcc_cnt;struct edge&#123; int u,v; edge()&#123;&#125; edge(int uu,int vv):u(uu),v(vv)&#123;&#125;&#125;;deque&lt;edge&gt; edges;//tarjan模板void tarjan(int u,int f)&#123; int i,j,k; int child = 0;//low在这里代表非父边所能连到的最早的结点的时间（与求强连通分量时候的low数组意思不一样，一定注意！），dfn表示该结点的开始搜索时间，初始时间dfn等于low low[u] = dfn[u] = ++ntime; for(i=0;i&lt;G[u].size();i++)&#123; int v = G[u][i]; if(!dfn[v])&#123; child++;//统计孩子个数，为1且没有父节点的话则为割顶 edges.push_back(edge(u,v)); tarjan(v,u); low[u] = min(low[u],low[v]);//更新最早的时间 if(dfn[u]&lt;=low[v])&#123; edge tmp; iscut[u] = 1;//bcc_cnt用来记录双连通分量个数，bcc数组用来记录其中有哪些顶点 bcc_cnt++; bcc[bcc_cnt].clear(); do&#123; tmp = edges.back(); edges.pop_back(); if(bccno[tmp.u]!=bcc_cnt)&#123; bcc[bcc_cnt].push_back(tmp.u); bccno[tmp.u] = bcc_cnt; &#125; if(bccno[tmp.v]!=bcc_cnt)&#123; bcc[bcc_cnt].push_back(tmp.v); bccno[tmp.v] = bcc_cnt; &#125; &#125;while(!(tmp.u==u&amp;&amp;tmp.v == v)); &#125; &#125;//如果v能连回之前的结点且不是他自己的父节点 else if(dfn[v]&lt;dfn[u]&amp;&amp;v!=f)&#123; edges.push_back(edge(u,v)); low[u] = min(low[u],dfn[v]); &#125; &#125; if(f&lt;0&amp;&amp;child==1)iscut[u] = 0;//标记为割顶&#125;void find_bcc(int n)&#123; memset(dfn,0,sizeof(dfn)); memset(iscut,0,sizeof(iscut)); memset(bccno,0,sizeof(bccno)); ntime = bcc_cnt = 0; for(int i=0;i&lt;n;i++)&#123; if(!dfn[i])tarjan(i,-1); &#125;&#125;//二分图利用dfs染色bool bipartite(int u,int b)&#123; for(int i=0;i&lt;G[u].size();i++)&#123; int v = G[u][i]; if(bccno[v]!=b)continue; if(color[v]==color[u])return false; if(!color[v])&#123; color[v] = 3-color[u]; if(!bipartite(v,b))return false; &#125; &#125; return true;&#125;int A[1001][1001];int main()&#123; int kase = 0; while(scanf("%d%d",&amp;n,&amp;m)&amp;&amp;n)&#123; for(int i=0;i&lt;n;i++)G[i].clear(); memset(A,0,sizeof(A)); for(int i=0;i&lt;m;i++)&#123; int u,v; scanf("%d%d",&amp;u,&amp;v); u--; v--; A[u][v] = A[v][u] = 1; &#125; for(int u=0;u&lt;n;u++)&#123; for(int v=u+1;v&lt;n;v++)&#123; if(!A[u][v])&#123; G[u].push_back(v); G[v].push_back(u); &#125; &#125; &#125; find_bcc(n); memset(odd,0,sizeof(odd)); for(int i=1;i&lt;=bcc_cnt;i++)&#123; memset(color,0,sizeof(color)); for(int j=0;j&lt;bcc[i].size();j++) bccno[bcc[i][j]] = i;//处理割顶 int u = bcc[i][0]; color[u] = 1; if(!bipartite(u,i)) for(int j=0;j&lt;bcc[i].size();j++) odd[bcc[i][j]] = 1;//可以参加会议 &#125; int ans = n; for(int i=0;i&lt;n;i++)if(odd[i])ans--; printf("%d\n",ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>tarjan强连通分量</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[POJ(2240)(Arbitrage)]]></title>
    <url>%2F2018%2F11%2F17%2FPOJ(2240)(Arbitrage)%2F</url>
    <content type="text"><![CDATA[链接：https://vjudge.net/problem/POJ-2240思路：题目要求通过一系列汇率转换，可否使最后赚钱。这是一个很典型的最小生成树（其实是最大生成树）问题，类似的还有收取手续费兑换的汇率问题，大概思路就是指定一个初始金额，然后对每一个点的金额进行更新，如果第n次还在更新，说明存在正环，此时就可以通过兑换赚钱。由于本题没有指定开始的点，所以所有的点都要搜索一遍。代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172/************************************************************************* &gt; File Name: arbitrage.cpp &gt; Author: &gt; Mail: &gt; Created Time: Mon 30 Jul 2018 11:07:05 PM CST ************************************************************************/#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;map&gt;using namespace std;int n,m;map&lt;string,int&gt; trans;//记录货币的序号double d[31];//记录汇率struct edge&#123;int from,to; double cost; edge()&#123;&#125; edge(int fromm,int too,double costt)&#123; from = fromm; to = too; cost = costt; &#125;&#125;es[901];bool shortpath(int w)&#123;for(int i=0;i&lt;n;i++)d[i] = 0;//注意是最大生成树，所以初始化为0或者无穷小 d[w] = 10; for(int i=0;i&lt;n;i++)&#123; for(int j=0;j&lt;m;j++)&#123; edge e = es[j]; if(d[e.from]!=0&amp;&amp;d[e.to]&lt;d[e.from]*e.cost)&#123; d[e.to] = d[e.from]*e.cost; if(i==n-1)return true;//如果更新了n次，则有正环 &#125; &#125; &#125; return false;&#125;int main()&#123; int o = 0; freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin); freopen(&quot;out.txt&quot;,&quot;w&quot;,stdout); while(cin&gt;&gt;n&amp;&amp;n)&#123; string s,ss; double t; for(int i=0;i&lt;n;i++)&#123; cin&gt;&gt;s; trans[s] = i; &#125; cin&gt;&gt;m; for(int i=0;i&lt;m;i++)&#123; cin&gt;&gt;s&gt;&gt;t&gt;&gt;ss; es[i].from = trans[s]; es[i].to = trans[ss]; es[i].cost = t; &#125; int judge = 0;//搜索所有的点作为起点 for(int i=0;i&lt;n;i++)&#123; if(shortpath(i))judge = 1; &#125; if(judge)cout&lt;&lt;&quot;Case &quot;&lt;&lt;++o&lt;&lt;&quot;: Yes&quot;&lt;&lt;endl; else cout&lt;&lt;&quot;Case &quot;&lt;&lt;++o&lt;&lt;&quot;: No&quot;&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>最小生成树</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[POJ(1930)(Dead-Fraction)(辗转相除法)]]></title>
    <url>%2F2018%2F11%2F17%2FPOJ(1930)(Dead-Fraction)(%E8%BE%97%E8%BD%AC%E7%9B%B8%E9%99%A4%E6%B3%95)%2F</url>
    <content type="text"><![CDATA[链接：https://vjudge.net/problem/POJ-1930#author=laguna 思路：要用到数论，一开始也不懂，贴在这里吧一，纯循环小数化分数：循环节的数字除以循环节的位数个9组成的整数。例如：0.3333……=3/9=1/3；0.285714285714……=285714/999999＝2/7.二，混循环小数：（例如：0.24333333……）不循环部分和循环节构成的的数减去不循环部分的差，再除以循环节位数个9添上不循环部分的位数个0。例如：0.24333333…………=(243-24)/900=73/3000.9545454…………=(954-9)/990=945/990=21/22 注意到题目中说的循环节是可以选定的，要求分母最小，那么可以从最后一位开始枚举，找到分母最小的即可代码：123456789101112131415161718192021222324252627282930313233343536#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;using namespace std;int gcd(int a,int b)&#123; if(a==0)return b; return gcd(b%a,a);&#125;int main()&#123; char str[200]; int num,k,all,a,b,i,j,mina,minb,l; while(cin&gt;&gt;str&amp;&amp;strcmp(str,"0"))&#123; mina = minb = 1e9; for(i=2,all=0,l=0;str[i]!='.';i++)&#123; all = all*10+str[i]-48; l++; &#125; for(num=all,k=1,i=1;i&lt;=l;i++)&#123; num/=10; k*=10; a = all-num; b = (int)pow(10.0,l-i)*(k-1); j = gcd(a,b); if(b/j&lt;minb)&#123;//选定分母最小的结果 mina = a/j;minb = b/j; &#125; &#125; cout&lt;&lt;mina&lt;&lt;'/'&lt;&lt;minb&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>数论</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[POJ(1797)(Silver-Cow-Party)]]></title>
    <url>%2F2018%2F11%2F17%2FPOJ(1797)(Silver-Cow-Party)%2F</url>
    <content type="text"><![CDATA[链接：https://vjudge.net/problem/POJ-3268思路：求1-n路径上最小边权值的最大值，用最短路模拟即可，只是d改为从根节点到当前节点边上边权值的最小值，注意此时要求最大值所以队列要出优先最大值，如果是求最大权值边的最小值则队列优先出最小值。代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;queue&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;functional&gt;using namespace std;const int maxn = 1010;int n,m;int dp[maxn];typedef pair&lt;int,int&gt; P;struct edge&#123; int from,to,dist; edge()&#123;&#125; edge(int f,int t,int d):from(f),to(t),dist(d)&#123;&#125;&#125;;struct Dijkstra&#123; int n,m; vector&lt;edge&gt; edges; vector&lt;int&gt; G[maxn]; int d[maxn]; int p[maxn]; int vis[maxn]; void init(int n)&#123; this-&gt;n = n; for(int i=0;i&lt;n;i++)G[i].clear(); edges.clear(); &#125; void addedge(int from,int to,int dist)&#123; edges.push_back(edge(from,to,dist)); m = edges.size(); G[from].push_back(m-1);//放入的是edges中的编号 &#125; void dijkstra()&#123; memset(vis,0,sizeof(vis)); priority_queue&lt;P,vector&lt;P&gt;,less&lt;P&gt; &gt; Q;//优先队列最大值优先出队 memset(d,0,sizeof(d)); for(int i=0;i&lt;=n;i++)d[i] = -1e9; d[0] = 1e9; Q.push(P(d[0],0)); while(!Q.empty())&#123; P p1 = Q.top(); Q.pop(); int v = p1.second; if(vis[v])continue; vis[v] = 1; for(int i=0;i&lt;G[v].size();i++)&#123; edge&amp; e = edges[G[v][i]]; if(!vis[e.to]&amp;&amp;d[e.to]&lt;min(d[v],e.dist))&#123; d[e.to] = min(d[v],e.dist); Q.push(P(d[e.to],e.to)); &#125; &#125; &#125; &#125; void output(int s,int e,vector&lt;int&gt;&amp; path)&#123; int pos=e; while(1)&#123; path.push_back(pos); if(pos==s) break; pos=p[pos]; &#125; &#125;&#125;solver;int main()&#123; int t; scanf(&quot;%d&quot;,&amp;t); for(int i=1;i&lt;=t;i++)&#123; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); solver.init(n); for(int j=0;j&lt;m;j++)&#123; int a,b,c; scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c); a--; b--; solver.addedge(a,b,c); solver.addedge(b,a,c); &#125; solver.dijkstra(); printf(&quot;Scenario #%d:\n%d\n\n&quot;,i,solver.d[n-1]); &#125; return 0;&#125;]]></content>
      <categories>
        <category>最短路</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[POJ(1062)(昂贵的聘礼)]]></title>
    <url>%2F2018%2F11%2F17%2FPOJ(1062)(%E6%98%82%E8%B4%B5%E7%9A%84%E8%81%98%E7%A4%BC)%2F</url>
    <content type="text"><![CDATA[链接：https://vjudge.net/problem/POJ-1062#author=0思路：题目描述有点别扭，第一次被误导了以为是不能比之前交易低的交易，没想到只是背景后来改变规则了，要求的是阶级不超过m的可以交易（所有交易中的最大和最小），那么就肯定不能单笔交易比较阶级了，我们考虑枚举一下阶级的范围，因为必须要包含酋长的阶级，所以区间在[酋长阶级-m,酋长阶级+m]中长度为m的连续子区间，那么跑最短路时判断一下当前边的两边是否在区间内，如果在内则更新，不在内不更新，最后取所有跑的最短路中的最小值即可。代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include&lt;cstdio&gt;#include&lt;queue&gt;#include&lt;functional&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;vector&gt;using namespace std;typedef pair&lt;int,int&gt; P;int n,rr;int sx,ex;struct edge&#123; int from,to,dist; edge(int f,int t,int d)&#123; from = f; to = t; dist = d; &#125;&#125;;const int maxn = 110;struct Dij&#123; int d[maxn]; int r[maxn]; vector&lt;int&gt; G[maxn]; vector&lt;edge&gt; edges; int n,m; void init(int n)&#123; this-&gt;n = n; for(int i=0;i&lt;=n;i++)G[i].clear(); edges.clear(); memset(r,0,sizeof(r)); &#125; void addedge(int from,int to,int dist)&#123; edges.push_back(edge(from,to,dist)); m = edges.size(); G[from].push_back(m-1); &#125; void dij(int w)&#123; for(int i=0;i&lt;=n;i++)d[i] = 1e9; d[w] = 0; priority_queue&lt;P,vector&lt;P&gt;,greater&lt;P&gt; &gt; q; q.push(P(0,w)); while(!q.empty())&#123; P p = q.top(); q.pop(); int u = p.second; if(r[u]!=-1&amp;&amp;(d[u]&lt;p.first||r[u]&gt;ex||r[u]&lt;sx))continue;//判断边起点是否合法，注意起点0要单独特判-1 for(int i=0;i&lt;G[u].size();i++)&#123; edge e = edges[G[u][i]]; if(d[e.to]&gt;d[u] + e.dist&amp;&amp;r[e.to]&lt;=ex&amp;&amp;r[e.to]&gt;=sx)&#123;//判断边终点是否在枚举的区间内 d[e.to] = d[u] + e.dist; q.push(P(d[e.to],e.to)); &#125; &#125; &#125; &#125;&#125;solver;int k;int cost;vector&lt;P&gt; mat[maxn];int main()&#123; while(~scanf(&quot;%d%d&quot;,&amp;rr,&amp;n))&#123; solver.init(n); solver.r[0] = -1; for(int i=0;i&lt;=n;i++)mat[i].clear(); for(int i=1;i&lt;=n;i++)&#123; scanf(&quot;%d%d%d&quot;,&amp;cost,&amp;solver.r[i],&amp;k); solver.addedge(0,i,cost); int nn; for(int j=0;j&lt;k;j++)&#123; scanf(&quot;%d%d&quot;,&amp;nn,&amp;cost); mat[i].push_back(P(nn,cost)); &#125; &#125; for(int i=1;i&lt;=n;i++)&#123; for(int j=0;j&lt;mat[i].size();j++)&#123; pair&lt;int,int&gt; p = mat[i][j]; solver.addedge(p.first,i,p.second); &#125; &#125; int res = 1e9; for(sx=solver.r[1]-rr;sx&lt;=solver.r[1];sx++)&#123;//枚举区间跑最短路 ex = sx + rr; solver.dij(0); res = min(res,solver.d[1]);;//更新最小值 &#125; printf(&quot;%d\n&quot;,res); &#125; return 0;&#125;]]></content>
      <categories>
        <category>最短路</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[POJ(1042)(Gone-Fishing)]]></title>
    <url>%2F2018%2F11%2F17%2FPOJ(1042)(Gone-Fishing)%2F</url>
    <content type="text"><![CDATA[链接：https://vjudge.net/problem/POJ-1042思路：贪心题。首先中途花费的时间总和只跟最终的终点有关，所以考虑枚举终点。然后用一个优先队列储存当前能钓鱼的总量，每次取出最大的，然后减去减少量再放入队列，注意如果存在相等的钓鱼总量则取鱼塘序号（靠前面）较小的哪一个，然后一直直到时间]]></content>
      <categories>
        <category>贪心</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Points-and-Powers-of-Two]]></title>
    <url>%2F2018%2F11%2F17%2FPoints-and-Powers-of-Two%2F</url>
    <content type="text"><![CDATA[题目链接：http://codeforces.com/contest/988/problem/D意思：从一堆数中选一个最大子集，使得任意两个数相减的绝对值都是2的幂。思考：首先很难的一点，需要想到子集最多只能有三个，四个及以上的子集一定不存在（可以下去证明一下），有了这一条，我们可以考虑从三个的开始搜索，用set集合储存并对齐进行遍历。当有三个元素时，则必有其中两对元素之差相等（自行证明），那么可以对set中元素加上2的某次幂，减去2的某次幂，然后判断是否再set中，是的话即可输出。 对于两个元素和一个元素类比。（注意如果集合中只有一个元素不管是否为2的幂都要输出。） 注意：&lt;&lt;位运算优先级比+低，需要打括号。代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include&lt;iostream&gt;#include&lt;set&gt;using namespace std;set&lt;long long int&gt; a;int main()&#123; long long int n; cin&gt;&gt;n; long long int now; while(n--)&#123; cin&gt;&gt;now; a.insert(now); &#125; if(a.size()==1)&#123; for(int i:a)&#123; cout&lt;&lt;&quot;1\n&quot;&lt;&lt;i&lt;&lt;endl; &#125; &#125;else&#123;int judge = 1;//判断是否已经存在解 for(long long int i:a)&#123; if(!judge)break; for(int j=0;j&lt;32;j++)&#123; if(a.count(i-(1LL&lt;&lt;j))&amp;&amp;a.count(i+(1LL&lt;&lt;j)))&#123; cout&lt;&lt;&quot;3\n&quot;&lt;&lt;i&lt;&lt;&quot; &quot;&lt;&lt;(i+(1LL&lt;&lt;j))&lt;&lt;&quot; &quot;&lt;&lt;(i-(1LL&lt;&lt;j))&lt;&lt;endl;//i-2的幂，i,i+2的幂 都要在set内即有解 judge = 0; break; &#125; &#125; &#125; if(judge)&#123; for(long long int i:a)&#123; if(!judge)break; for(int j=0;j&lt;32;j++)&#123; if(a.count(i+(1LL&lt;&lt;j)))&#123; cout&lt;&lt;&quot;2\n&quot;&lt;&lt;i&lt;&lt;&quot; &quot;&lt;&lt;(i+(1LL&lt;&lt;j))&lt;&lt;endl; judge = 0; break; &#125; &#125; &#125; &#125;if(judge)&#123; for(int i:a)&#123; if(!judge)break; for(int j=0;j&lt;32;j++)&#123; if(i==(1LL&lt;&lt;j))&#123; cout&lt;&lt;&quot;1\n&quot;&lt;&lt;i&lt;&lt;endl; judge = 0; break; &#125; &#125; &#125; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>状压dp</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Openjudge(课程大作业)]]></title>
    <url>%2F2018%2F11%2F17%2FOpenjudge(%E8%AF%BE%E7%A8%8B%E5%A4%A7%E4%BD%9C%E4%B8%9A)%2F</url>
    <content type="text"><![CDATA[链接：https://vjudge.net/problem/OpenJ_Bailian-4149 思路：dp+状态压缩，首先最小扣分只跟选什么课程有关，一旦课程选定那么最小扣分也就选定了。所以状态压缩可以用二进制01;来表示是否选这门课。代码：~~~ includeincludeincludeincludeincludeusing namespace std; int t,n; //记录课程的结束时间，需要花费的时间struct homework{string name; int d,c;}hw[20]; //记录路径，最小扣分以及最后结束的天数，用于dpstruct node{ int pre; int minscore; int last; int finishday;}dp[(1&lt;&lt;16)+20]; //返回路径vector getpath(int status){ vector path; while(status){ path.push_back(dp[status].last); status = dp[status].pre; } reverse(path.begin(),path.end()); return path;} int main(){ cin&gt;&gt;t; while(t—){ cin&gt;&gt;n; char name[60]; int d,c; for(int i=0;i&gt;hw[i].name&gt;&gt;hw[i].d&gt;&gt;hw[i].c; dp[0].finishday = 0; dp[0].minscore = 0; dp[0].pre = -1; int m = 1&lt;&lt;n; for(int i=1;i&lt;m;++i){ dp[i].minscore = 1&lt;&lt;30; for(int j=0;j&lt;n;++j){ if(i&amp;(1&lt;&lt;j)){ //枚举最后一个做的课程是什么 int pre = i - (1&lt;&lt;j); // 上一个课程 int finishday = dp[pre].finishday + hw[j].c; int tmpscore = finishday - hw[j].d; if(tmpscore&lt;0)tmpscore = 0; if(dp[i].minscore&gt;dp[pre].minscore + tmpscore){ dp[i].minscore = dp[pre].minscore + tmpscore; dp[i].pre = pre; dp[i].finishday = finishday; dp[i].last = j; } if(dp[i].minscore==dp[pre].minscore+tmpscore){ vector&lt;int&gt; p1 = getpath(dp[i].pre); vector&lt;int&gt; p2 = getpath(pre); if(p2&lt;p1){ dp[i].pre = pre; dp[i].finishday = finishday; dp[i].last = j; } } } } } cout&lt;&lt;dp[m-1].minscore&lt;&lt;endl; int status = m-1; vector&lt;int&gt; path = getpath(status); for(int i=0;i&lt;path.size();i++)cout&lt;&lt;hw[path[i]].name&lt;&lt;endl; } return 0; }]]></content>
      <categories>
        <category>状压dp</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[OpenJudge(硬币)]]></title>
    <url>%2F2018%2F11%2F17%2FOpenJudge(%E7%A1%AC%E5%B8%81)%2F</url>
    <content type="text"><![CDATA[链接：https://vjudge.net/problem/OpenJ_Bailian-4120思路：首先分析，如果一种硬币必须，那么除开这种硬币，就没法达到预期x的值，所以想着遍历所有硬币，除开当前硬币进行dp，如果能得到最后x值则不是必须的，反之为必须的，这样的复杂度为O（mn^2），超时，及时加了优化也不行。后来发现，其实很多部分重新计算了，不如计算出每种钱j选法的次数g[j]，如果g[x]=0，那么当前硬币就是必需的。这种方法的复杂度O（mn）代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;using namespace std;const int maxn = 201;int a[maxn];int f[10001];int g[10001];int n,x,t=0;int b[maxn];int main()&#123; scanf(&quot;%d%d&quot;,&amp;n,&amp;x); memset(b,0,sizeof(b)); for(int i=0;i&lt;n;++i)scanf(&quot;%d&quot;,&amp;a[i]); f[0] = 1; for(int i=0;i&lt;n;++i)&#123; for(int j=x;j&gt;=a[i];--j)&#123; f[j] += f[j-a[i]]; &#125; &#125; for(int i=0;i&lt;n;i++)&#123; memset(g,0,sizeof(g)); for(int j=0;j&lt;=x;j++)&#123; if(j-a[i]&gt;=0)&#123; g[j] = f[j] - g[j-a[i]]; &#125; else g[j] = f[j]; &#125; if(g[x]==0)&#123; b[i] = 1; t++; &#125; &#125; printf(&quot;%d\n&quot;,t); t = 0; for(int i=0;i&lt;n;i++)&#123; if(b[i]==1)&#123; if(t)&#123; printf(&quot; &quot;); &#125; printf(&quot;%d&quot;,a[i]); t++; &#125; &#125; printf(&quot;\n&quot;); return 0;&#125;]]></content>
      <categories>
        <category>基础dp</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[OpenJudge(复杂整数的划分问题)]]></title>
    <url>%2F2018%2F11%2F17%2FOpenJudge(%E5%A4%8D%E6%9D%82%E6%95%B4%E6%95%B0%E7%9A%84%E5%88%92%E5%88%86%E9%97%AE%E9%A2%98)%2F</url>
    <content type="text"><![CDATA[链接：https://vjudge.net/problem/OpenJ_Bailian-4119思路：这个题一共有三个小问，均可以用同一个类似的状态转移，即如果分的数里面有1，则减去1，如果没有，则减去数字的个数（相当于每个数减一），从而有dp[i][j]=dp[i-j][j]+dp[i-1][j-1]代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;const int maxn = 51;int n,k;long long int dp1[maxn][maxn],dp2[maxn][maxn],dp3[maxn][maxn];int main()&#123; while(cin&gt;&gt;n&gt;&gt;k)&#123; memset(dp1,0,sizeof(dp1)); for(int i=1;i&lt;=n;i++)&#123; dp1[i][1] = 1; &#125;//这里的j表示相加数字的个数总和 for(int i=1;i&lt;=n;i++)&#123; for(int j=2;j&lt;=i;j++)&#123; dp1[i][j] = dp1[i-j][j] + dp1[i-1][j-1]; &#125; &#125;//这里j表示相加数字的个数总和的上限 memset(dp2,0,sizeof(dp2)); dp2[0][0] = 1; for(int i=0;i&lt;=n;i++)&#123; for(int j=1;j&lt;=n;j++)&#123; if(j&lt;=i)dp2[i][j] = dp2[i-j][j-1]+dp2[i][j-1]; else dp2[i][j] = dp2[i][i]; &#125; &#125;//这里j的意思同第二个 memset(dp3,0,sizeof(dp3));for(int i=0;i&lt;=n;++i) &#123; dp3[i][1]=1; if(i&amp;1)dp3[0][i]=1; &#125; for(int i=1;i&lt;=n;i++) &#123; for(int j=1;j&lt;=n;j++) &#123; if(j&amp;1) &#123; if(j&lt;=i)dp3[i][j]=dp3[i-j][j]+dp3[i][j-1]; else dp3[i][j]=dp3[i][i]; &#125; else dp3[i][j]=dp3[i][j-1]; &#125; &#125; cout&lt;&lt;dp1[n][k]&lt;&lt;endl&lt;&lt;dp2[n][n]&lt;&lt;endl&lt;&lt;dp3[n][n]&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>基础dp</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[OpenJudge(上机)]]></title>
    <url>%2F2018%2F11%2F17%2FOpenJudge(%E4%B8%8A%E6%9C%BA)%2F</url>
    <content type="text"><![CDATA[链接：https://vjudge.net/problem/OpenJ_Bailian-4150思路：状态设计非常的重要，我们考虑某一个位置与左右坐人的顺序，则设计状态dp[][]，dp[0][i]表示i在i+1之前入座，dp[1][i]表示i在i-1之后入座，则有 dp[0][i] = max(dp[0][i-1]+b[i],dp[1][i-1]+a[i]) dp[1][i] = max(dp[0][i-1]+c[i],dp[1][i-1]+b[i])代码：123456789101112131415161718192021222324#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int maxn = 10001;int a[maxn],b[maxn],c[maxn];int n;int dp[2][maxn];int main()&#123; scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;++i)scanf(&quot;%d&quot;,&amp;a[i]); for(int i=1;i&lt;=n;++i)scanf(&quot;%d&quot;,&amp;b[i]); for(int i=1;i&lt;=n;++i)scanf(&quot;%d&quot;,&amp;c[i]); memset(dp,0,sizeof(dp)); dp[0][1] = a[1];dp[1][1] = b[1]; for(int i=2;i&lt;=n;++i)&#123; dp[0][i] = max(dp[0][i-1]+b[i],dp[1][i-1]+a[i]); dp[1][i] = max(dp[0][i-1]+c[i],dp[1][i-1]+b[i]); &#125; printf(&quot;%d\n&quot;,dp[0][n]); return 0;&#125;]]></content>
      <categories>
        <category>基础dp</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[OpenJudge(Zipper)]]></title>
    <url>%2F2018%2F11%2F17%2FOpenJudge(Zipper)%2F</url>
    <content type="text"><![CDATA[链接：https://vjudge.net/problem/OpenJ_Bailian-2192思路：用dp[i][j]表示第一个字符串使用前i个字符，第二个字符串使用j个字符能否与后面的长串匹配，那么下一个字符匹配要嘛和dp[i+1][j]相同，要嘛和dp[i][j+1]相同，所以建立状态转移。代码：1234567891011121314151617181920212223242526272829#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;cstring&gt;using namespace std;string a,b,c;const int maxn = 201;int dp[maxn][maxn];int main()&#123; int t; cin&gt;&gt;t; int o=0; while(t--)&#123; cin&gt;&gt;a&gt;&gt;b&gt;&gt;c; memset(dp,0,sizeof(dp)); dp[0][0] = 1; for(int i=0;i&lt;=a.size();i++)&#123; for(int j=0;j&lt;=b.size();j++)&#123; if(i&gt;0&amp;&amp;dp[i-1][j]==1&amp;&amp;a[i-1]==c[i+j-1])dp[i][j] = 1; if(j&gt;0&amp;&amp;dp[i][j-1]==1&amp;&amp;b[j-1]==c[i+j-1])dp[i][j] = 1; &#125; &#125; cout&lt;&lt;&quot;Data set &quot;&lt;&lt;++o&lt;&lt;&quot;: &quot;; if(dp[a.size()][b.size()]) cout&lt;&lt;&quot;yes&quot;&lt;&lt;endl; else cout&lt;&lt;&quot;no&quot;&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>基础dp</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[OpenJudge(C16H)(Magical-Balls)]]></title>
    <url>%2F2018%2F11%2F17%2FOpenJudge(C16H)(Magical-Balls)%2F</url>
    <content type="text"><![CDATA[链接：https://vjudge.net/problem/OpenJ_POJ-C16H思路：借着这个题把矩阵快速幂学了，其实原理跟快速幂一样只是把数换成了矩阵而已，首先我们推出公式如下：引用自(https://www.cnblogs.com/niwatori1217/p/5689633.html)由于是周期重复，考虑把一个周期的变化能写成矩阵，那么我们算出这一个周期内的矩阵的对应值，然后m/n个周期内快速幂一下，最后剩余的m%n个直接硬算过去即可得到最终答案。代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include&lt;bits/stdc++.h&gt;using namespace std;const int mod = 1e9+7;const int maxn = 2;long long t,n,m,x,y;long long A[20010],B[20010];struct Martix&#123; long long a[maxn][maxn]; Martix()&#123; for(int i=0;i&lt;maxn;i++)&#123; for(int j=0;j&lt;maxn;j++)&#123; if(i==j) a[i][j] = 1; else a[i][j] = 0; &#125; &#125; &#125; void init()&#123; for(int i=0;i&lt;maxn;i++)&#123; for(int j=0;j&lt;maxn;j++)&#123; if(i==j) a[i][j] = 1; else a[i][j] = 0; &#125; &#125; &#125; Martix operator*(const Martix &amp; r)&#123; Martix res; for(int i=0;i&lt;maxn;i++)&#123; for(int j=0;j&lt;maxn;j++)&#123; res.a[i][j] = 0; for(int k=0;k&lt;maxn;k++)&#123; res.a[i][j] = (res.a[i][j] + a[i][k]*r.a[k][j])%mod; &#125; &#125; &#125; return res; &#125; void print(int n,int m)&#123; for(int i=0;i&lt;n;i++)&#123; for(int j=0;j&lt;m;j++)&#123; printf(&quot;%lld &quot;,a[i][j]); &#125; printf(&quot;\n&quot;); &#125; &#125;&#125;;Martix quick_mod(Martix q,long long w)&#123; Martix res; while(w)&#123; if(w%2)res = res * q; q = q*q; w&gt;&gt;=1; &#125; return res;&#125;int main()&#123; scanf(&quot;%lld&quot;,&amp;t); while(t--)&#123; scanf(&quot;%lld%lld%lld%lld&quot;,&amp;n,&amp;m,&amp;x,&amp;y); x = (x%mod+mod)%mod;//注意取模加模再取模 y = (y%mod+mod)%mod; long long pt = n/m; long long left = n%m; for(int i=1;i&lt;=m;i++)&#123; long long u,d,l,r; scanf(&quot;%lld%lld%lld%lld&quot;,&amp;u,&amp;d,&amp;l,&amp;r); A[i] = 1+u+d+l+r; B[i] = u-d+r-l; &#125; Martix base,r; //先算一个周期的，然后快速幂，再补剩下的 for(int i=1;i&lt;=m;i++)&#123; r.a[0][0] = A[i]; r.a[0][1] = 0; r.a[1][0] = B[i]; r.a[1][1] = A[i]; base = base*r; &#125; base = quick_mod(base,pt); for(int i=1;i&lt;=left;i++)&#123; r.a[0][0] = A[i]; r.a[0][1] = 0; r.a[1][0] = B[i]; r.a[1][1] = A[i]; base = base*r; &#125; printf(&quot;%lld\n&quot;,(base.a[1][0]+base.a[1][1]*(x+y))%mod); &#125; return 0;&#125;]]></content>
      <categories>
        <category>矩阵快速幂</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[OpenJudge(4121)(股票买卖)]]></title>
    <url>%2F2018%2F11%2F17%2FOpenJudge(4121)(%E8%82%A1%E7%A5%A8%E4%B9%B0%E5%8D%96)%2F</url>
    <content type="text"><![CDATA[链接：https://vjudge.net/problem/OpenJ_Bailian-4121思路：题目的意思可以囊括为，从序列中取出四个数a1,a2,a3,a4，要求a4-a3+a2-a1的值最大。后一个数的下标大于等于前一个数，也就是可以选同一个数。不妨用a2，a3之间某个数（也可能是a2，a3本身）来描述状态，前一部分选两个数相减的最大值还有后面两个数的最大值，所以可以考虑从前面来一次dp再从后面来一次dp，最后取一个前面+后面的最大值。代码：1234567891011121314151617181920212223242526272829303132#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;using namespace std;const int maxn = 1e5+1;int t,n,a[maxn];int dp1[maxn],dp2[maxn];int main()&#123; scanf(&quot;%d&quot;,&amp;t); while(t--)&#123; memset(dp1,0,sizeof(dp1));//某个点前面两个数相减的最大值 memset(dp2,0,sizeof(dp2));//某个点后面两个数相减的最大值 scanf(&quot;%d&quot;,&amp;n); for(int i=0;i&lt;n;++i)scanf(&quot;%d&quot;,&amp;a[i]); int head = a[0],tail = a[n-1]; for(int i=0;i&lt;n;++i)&#123; dp1[i] = max(dp1[i-1],a[i]-head); head = min(head,a[i]);//更新前i个数中的最小值 &#125; for(int j=n-1;j&gt;=0;j--)&#123; dp2[j] = max(dp2[j+1],tail-a[j]); tail = max(tail,a[j]);//更新后j个数中的最大值 &#125; int ans = 0; for(int i=0;i&lt;n;i++) ans = max(ans,dp1[i]+dp2[i+1]);//最大值即为解 printf(&quot;%d\n&quot;,ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>基础dp</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[ICPC2017北京J题(Pangu-and-Stones)]]></title>
    <url>%2F2018%2F11%2F17%2FICPC2017%E5%8C%97%E4%BA%ACJ%E9%A2%98(Pangu-and-Stones)%2F</url>
    <content type="text"><![CDATA[链接：https://vjudge.net/problem/HihoCoder-1636思路：区间dp，可以说是石子合并的加强版，只是因为由相邻合并改为了一个范围合并，所以我们要在原来dp上多加一维，dp[l][r][k]表示从l到r区间被分成k堆所需要的最小值，k=1时表示整个区间合并完成，状态表示如下：k&gt;2 dp[l][r][k] = min(dp[l][r][k],dp[l][d][1]+dp[d+1][r][k-1])k=1 dp[l][r][1] = min(dp[l][r][1],dp[l][r][k]+sum(r)-sum(l-1))巧妙的地方就是把答案放到k=1的地方去，这样我们只用在合并的时候加上前缀和，也算是一个套路吧，分解区间的时候不加前缀和，因为之前的都已经算好了，合并的时候更新当前状态的最优解，加上前缀和。代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int n,L,R;const int maxn = 500;const ll INF = 1e18;ll dp[maxn][maxn][maxn];ll sum[maxn];int a[maxn];int main()&#123; while(~scanf(&quot;%d%d%d&quot;,&amp;n,&amp;L,&amp;R))&#123; sum[0] = 0; for(int i=1;i&lt;=n;i++)&#123; scanf(&quot;%d&quot;,&amp;a[i]); sum[i] = sum[i-1] + a[i]; &#125; for(int i=1;i&lt;=n;i++)&#123; for(int j=1;j&lt;=n;j++)&#123; for(int k=1;k&lt;=n;k++)&#123; dp[i][j][k] = INF; &#125; &#125; &#125; for(int i=0;i&lt;=n;i++)dp[i][i][1] = 0; for(int len=2;len&lt;=n;len++)&#123; for(int l=1;l+len-1&lt;=n;l++)&#123; int r = l+len-1; for(int p=2;p&lt;=len;p++)&#123;//枚举大于1的情况 for(int k=l;k&lt;r;k++)&#123;//拆分区间 dp[l][r][p] = min(dp[l][r][p],dp[l][k][1]+dp[k+1][r][p-1]); &#125; &#125; //将最优解合并到k=1的时候，更新当前状态的最优解 for(int k=0;k&lt;=n;k++)&#123; if((k&gt;=L&amp;&amp;k&lt;=R)||(k==0&amp;&amp;len&gt;=L&amp;&amp;len&lt;=R)) dp[l][r][1] = min(dp[l][r][1],dp[l][r][k]+sum[r]-sum[l-1]); &#125; &#125; &#125; printf(&quot;%lld\n&quot;,dp[1][n][1]&gt;=INF?0:dp[1][n][1]); &#125; return 0;&#125;]]></content>
      <categories>
        <category>区间dp</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[HDU5517(Triple)]]></title>
    <url>%2F2018%2F11%2F17%2FHDU5517(Triple)%2F</url>
    <content type="text"><![CDATA[链接：https://vjudge.net/problem/HDU-5517思路：之前没写过二维树状数组啊，不过大概知道原理，这个题也是，比较三维的话，我们可以先把一维排好序，然后变为剩下二维，正好这二维数据范围较小，可以用前缀来维护，只要前面的和等于0，就说明前面没有完全被覆盖的(因为a是按排序大小来的)，此时把当前加入集合中。注意有几个优化，首先当原来b相同的二元组时，我们只需要取最大的a即可，因为此时小的a合并后一定会被大的a囊括，不会属于新的集合，那么对于相同最大b对应的最大a我们记录下他的个数，合并成新的三元组也对应这么多个数，最后可能不同b会产生相同三元组，我们先对新集合按a，b，c排序，如果相邻项相等的话则我们把它合并，然后最后用二维树状数组维护b，c，当前缀和为0满足的元素加1，求出答案即可。代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1010;long long csum[maxn][maxn];struct tri&#123;//三元组 int a,b,c; long long num; bool operator&lt;(const tri &amp; r)const&#123; if(a!=r.a) return a&lt;r.a; if(b!=r.b)return b&lt;r.b; if(c!=r.c)return c&lt;r.c; return num&lt;r.num; &#125; bool operator==(const tri &amp;r)const&#123;//比较 return a == r.a &amp;&amp; b == r.b &amp;&amp; c == r.c; &#125;&#125;ss[100010];int lowbit(int x)&#123; return x&amp;(-x);&#125;void add(int x,int y,long long d)&#123; for(int i=x;i&lt;=1000;i+=lowbit(i))&#123; for(int j=y;j&lt;=1000;j+=lowbit(j))&#123; csum[i][j]+=d; &#125; &#125;&#125;long long s(int x,int y)&#123; long long ret = 0; for(int i=x;i&gt;0;i-=lowbit(i))&#123; for(int j=y;j&gt;0;j-=lowbit(j))&#123; ret+=csum[i][j]; &#125; &#125; return ret;&#125;long long sum(int x1,int y1,int x2,int y2)&#123; return s(x2,y2) - s(x1-1,y2) - s(x2,y1-1) + s(x1-1,y1-1);&#125;int maxv[100010];int cnt[100010];int t,n,m;int main()&#123; int kase = 0; scanf(&quot;%d&quot;,&amp;t); while(t--)&#123; memset(csum,0,sizeof(csum)); memset(maxv,0,sizeof(maxv)); memset(cnt,0,sizeof(cnt)); scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=0;i&lt;n;i++)&#123;//统计相同b中的最大的a的值 int a,b; scanf(&quot;%d%d&quot;,&amp;a,&amp;b); if(maxv[b]&lt;a)&#123; maxv[b] = a; cnt[b] = 1; &#125; else if(maxv[b]==a)cnt[b]++; &#125; for(int i=1;i&lt;=m;i++)&#123; int c,d,e; scanf(&quot;%d%d%d&quot;,&amp;c,&amp;d,&amp;e); ss[i] = &#123;maxv[e],c,d,cnt[e]&#125;;//生成新的三元组 &#125; sort(ss+1,ss+m+1); int tot = 0; for(int i=1;i&lt;=m;i++)&#123; if(!ss[i].num)continue; if(ss[i]==ss[tot])ss[tot].num+=ss[i].num;//合并相邻的相同项 else ss[++tot] = ss[i]; &#125; long long ans = 0; for(int i = tot;i&gt;=1;i--)&#123; if(!sum(ss[i].b,ss[i].c,1000,1000))ans+=ss[i].num; add(ss[i].b,ss[i].c,ss[i].num); &#125; printf(&quot;Case #%d: %lld\n&quot;,++kase,ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>树状数组</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[HDU5510(Bazinga)]]></title>
    <url>%2F2018%2F11%2F17%2FHDU5510(Bazinga)%2F</url>
    <content type="text"><![CDATA[链接：https://vjudge.net/problem/HDU-5510思路：首先暴力匹配复杂度肯定不能接受，我们考虑如果对任意两个串用kmp可以把单词匹配复杂度降到O(len)，这样整个复杂度就是O(tnn*len)，这样还是会超时，我们考虑对于前面一个串如果是后面一个串的字串，那么我们只用跟后面那个串进行比较，这样一来因为只用求最大的下标位置，所以我们先预处理所有相邻串的关系，然后相邻串进行暴力kmp即可，这样可以减少大量的不必要运算，从而计算出结果。代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include&lt;bits/stdc++.h&gt;using namespace std;int t,n,cnt;char str[510][2010];int flag[510];int f[2010];void getfail(char *P)&#123; int m = strlen(P); f[0] = 0; f[1] = 0; for(int i=1;i&lt;m;i++)&#123; int j = f[i]; while(j&amp;&amp;P[i]!=P[j])j = f[j]; f[i+1] = P[i] == P[j]?j+1:0; &#125;&#125;bool find(char *T,char *P)&#123; int n = strlen(T); int m = strlen(P); cnt = 0; memset(f,0,sizeof(f)); getfail(P); int j = 0; for(int i=0;i&lt;n;i++)&#123; while(j&amp;&amp;P[j]!=T[i])j = f[j]; if(P[j]==T[i])j++; if(j==m)cnt++; if(cnt!=0)break; &#125; return cnt;&#125;int main()&#123; int kase = 0; scanf(&quot;%d&quot;,&amp;t); while(t--)&#123; memset(flag,0,sizeof(flag)); scanf(&quot;%d&quot;,&amp;n); for(int i=0;i&lt;n;i++)scanf(&quot;%s&quot;,str[i]); for(int i=0;i&lt;n-1;i++)&#123; if(find(str[i+1],str[i])!=0)//预处理所有的相邻串 flag[i] = 1; &#125; int fff = 0; for(int i=n-1;i&gt;=0;i--)&#123; int ff = 0; for(int j=0;j&lt;i;j++)&#123; if(flag[j])continue; find(str[i],str[j]); if(cnt==0)&#123; printf(&quot;Case #%d: %d\n&quot;,++kase,i+1); ff = 1; break; &#125; &#125; if(ff)&#123; fff = 1; break; &#125; &#125; if(!fff)printf(&quot;Case #%d: %d\n&quot;,++kase,-1); &#125; return 0;&#125;]]></content>
      <categories>
        <category>kmp</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[HDU4725(The-Shortest-Path-in-Nya-Graph)]]></title>
    <url>%2F2018%2F11%2F17%2FHDU4725(The-Shortest-Path-in-Nya-Graph)%2F</url>
    <content type="text"><![CDATA[链接：https://vjudge.net/problem/HDU-4725思路：题意是在普通最短路中，每个点有个对应的层次，相邻层次间的不同可以花代价c进行移动，求1-n的最短路。所以如何建图成为了一个关键。为了能够将不同层次的点之间花代价表示出来，不妨每个层次建立一个两个虚点，一个虚点表示从实点出来的，另一个表示要进入实点的，然后将每个实点与对应的两个虚点建立对应的两条边（由实点到出去的虚点，由另一个虚点到实点），然后相邻层次的虚点的出点和入点对应连接一条代价为c的边（注意要判断两个层次都必须有点存在才连，否则入1，3层次有点，2层次无点，则1无法到3），建图后跑一边最短路即可（spfa用优先队列优化一下）代码：~~~ includeincludeincludeincludeincludeincludeusing namespace std; const int maxn = 3e5+10;//一实点两虚点，总共三倍int n,m,c,t; typedef pair P; struct edge{ int from,to,dist; edge(){} edge(int f,int t,int d):from(f),to(t),dist(d){}}; struct SPFA{ int n,m; vector edges; vector G[maxn]; int d[maxn]; int p[maxn]; int f[maxn]; int vis[maxn]; int inq[maxn]; int cnt[maxn]; void init(int n){ this-&gt;n = n; for(int i=0;i&lt;=n;i++)G[i].clear(); edges.clear(); memset(vis,0,sizeof(vis)); } void addedge(int from,int to,int dist){ edges.push_back(edge(from,to,dist)); m = edges.size(); G[from].push_back(m-1);//放入的是edges中的编号 } void spfa(int s){ priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt; Q;//优先队列优化 memset(inq,0,sizeof(inq)); memset(cnt,0,sizeof(cnt)); for(int i=0;i&lt;n;i++){ d[i] = 0x3f3f3f3f; } d[s] = 0; Q.push(s); while(!Q.empty()){ int u = Q.top(); Q.pop(); inq[u] = false; for(int i=0;i&lt;G[u].size();i++){ edge&amp; e = edges[G[u][i]]; if(d[e.to]&gt;d[u]+e.dist){ d[e.to] = d[u] + e.dist; p[e.to] = u; if(!inq[e.to]){ Q.push(e.to); inq[e.to] = true; if(++cnt[e.to]&gt;n){ return ; } } } } } } void output(int s,int e,vector&lt;int&gt;&amp; path){ int pos=e; while(1){ path.push_back(pos); if(pos==s) break; pos=p[pos]; } } }solver; int main(){ int kase = 0; scanf(“%d”,&amp;t); while(t—){ scanf(“%d%d%d”,&amp;n,&amp;m,&amp;c); solver.init(3n); int now; for(int i=0;i&lt;n;i++){ scanf(“%d”,&amp;now); solver.f[i] = now-1; solver.vis[now-1+n] = 1;//该层次有点存在，标记 } for(int i=0;i&lt;n;i++){ solver.addedge(i,n+solver.f[i],0);//实点到出去的虚点 solver.addedge(solver.f[i]+2n,i,0);//进入的虚点到实点 } for(int i=1;i&lt;n;i++){ if(solver.vis[i+n-1]&amp;&amp;solver.vis[i+n]){//相邻层次存在点，则连边 solver.addedge(i+n-1,i+2n,c); solver.addedge(i+n,i+2n-1,c); } } for(int i=0;i&lt;m;i++){ int a,b,c; scanf(“%d%d%d”,&amp;a,&amp;b,&amp;c); a—; b—; solver.addedge(a,b,c); solver.addedge(b,a,c); } solver.spfa(0); if(solver.d[n-1]==0x3f3f3f3f)printf(“Case #%d: -1\n”,++kase); else printf(“Case #%d: %d\n”,++kase,solver.d[n-1]); } return 0;}]]></content>
      <categories>
        <category>最短路</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[HDU4725(Marriage-Match-IV)]]></title>
    <url>%2F2018%2F11%2F17%2FHDU4725(Marriage-Match-IV)%2F</url>
    <content type="text"><![CDATA[链接：https://vjudge.net/problem/HDU-3416思路：求最短路一共多少条，首先想清楚一点，如果某条路是最短路，那他路上所有点的距离都应该是最短路的距离，为了求出所有最短路存在的边，我们枚举所有边，如果两个端点的最短距离差等于边长， 那么这条边就一定会被选入最短路，然后在网络流上建一条容量为1的边，最后跑一个最大流即可代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1010;const int INF = 1e9;typedef pair&lt;int,int&gt; P;struct edge1&#123; int from,to,dist;&#125;;struct edge&#123; int from,to,cap,flow;&#125;;struct Dij&#123; int n,m; int d[2][maxn]; vector&lt;int&gt; G[2][maxn]; vector&lt;edge1&gt; edges[2]; void init(int n)&#123; this-&gt;n = n; for(int i=0;i&lt;=n;i++)G[0][i].clear(),G[1][i].clear(); edges[0].clear(); edges[1].clear(); &#125; void addedge(int from,int to,int dist,int f)&#123; edges[f].push_back(edge1&#123;from,to,dist&#125;); m = edges[f].size(); G[f][from].push_back(m-1); &#125; void dij(int s,int f)&#123; for(int i=0;i&lt;=n;i++)d[f][i] = 1e9; d[f][s] = 0; priority_queue&lt;P,vector&lt;P&gt;,greater&lt;P&gt; &gt;q; q.push(P&#123;0,s&#125;); d[f][s] = 0; while(!q.empty())&#123; P p = q.top(); q.pop(); int u = p.second; if(d[f][u]&lt;p.first)continue; for(int i=0;i&lt;G[f][u].size();i++)&#123; edge1 &amp;e = edges[f][G[f][u][i]]; if(d[f][e.to]&gt;d[f][u]+e.dist)&#123; d[f][e.to] = d[f][u] + e.dist; q.push(P&#123;d[f][e.to],e.to&#125;); &#125; &#125; &#125; &#125;&#125;solver1;struct Dinic&#123; int n,m,s,t; vector&lt;edge&gt; edges; vector&lt;int&gt; G[maxn]; bool vis[maxn]; int d[maxn]; int cur[maxn]; void init(int n)&#123; this-&gt;n = n; edges.clear(); for(int i=0;i&lt;=n;i++)G[i].clear(); &#125; void addedge(int from,int to,int cap)&#123; edges.push_back(edge&#123;from,to,cap,0&#125;); edges.push_back(edge&#123;to,from,0,0&#125;); m = edges.size(); G[from].push_back(m-2); G[to].push_back(m-1); &#125; bool bfs()&#123; memset(vis,0,sizeof(vis)); queue&lt;int&gt; q; q.push(s); d[s] = 0; vis[s] = 1; while(!q.empty())&#123; int x = q.front(); q.pop(); for(int i=0;i&lt;G[x].size();i++)&#123; edge &amp;e = edges[G[x][i]]; if(!vis[e.to]&amp;&amp;e.cap&gt;e.flow)&#123; vis[e.to] = 1; d[e.to] = d[x] + 1; q.push(e.to); &#125; &#125; &#125; return vis[t]; &#125; int dfs(int x,int a)&#123; if(x==t||a==0)return a; int flow = 0,f; for(int &amp;i = cur[x];i&lt;G[x].size();i++)&#123; edge &amp;e = edges[G[x][i]]; if(d[x] + 1 == d[e.to]&amp;&amp;(f=dfs(e.to,min(a,e.cap-e.flow)))&gt;0)&#123; e.flow+=f; edges[G[x][i]^1].flow -=f; flow+=f; a-=f; if(a==0)break; &#125; &#125; return flow; &#125; int maxflow(int s,int t)&#123; this-&gt;s = s; this-&gt;t = t; int flow = 0; while(bfs())&#123; memset(cur,0,sizeof(cur)); flow+=dfs(s,INF); &#125; return flow; &#125;&#125;solver2;int T;int n,m;int s,t;int main()&#123; scanf(&quot;%d&quot;,&amp;T); while(T--)&#123; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); solver1.init(n); solver2.init(n); for(int i=0;i&lt;m;i++)&#123; int a,b,c; scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c); solver1.addedge(a,b,c,0); solver1.addedge(b,a,c,1); &#125; scanf(&quot;%d%d&quot;,&amp;s,&amp;t); solver1.dij(s,0); solver1.dij(t,1); int res = solver1.d[0][t]; for(int i=0;i&lt;solver1.edges[0].size();i++)&#123; int u = solver1.edges[0][i].from; int v = solver1.edges[0][i].to; int w = solver1.edges[0][i].dist; if(solver1.d[0][u]+solver1.d[1][v]+w==res)solver2.addedge(u,v,1); &#125; int ans = solver2.maxflow(s,t); printf(&quot;%d\n&quot;,ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>最短路</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[HDU4614(Vases-and-Flowers)]]></title>
    <url>%2F2018%2F11%2F17%2FHDU4614(Vases-and-Flowers)%2F</url>
    <content type="text"><![CDATA[链接：https://vjudge.net/contest/260644#problem/L思路：插花，每次如果能够完成操作返回第一朵花的位置和最后一朵花的位置，还有清空操作，我们考虑到第一朵花的位置应该搜索到当前区间和恰好等于终点-起点+1的那个区间的左端点，最后一朵花的位置就是左端点向右插x朵花所到达的位置，所以我们需要记录每个区间的和即可，然后通过二分查找找到起始位置，然后二分找到最终位置，最后update完成更新，清空的话就用tag标记正常操作即可。（总结一下，对于这种离散的区间修改问题的另一个思路是，先确定更改整体的最小范围，即最小要把哪段连续的更改，然后update的时候直接整段更改并且传递标记即可）。代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e5+10;int sum[maxn&lt;&lt;2],tag[maxn&lt;&lt;2];int t,n,q;inline void pushup(int o)&#123; sum[o] = sum[o&lt;&lt;1] + sum[o&lt;&lt;1|1];&#125;void pushdown(int o,int m)&#123; tag[o&lt;&lt;1] = tag[o&lt;&lt;1|1] = tag[o]; if(tag[o])&#123; sum[o&lt;&lt;1] = m - (m&gt;&gt;1); sum[o&lt;&lt;1|1] = m&gt;&gt;1; &#125; else sum[o&lt;&lt;1] = sum[o&lt;&lt;1|1] = 0; tag[o] = -1;&#125;void build(int o,int l,int r)&#123; tag[o] = -1; sum[o] = 0; if(l&lt;r)&#123; int mid = l+r&gt;&gt;1; build(o&lt;&lt;1,l,mid); build(o&lt;&lt;1|1,mid+1,r); &#125;&#125;void update(int o,int tl,int tr,int l,int r,int v)&#123; if(tl==l&amp;&amp;tr==r)&#123; tag[o] = v; if(v)sum[o] = tr-tl+1; else sum[o] = 0; return; &#125; if(tag[o] &gt; -1) pushdown(o,tr-tl+1); int mid = tl+tr&gt;&gt;1; if(r &lt;= mid) update(o&lt;&lt;1,tl,mid,l,r,v); else &#123; if(l &gt; mid) update(o&lt;&lt;1|1,mid + 1,tr,l,r,v); else &#123; update(o&lt;&lt;1,tl,mid,l,mid,v); update(o&lt;&lt;1|1,mid + 1,tr,mid + 1,r,v); &#125; &#125; pushup(o);&#125;int query(int o,int tl,int tr,int l,int r)&#123; if(l==tl&amp;&amp;tr==r)return sum[o]; if(tag[o]&gt;-1) pushdown(o,tr-tl+1); int mid = (tl+tr)&gt;&gt;1; int ret = 0; if(r&lt;=mid) ret = query(o&lt;&lt;1,tl,mid,l,r); else&#123; if(l&gt;mid)ret = query(o&lt;&lt;1|1,mid+1,tr,l,r); else ret = query(o&lt;&lt;1,tl,mid,l,mid) + query(o&lt;&lt;1|1,mid+1,tr,mid+1,r); &#125; return ret;&#125;int bs(int s,int len)&#123;//二分枚举起点和终点 int l = s; int r = n; int ans = -1; int mid; while(l&lt;=r)&#123;//注意终点不同的二分写法，如果是r&gt;l的写法需要先判断是否存在解，如果无解的话会使二分陷入死循环 int mid = l+r&gt;&gt;1; int tmp = query(1,1,n,s,mid); if(tmp+len==mid-s+1)&#123; ans = mid; r = mid-1; &#125; else&#123; if(tmp+len&lt;mid-s+1) r = mid - 1; else l = mid+1; &#125; &#125; return ans;&#125;int main()&#123; scanf(&quot;%d&quot;,&amp;t); while(t--)&#123; scanf(&quot;%d%d&quot;,&amp;n,&amp;q); build(1,1,n); while(q--)&#123; int a,b,c; scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c); if(a==1)&#123; int ss,ee; b++; ss = bs(b,1); if(ss==-1)printf(&quot;Can not put any one.\n&quot;); else&#123; int tmp = query(1,1,n,ss,n); tmp = n-ss+1-tmp; if(tmp&lt;=c)&#123; c = tmp; &#125; ee = bs(b,c); printf(&quot;%d %d\n&quot;,ss-1,ee-1); update(1,1,n,ss,ee,1); &#125; &#125; else&#123; b++; c++; printf(&quot;%d\n&quot;,query(1,1,n,b,c)); update(1,1,n,b,c,0); &#125; &#125; printf(&quot;\n&quot;); &#125; return 0;&#125;]]></content>
      <categories>
        <category>线段树</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[HDU4578(Transformation)]]></title>
    <url>%2F2018%2F11%2F17%2FHDU4578(Transformation)%2F</url>
    <content type="text"><![CDATA[链接：https://vjudge.net/problem/HDU-4578思路：之前做过一个平方的，这次多了一个立方，操作一样不过立方要比平方先更新，平方比和先更新，最后更新tag，然后惯例的先更新乘法后更新加法，然后注意变数时不能直接更新到节点否则会超时，这时候先用一个清空标记记录要变的值，push下去时清空下面的加法和乘法标记同时将清空标记传下去，随后再更新加法和乘法标记，注意因为取模不要爆范围，中间一直因为爆范围导致WA。。。。。代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e5+100 ;long long tagp[maxn&lt;&lt;2],tagm[maxn&lt;&lt;2],clear[maxn&lt;&lt;2];long long sum[maxn&lt;&lt;2],dou[maxn&lt;&lt;2],tri[maxn&lt;&lt;2];int n,q;const int mod = 10007;inline void pushup(int o)&#123; sum[o] = (sum[o&lt;&lt;1] + sum[o&lt;&lt;1|1])%mod; dou[o] = (dou[o&lt;&lt;1] + dou[o&lt;&lt;1|1])%mod; tri[o] = (tri[o&lt;&lt;1] + tri[o&lt;&lt;1|1])%mod;&#125;void pushdown(int o,int m)&#123; if(clear[o]!=-1)&#123; sum[o&lt;&lt;1] = (m-(m&gt;&gt;1))*clear[o]%mod; sum[o&lt;&lt;1|1] = ((m&gt;&gt;1))*clear[o]%mod; dou[o&lt;&lt;1] = (m-(m&gt;&gt;1))*clear[o]%mod*clear[o]%mod; dou[o&lt;&lt;1|1] = ((m&gt;&gt;1))*clear[o]%mod*clear[o]%mod; tri[o&lt;&lt;1] = (m-(m&gt;&gt;1))*clear[o]%mod*clear[o]%mod*clear[o]%mod; tri[o&lt;&lt;1|1] = ((m&gt;&gt;1))*clear[o]%mod*clear[o]%mod*clear[o]%mod; clear[o&lt;&lt;1] = clear[o&lt;&lt;1|1] = clear[o]; tagp[o&lt;&lt;1] = tagp[o&lt;&lt;1|1] = 0; tagm[o&lt;&lt;1] = tagm[o&lt;&lt;1|1] = 1; clear[o] = -1; &#125; if(tagm[o]!=1)&#123; sum[o&lt;&lt;1] = sum[o&lt;&lt;1]*tagm[o]%mod; sum[o&lt;&lt;1|1]=sum[o&lt;&lt;1|1]*tagm[o]%mod; dou[o&lt;&lt;1]=dou[o&lt;&lt;1]*tagm[o]%mod*tagm[o]%mod; dou[o&lt;&lt;1|1] =dou[o&lt;&lt;1|1] * tagm[o]%mod*tagm[o]%mod; tri[o&lt;&lt;1] = tri[o&lt;&lt;1] *tagm[o]%mod*tagm[o]%mod*tagm[o]%mod; tri[o&lt;&lt;1|1]=tri[o&lt;&lt;1|1]*tagm[o]%mod*tagm[o]%mod*tagm[o]%mod; tagm[o&lt;&lt;1] = tagm[o&lt;&lt;1] *tagm[o]%mod; tagm[o&lt;&lt;1|1] =tagm[o&lt;&lt;1|1] * tagm[o]%mod; tagp[o&lt;&lt;1] = tagp[o&lt;&lt;1] * tagm[o]%mod; tagp[o&lt;&lt;1|1] = tagp[o&lt;&lt;1|1] *tagm[o]%mod; tagm[o] = 1; &#125; if(tagp[o])&#123; tri[o&lt;&lt;1] = (tri[o&lt;&lt;1] + 3*dou[o&lt;&lt;1]*tagp[o]%mod+3*sum[o&lt;&lt;1]*tagp[o]%mod*tagp[o]%mod+tagp[o]*tagp[o]%mod*tagp[o]%mod*(m-(m&gt;&gt;1)))%mod; tri[o&lt;&lt;1|1]= (tri[o&lt;&lt;1|1] + 3*dou[o&lt;&lt;1|1]*tagp[o]%mod+3*sum[o&lt;&lt;1|1]*tagp[o]%mod*tagp[o]%mod+tagp[o]*tagp[o]%mod*tagp[o]%mod*(m&gt;&gt;1))%mod; dou[o&lt;&lt;1]= (dou[o&lt;&lt;1] + 2*sum[o&lt;&lt;1]*tagp[o]%mod + tagp[o]*tagp[o]%mod*(m-(m&gt;&gt;1)))%mod; dou[o&lt;&lt;1|1] = (dou[o&lt;&lt;1|1] + 2*sum[o&lt;&lt;1|1]*tagp[o]%mod +tagp[o] *tagp[o]%mod*(m&gt;&gt;1))%mod; sum[o&lt;&lt;1] = (sum[o&lt;&lt;1] + tagp[o]*(m-(m&gt;&gt;1)))%mod; sum[o&lt;&lt;1|1] = (sum[o&lt;&lt;1|1] + tagp[o]*(m&gt;&gt;1))%mod; tagp[o&lt;&lt;1] = (tagp[o&lt;&lt;1] + tagp[o])%mod; tagp[o&lt;&lt;1|1] = (tagp[o&lt;&lt;1|1] + tagp[o])%mod; tagp[o] = 0; &#125;&#125;void build(int o,int l,int r)&#123; tagp[o] = 0; tagm[o] = 1; sum[o] = 0; dou[o] = 0; tri[o] = 0; clear[o] = -1; if(l&lt;r)&#123; int mid = l+r&gt;&gt;1; build(o&lt;&lt;1,l,mid); build(o&lt;&lt;1|1,mid+1,r); pushup(o); &#125;&#125;void updatesum(int o,int tl,int tr,int l,int r,int v)&#123; if(tr&lt;l||r&lt;tl)return; if(l&lt;=tl&amp;&amp;tr&lt;=r)&#123; tagp[o] = (tagp[o] + v)%mod; tri[o] = (tri[o] + 3*dou[o]*v%mod +3*sum[o]*v%mod*v%mod+(tr-tl+1)*v%mod*v%mod*v%mod)%mod; dou[o] = (dou[o] + 2*sum[o]*v%mod+(tr-tl+1)*v%mod*v%mod)%mod; sum[o] = (sum[o] + (tr-tl+1)*v%mod)%mod; return; &#125; pushdown(o,tr-tl+1); int mid = (tl+tr)&gt;&gt;1; updatesum(o&lt;&lt;1,tl,mid,l,r,v); updatesum(o&lt;&lt;1|1,mid+1,tr,l,r,v); pushup(o);&#125; void updatemul(int o,int tl,int tr,int l,int r,int v)&#123; if(tr&lt;l||r&lt;tl)return; if(l&lt;=tl&amp;&amp;tr&lt;=r)&#123; tagm[o] = (tagm[o]*v)%mod; tagp[o] = (tagp[o]*v)%mod; tri[o] = (tri[o]*v)%mod*v%mod*v%mod; dou[o] = (dou[o]*v%mod*v)%mod; sum[o] = sum[o]*v%mod; return; &#125; pushdown(o,tr-tl+1); int mid = (tl+tr)&gt;&gt;1; updatemul(o&lt;&lt;1,tl,mid,l,r,v); updatemul(o&lt;&lt;1|1,mid+1,tr,l,r,v); pushup(o);&#125; void updatecha(int o,int tl,int tr,int l,int r,int v)&#123; if(tr&lt;l||r&lt;tl)return; if(l&lt;=tl&amp;&amp;tr&lt;=r)&#123; tri[o] = v*v%mod*v%mod*(tr-tl+1)%mod; dou[o] = (tr-tl+1)*v%mod*v%mod; sum[o] = (tr-tl+1)*v%mod; tagp[o] = 0; tagm[o] = 1; clear[o] = v; return; &#125; pushdown(o,tr-tl+1); int mid = (tl+tr)&gt;&gt;1; updatecha(o&lt;&lt;1,tl,mid,l,r,v); updatecha(o&lt;&lt;1|1,mid+1,tr,l,r,v); pushup(o);&#125; long long query(int o,int tl,int tr,int l,int r,int p)&#123; if(tr&lt;l||r&lt;tl)return 0; if(l&lt;=tl&amp;&amp;tr&lt;=r)&#123; if(p==1) return sum[o]%mod; if(p==2) return dou[o]%mod; if(p==3) return tri[o]%mod; &#125; pushdown(o,tr-tl+1); int mid = (tl+tr)&gt;&gt;1; long long ret = query(o&lt;&lt;1,tl,mid,l,r,p); ret+=query(o&lt;&lt;1|1,mid+1,tr,l,r,p); return ret%mod;&#125;int main()&#123; while(~scanf(&quot;%d%d&quot;,&amp;n,&amp;q)&amp;&amp;(n||q))&#123; build(1,1,n); for(int i=0;i&lt;q;i++)&#123; int c,x,y,p; scanf(&quot;%d%d%d%d&quot;,&amp;c,&amp;x,&amp;y,&amp;p); if(c==1)&#123; updatesum(1,1,n,x,y,p); &#125; if(c==2)updatemul(1,1,n,x,y,p); if(c==3)updatecha(1,1,n,x,y,p); if(c==4)printf(&quot;%lld\n&quot;,query(1,1,n,x,y,p)%mod); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>线段树</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[HDU4553(约会安排)]]></title>
    <url>%2F2018%2F11%2F17%2FHDU4553(%E7%BA%A6%E4%BC%9A%E5%AE%89%E6%8E%92)%2F</url>
    <content type="text"><![CDATA[链接：https://vjudge.net/contest/260644#problem/M思路：这道题题目意思很好懂，就是屌丝和女神有相同的安排时间的方法，但是如果女神没法安排时可以占用屌丝的时间，然后包含一个清空操作。一开始拿到题目无从下手，我们还是慢慢解剖整个思路，我们对于一个安排时间的操作我们需要知道哪一个时间段刚好有连续的长度为t的时间，这不跟前面一个询问某个点的最长连续区间是一样的道理嘛，对于每个区间维护一个左连续区间，右连续区间和最大连续区间，然后寻找区间时优先看左子树的最大连续区间长度是否大于等于t，如果否的话就看中间合并的一段，如果还否的话就看右子树，这样就可以解决安排的问题。对于女神和屌丝的不同操作，首先屌丝是不能占用之前屌丝的安排时间，所以屌丝和女神的区间信息我们考虑单独维护，屌丝就直接按上述步骤查看屌丝区间即可，女神的话先查看屌丝区间，如果有空的话优先占用屌丝区间（这样不冲突），否则再查看女神区间，如果有空的话占用并更新屌丝区间信息。注意处理女神区间时所有的屌丝标记也要随之改变，所以我们应该优先处理清空标记，然后是屌丝标记，最后才是女神标记，还是跟之前一样的思路，因为区间内信息是离散的，所以我们要通过和去确定唯一的确定区间，然后update直接覆盖整个区间并打上标记。细节问题很多看注释。还是那句总结：对于离散的区间信息我们可以通过维护一些总体信息（比如区间和）来确定出准确的区间位置，然后再把整个区间直接更新，这样可以避免离散区间信息没法维护的问题。代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 2e5+10;int dsum[maxn&lt;&lt;2],nsum[maxn&lt;&lt;2],dl[maxn&lt;&lt;2],dr[maxn&lt;&lt;2],nl[maxn&lt;&lt;2],nr[maxn&lt;&lt;2];int clear[maxn&lt;&lt;2],tagd[maxn&lt;&lt;2],tagn[maxn&lt;&lt;2];int n,q;void pushup(int o,int m)&#123; if(dl[o&lt;&lt;1]==m-(m&gt;&gt;1))dl[o] = dl[o&lt;&lt;1] + dl[o&lt;&lt;1|1];//左连续区间覆盖左子树则要和右子树的左区间合并 else dl[o] = dl[o&lt;&lt;1]; if(dr[o&lt;&lt;1|1]==(m&gt;&gt;1))dr[o] = dr[o&lt;&lt;1|1] + dr[o&lt;&lt;1];//右连续区间覆盖左子树则要和左子树的右区间合并 else dr[o] = dr[o&lt;&lt;1|1]; dsum[o] = max(dsum[o&lt;&lt;1],max(dsum[o&lt;&lt;1|1],dr[o&lt;&lt;1]+dl[o&lt;&lt;1|1]));//一定记住最大值是左子树最大值，右子树最大值或者中间合并后的三者之一！！！不要再写错了！！！ if(nl[o&lt;&lt;1]==m-(m&gt;&gt;1))nl[o] = nl[o&lt;&lt;1] + nl[o&lt;&lt;1|1]; else nl[o] = nl[o&lt;&lt;1]; if(nr[o&lt;&lt;1|1]==(m&gt;&gt;1))nr[o] = nr[o&lt;&lt;1|1] + nr[o&lt;&lt;1]; else nr[o] = nr[o&lt;&lt;1|1]; nsum[o] = max(nsum[o&lt;&lt;1],max(nsum[o&lt;&lt;1|1],nr[o&lt;&lt;1]+nl[o&lt;&lt;1|1]));&#125;void pushdown(int o,int m)&#123; if(clear[o])&#123;//清空标记，最先考虑 clear[o&lt;&lt;1] = clear[o&lt;&lt;1|1] = clear[o]; nsum[o&lt;&lt;1] = nl[o&lt;&lt;1] = nr[o&lt;&lt;1] = m-(m&gt;&gt;1); nsum[o&lt;&lt;1|1] = nl[o&lt;&lt;1|1] = nr[o&lt;&lt;1|1] = (m&gt;&gt;1); dsum[o&lt;&lt;1] = dl[o&lt;&lt;1] = dr[o&lt;&lt;1] = m-(m&gt;&gt;1); dsum[o&lt;&lt;1|1] = dl[o&lt;&lt;1|1] = dr[o&lt;&lt;1|1] = (m&gt;&gt;1); clear[o] = 0; tagd[o&lt;&lt;1] = tagd[o&lt;&lt;1|1] = tagn[o&lt;&lt;1] = tagn[o&lt;&lt;1|1] = 0; &#125; if(tagd[o])&#123;//因为女神标记会影响屌丝标记，所以优先考虑屌丝标记 tagd[o&lt;&lt;1] = tagd[o&lt;&lt;1|1] = tagd[o]; dsum[o&lt;&lt;1] = dl[o&lt;&lt;1] = dr[o&lt;&lt;1] = 0; dsum[o&lt;&lt;1|1] = dl[o&lt;&lt;1|1] = dr[o&lt;&lt;1|1] = 0; tagd[o] = 0; &#125; if(tagn[o])&#123;//女神标记，注意更新时更新子区间所有的屌丝标记以及屌丝区间的值 tagn[o&lt;&lt;1] = tagn[o&lt;&lt;1|1] = tagn[o]; tagd[o&lt;&lt;1] = tagd[o&lt;&lt;1|1] = 0; nsum[o&lt;&lt;1] = nl[o&lt;&lt;1] = nr[o&lt;&lt;1] = 0; nsum[o&lt;&lt;1|1] = nl[o&lt;&lt;1|1] = nr[o&lt;&lt;1|1] = 0; dsum[o&lt;&lt;1] = dl[o&lt;&lt;1] = dr[o&lt;&lt;1] = 0; dsum[o&lt;&lt;1|1] = dl[o&lt;&lt;1|1] = dr[o&lt;&lt;1|1] = 0; tagn[o] = 0; &#125;&#125;void build(int o,int l,int r)&#123;//初始sum全部为区间长度 dsum[o] = nsum[o] = dl[o] = dr[o] = nl[o] = nr[o] = r-l+1; clear[o] = tagd[o] = tagn[o] = 0; if(l&lt;r)&#123; int mid = l+r&gt;&gt;1; build(o&lt;&lt;1,l,mid); build(o&lt;&lt;1|1,mid+1,r); pushup(o,r-l+1); &#125;&#125;void update(int o,int tl,int tr,int l,int r,int v)&#123; if(tr&lt;l||r&lt;tl)return; if(l&lt;=tl&amp;&amp;tr&lt;=r)&#123; if(v==1)&#123;//以屌丝身份更新屌丝区间的信息 dsum[o] = dl[o] = dr[o] = 0; tagd[o] = 1; return ; &#125; if(v==2)&#123;//以女神身份更新女神区间的信息同时覆盖屌丝区间的信息，更新屌丝的标记 nsum[o] = nl[o] = nr[o] = 0; dsum[o] = dl[o] = dr[o] = 0; tagd[o] = 0; tagn[o] = 1; return; &#125; if(v==0)&#123;//清空信息并打上标记 nsum[o] = nl[o] = nr[o] = tr-tl+1; dsum[o] = dl[o] = dr[o] = tr-tl+1; tagd[o] = tagn[o] = 0; clear[o] = 1; return ; &#125; &#125; pushdown(o,tr-tl+1); int mid = (tl+tr)&gt;&gt;1; update(o&lt;&lt;1,tl,mid,l,r,v); update(o&lt;&lt;1|1,mid+1,tr,l,r,v); pushup(o,tr-tl+1);&#125; int query(int o,int tl,int tr,int l,int r,int v,int t)&#123;//这一段我感觉不太好理解，首先对于当前区间，先查看左子树能不能满足情况，能的话在左子树里面找，否则的话看中间合并后能不能满足情况，能的话我们可以直接得到区间左端点的值，最后看右子树，可以证明最后一定会递归到某个单点或者区间合并的时候(一直向左就是某个点，中间的话就是区间合并的时候)，所以一定能够得到左端点的位置。还是要分女神区间和屌丝区间 if(tl==tr)&#123; return tl; &#125; pushdown(o,tr-tl+1); int mid = (tl+tr)&gt;&gt;1; if(v==1)&#123; if(dsum[o&lt;&lt;1]&gt;=t)return query(o&lt;&lt;1,tl,mid,l,r,v,t); else if(dr[o&lt;&lt;1]+dl[o&lt;&lt;1|1]&gt;=t)return mid-dr[o&lt;&lt;1]+1; else return query(o&lt;&lt;1|1,mid+1,tr,l,r,v,t); &#125; else&#123; if(nsum[o&lt;&lt;1]&gt;=t)return query(o&lt;&lt;1,tl,mid,l,r,v,t); else if(nr[o&lt;&lt;1]+nl[o&lt;&lt;1|1]&gt;=t)return mid-nr[o&lt;&lt;1]+1; else return query(o&lt;&lt;1|1,mid+1,tr,l,r,v,t); &#125;&#125;int T;int main()&#123; scanf(&quot;%d&quot;,&amp;T); int kase = 0; while(T--)&#123; scanf(&quot;%d%d&quot;,&amp;n,&amp;q); printf(&quot;Case %d:\n&quot;,++kase); build(1,1,n); char ch[100]; int p,o; for(int i=1;i&lt;=q;i++)&#123; scanf(&quot;%s&quot;,ch); if(ch[0]==&apos;D&apos;)&#123; scanf(&quot;%d&quot;,&amp;p); if(dsum[1]&lt;p)printf(&quot;fly with yourself\n&quot;);//查看最大的剩余量，判断是否存在解 else&#123; int tt = query(1,1,n,1,n,1,p); update(1,1,n,tt,tt+p-1,1); printf(&quot;%d,let&apos;s fly\n&quot;,tt); &#125; &#125; else if(ch[0]==&apos;N&apos;)&#123; scanf(&quot;%d&quot;,&amp;p); if(dsum[1]&lt;p)&#123;//先看屌丝区间能不能满足分配情况 if(nsum[1]&lt;p)&#123;//屌丝区间不能则看女神区间 printf(&quot;wait for me\n&quot;); &#125; else&#123; int tt = query(1,1,n,1,n,2,p);//以女神身份寻找女神区间的左端点 update(1,1,n,tt,tt+p-1,2);//确定具体区间以女神身份更新区间信息 printf(&quot;%d,don&apos;t put my gezi\n&quot;,tt); &#125; &#125; else&#123;//屌丝区间能够满足，优先考虑 int tt = query(1,1,n,1,n,1,p);//以屌丝身份查看屌丝区间的信息 update(1,1,n,tt,tt+p-1,2);//以女神身份更新女神区间信息以及屌丝区间信息 printf(&quot;%d,don&apos;t put my gezi\n&quot;,tt); &#125; &#125; else&#123; scanf(&quot;%d%d&quot;,&amp;p,&amp;o); update(1,1,n,p,o,0);//清空区间信息 printf(&quot;I am the hope of chinese chengxuyuan!!\n&quot;); &#125; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>线段树</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[HDU4370(0-or-1)]]></title>
    <url>%2F2018%2F11%2F17%2FHDU4370(0-or-1)%2F</url>
    <content type="text"><![CDATA[链接：https://vjudge.net/contest/254476#problem/R思路：这道题很巧妙，我以为是模拟建图，没有看出来新矩阵可以看作一个1-n的邻接矩阵，且保证1的出度为1，n的入度为1，相当于求一个1-n的最短路，或者是一个1出发的自环+一个n出发的自环，只要看出来了这个题就很简单了，按思路建图跑两遍最短路即可。（注意1开始的距离并不是0，所以迪杰斯特拉不适用，这时候用spfa比较好）代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 500*500;const int INF = 1e9;int a[500][500];typedef pair&lt;int,int&gt; P;struct edge&#123; int from,to,dist;&#125;;struct Dij&#123; int n,m; vector&lt;int&gt; G[maxn]; vector&lt;edge&gt; edges; int d[maxn]; int inq[maxn]; int cnt[maxn]; void init(int n)&#123; this-&gt;n = n; for(int i=0;i&lt;=n;i++)G[i].clear(); edges.clear(); &#125; void addedge(int from,int to,int dist)&#123; edges.push_back(edge&#123;from,to,dist&#125;); m = edges.size(); G[from].push_back(m-1); &#125; bool spfa(int s)&#123; queue&lt;int&gt; Q; memset(inq,0,sizeof(inq)); memset(cnt,0,sizeof(cnt)); for(int i=1;i&lt;=n;i++) &#123; if(i==s) &#123; d[s]=1e9;continue; &#125; d[i]=a[s][i]; inq[i]=1; Q.push(i); &#125; Q.push(s); while(!Q.empty())&#123; int u = Q.front(); Q.pop(); inq[u] = false; for(int i=0;i&lt;G[u].size();i++)&#123; edge&amp; e = edges[G[u][i]]; if(d[e.to]&gt;d[u]+e.dist)&#123; d[e.to] = d[u] + e.dist; if(!inq[e.to])&#123; Q.push(e.to); inq[e.to] = true; if(++cnt[e.to]&gt;n)&#123; return true; &#125; &#125; &#125; &#125; &#125; return false; &#125;&#125;solver;int n;int main()&#123; while(~scanf(&quot;%d&quot;,&amp;n))&#123; solver.init(n); for(int i=1;i&lt;=n;i++)&#123; for(int j=1;j&lt;=n;j++)&#123; scanf(&quot;%d&quot;,&amp;a[i][j]); solver.addedge(i,j,a[i][j]); &#125; &#125; solver.spfa(1); int ans1 = solver.d[n]; int loop1 = solver.d[1]; solver.spfa(n); int loop2 = solver.d[n]; printf(&quot;%d\n&quot;,min(loop1 + loop2,ans1)); &#125; return 0;&#125;]]></content>
      <categories>
        <category>最短路</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[HDU4027(Can-you-answer-these-queries)]]></title>
    <url>%2F2018%2F11%2F17%2FHDU4027(Can-you-answer-these-queries)%2F</url>
    <content type="text"><![CDATA[链接：https://vjudge.net/contest/260644#problem/H思路：我们考虑1e18内的数据可以在常数次以内开根号变为1，所以我们维护区间信息时考虑维护区间最大值，如果区间最大值为1的话那么当前区间所有值都为1不用再递归，否则递归左右子树一直到叶节点或者到区间最大值为1的地方，在叶节点更新值，同时pushup回去合并区间信息。注意本题有些很无聊的坑点，输入需要特判一下。代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e5+10;int maxv[maxn&lt;&lt;2];long long sum[maxn&lt;&lt;2],a[maxn];int n,q;inline void pushup(int o)&#123; sum[o] = sum[o&lt;&lt;1] + sum[o&lt;&lt;1|1]; maxv[o] = max(maxv[o&lt;&lt;1],maxv[o&lt;&lt;1|1]);&#125;void build(int o,int l,int r)&#123; if(l&lt;r)&#123; int mid = l+r&gt;&gt;1; build(o&lt;&lt;1,l,mid); build(o&lt;&lt;1|1,mid+1,r); pushup(o); &#125; else&#123; sum[o] = a[l]; maxv[o] = a[l]; &#125;&#125;void update(int o,int tl,int tr,int l,int r)&#123; if(tr&lt;l||r&lt;tl)return; if(maxv[o]==1)&#123; return; &#125; if(tr==tl)&#123; a[tl] = (int)sqrt(a[tl]+0.5); maxv[o] = a[tl]; sum[o] = a[tl]; return; &#125; int mid = (tl+tr)&gt;&gt;1; update(o&lt;&lt;1,tl,mid,l,r); update(o&lt;&lt;1|1,mid+1,tr,l,r); pushup(o);&#125; long long query(int o,int tl,int tr,int l,int r)&#123; if(tr&lt;l||r&lt;tl)return 0; if(l&lt;=tl&amp;&amp;r&gt;=tr)return sum[o]; //pushdown(o,tr-tl+1); int mid = (tl+tr)&gt;&gt;1; long long ret = query(o&lt;&lt;1,tl,mid,l,r); ret+=query(o&lt;&lt;1|1,mid+1,tr,l,r); return ret;&#125;int main()&#123; int kase = 0; while(~scanf(&quot;%d&quot;,&amp;n))&#123; printf(&quot;Case #%d:\n&quot;,++kase); memset(maxv,0,sizeof(maxv)); memset(sum,0,sizeof(sum)); for(int i=1;i&lt;=n;i++)&#123; scanf(&quot;%lld&quot;,&amp;a[i]); &#125; build(1,1,n); scanf(&quot;%d&quot;,&amp;q); for(int i=1;i&lt;=q;i++)&#123; int d,e,f; scanf(&quot;%d%d%d&quot;,&amp;d,&amp;e,&amp;f); if(e&gt;f)swap(e,f);//特判一下 if(d)printf(&quot;%lld\n&quot;,query(1,1,n,e,f)); else update(1,1,n,e,f); &#125; printf(&quot;\n&quot;); &#125; return 0;&#125;]]></content>
      <categories>
        <category>线段树</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[HDU3974(Assign-the-task)]]></title>
    <url>%2F2018%2F11%2F17%2FHDU3974(Assign-the-task)%2F</url>
    <content type="text"><![CDATA[链接：https://vjudge.net/problem/HDU-3974思路：终于明白了dfs序建线段树是什么意思了，能听懂蔡队讲话了- -，对于更新一个结点及其子节点的操作，我们在树上没办法直接操作，我们可以考虑利用dfs给所有点编一个开始点号和结束点号，这样在开始和结束点号间的点号都是该结点的子结点，所以只要对这个区间的数操作即可完成对所有子节点的操作，就成功将树给序列化了，然后进行正常线段树操作就行，访问的话访问l或者r查询其标记值即可。代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e6+10;int a[maxn&lt;&lt;2],tag[maxn&lt;&lt;2];int n,q,t;vector&lt;int&gt; G[maxn];int inout[maxn];int s[maxn];int e[maxn];int nn;char ch[10];void dfs(int u)&#123; s[u] = ++nn; for(int i=0;i&lt;G[u].size();i++)&#123; int v = G[u][i]; dfs(v); &#125; e[u] = ++nn;&#125;void pushdown(int o,int m)&#123; if(tag[o]!=-1)&#123; tag[o&lt;&lt;1] = tag[o]; tag[o&lt;&lt;1|1] = tag[o]; tag[o] = -1; &#125;&#125;void build(int o,int l,int r)&#123; tag[o] = -1; if(l&lt;r)&#123; int mid = l+r&gt;&gt;1; build(o&lt;&lt;1,l,mid); build(o&lt;&lt;1|1,mid+1,r); &#125;&#125;void update(int o,int tl,int tr,int l,int r,int v)&#123; if(tr&lt;l||r&lt;tl)return; if(l&lt;=tl&amp;&amp;tr&lt;=r)&#123; tag[o] = v; return; &#125; pushdown(o,tr-tl+1); int mid = (tl+tr)&gt;&gt;1; update(o&lt;&lt;1,tl,mid,l,r,v); update(o&lt;&lt;1|1,mid+1,tr,l,r,v);&#125; int query(int o,int tl,int tr,int v)&#123; if(tl==tr)return tag[o]; pushdown(o,tr-tl+1); int mid = (tl+tr)&gt;&gt;1; if(v&lt;=mid) return query(o&lt;&lt;1,tl,mid,v); else return query(o&lt;&lt;1|1,mid+1,tr,v);&#125;int main()&#123; scanf(&quot;%d&quot;,&amp;t); int kase = 0; while(t--)&#123; memset(inout,0,sizeof(inout)); scanf(&quot;%d&quot;,&amp;n); nn = 0; for(int i=0;i&lt;=n;i++)G[i].clear(); printf(&quot;Case #%d:\n&quot;,++kase); for(int i=0;i&lt;n-1;i++)&#123; int b,c; scanf(&quot;%d%d&quot;,&amp;b,&amp;c); G[c].push_back(b); inout[b]++; &#125; for(int i=1;i&lt;=n;i++)&#123; if(!inout[i])dfs(i);//从根节点开始dfs建立序列 &#125; build(1,1,nn);//根据新序列建立线段树 scanf(&quot;%d&quot;,&amp;q); for(int i=0;i&lt;q;i++)&#123; int p,o; scanf(&quot;%s%d&quot;,ch,&amp;p); if(ch[0]==&apos;C&apos;)printf(&quot;%d\n&quot;,query(1,1,nn,e[p])); if(ch[0]==&apos;T&apos;)&#123; scanf(&quot;%d&quot;,&amp;o); update(1,1,nn,s[p],e[p],o); &#125; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>线段树</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[HDU3642(Get-The-Treasury)]]></title>
    <url>%2F2018%2F11%2F17%2FHDU3642(Get-The-Treasury)%2F</url>
    <content type="text"><![CDATA[链接：https://vjudge.net/problem/HDU-3642思路：三维立方体体积并，考虑二维面积并，体积并就等于高度差*面积并。我们枚举离散化x，然后y上构造线段树，用扫描线进行。三维的话就类比了，离散化x和z，然后枚举x和z，还是在y轴上构造线段树，注意枚举两个z之间的面积并的时候，我们要先把所有在两个z范围之内的扫描线提出来，再进行扫描(这样才能知道后面是哪一个)，然后面积并再乘以z坐标之差，最后求出来的就是答案代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e4+10;int n,q,t;struct Line&#123; int x1,y1,y2,z1,z2,k; Line()&#123;&#125; Line(int xx1,int yy1,int yy2,int zz1,int zz2,int kk)&#123; x1 = xx1; y1 = yy1; y2 = yy2; z1 = zz1; z2 = zz2; k = kk; &#125; bool operator&lt;(const Line &amp;r)&#123; return x1&lt;r.x1||(x1==r.x1&amp;&amp;k&gt;r.k); &#125;&#125;line[maxn],tmp[maxn];int y[maxn],z[maxn];int tag[maxn&lt;&lt;2],len0[maxn&lt;&lt;2],len1[maxn&lt;&lt;2],len2[maxn&lt;&lt;2],len3[maxn&lt;&lt;2];void pushup(int o,int l,int r)&#123;//一系列更新操作，自行理解 if(tag[o]&gt;=3)&#123; len3[o] = len0[o]; len2[o] = len1[o] = 0; &#125; else if(tag[o]==2)&#123; if(l==r)&#123; len3[o] = len1[o] = 0; len2[o] = len0[o]; &#125; else&#123; len3[o] = len3[o&lt;&lt;1] + len3[o&lt;&lt;1|1]+len2[o&lt;&lt;1]+len2[o&lt;&lt;1|1]+len1[o&lt;&lt;1]+len1[o&lt;&lt;1|1]; len2[o] = len0[o] - len3[o]; len1[o] = 0; &#125; &#125; else if(tag[o]==1)&#123; if(l==r)&#123; len1[o] = len0[o]; len2[o] = len3[o] = 0; &#125; else&#123; len3[o] = len3[o&lt;&lt;1] + len3[o&lt;&lt;1|1] + len2[o&lt;&lt;1] + len2[o&lt;&lt;1|1]; len2[o] = len1[o&lt;&lt;1] + len1[o&lt;&lt;1|1]; len1[o] = len0[o] - len3[o] - len2[o]; &#125; &#125; else&#123; if(l==r)&#123; len1[o] = len2[o] = len3[o] = 0; &#125; else&#123; len3[o] = len3[o&lt;&lt;1] + len3[o&lt;&lt;1|1]; len2[o] = len2[o&lt;&lt;1] + len2[o&lt;&lt;1|1]; len1[o] = len1[o&lt;&lt;1] + len1[o&lt;&lt;1|1]; &#125; &#125;&#125;void build(int o,int l,int r)&#123; tag[o] = 0; len1[o] = len2[o] = len3[o] = 0; len0[o] = y[r] - y[l-1]; if(l&lt;r)&#123; int mid = l+r&gt;&gt;1; build(o&lt;&lt;1,l,mid); build(o&lt;&lt;1|1,mid+1,r); pushup(o,l,r); &#125;&#125;void update(int o,int tl,int tr,int l,int r,int v)&#123; if(tr&lt;l||r&lt;tl)return; if(l&lt;=tl&amp;&amp;tr&lt;=r)&#123; tag[o]+=v; pushup(o,tl,tr); return; &#125; int mid = (tl+tr)&gt;&gt;1; update(o&lt;&lt;1,tl,mid,l,r,v); update(o&lt;&lt;1|1,mid+1,tr,l,r,v); pushup(o,tl,tr);&#125; int main()&#123; int kase = 0; scanf(&quot;%d&quot;,&amp;t); while(t--)&#123; scanf(&quot;%d&quot;,&amp;n); int cnt = 0; int ty = 0; int tz = 0; for(int i=0;i&lt;n;i++)&#123; int a,b,c,d,e,f; scanf(&quot;%d%d%d%d%d%d&quot;,&amp;a,&amp;b,&amp;c,&amp;d,&amp;e,&amp;f); line[cnt].x1 = a; line[cnt].y1 = b; line[cnt].y2 = e; line[cnt].z1 = c; line[cnt].z2 = f; line[cnt++].k = 1; line[cnt].x1 = d; line[cnt].y1 = b; line[cnt].y2 = e; line[cnt].z1 = c; line[cnt].z2 = f; line[cnt++].k = -1; y[ty++] = b; y[ty++] = e; z[tz++] = c; z[tz++] = f; &#125; sort(line,line+cnt); sort(y,y+ty); sort(z,z+tz); ty = unique(y,y+ty) - y; tz = unique(z,z+tz) - z; long long res = 0; for(int i=0;i&lt;tz-1;i++)&#123; int z1 = z[i]; int z2 = z[i+1]; build(1,1,ty); long long ans = 0 ; int now = 0; for(int j=0;j&lt;cnt;j++)&#123;//先把两个z之间符合条件的扫面先提出来 if(line[j].z1&lt;=z1&amp;&amp;line[j].z2&gt;=z2)tmp[now++] = line[j]; &#125; for(int j=0;j&lt;now;j++)&#123;//正常二维扫描线操作 int l = lower_bound(y,y+ty,tmp[j].y1) - y+1; int r = lower_bound(y,y+ty,tmp[j].y2) - y; update(1,1,ty,l,r,tmp[j].k); if(j!=now-1)ans+=1LL*(tmp[j+1].x1-tmp[j].x1)*len3[1]; &#125; res+=1LL*ans*(z2-z1); &#125; printf(&quot;Case %d: %lld\n&quot;,++kase,res); &#125; return 0;&#125;]]></content>
      <categories>
        <category>线段树</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[HDU3038(How-Many-Answers-Are-Wrong)]]></title>
    <url>%2F2018%2F11%2F17%2FHDU3038(How-Many-Answers-Are-Wrong)%2F</url>
    <content type="text"><![CDATA[链接：https://vjudge.net/problem/HDU-3038思路：带权并查集，首先我们要考虑在什么情况下会出错，当且仅当某个区间开头和位置以及和都确定并且产生矛盾的时候，于是我们建立一个带权并查集，每个区间查询其左端点-1的节点(因为左端点也要算在和内)与右端点的节点的祖先节点，如果相同说明通过其他的操作已经可以推算出这个区间的值了(自行思考推理一下)，只需要比对一下前后到祖先节点距离的差值是否等于给定的值即可，如果不等则说明没法推断出，则不会产生矛盾，此时将两个端点合并，并且更新各节点到祖先节点的距离。代码：1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 200010;int par[maxn];int n,m;int sum[maxn];int getroot(int a)&#123; if(par[a]==a)return a; int p = par[a]; par[a] = getroot(par[a]); sum[a]+=sum[p];//更新到祖先节点的距离 return par[a];&#125;int main()&#123; while(~scanf(&quot;%d%d&quot;,&amp;n,&amp;m))&#123; int res = 0; for(int i=0;i&lt;=n;i++)&#123; par[i] = i; sum[i] = 0; &#125; for(int i=0;i&lt;m;i++)&#123; int u,v,w; scanf(&quot;%d%d%d&quot;,&amp;u,&amp;v,&amp;w); u--; int p1 = getroot(u); int p2 = getroot(v); if(p1==p2)&#123; if(sum[v]-sum[u]!=w)res++;//更新答案 &#125; else&#123; par[p2] = p1; sum[p2] = sum[u] - sum[v] + w;//自行画图即可得出该表达式 &#125; &#125; printf(&quot;%d\n&quot;,res); &#125; return 0;&#125;]]></content>
      <categories>
        <category>并查集</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[HDU1542(Atlantis)]]></title>
    <url>%2F2018%2F11%2F17%2FHDU1542(Atlantis)%2F</url>
    <content type="text"><![CDATA[链接：https://vjudge.net/problem/HDU-1542思路：做了之前矩形面积的覆盖和周长的题目后，这个题就容易多了，十几分钟就写完了，但之所以还要写一份题解是有个地方想要提醒一下。还是从头说起，因为端点是小数所以必须要经过离散化，然后每个区间记录被覆盖的次数和区间覆盖长度总和，因为只用求sum[1]所以只需要把下面的信息向上整合即可，问题在于离散化后端点到底表示的是什么，一开始一直没想清楚理所当然的写，后面细细考虑了一下，对于某个端点l，他表示的是l到l+1这个区间的长度，这样的话叶节点本身也才具有意义，所以我们的每个叶节点应该是保存的某个区间，只是用区间的左边界来代替表示区间罢了，所以更新的时候找出来的右端点要-1，里面查询的时候不用再减即可。（注意输出格式，最近一直吃pe就很难受~）代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e5+10;int tag[maxn&lt;&lt;2];double seg[maxn],sum[maxn&lt;&lt;2];int n,q;struct line&#123;//扫描线 double x1,y1,y2; int k; bool operator&lt;(const line &amp; r)&#123; return x1&lt;r.x1||(x1==r.x1&amp;&amp;k&gt;r.k); &#125;&#125;li[maxn];inline void pushup(int o,int l,int r)&#123; if(tag[o])sum[o] = seg[r] - seg[l-1];//在外面区间减过了这里就不需要再减了 else sum[o] = sum[o&lt;&lt;1] + sum[o&lt;&lt;1|1];&#125;void build(int o,int l,int r)&#123; tag[o] = 0; sum[o] = 0; if(l&lt;r)&#123; int mid = l+r&gt;&gt;1; build(o&lt;&lt;1,l,mid); build(o&lt;&lt;1|1,mid+1,r); pushup(o,l,r); &#125;&#125;void update(int o,int tl,int tr,int l,int r,int v)&#123; if(tr&lt;l||r&lt;tl)return; if(l&lt;=tl&amp;&amp;tr&lt;=r)&#123; tag[o]+=v; pushup(o,tl,tr);//不要忘记这里需要pushup一次 return; &#125; int mid = (tl+tr)&gt;&gt;1; update(o&lt;&lt;1,tl,mid,l,r,v); update(o&lt;&lt;1|1,mid+1,tr,l,r,v); pushup(o,tl,tr);&#125; int main()&#123; int kase = 0; while(~scanf(&quot;%d&quot;,&amp;n)&amp;&amp;n)&#123; int cnt = 0; int tt = 0; for(int i=0;i&lt;n;i++)&#123; double a,b,c,d; scanf(&quot;%lf%lf%lf%lf&quot;,&amp;a,&amp;b,&amp;c,&amp;d); li[cnt].x1 = a; li[cnt].y1 = b; li[cnt].y2 = d; li[cnt++].k = 1; li[cnt].x1 = c; li[cnt].y1 = b; li[cnt].y2 = d; li[cnt++].k = -1; seg[tt++] = b; seg[tt++] = d; &#125; sort(seg,seg+tt); sort(li,li+cnt); tt = unique(seg,seg+tt) - seg; build(1,1,tt); double res = 0; for(int i=0;i&lt;cnt;i++)&#123; int l = lower_bound(seg,seg+tt,li[i].y1)-seg+1; int r = lower_bound(seg,seg+tt,li[i].y2)-seg;//右区间需要减1 update(1,1,tt,l,r,li[i].k); if(i!=cnt-1)res+=(li[i+1].x1-li[i].x1)*sum[1]; &#125; printf(&quot;Test case #%d\nTotal explored area: %.2f\n\n&quot;,++kase,res); &#125; return 0;&#125;]]></content>
      <categories>
        <category>线段树</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[HDU1540(Tunnel-Warfare-)]]></title>
    <url>%2F2018%2F11%2F17%2FHDU1540(Tunnel-Warfare-)%2F</url>
    <content type="text"><![CDATA[链接：https://vjudge.net/problem/HDU-1540思路：这个题真的想透我感觉能明白线段树很多本质，首先我们要思考区间合并信息时我们需要什么，因为是左区间的右端点和右区间的左端点进行合并，所以我们需要记录左区间的最大长度和右区间的最大长度，再维护一个当前区间的最大长度用于求合并的最大长度(合并后的最大长度可能是左右区间中某一个不含端点的区间)，合并的时候注意判断。因为是单点更新，我们考虑直接更新到叶节点，查询的时候我们考虑对于需要查询的点，往左右两个区间转移，如果在左子树且在右区间范围，那么结果就是左子树的右区间长度+右子树的左区间长度，如果在左子树但是不在其右区间范围内，那么查询左子树，如果在右子树同理可推(在这里wa了两个小时，我直接查询的左右区间，这样当查询点不在当前区间内也会有返回值)。代码： #include&lt;cstdio&gt; #include&lt;algorithm&gt; #include&lt;cstring&gt; #include&lt;stack&gt; using namespace std; const int maxn = 1e5+10; int sum[maxn&lt;&lt;2],ll[maxn&lt;&lt;2],rr[maxn&lt;&lt;2]; int n,q; inline void pushup(int o,int m){//判断各种合并情况 if(ll[o&lt;&lt;1]==(m-(m&gt;&gt;1)))ll[o] = ll[o&lt;&lt;1] + ll[o&lt;&lt;1|1]; else ll[o] = ll[o&lt;&lt;1]; if(rr[o&lt;&lt;1|1]==(m&gt;&gt;1))rr[o] = rr[o&lt;&lt;1|1] + rr[o&lt;&lt;1]; else rr[o] = rr[o&lt;&lt;1|1]; sum[o] = max(max(sum[o&lt;&lt;1],sum[o&lt;&lt;1|1]),rr[o&lt;&lt;1]+ll[o&lt;&lt;1|1]); } void build(int o,int l,int r){ if(l&lt;r){ int mid = l+r&gt;&gt;1; build(o&lt;&lt;1,l,mid); build(o&lt;&lt;1|1,mid+1,r); pushup(o,r-l+1); } else{ sum[o] = 1; ll[o] = 1; rr[o] = 1; } } void destroy(int o,int tl,int tr,int v){ if(v&lt;tl||v&gt;tr)return; if(tl==tr){ ll[o] = 0; rr[o] = 0; sum[o] = 0; return ; } int mid = (tl+tr)&gt;&gt;1; destroy(o&lt;&lt;1,tl,mid,v); destroy(o&lt;&lt;1|1,mid+1,tr,v); pushup(o,tr-tl+1); } void rebuild(int o,int tl,int tr,int v){ if(v&lt;tl||v&gt;tr)return; if(tl==tr){ ll[o] = 1; rr[o] = 1; sum[o] = 1; return ; } int mid = (tl+tr)&gt;&gt;1; rebuild(o&lt;&lt;1,tl,mid,v); rebuild(o&lt;&lt;1|1,mid+1,tr,v); pushup(o,tr-tl+1); } int query(int o,int tl,int tr,int v){ if(sum[o]==tr-tl+1||sum[o]==0||tr==tl)return sum[o]; int mid = (tl+tr)&gt;&gt;1; if(v&lt;=mid){ if(v&gt;=mid-rr[o&lt;&lt;1]+1)return rr[o&lt;&lt;1]+ll[o&lt;&lt;1|1]; else return query(o&lt;&lt;1,tl,mid,v); } else{ if(v&lt;=mid+ll[o&lt;&lt;1|1])return rr[o&lt;&lt;1]+ll[o&lt;&lt;1|1]; else return query(o&lt;&lt;1|1,mid+1,tr,v); } } stack&lt;int&gt; s; char ch[10]; int main(){ while(~scanf(&quot;%d%d&quot;,&amp;n,&amp;q)){ while(!s.empty())s.pop(); memset(sum,0,sizeof(sum)); memset(ll,0,sizeof(ll)); memset(rr,0,sizeof(rr)); build(1,1,n); for(int i=0;i&lt;q;i++){ int o; scanf(&quot;%s&quot;,ch); if(ch[0]==&#39;D&#39;){ scanf(&quot;%d&quot;,&amp;o); destroy(1,1,n,o); s.push(o); } if(ch[0]==&#39;R&#39;){ if(!s.empty()){ int p = s.top(); s.pop(); rebuild(1,1,n,p); } } if(ch[0]==&#39;Q&#39;){ scanf(&quot;%d&quot;,&amp;o); printf(&quot;%d\n&quot;,query(1,1,n,o)); } } } return 0; }]]></content>
      <categories>
        <category>线段树</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[HDU1255(覆盖的面积)]]></title>
    <url>%2F2018%2F11%2F17%2FHDU1255(%E8%A6%86%E7%9B%96%E7%9A%84%E9%9D%A2%E7%A7%AF)%2F</url>
    <content type="text"><![CDATA[链接：https://vjudge.net/contest/260644#problem/O思路：本来以为只用维护一个tag表示该区间被覆盖了几次就完事了，后来怎么调试都不对，经过gay一指导可能存在先把子区间全部覆盖完全，再把父区间覆盖，这样的话父区间已经被覆盖了两次但是由于tag没法表示离散的覆盖一整段所以没法实现，没办法看了题解，用len0表示区间长度，len1表示区间被覆盖一次的长度，len2表示区间被覆盖两次的长度，tag表示区间覆盖的次数，这样分类讨论一下就不会存在离散区间覆盖不了的问题。代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e5+10;double seg[maxn];int tag[maxn&lt;&lt;2];double len0[maxn&lt;&lt;2],len1[maxn&lt;&lt;2],len2[maxn&lt;&lt;2];int n;struct Segment&#123; double x1,y1,y2; int k; bool operator&lt;(const Segment &amp;r)&#123; return x1&lt;r.x1||(x1==r.x1&amp;&amp;k&gt;r.k); &#125;&#125;ss[maxn];void pushup(int o,int l,int r)&#123; if(tag[o]&gt;=2)&#123;//如果覆盖两次及以上，len2等于区间长度，len1为0 len2[o] = len0[o]; len1[o] = 0; &#125; else if(tag[o]==1)&#123;覆盖一次，len1等于区间长度 len1[o] = len0[o]; if(l==r)len2[o] = 0;//如果在端点，len2为0 else//否则len2等于左右子树len2之和 len2[o] = len1[o&lt;&lt;1] + len1[o&lt;&lt;1|1] + len2[o&lt;&lt;1] + len2[o&lt;&lt;1|1]; len1[o]-=len2[o]; &#125; else&#123; if(l==r)len1[o] = len2[o] = 0;//端点全为0 else&#123;//否则为左右子树和 len2[o] = len2[o&lt;&lt;1] + len2[o&lt;&lt;1|1]; len1[o] = len1[o&lt;&lt;1] + len1[o&lt;&lt;1|1]; &#125; &#125;&#125;void build(int o,int l,int r)&#123; tag[o] = 0; len0[o] = seg[r] - seg[l-1]; len1[o] = len2[o] = 0; if(l&lt;r)&#123; int mid = l+r&gt;&gt;1; build(o&lt;&lt;1,l,mid); build(o&lt;&lt;1|1,mid+1,r); pushup(o,l,r); &#125;&#125;void update(int o,int tl,int tr,int l,int r,int v)&#123; if(tr&lt;l||r&lt;tl)return; if(l&lt;=tl&amp;&amp;tr&lt;=r)&#123; tag[o]+=v; pushup(o,tl,tr);//一定要记住在这里pushup，把信息整合上去，因为处理的是本节点的信息。 return; &#125; int mid = (tl+tr)&gt;&gt;1; update(o&lt;&lt;1,tl,mid,l,r,v); update(o&lt;&lt;1|1,mid+1,tr,l,r,v); pushup(o,tl,tr);&#125; int T;int main()&#123; scanf(&quot;%d&quot;,&amp;T); while(T--)&#123; scanf(&quot;%d&quot;,&amp;n); int cnt = 0; int tt = 0; for(int i=0;i&lt;n;i++)&#123; double a,b,c,d; scanf(&quot;%lf%lf%lf%lf&quot;,&amp;a,&amp;b,&amp;c,&amp;d); ss[cnt].x1 = a; ss[cnt].y1 = b; ss[cnt].y2 = d; ss[cnt++].k = 1; ss[cnt].x1 = c; ss[cnt].y1 = b; ss[cnt].y2 = d; ss[cnt++].k = -1; seg[tt++] = b; seg[tt++] = d; &#125; sort(ss,ss+cnt); sort(seg,seg+tt); double res = 0; tt = unique(seg,seg+tt)-seg; build(1,1,tt); for(int i=0;i&lt;cnt;i++)&#123; int l = lower_bound(seg,seg+tt,ss[i].y1)-seg+1; int r = lower_bound(seg,seg+tt,ss[i].y2)-seg; update(1,1,tt,l,r,ss[i].k); if(i!=cnt-1) res+=(ss[i+1].x1-ss[i].x1)*len2[1];//注意是后面x减当前x &#125; printf(&quot;%.2f\n&quot;,res); &#125; return 0;&#125;]]></content>
      <categories>
        <category>线段树</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[HDU1024(Max-Sum-Plus-Plus)]]></title>
    <url>%2F2018%2F11%2F17%2FHDU1024(Max-Sum-Plus-Plus)%2F</url>
    <content type="text"><![CDATA[链接：https://vjudge.net/problem/HDU-1024思路：强迫自己全程写不看题解，结果中间因为初始化wa了一次，状态转移没考虑完全又wa了一次。希望以后能够把这些细节全部考虑完全吧。一开始觉得有点难因为m没给范围，想了想怎么都避不开O(nm)的复杂度，那猜了一下O(nm)可能可以过，空间的话我们可以滚动数组优化，考虑描述状态，dp[i][j][k]表示选了i个数（j=0表示第i个数不选，j=1表示第i个数选，k用来滚动），那么转移的话dp[i][1][nowi^1] = max(dp[i-1][0][nowi],dp[i][1][nowi],dp[i][1][nowi])+a[i] (注意即使之前选了也可以强制分成在本次操作中加一次分割次数)，dp[i][0][nowi^1] = max(dp[i][0][nowi],dp[i][1][nowi])，注意初始化状态即可。代码：1234567891011121314151617181920212223242526272829303132#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 1e6+100;ll dp[maxn][2][2];int a[maxn];int n,m;int main()&#123; while(~scanf(&quot;%d%d&quot;,&amp;m,&amp;n))&#123; for(int i=1;i&lt;=n;i++)&#123; scanf(&quot;%d&quot;,&amp;a[i]); dp[i][0][0] = dp[i][0][1] = -1e18; dp[i][1][0] = dp[i][1][1] = -1e18; &#125; dp[0][0][0] = dp[0][0][1] = 0; dp[0][1][0] = dp[0][1][1] = 0; int nowi = 0; if(m&gt;n)m = n; for(int i=1;i&lt;=n;i++)&#123; for(int j=1;j&lt;=m;j++)&#123; dp[j][1][nowi^1] = max(dp[j-1][1][nowi],max(dp[j][1][nowi],dp[j-1][0][nowi]))+a[i]; dp[j][0][nowi^1] = max(dp[j][0][nowi],dp[j][1][nowi]); &#125; nowi^=1; &#125; long long res = max(dp[m][0][nowi],dp[m][1][nowi]); printf(&quot;%lld\n&quot;,res); &#125; return 0;&#125;]]></content>
      <categories>
        <category>基础dp</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[HDU(5985)(Lucky-Coins)]]></title>
    <url>%2F2018%2F11%2F17%2FHDU(5985)(Lucky-Coins)%2F</url>
    <content type="text"><![CDATA[链接：https://vjudge.net/problem/HDU-5985思路：数学题，哎呀差一丢丢就自己做出来了，没发现有地方重复计算了。说一下思路，先算出前100天（100天之后基本不影响最后结果的精度了，可以忽略不计）每种硬币全部死亡的概率。然后开始枚举，某种硬币在某一天（1-100）成为幸运硬币的可能，将所有的天的概率加起来。注意为了避免重复，某一天成为幸运硬币的概率应该等于其他所有种类硬币全死概率×（自己当天存活-上一天存货概率）（即为在这一天活下来且下一天死亡的概率），这样保存枚举的那天就恰好是幸运硬币出现的那天，不会出现重复计算的可能，这一点没想到啊！！！！！！代码：1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;bits/stdc++.h&gt;using namespace std;double p[10];double pp[10][100];int num[10];double res[10];int t,n;int main()&#123; scanf(&quot;%d&quot;,&amp;t); while(t--)&#123; memset(pp,0,sizeof(pp)); scanf(&quot;%d&quot;,&amp;n); memset(res,0,sizeof(res)); for(int i=0;i&lt;n;i++)scanf(&quot;%d%lf&quot;,&amp;num[i],&amp;p[i]); if(n==1)printf(&quot;1.000000\n&quot;); else&#123; for(int i=0;i&lt;n;i++)&#123; for(int j=1;j&lt;=100;j++)&#123; pp[i][j] = pow(1-pow(p[i],j),num[i]);//某种硬币在第j天全部死亡的概率 &#125; &#125; for(int i=0;i&lt;n;i++)&#123; for(int j=1;j&lt;=99;j++)&#123; double ans = 1; for(int k=0;k&lt;n;k++)&#123; if(k==i)continue; ans*=pp[k][j]; &#125; res[i]+=(pp[i][j+1]-pp[i][j])*ans;//当天存活下一天死亡的概率*其他所有硬币死亡的概率 &#125; &#125; for(int i=0;i&lt;n-1;i++)&#123; printf(&quot;%.6f &quot;,res[i]); &#125; printf(&quot;%.6f\n&quot;,res[n-1]);&#125;&#125; return 0;&#125;]]></content>
      <categories>
        <category>期望/概率</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Educational-Codeforces-Round-54-(Rated-for-Div--2)(E--Vasya-and-a-Tree)]]></title>
    <url>%2F2018%2F11%2F17%2FEducational-Codeforces-Round-54-(Rated-for-Div--2)(E--Vasya-and-a-Tree%2F</url>
    <content type="text"><![CDATA[链接：http://codeforces.com/contest/1076/problem/E思路：学到了一种新姿势啊，首先来一次dfs或者bfs给树标上深度，然后来dfs，每次到一个结点查询上面是否有需要更新的，然后用深度代表树状数组的下标，在dep[u]上加上权值，在dep[u]+d+1上减去一个权值，这样对于范围外的点用树状数组求和时就可以刚好抵消使得答案不变，而里面的点就可以得到更新后的答案，然后当遍历完回溯时把加上和扣除的权值还原即可。代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef pair&lt;int,ll&gt; P;const int maxn = 3e5+100;ll c[maxn];ll res[maxn];int dep[maxn];vector&lt;int&gt; G[maxn];int n,m;vector&lt;P&gt; ans[maxn];int lowbit(int x)&#123; return x&amp;(-x);&#125;void add(int x,ll d)&#123; while(x&lt;maxn)&#123; c[x]+=d; x+=lowbit(x); &#125;&#125;ll query(int x)&#123; ll res = 0; while(x)&#123; res+=c[x]; x-=lowbit(x); &#125; return res;&#125;void dfs(int u,int f)&#123; for(int i=0;i&lt;G[u].size();i++)&#123; int v = G[u][i]; if(v==f)continue; dep[v] = dep[u] + 1; dfs(v,u); &#125;&#125;void work(int u,int f)&#123; for(int i=0;i&lt;ans[u].size();i++)&#123; int d = ans[u][i].first; int w = ans[u][i].second; if(d&gt;n)d = n; //差分，用dfs当一个偏序，然后在此偏序上用树状数组维护前缀和 add(dep[u],w); add(dep[u]+d+1,-w); &#125; res[u] = query(dep[u]); for(int i=0;i&lt;G[u].size();i++)&#123; int v = G[u][i]; if(v==f)continue; work(v,u); &#125; for(int i=0;i&lt;ans[u].size();i++)&#123; int d = ans[u][i].first; int w = ans[u][i].second; if(d&gt;n)d = n; //还原 add(dep[u],-w); add(dep[u]+d+1,w); &#125;&#125;int main()&#123; scanf(&quot;%d&quot;,&amp;n); for(int i=0;i&lt;n-1;i++)&#123; int u,v; scanf(&quot;%d%d&quot;,&amp;u,&amp;v); G[u].push_back(v); G[v].push_back(u); &#125; scanf(&quot;%d&quot;,&amp;m); for(int i=0;i&lt;m;i++)&#123; int v,d; ll x; scanf(&quot;%d%d%lld&quot;,&amp;v,&amp;d,&amp;x); ans[v].push_back(P&#123;d,x&#125;); &#125; dep[1] = 1; dfs(1,-1); work(1,-1); for(int i=1;i&lt;=n;i++)printf(&quot;%lld &quot;,res[i]); printf(&quot;\n&quot;); return 0;&#125;]]></content>
      <categories>
        <category>树状数组</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Codeforces-Round-520-(Div--2)(E--Company)]]></title>
    <url>%2F2018%2F11%2F17%2FCodeforces-Round-520-(Div--2)(E--Company)%2F</url>
    <content type="text"><![CDATA[链接：http://codeforces.com/contest/1062/problem/E思路：求一个区间内删去一个点后深度最深的lca，首先我们要了解与一个性质，如果按照dfs序下来，那么一个区间内的lca就等于dfs区间中dfs序最小和最大的两个点的lca（其他的点一定都属于这两个点lca的子树里面，可自行证明），这个性质是我们做这个题的前提题，然后区间最值的维护方法有很多，这里我用了线段树不过显得麻烦了，简单一点可以用st表，首先选出最大点u和最小点v，去除最大掉就在（l,u-1）U (u+1,r)中寻找最大值与v求lca，同理对于去除v，最终比较一下两种情况下谁的lca的深度最深就是答案了。顺便用这个题练习了一下倍增法求lca以及lca转RMQ问题，tarjan离线在这个题上我还不太清楚怎么使用，反正通过这个题把三个求lca的板子都顺带写了一下，至于树剖的版本等以后学了再补上来吧。 倍增法版本：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e5+100;int n,q,t;int maxv[maxn&lt;&lt;2],minv[maxn&lt;&lt;2],mini[maxn&lt;&lt;2],maxi[maxn&lt;&lt;2];int in[maxn];void pushup(int o)&#123; if(minv[o&lt;&lt;1]&lt;minv[o&lt;&lt;1|1])&#123; minv[o] = minv[o&lt;&lt;1]; mini[o] = mini[o&lt;&lt;1]; &#125; else&#123; minv[o] = minv[o&lt;&lt;1|1]; mini[o] = mini[o&lt;&lt;1|1]; &#125; if(maxv[o&lt;&lt;1]&gt;maxv[o&lt;&lt;1|1])&#123; maxv[o] = maxv[o&lt;&lt;1]; maxi[o] = maxi[o&lt;&lt;1]; &#125; else&#123; maxv[o] = maxv[o&lt;&lt;1|1]; maxi[o] = maxi[o&lt;&lt;1|1]; &#125;&#125;void build(int o,int l,int r)&#123; if(l&lt;r)&#123; int mid = l+r&gt;&gt;1; build(o&lt;&lt;1,l,mid); build(o&lt;&lt;1|1,mid+1,r); pushup(o); &#125; else&#123; minv[o] = maxv[o] = in[l]; mini[o] = l; maxi[o] = l; &#125;&#125;int querymin(int o,int tl,int tr,int l,int r)&#123; if(tr&lt;l||r&lt;tl)return maxn-1; if(l&lt;=tl&amp;&amp;tr&lt;=r)return mini[o]; int mid = (tl+tr)&gt;&gt;1; int ret1 = querymin(o&lt;&lt;1,tl,mid,l,r); int ret2 = querymin(o&lt;&lt;1|1,mid+1,tr,l,r); if(in[ret1]&lt;in[ret2])return ret1; return ret2;&#125;int querymax(int o,int tl,int tr,int l,int r)&#123; if(tr&lt;l||r&lt;tl)return maxn-2; if(l&lt;=tl&amp;&amp;tr&lt;=r)return maxi[o]; int mid = (tl+tr)&gt;&gt;1; int ret1 = querymax(o&lt;&lt;1,tl,mid,l,r); int ret2 = querymax(o&lt;&lt;1|1,mid+1,tr,l,r); if(in[ret1]&gt;in[ret2])return ret1; return ret2;&#125;struct edge&#123; int from,to,dist;&#125;;struct LCA&#123; int f[maxn][25]; int d[maxn]; int dep[maxn]; vector&lt;int&gt; G[maxn]; vector&lt;edge&gt; edges; int n,m,t; void init(int n,int t)&#123; this-&gt;n = n; this-&gt;t = t; for(int i=0;i&lt;=n;i++)G[i].clear(),dep[i] = d[i] = 0; edges.clear(); &#125; void addedge(int from,int to,int dist = 1)&#123; edges.push_back(edge&#123;from,to,dist&#125;); m = edges.size(); G[from].push_back(m-1); &#125; void bfs()&#123; queue&lt;int&gt; q; q.push(1); dep[1] = 1; while(!q.empty())&#123; int u = q.front(); q.pop(); for(int i=0;i&lt;G[u].size();i++)&#123; edge e = edges[G[u][i]]; int v = e.to; if(dep[v])continue; dep[v] = dep[u] + 1; d[v] = d[u] + e.dist; f[v][0] = u; for(int j=1;j&lt;=t;j++)&#123; f[v][j] = f[f[v][j-1]][j-1]; q.push(v); &#125; &#125; &#125; &#125; int lca(int x,int y)&#123; if(dep[x]&gt;dep[y])swap(x,y); for(int i=t;i&gt;=0;i--)&#123; if(dep[f[y][i]]&gt;=dep[x])y = f[y][i]; &#125; if(x==y)return x; for(int i=t;i&gt;=0;i--)&#123; if(f[x][i]!=f[y][i])x = f[x][i],y = f[y][i]; &#125; return f[x][0]; &#125;&#125;solver;void dfs(int u,int f)&#123; in[u] = t++; for(int i=0;i&lt;solver.G[u].size();i++)&#123; edge e = solver.edges[solver.G[u][i]]; int v = e.to; if(v==f)continue; dfs(v,u); &#125;&#125;int main()&#123; scanf(&quot;%d%d&quot;,&amp;n,&amp;q); solver.init(n,log(n)/log(2)+1); for(int i=2;i&lt;=n;i++)&#123; int a; scanf(&quot;%d&quot;,&amp;a); solver.addedge(i,a); solver.addedge(a,i); &#125; in[maxn-1] = 1e9; in[maxn-2] = 0; solver.bfs(); t = 1; dfs(1,-1); build(1,1,n); // for(int i=1;i&lt;=n;i++)printf(&quot;%d %d\n&quot;,i,in[i]); for(int i=0;i&lt;q;i++)&#123; int l,r; scanf(&quot;%d%d&quot;,&amp;l,&amp;r); int u0 = querymax(1,1,n,l,r); int v0 = querymin(1,1,n,l,r); //printf(&quot;%d %d 111111111\n&quot;,u0,v0); int uu,vv; int u1 = querymax(1,1,n,l,u0-1); int u2 = querymax(1,1,n,u0+1,r); if(in[u1]&gt;in[u2])uu = u1; else uu = u2; int v1 = querymin(1,1,n,l,v0-1); int v2 = querymin(1,1,n,v0+1,r); if(in[v1]&lt;in[v2])vv = v1; else vv = v2; // printf(&quot;%d %d %d %d 3333333333\n&quot;,u1,u2,v1,v2); //printf(&quot;%d %d\n&quot;,uu,vv); int x1 = solver.lca(u0,vv); int x2 = solver.lca(uu,v0); int res = 0; int resx = 1; printf(&quot;%d %d\n&quot;,x1,x2); //printf(&quot;%d %d %d %d 222222222222\n&quot;,x[0],x[1],x[2],x[3]); //printf(&quot;%d %d %d %d 222222222222\n&quot;,solver.dep[x[0]],solver.dep[x[1]],solver.dep[x[2]],solver.dep[x[3]]); int resm; if(solver.dep[x1]&gt;solver.dep[x2])&#123; resm = v0; res = solver.dep[x1]; &#125; else&#123; resm = u0; res = solver.dep[x2]; &#125; printf(&quot;%d %d\n&quot;,resm,res-1); &#125; return 0;&#125; RMQ版本123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e5+100;int n,q,t;int maxv[maxn&lt;&lt;2],minv[maxn&lt;&lt;2],mini[maxn&lt;&lt;2],maxi[maxn&lt;&lt;2];int in[maxn];void pushup(int o)&#123; if(minv[o&lt;&lt;1]&lt;minv[o&lt;&lt;1|1])&#123; minv[o] = minv[o&lt;&lt;1]; mini[o] = mini[o&lt;&lt;1]; &#125; else&#123; minv[o] = minv[o&lt;&lt;1|1]; mini[o] = mini[o&lt;&lt;1|1]; &#125; if(maxv[o&lt;&lt;1]&gt;maxv[o&lt;&lt;1|1])&#123; maxv[o] = maxv[o&lt;&lt;1]; maxi[o] = maxi[o&lt;&lt;1]; &#125; else&#123; maxv[o] = maxv[o&lt;&lt;1|1]; maxi[o] = maxi[o&lt;&lt;1|1]; &#125;&#125;void build(int o,int l,int r)&#123; if(l&lt;r)&#123; int mid = l+r&gt;&gt;1; build(o&lt;&lt;1,l,mid); build(o&lt;&lt;1|1,mid+1,r); pushup(o); &#125; else&#123; minv[o] = maxv[o] = in[l]; mini[o] = l; maxi[o] = l; &#125;&#125;int querymin(int o,int tl,int tr,int l,int r)&#123; if(tr&lt;l||r&lt;tl)return maxn-1; if(l&lt;=tl&amp;&amp;tr&lt;=r)return mini[o]; int mid = (tl+tr)&gt;&gt;1; int ret1 = querymin(o&lt;&lt;1,tl,mid,l,r); int ret2 = querymin(o&lt;&lt;1|1,mid+1,tr,l,r); if(in[ret1]&lt;in[ret2])return ret1; return ret2;&#125;int querymax(int o,int tl,int tr,int l,int r)&#123; if(tr&lt;l||r&lt;tl)return maxn-2; if(l&lt;=tl&amp;&amp;tr&lt;=r)return maxi[o]; int mid = (tl+tr)&gt;&gt;1; int ret1 = querymax(o&lt;&lt;1,tl,mid,l,r); int ret2 = querymax(o&lt;&lt;1|1,mid+1,tr,l,r); if(in[ret1]&gt;in[ret2])return ret1; return ret2;&#125;struct edge&#123; int from,to,dist;&#125;;struct LCA&#123; int n,m; vector&lt;int&gt; G[maxn]; vector&lt;edge&gt; edges; int ntime; int dep[maxn&lt;&lt;1]; int d[maxn&lt;&lt;1][25]; int first[maxn]; int vis[maxn&lt;&lt;1]; void init(int n)&#123; this-&gt;n = n; for(int i=0;i&lt;=n;i++)G[i].clear(); edges.clear(); ntime = 1; memset(vis,0,sizeof(vis)); memset(first,0,sizeof(first)); memset(dep,0,sizeof(dep)); &#125; void addedge(int from,int to,int dist = 1)&#123; edges.push_back(edge&#123;from,to,dist&#125;); m = edges.size(); G[from].push_back(m-1); &#125; void dfs(int u,int f,int d)&#123; first[u] = ntime; vis[ntime] = u; dep[ntime++] = d; for(int i=0;i&lt;G[u].size();i++)&#123; edge e = edges[G[u][i]]; int v = e.to; if(v==f)continue; dfs(v,u,d+1); vis[ntime] = u; dep[ntime++] = d; &#125; &#125; void RMQ_init(int len)&#123; for(int i=1;i&lt;=len;i++)d[i][0] = i; for(int j=1;(1&lt;&lt;j)&lt;=len;j++)&#123; for(int i=1;i+(1&lt;&lt;j)-1&lt;=len;i++)&#123; int a = d[i][j-1]; int b = d[i+(1&lt;&lt;(j-1))][j-1]; if(dep[a]&lt;=dep[b])d[i][j] = a; else d[i][j] = b; &#125; &#125; &#125; int query(int l,int r)&#123; int k = 0; while((1&lt;&lt;(k+1))&lt;=r-l+1)k++; int a = d[l][k]; int b = d[r-(1&lt;&lt;k)+1][k]; if(dep[a]&lt;=dep[b])return a; return b; &#125; int lca(int u,int v)&#123; int x = first[u]; int y = first[v]; if(x&gt;y)swap(x,y); return vis[query(x,y)]; &#125; void solve()&#123; dfs(1,-1,0); RMQ_init(ntime-1); &#125;&#125;solver;int dd[maxn];void dfs(int u,int f)&#123; in[u] = t++; for(int i=0;i&lt;solver.G[u].size();i++)&#123; edge e = solver.edges[solver.G[u][i]]; int v = e.to; if(v==f)continue; dd[v] = dd[u] + 1; dfs(v,u); &#125;&#125;int main()&#123; scanf(&quot;%d%d&quot;,&amp;n,&amp;q); solver.init(n); for(int i=2;i&lt;=n;i++)&#123; int a; scanf(&quot;%d&quot;,&amp;a); solver.addedge(i,a); solver.addedge(a,i); &#125; solver.solve(); in[maxn-1] = 1e9; in[maxn-2] = 0; t = 1; dd[1] = 1; dfs(1,-1); build(1,1,n); //for(int i=1;i&lt;=n;i++)printf(&quot;%d %d\n&quot;,i,dd[i]); for(int i=0;i&lt;q;i++)&#123; int l,r; scanf(&quot;%d%d&quot;,&amp;l,&amp;r); int u0 = querymax(1,1,n,l,r); int v0 = querymin(1,1,n,l,r); //printf(&quot;%d %d 111111111\n&quot;,u0,v0); int uu,vv; int u1 = querymax(1,1,n,l,u0-1); int u2 = querymax(1,1,n,u0+1,r); if(in[u1]&gt;in[u2])uu = u1; else uu = u2; int v1 = querymin(1,1,n,l,v0-1); int v2 = querymin(1,1,n,v0+1,r); if(in[v1]&lt;in[v2])vv = v1; else vv = v2; //printf(&quot;%d %d %d %d 3333333333\n&quot;,u1,u2,v1,v2); //printf(&quot;%d %d\n&quot;,uu,vv); int x1 = solver.lca(u0,vv); int x2 = solver.lca(uu,v0); int res = 0; int resx = 1; //printf(&quot;%d %d\n&quot;,x1,x2); //printf(&quot;%d %d %d %d 222222222222\n&quot;,x[0],x[1],x[2],x[3]); //printf(&quot;%d %d %d %d 222222222222\n&quot;,solver.dep[x[0]],solver.dep[x[1]],solver.dep[x[2]],solver.dep[x[3]]); int resm; if(dd[x1]&gt;dd[x2])&#123; resm = v0; res = dd[x1]; &#125; else&#123; resm = u0; res = dd[x2]; &#125; printf(&quot;%d %d\n&quot;,resm,res-1); &#125; return 0;&#125;]]></content>
      <categories>
        <category>LCA</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Codeforces-Round-514-(Div--2)(Nature-Reserve)]]></title>
    <url>%2F2018%2F11%2F17%2FCodeforces-Round-514-(Div--2)(Nature-Reserve)%2F</url>
    <content type="text"><![CDATA[链接：https://codeforces.com/contest/1059/problem/D思路：给n个点，一个半径为r圆包含所有点（包括在圆上）并且与y轴相切，求r的最小值。二分三分都可做，一个一个来。二分：枚举半径，然后用射影定理化简得出这个点覆盖的x的坐标，如果所有的x覆盖的区间有交集的话这个圆就存在，并且枚举满足单调性。代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e5+100;struct point&#123; double x,y;&#125;pp[maxn];int n;bool c(double d)&#123; double maxv = -1e17; double minv = 1e17; double t; for(int i=0;i&lt;n;i++)&#123; t = pp[i].y * (2*d - pp[i].y); if(t&lt;0)return false; //当比半径2倍还高说明无法走到 t = sqrt(t); maxv = max(maxv,pp[i].x-t); minv = min(minv,pp[i].x+t); &#125; return maxv&lt;=minv;&#125;int main()&#123; scanf(&quot;%d&quot;,&amp;n); int now = 0; int flag = 0; for(int i=0;i&lt;n;i++)&#123; scanf(&quot;%lf%lf&quot;,&amp;pp[i].x,&amp;pp[i].y); if(i==0)&#123; if(pp[i].y&lt;0)now = -1; else now = 1; &#125; if(i)&#123; if(now*pp[i].y&lt;0)&#123; flag = 1; &#125; &#125; pp[i].y = abs(pp[i].y); &#125; if(flag)&#123; printf(&quot;-1\n&quot;); return 0; &#125; double ub = 1e15; double lb = 0; double ans = 1e15; while(fabs(ub-lb)/max(lb,1.0)&gt;1e-7)&#123; double mid = (ub+lb)/2; if(c(mid))&#123; ub = mid; ans = min(ans,mid); &#125; else lb = mid; &#125; printf(&quot;%.7f\n&quot;,ans); return 0;&#125; 三分：写出点到圆心的距离，发现是只跟x有关的一个二次函数，满足减增减的性质，考虑枚举x的坐标，然后通过化简可以发现距离跟圆心位置的y坐标无关，然后每次取n个点中距离的最大值返回，三分求一个最小值即可。代码：123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e5+100;int n;struct point&#123; double x,y;&#125;pp[maxn];double c(double d)&#123; double res = 0; for(int i=0;i&lt;n;i++)&#123; res = max(res,(pp[i].y*pp[i].y+(pp[i].x-d)*(pp[i].x-d))/2.0/pp[i].y); &#125; return res;&#125;int main()&#123; scanf(&quot;%d&quot;,&amp;n); int xx = 0,yy = 0; for(int i=0;i&lt;n;i++)&#123; scanf(&quot;%lf%lf&quot;,&amp;pp[i].x,&amp;pp[i].y); if(pp[i].y&lt;0)xx++; else yy++; pp[i].y = fabs(pp[i].y); &#125; if(xx&amp;&amp;yy)&#123; printf(&quot;-1\n&quot;); return 0; &#125; double ub = 1e7; double lb = -1e7; while(ub-lb&gt;1e-8)&#123; double r1 = lb + (ub-lb)/3; double r2 = lb + 2*(ub-lb)/3; if(c(r1)&lt;c(r2))ub = r2; else lb = r1; &#125; printf(&quot;%.7f\n&quot;,c(lb)); return 0;&#125;]]></content>
      <categories>
        <category>三分</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Codeforces-Round-506-(Div--3)(Tree-with-Small-Distances)]]></title>
    <url>%2F2018%2F11%2F17%2FCodeforces-Round-506-(Div--3)(Tree-with-Small-Distances)%2F</url>
    <content type="text"><![CDATA[链接：https://codeforces.com/contest/1029/problem/E思路：一开始想用树形dp做，但后来怎么做都有错，想法时用dp(u,f,flag)表示状态，u表示当前节点，f表示父节点，flag表示上一个节点是否与1连通.先做一遍dfs把与1节点距离在2以内的点全部先标记出来，然后如果flag为0或者与1距离位2及以内则不需要+1，否则必须连边+1，然后直到无路可走最后就是正确答案，但是不知道哪里错了= =，就有几个数据过不了不知道是哪种特殊情况没有考虑到QAQ。然后说一下官方的做法吧，直接遍历一遍，因为连通且只有n-1条边，所以到每个点的路有且仅有一条，所以距离也是唯一确定的，直接一遍dfs更新所有点的距离，然后把距离大于2的点放入一个set中，然后我们考虑，因为是有向图且只有一条路径，所以如果你连接一个点，他有可能为根节点，结果一定没有连他的父节点优，那父节点是不是一定是最优的呢，答案是肯定的，因为父节点一定要连，不然根节点就没法在距离2以内，所以我们就贪心，遍历整个set，然后找到他的父节点，连边并将+1，然后将这个父节点指向的所有其他节点（如果在set集合内）全部从set中删去，直到最终set只有一个节点，最后这个节点需要特判，直接+1即可= =，这样的贪心一定得到的是最优解代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include&lt;bits/stdc++.h&gt;using namespace std;int n;const int maxn = 2e5+100;vector&lt;int&gt; G[maxn];//这一部分是dp代码错误的，不知道哪里错了放在这里吧- -/*int used[maxn];int d[maxn];int ans = 0;void dfs(int u,int f)&#123;bool flag = false; for(int i=0;i&lt;G[u].size();i++)&#123; int v = G[u][i]; if(v!=f)&#123; d[v] = d[u] + 1; dfs(v,u); flag|=used[v]; &#125; &#125; if(d[u]&gt;2&amp;&amp;!used[u]&amp;&amp;!flag&amp;&amp;!used[f])&#123; used[f] = true; ans++; &#125;&#125;int main()&#123; scanf(&quot;%d&quot;,&amp;n); for(int i=0;i&lt;n-1;i++)&#123; int a,b; scanf(&quot;%d%d&quot;,&amp;a,&amp;b); G[a].push_back(b); G[b].push_back(a); &#125; dfs(1,0); printf(&quot;%d\n&quot;,ans); return 0;&#125;*/int d[maxn];int f[maxn];set&lt;pair&lt;int,int&gt; &gt; jj;void dfs(int u,int p)&#123; f[u] = p; for(int i=0;i&lt;G[u].size();i++)&#123; int v = G[u][i]; if(v!=p)&#123; d[v] = d[u] + 1; dfs(v,u); &#125; &#125;&#125;int main()&#123; scanf(&quot;%d&quot;,&amp;n); for(int i=0;i&lt;n-1;i++)&#123; int a,b; scanf(&quot;%d%d&quot;,&amp;a,&amp;b); G[a].push_back(b); G[b].push_back(a); &#125; dfs(1,-1); for(int i=1;i&lt;=n;i++)&#123; if(d[i]&gt;2)jj.insert(make_pair(-d[i],i)); &#125; int ans = 0; while(!jj.empty())&#123; int v = jj.begin()-&gt;second; v = f[v]; ++ans; auto it = jj.find(make_pair(-d[v],v));//可以学习一下auto的用法 if(it!=jj.end())jj.erase(it); for(auto to : G[v])&#123; auto it = jj.find(make_pair(-d[to],to)); if(it!=jj.end()) jj.erase(it);从set中剔除it元素 &#125; &#125; printf(&quot;%d\n&quot;,ans); return 0;&#125;]]></content>
      <categories>
        <category>树形dp</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Codeforces-Round-506-(Div--3)(F--Multicolored-Markers)]]></title>
    <url>%2F2018%2F11%2F17%2FCodeforces-Round-506-(Div--3)(F--Multicolored-Markers)%2F</url>
    <content type="text"><![CDATA[链接：https://codeforces.com/contest/1029/problem/F思路：i从1开始到根号（a+b）进行遍历，维护一个最小值，当某个值是a或b的因子时，更新这个最小值为(a或者b)/i，表示要放一个矩形在里面所需要的最小的边，如果当(a+b)%i==0时且最小值小于(a+b)/i，就表示可以放下一个矩形，从而更新一下周长的最小值，一直到遍历结束即可。这个题必须要这样从小到大遍历，不然将面临一个大矩形里面放能否放一个a或者b的矩形这样的问题，无法在常数的时间内解决，复杂度会加一个维度，从小到达遍历保证每一种能放的情况都考虑到了，从而一定会找到最优解。代码：1234567891011121314151617#include&lt;bits/stdc++.h&gt;using namespace std;long long a,b;int main()&#123; scanf(&quot;%I64d%I64d&quot;,&amp;a,&amp;b); long long i = sqrt(a+b+0.1); long long minv = 1e18,res = 1e18; for(long long j=1;j&lt;=i;j++)&#123; if(a%j==0)minv = min(minv,a/j); if(b%j==0)minv = min(minv,b/j); if((a+b)%j==0&amp;&amp;minv&lt;=(a+b)/j)res = min(res,2*j+2*(a+b)/j); &#125; printf(&quot;%I64d\n&quot;,res); return 0;&#125;]]></content>
      <categories>
        <category>数论</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Codeforces-Round-506-(Div--3)(D--Concatenated-Multiples)]]></title>
    <url>%2F2018%2F11%2F17%2FCodeforces-Round-506-(Div--3)(D--Concatenated-Multiples)%2F</url>
    <content type="text"><![CDATA[链接：https://codeforces.com/contest/1029/problem/D思路：题目要求任选两个不相同数按照字符串形式拼起来后，能被k整除，求一共有多少组。首先我们不可能真的把他拼起来再去算，而且n的范围告诉我们我们只能枚举一个数，个数要在O（1）时间内求出，那么我们自然而然想到枚举这个每个数字后面拼1-9位时他的余数，用一个map记录某位数余数位某个数时的数字的个数，然后查询即可。代码：123456789101112131415161718192021222324252627282930313233#include&lt;bits/stdc++.h&gt;using namespace std;int n,k;const int maxn = 2e5+100;int a[maxn];map&lt;int,int&gt; jj[15]; //map&lt;余数,数目&gt; jj[位数]int num[maxn];long long res = 0;int main()&#123; scanf(&quot;%d%d&quot;,&amp;n,&amp;k); for(int i=1;i&lt;=n;i++)&#123; scanf(&quot;%d&quot;,&amp;a[i]); int now = a[i]; while(now&gt;0)&#123; now/=10; num[i]++; &#125; jj[num[i]][a[i]%k]++;//位数位num[i]余数位a[i]%k的数个数+1 &#125; for(int i=1;i&lt;=n;i++)&#123; long long base = 1,now = 0; for(int j=1;j&lt;=10;j++)&#123; base*=10; now = ((base%k)*(a[i]%k))%k; res+=jj[j][(k-now)%k];//查询位数为j且余数为(k-now)%k的数有多少个 if(j==num[i]&amp;&amp;(now%k+a[i]%k)%k==0)res--; //如果对应相等，则他自己也被算了一次，要在这里扣除 &#125; &#125; printf(&quot;%I64d\n&quot;,res); return 0;&#125;]]></content>
      <categories>
        <category>数位dp</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Codeforces(Vasya-And-The-Mushrooms)]]></title>
    <url>%2F2018%2F11%2F17%2FCodeforces(Vasya-And-The-Mushrooms)%2F</url>
    <content type="text"><![CDATA[链接：http://codeforces.com/contest/1016/problem/C思路：首先观察可知一共有n个终点，所以自然想到遍历一遍复杂度应该为O(n)，但是要求和，如果不加以处理必定会上升到O(n^2)的复杂度，考虑以下：sum123表示从左到右走到头所摘蘑菇总数，sun321表示从右到左所摘蘑菇总数，sum111表示这一段初始蘑菇总和。我们观察到，不管什么时候开始走sum123+sum321的情况(即一路走到头再从上面回来，中间不转弯)，都与原始求的sum123与sum321差一个常数*sum111，因为可把复杂度变为O(n)代码：12345678910111213141516171819202122232425262728293031323334#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;long long sum123[2][300001],sum321[2][300001],sum111[2][300001];int n;int a[2][300001];int main()&#123;scanf(&quot;%d&quot;,&amp;n);for(int i=0;i&lt;2;i++)&#123; for(int j=0;j&lt;n;j++)&#123; scanf(&quot;%d&quot;,&amp;a[i][j]); &#125;&#125;for(int i=0;i&lt;2;i++)&#123;for(int j=n-1;j&gt;=0;j--)&#123; sum123[i][j] = sum123[i][j+1] + j*1LL*a[i][j]; //从i,j一直走到右边端点所摘磨菇数总和 sum321[i][j] = sum321[i][j+1] + (n-j)*1LL*a[i][j];//从右端点走到i,j所摘磨菇数总和 sum111[i][j] = sum111[i][j+1] + a[i][j];//初始磨菇数总和&#125;&#125;long long res = 0;long long sum = 0;for(int i=0,j=0;j&lt;n;++j,i^=1)&#123;//学会位运算，k^=1表示：k为偶数k-=1，k为奇数k+=1 long long nres = sum; //用sum维护左端一直拐弯的蘑菇总和 nres+=sum123[i][j] +j*1LL*sum111[i][j];//补上一个常数(j+1)*sum111的蘑菇数量 nres+=sum321[i^1][j] + (j+n-1)*1LL*sum111[i^1][j];//补上一个常数(j+n)*sum111的蘑菇数量 res = max(res,nres);//更新总和 sum+=a[i][j]*1LL*(j+j);//更新维护的和 sum+=a[i^1][j]*1LL*(j+j+1);&#125; printf(&quot;%I64d\n&quot;, res);return 0;&#125;]]></content>
      <categories>
        <category>基础dp</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[AtCoder-Beginner-Contest-107(D---Median-of-Medians)]]></title>
    <url>%2F2018%2F11%2F17%2FAtCoder-Beginner-Contest-107(D---Median-of-Medians)%2F</url>
    <content type="text"><![CDATA[链接：https://abc107.contest.atcoder.jp/tasks/arc101_b思路：我感觉是道神仙题， 我要在这里手动膜一下余大神！！！！口解题目tql！！！，首先不可能硬求中位数，我们考虑，如果所有的数为0和1的解法，那么我们可以考虑把0变为-1，然后对所有位置求前缀和，某两个前缀和后减前如果大于0则说明这个区间1更多（中位数是1），有了这个想法，我们就想到了可以用二分枚举，比当前枚举值大或者相等的设为1，小的设为-1，，然后用01的求法求解当前问题，算出逆序数，用总数-逆序和-（遍历1-n中]]></content>
      <categories>
        <category>树状数组</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Atcoder(Crossing)]]></title>
    <url>%2F2018%2F11%2F17%2FAtcoder(Crossing)%2F</url>
    <content type="text"><![CDATA[链接：https://tenka1-2018.contest.atcoder.jp/tasks/tenka1_2018_d思路：构造题，首先我们要考虑清楚一个问题，任意两个集合公有元素只有一个，那么可以看为从k个集合中选2个集合得到一个共有元素，那么一共有k（k-1）/2种选择方法，而由于每个元素刚好属于两个集合，所以每种选法得到的元素应该恰好都不同，所以n = k（k-1）/2，满足时有解否则无解。构造方法如下：（k=6）可正好保证要求按照如下构造方式即可得到最终答案。代码：123456789101112131415161718192021222324252627282930#include&lt;bits/stdc++.h&gt;using namespace std;int n;vector&lt;int&gt; a[1010];int main()&#123; scanf(&quot;%d&quot;,&amp;n); int t = sqrt(2*n+0.5); if(t*(t+1)==2*n)&#123; printf(&quot;Yes\n%d\n&quot;,t+1); int cnt = 1; for(int i=1;i&lt;=t;i++)&#123; for(int j=1;j&lt;=i;j++)&#123; a[i].push_back(cnt); if(j==i)a[t+1].push_back(cnt); else a[j].push_back(cnt); cnt++; &#125; &#125; for(int i=1;i&lt;=t+1;i++)&#123; printf(&quot;%d&quot;,t); for(int j=0;j&lt;a[i].size();j++)&#123; printf(&quot; %d&quot;,a[i][j]); &#125; printf(&quot;\n&quot;); &#125; &#125; else printf(&quot;No\n&quot;);&#125;]]></content>
      <categories>
        <category>构造</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[AOJ-Single-Source-Shortest-Path-I（单源最短路径）]]></title>
    <url>%2F2018%2F11%2F17%2FAOJ-Single-Source-Shortest-Path-I%EF%BC%88%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%EF%BC%89%2F</url>
    <content type="text"><![CDATA[链接：https://vjudge.net/problem/Aizu-ALDS1_12_B思路：与最小生成树写法类似，只是判断条件有所更改。最小生成树是搜索到每个点最小的距离然后更新，最短路径则是通过if(d[v]&gt;d[u]+M[u][v])d[v] = d[u] + M[u][v];来更新最短路径，相邻点加上两点路径若小于原来的最短路径，则更新。 其余类似请参考最小生成树：https://www.jianshu.com/p/e07bfcb7b82c代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;iostream&gt;using namespace std;static const int MAX = 100;static const int INFTY = (1&lt;&lt;21);static const int WHITE = 0;static const int GRAY = 1;static const int BLACK = 2;int n,M[MAX][MAX];void dijkstra()&#123;int minv;int d[MAX],color[MAX];for(int i=0;i&lt;n;i++)&#123;d[i] = INFTY;color[i] = WHITE;&#125;color[0] = GRAY;d[0] = 0;while(1)&#123;minv = INFTY;int u = -1;for(int i=0;i&lt;n;i++)&#123;if(minv&gt;d[i]&amp;&amp;color[i]!=BLACK)&#123;u = i;minv = d[i];&#125;&#125;if(u==-1)break;color[u] = BLACK;for(int v=0;v&lt;n;v++)&#123;if(color[v]!=BLACK&amp;&amp;M[u][v]!=INFTY)&#123;if(d[v]&gt;d[u]+M[u][v])&#123;//如果相邻点两步距离之和小于原来的一步，则更新最小步数。d[v] = d[u] + M[u][v];color[v] = GRAY;&#125;&#125;&#125;&#125;for(int i=0;i&lt;n;i++)&#123;cout&lt;&lt;i&lt;&lt;&quot; &quot;&lt;&lt;(d[i]==INFTY?-1:d[i])&lt;&lt;endl;&#125;&#125;int main()&#123;cin&gt;&gt;n;for(int i=0;i&lt;n;i++)&#123;for(int j=0;j&lt;n;j++)&#123;M[i][j] = INFTY;&#125;&#125;int k,c,u,v;for(int i=0;i&lt;n;i++)&#123;cin&gt;&gt;u&gt;&gt;k;for(int j=0;j&lt;k;j++)&#123;cin&gt;&gt;v&gt;&gt;c;M[u][v] = c;&#125;&#125;dijkstra();return 0;&#125;]]></content>
      <categories>
        <category>最短路</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[AOJ-Minimum-Spanning-Tree-(最小生成树）]]></title>
    <url>%2F2018%2F11%2F17%2FAOJ-Minimum-Spanning-Tree-(%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%EF%BC%89%2F</url>
    <content type="text"><![CDATA[链接：https://vjudge.net/problem/Aizu-ALDS1_12_A思路：从第一个结点开始，搜索相邻结点，然后更新所有结点的最小距离，将所有结点重复上述过程即可得到最小生成树 参考链接：https://www.jianshu.com/p/e04a8bdaf7c9 https://www.jianshu.com/p/7eb040a78060代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include&lt;iostream&gt;using namespace std;const int MAX = 100;const int INFTY = (1&lt;&lt;21);int n;int distance1[MAX][MAX];int MST()&#123;int d[MAX];int color[MAX]; //white = 0,gray = 1,black = 2int father[MAX];int u,mins; for(int i=0;i&lt;n;i++)&#123; //搜索一个有效结点d[i] = INFTY;color[i] = 0;father[i] = -1;&#125;d[0] = 0;while(1)&#123;mins = INFTY;u = -1;for(int i=0;i&lt;n;i++)&#123; //用该结点对所有的if(d[i]&lt;mins&amp;&amp;color[i]!=2)&#123;u = i;mins = d[i];&#125;&#125;if(u==-1)break;color[u] = 2;for(int j=0;j&lt;n;j++)&#123;if(color[j]!=2&amp;&amp;distance1[u][j]!=INFTY)&#123;if(distance1[u][j]&lt;d[j])&#123;d[j] = distance1[u][j];color[j] = 1;father[j] = u;&#125;&#125;&#125;&#125;int sum = 0;for(int i=0;i&lt;n;i++)&#123;if(father[i]!=-1)sum+=distance1[i][father[i]];&#125;return sum;&#125;int main()&#123;cin&gt;&gt;n;for(int i=0;i&lt;n;i++)&#123;for(int j=0;j&lt;n;j++)&#123;int e;cin&gt;&gt;e;distance1[i][j] = (e==-1)?INFTY:e;&#125;&#125;cout&lt;&lt;MST()&lt;&lt;endl;return 0;&#125; 再次书写的版本：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;iostream&gt;using namespace std;const int MAX = 100;const int INFTY = (1&lt;&lt;21);int n;int distance1[MAX][MAX];int MST()&#123;int d[MAX];int color[MAX];//white = 0,gray = 1,black = 2int father[MAX];int u,mins;for(int i=0;i&lt;n;i++)&#123;//搜索一个有效结点d[i] = INFTY;color[i] = 0;father[i] = -1;&#125;d[0] = 0;while(1)&#123;mins = INFTY;u = -1;for(int i=0;i&lt;n;i++)&#123; //用该结点对所有点的最小距离进行更新if(d[i]&lt;mins&amp;&amp;color[i]!=2)&#123;u = i;mins = d[i];&#125;&#125;if(u==-1)break;//搜索完成后退出color[u] = 2;for(int j=0;j&lt;n;j++)&#123;if(color[j]!=2&amp;&amp;distance1[u][j]!=INFTY)&#123;if(distance1[u][j]&lt;d[j])&#123;d[j] = distance1[u][j];color[j] = 1;father[j] = u;&#125;&#125;&#125;&#125;int sum = 0;for(int i=0;i&lt;n;i++)&#123; //对最小生成树的距离求和if(father[i]!=-1)sum+=distance1[i][father[i]];&#125;return sum;&#125;int main()&#123;cin&gt;&gt;n;for(int i=0;i&lt;n;i++)&#123;for(int j=0;j&lt;n;j++)&#123;int e;cin&gt;&gt;e;distance1[i][j] = (e==-1)?INFTY:e;&#125;&#125;cout&lt;&lt;MST()&lt;&lt;endl;return 0;&#125;]]></content>
      <categories>
        <category>最小生成树</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[AOJ-Connected-Components(连通分量)]]></title>
    <url>%2F2018%2F11%2F17%2FAOJ-Connected-Components(%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F)%2F</url>
    <content type="text"><![CDATA[链接：https://vjudge.net/problem/Aizu-ALDS1_11_D本题求连通分量：即判断两个点之间是否有路径。 思路：用深度或者广度进行搜索，并用一个color数组对顶点就行标记，能连通的设置为同一个值，最后对数组进行查询即可。本题用vector代替链表实现邻接表。代码：（dfs版本）12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;stack&gt;using namespace std;int n;vector&lt;int&gt; G[100000]; int color[100000];void dfs(int r,int c)&#123; stack&lt;int&gt; S; //开栈进行深度优先搜索S.push(r);color[r] = c; //标记颜色while(!S.empty())&#123;int u = S.top();S.pop();for(int i=0;i&lt;G[u].size();i++)&#123;int v = G[u][i];if(color[v]==-1)&#123; //若未访问过则入栈color[v] = c;S.push(v);&#125;&#125;&#125;&#125;void setcolor()&#123;int id = 1;for(int i=0;i&lt;n;i++)color[i] = -1; //初始化color数组for(int i=0;i&lt;n;i++)&#123;if(color[i]==-1)dfs(i,id++); //对每个顶点进行搜索&#125;&#125;int main()&#123;int a,b,c,d;cin&gt;&gt;n&gt;&gt;a;while(a--)&#123;cin&gt;&gt;b&gt;&gt;c;G[b].push_back(c);G[c].push_back(b);&#125;setcolor();cin&gt;&gt;d;while(d--)&#123;cin&gt;&gt;b&gt;&gt;c;if(color[b]==color[c])cout&lt;&lt;&quot;yes&quot;&lt;&lt;endl;else cout&lt;&lt;&quot;no&quot;&lt;&lt;endl;&#125;return 0;&#125; 代码：（bfs版本）：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;queue&gt;using namespace std;int n;vector&lt;int&gt; G[10000];int color[10000];void bfs(int r,int c)&#123;queue&lt;int&gt; S;S.push(r);color[r] = c;while(!S.empty())&#123;int u = S.front();S.pop();for(int i=0;i&lt;G[u].size();i++)&#123;int v = G[u][i];if(color[v]==-1)&#123;color[v] = c;S.push(v);&#125;&#125;&#125;&#125;void setcolor()&#123;int id = 1;for(int i=0;i&lt;n;i++)color[i] = -1;for(int i=0;i&lt;n;i++)&#123;if(color[i]==-1)bfs(i,id++);&#125;&#125;int main()&#123;int a,b,c,d;cin&gt;&gt;n&gt;&gt;a;while(a--)&#123;cin&gt;&gt;b&gt;&gt;c;G[b].push_back(c);G[c].push_back(b);&#125;setcolor();cin&gt;&gt;d;while(d--)&#123;cin&gt;&gt;b&gt;&gt;c;if(color[b]==color[c])cout&lt;&lt;&quot;yes&quot;&lt;&lt;endl;else cout&lt;&lt;&quot;no&quot;&lt;&lt;endl;&#125;return 0;&#125;]]></content>
      <categories>
        <category>tarjan强连通分量</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[AOJ(Convenient-Location)(Floyd最短路，三重循环)]]></title>
    <url>%2F2018%2F11%2F17%2FAOJ(Convenient-Location)(Floyd%E6%9C%80%E7%9F%AD%E8%B7%AF%EF%BC%8C%E4%B8%89%E9%87%8D%E5%BE%AA%E7%8E%AF)%2F</url>
    <content type="text"><![CDATA[链接：https://vjudge.net/problem/Aizu-0189#author=ksqsf 思路：通过三重循环以及dp数组，更新两点之间的最短距离。代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;int dp[50][50];const int INF = 1e9;int main()&#123; int a,b,n,m,dist; while(cin&gt;&gt;m&amp;&amp;m!=0)&#123; n = 0; for(int i=0;i&lt;=m;i++) for(int j=0;j&lt;=m;j++) dp[i][j] = INF; for(int i=0;i&lt;m;i++)&#123; dp[i][i] = 0; cin&gt;&gt;a&gt;&gt;b&gt;&gt;dist; dp[a][b] = dp[b][a] = dist; n = max(n,max(a,b)); &#125; for(int j=0;j&lt;=n;j++)&#123; for(int k=0;k&lt;=n;k++)&#123; for(int p=0;p&lt;=n;p++)&#123; dp[k][p] = min(dp[k][p],dp[k][j]+dp[j][p]);//一定记得前面是内部两重循环对应的下标，，否则死不瞑目！！！！ &#125; &#125; &#125; int sum = 1e9; int ans = 0; for(int i=0;i&lt;=n;i++)&#123; int temp = 0; for(int j=0;j&lt;=n;j++)&#123; temp+=dp[i][j]; &#125; if(temp&lt;sum)&#123; sum = temp; ans = i; &#125; &#125; cout&lt;&lt;ans&lt;&lt;&quot; &quot;&lt;&lt;sum&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>最短路</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[All-Pairs-Shortest-Path]]></title>
    <url>%2F2018%2F11%2F17%2FAll-Pairs-Shortest-Path%2F</url>
    <content type="text"><![CDATA[链接:https://vjudge.net/problem/Aizu-GRL_1_C思路:通过弗洛伊德算法,三重循环:d[k][j] = min(d[k][j],d[k][i] + d[i][j])更新出所有点的最短距离,若是存在封闭环的加权值为负数,则二维数组中d[i][i]中必然存在负值,所以只需单独判断是否存在负值,从而可以确定是否存在封闭环加权值为负数的情况.代码:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;#include&lt;climits&gt;using namespace std;static const int MAX = 100;static const long long INFTY = (1LL&lt;&lt;32);int n;long long d[MAX][MAX];void floyd()&#123;for(int i=0;i&lt;n;i++)for(int j=0;j&lt;n;j++)&#123;if(d[j][i]==INFTY)continue;for(int k=0;k&lt;n;k++)&#123;if(d[i][k]==INFTY)continue;d[j][k] = min(d[j][k],d[j][i]+d[i][k]);//弗洛伊德算法核心&#125;&#125;&#125;int main()&#123;int times,a,b,now;cin&gt;&gt;n&gt;&gt;times;for(int i=0;i&lt;n;i++)//初始化整个数组,将起点和终点相同的数组对应的值设为0for(int j=0;j&lt;n;j++)&#123;if(i==j)d[i][j] = 0;else d[i][j] = INFTY;&#125;while(times--)&#123;cin&gt;&gt;a&gt;&gt;b&gt;&gt;now;d[a][b] = now;&#125;floyd();bool negative = false;for(int i=0;i&lt;n;i++)//判断是否存在加权值为负数的封闭环if(d[i][i]&lt;0)negative = true;if(negative)cout&lt;&lt;&quot;NEGATIVE CYCLE&quot;&lt;&lt;endl;else&#123;for(int i=0;i&lt;n;i++)&#123;for(int j=0;j&lt;n;j++)&#123;if(j)cout&lt;&lt;&quot; &quot;;if(d[i][j]==INFTY)cout&lt;&lt;&quot;INF&quot;;else cout&lt;&lt;d[i][j];&#125;cout&lt;&lt;endl;&#125;&#125;return 0;&#125;]]></content>
      <categories>
        <category>最短路</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[百练(网线主管)(double精度，血的教训！)]]></title>
    <url>%2F2018%2F11%2F17%2F%E7%99%BE%E7%BB%83(%E7%BD%91%E7%BA%BF%E4%B8%BB%E7%AE%A1)(double%E7%B2%BE%E5%BA%A6%EF%BC%8C%E8%A1%80%E7%9A%84%E6%95%99%E8%AE%AD%EF%BC%81)%2F</url>
    <content type="text"><![CDATA[链接：http://bailian.openjudge.cn/practice/1064/思路：二分法，但是题目数据卡了double的精度，所以一定需要把米转化为整数的厘米来算，以后一定要注意精度的问题啊！！！！代码：123456789101112131415161718192021222324252627282930313233343536373839404142/************************************************************************* &gt; File Name: wxzg.cpp &gt; Author: &gt; Mail: &gt; Created Time: Fri 03 Aug 2018 08:15:34 PM CST ************************************************************************/#include&lt;cstdio&gt;using namespace std;int a[10001];int n,m;bool c(int d)&#123; int sum = 0; for(int i=0;i&lt;n;++i)&#123; sum+=a[i]/d; &#125; return sum&gt;=m;&#125;int main()&#123; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); double e; for(int i=0;i&lt;n;++i)&#123; scanf(&quot;%lf&quot;,&amp;e); a[i] = 100*e; &#125; int ub = 1e9; int lb = 0; while(ub-lb&gt;1)&#123; int mid = (lb+ub)/2; if(c(mid))lb = mid; else ub = mid; &#125; if(lb&lt;1)printf(&quot;0.00\n&quot;); else printf(&quot;%.2f\n&quot;,(double)lb/100); double eee = 14.5*0.01; printf(&quot;%.2f\n&quot;,eee); return 0;&#125;]]></content>
      <categories>
        <category>二分</category>
      </categories>
  </entry>
</search>
